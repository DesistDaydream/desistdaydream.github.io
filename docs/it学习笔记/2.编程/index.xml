<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 2.编程</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/</link><description>Recent content in 2.编程 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Actions 样例</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/github/github-actions/actions-%E6%A0%B7%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/github/github-actions/actions-%E6%A0%B7%E4%BE%8B/</guid><description>
&lt;h1 id="定时同步-github-的代码仓库到-gitee">定时同步 GitHub 的代码仓库到 Gitee&lt;/h1>
&lt;p>该功能已经有很多实现了，这篇文章以 &lt;a href="https://github.com/Yikun/hub-mirror-action">https://github.com/Yikun/hub-mirror-action&lt;/a> 项目为例。这个项目的基本逻辑是这样的：&lt;/p>
&lt;ul>
&lt;li>通过 GitHub Actions 构建一个 Docker 容器，在 Docker 容器中，引入 Gitee 的私钥，这样可以在容器中使用 git 命令向 Gitee push 代码而不用输入密码了&lt;/li>
&lt;li>容器启动后，在容器内 pull github 上的代码，并 push 到 gitee 上。&lt;/li>
&lt;/ul>
&lt;p>首先先来一个最基本的 Action 的 workflow 文件示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Gitee repos mirror periodic job&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">on&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 取消 push 的注释后，向本仓库推送代码即可开始 Gitee 同步&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># push:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">schedule&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 每天北京时间9点跑&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">cron&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0 1 * * *&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">jobs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">build&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">runs-on&lt;/span>: &lt;span style="color:#ae81ff">ubuntu-latest&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">steps&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Cache phpdragon src repos&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 使用 github 官方提供的 action 来引用发行版的主要版本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">actions/cache@v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">with&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">path&lt;/span>: &lt;span style="color:#ae81ff">/home/runner/work/phpdragon/phpdragon-cache&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">key&lt;/span>: &lt;span style="color:#ae81ff">${{ runner.os }}-phpdragon-repos-cache&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Mirror the Github organization repos to Gitee.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 这里我将对方项目原封不动 copy 到自己的 github 上了，所以这个步骤就直接使用自己的 action&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">DesistDaydream/hub-mirror-action@main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">with&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 必选，需要同步的Github用户（源）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">src&lt;/span>: &lt;span style="color:#ae81ff">github/DesistDaydream&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 必选，需要同步到的Gitee的用户（目的）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">dst&lt;/span>: &lt;span style="color:#ae81ff">gitee/DesistDaydream&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 必选，Gitee公钥对应的私钥&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">dst_key&lt;/span>: &lt;span style="color:#ae81ff">${{ secrets.GITEE_PRIVATE_KEY }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 必选，Gitee对应的用于创建仓库的token&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">dst_token&lt;/span>: &lt;span style="color:#ae81ff">${{ secrets.GITEE_TOKEN }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 黑、白名单，静态名单机制，可以用于更新某些指定库&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># static_list: repo_name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">black_list&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;eHualu,kubernetesAPI,v2ray&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># white_list: &amp;#39;repo_name,repo_name2&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># force_update: true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>必选参数&lt;/p>
&lt;ul>
&lt;li>&lt;code>src&lt;/code> 需要被同步的源端账户名，如 github/DesistDaydream，表示 Github 的 DesistDaydream 账户。&lt;/li>
&lt;li>&lt;code>dst&lt;/code> 需要同步到的目的端账户名，如 gitee/DesistDaydream，表示 Gitee 的 DesistDaydream 账户。&lt;/li>
&lt;li>&lt;code>dst_key&lt;/code> 与 Gitee 公钥对应的私钥，给 GitHub Actions 激活后创建的容器中 git 命令认证所用。&lt;/li>
&lt;li>&lt;code>dst_token&lt;/code> 用于自动创建不存在的仓库。&lt;/li>
&lt;li>注意： dst_key 与 dst_token 的值是通过 GitHub 的 Secrets 功能 引用的，类似于 k8s 的 secret 功能。&lt;/li>
&lt;/ul>
&lt;p>可选参数&lt;/p>
&lt;ul>
&lt;li>&lt;code>account_type&lt;/code> 默认为 user，源和目的的账户类型，可以设置为 org（组织）或者 user（用户），目前仅支持&lt;strong>同类型账户&lt;/strong>（即组织到组织，或用户到用户）的同步。&lt;/li>
&lt;li>&lt;code>clone_style&lt;/code> 默认为 https，可以设置为 ssh 或者 https。&lt;/li>
&lt;li>&lt;code>cache_path&lt;/code> 默认为&amp;rsquo;&amp;rsquo;, 将代码缓存在指定目录，用于与 actions/cache 配合以加速镜像过程。&lt;/li>
&lt;li>&lt;code>black_list&lt;/code> 默认为&amp;rsquo;&amp;rsquo;, 配置后，黑名单中的 repos 将不会被同步，如“repo1,repo2,repo3”。&lt;/li>
&lt;li>&lt;code>white_list&lt;/code> 默认为&amp;rsquo;&amp;rsquo;, 配置后，仅同步白名单中的 repos，如“repo1,repo2,repo3”。&lt;/li>
&lt;li>&lt;code>static_list&lt;/code> 默认为&amp;rsquo;&amp;rsquo;, 配置后，仅同步静态列表，不会再动态获取需同步列表（黑白名单机制依旧生效），如“repo1,repo2,repo3”。&lt;/li>
&lt;li>&lt;code>force_update&lt;/code> 默认为 false, 配置后，启用 git push -f 强制同步，&lt;strong>注意：开启后，会强制覆盖目的端仓库&lt;/strong>。&lt;/li>
&lt;li>&lt;code>debug&lt;/code> 默认为 false, 配置后，启用 debug 开关，会显示所有执行命令。&lt;/li>
&lt;/ul>
&lt;h1 id="获取并配置-github-连接-gitee-所需的认证信息">获取并配置 GitHub 连接 Gitee 所需的认证信息&lt;/h1>
&lt;p>认证信息：&lt;a href="https://www.yuque.com/desistdaydream/lmstiv/uvgrw2">https://www.yuque.com/desistdaydream/lmstiv/uvgrw2&lt;/a>&lt;/p>
&lt;h2 id="获取-gitee-token">获取 Gitee TOKEN&lt;/h2>
&lt;p>使用该连接：&lt;a href="https://gitee.com/profile/personal_access_tokens/new">https://gitee.com/profile/personal_access_tokens/new&lt;/a>，添加&lt;code>令牌描述&lt;/code>后，点击&lt;code>提交&lt;/code>以生成 TOKEN&lt;/p>
&lt;h2 id="获取密钥对">获取密钥对&lt;/h2>
&lt;p>随便找一个有 ssh-keygen 命令的主机，用于生成一对密钥。使用 ssh-keygen 命令生成密钥对，ssh-keygen 命令用法详见此处&lt;/p>
&lt;pre>&lt;code>ssh-keygen -t rsa -C 373406000@qq.com
&lt;/code>&lt;/pre>
&lt;h2 id="配置-gitee-公钥">配置 Gitee 公钥&lt;/h2>
&lt;p>在 &lt;a href="https://gitee.com/profile/sshkeys">Gitee 的配置页面中&lt;/a>添加公钥信息。以便 GitHub 使用 私钥连接时，可以通过认证。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wn0scx/1640568955462-d3dbe873-2a73-4539-a477-0cfa71fb8a43.png" alt="image.png">&lt;/p>
&lt;h2 id="配置-私钥-和-token">配置 私钥 和 TOKEN&lt;/h2>
&lt;p>在 GitHub 以加密的方式传入到容器中。如果不加密，直接写到代码仓库中，那其他人就都看到了~~~~该操作主要是针对 代码仓库而言的，因为 私钥和 TOKEN 的信息，是需要在 Action 中引用的，而 Action 本身就是一摞代码~&lt;/p>
&lt;p>在&lt;a href="https://github.com/DesistDaydream/hub-mirror-action/settings/secrets">项目仓库的 Setting 中的 Secrets&lt;/a> 中&lt;a href="https://github.com/DesistDaydream/hub-mirror-action/settings/secrets/new">添加&lt;/a> 私钥 与 TOKEN 的变量。&lt;/p>
&lt;h3 id="添加-token">添加 TOKEN&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wn0scx/1640569010998-1d5f41bd-359d-4b4c-ae4d-d4352ba41ab7.png" alt="image.png">&lt;/p>
&lt;h3 id="添加私钥">添加私钥&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wn0scx/1616903594321-e357ab96-5486-42f9-ba85-9fdf869e9fbb.png" alt="">&lt;/p></description></item><item><title>Docs: API 相关工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/api%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3/api-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/api%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3/api-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/</guid><description/></item><item><title>Docs: API(应用程序接口)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/api%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3/api%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/api%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3/api%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://en.wikipedia.org/wiki/API">wiki&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Application Programming Interface(应用程序接口，简称 API)&lt;/strong>。它定义了可以进行的调用或请求的类型，如何进行调用，应使用的数据格式，遵循的约定等。它还可以提供扩展机制，以便用户可以通过各种方式扩展现有功能。在不同程度上。[1] API 可以是完全自定义的，特定于组件的，也可以基于行业标准设计以确保互操作性。通过&lt;a href="https://en.wikipedia.org/wiki/Information_hiding">信息隐藏&lt;/a>，API 支持&lt;a href="https://en.wikipedia.org/wiki/Modular_programming">模块化编程&lt;/a>，从而使用户可以独立于实现使用接口。&lt;/p>
&lt;h2 id="目的">目的&lt;/h2>
&lt;p>在构建应用程序时，API（应用程序编程接口）通过抽象化底层实现并仅公开开发人员需要的对象或动作来简化编程。电子邮件客户端的图形界面可能会为用户提供执行获取和突出显示新电子邮件的所有步骤的按钮，而用于文件输入/输出的 API 可能会为开发人员提供一种将文件从一个位置复制到另一个位置的功能，而无需要求开发人员了解幕后发生的文件系统操作。[2]&lt;/p>
&lt;h2 id="术语的历史">术语的历史&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/folw44/1616163705351-3d45137b-c5db-4656-839f-5fa583e353e3.png" alt="">&lt;/p>
&lt;p>1978 年的一张图建议将 API 的概念扩展为一个通用的编程接口，而不仅仅是应用程序。[3]&lt;/p>
&lt;p>“ &lt;em>API&lt;/em> ”一词的含义已经扩展了其历史。首先，它仅描述了面向面向最终用户的程序（称为应用程序）的接口。此起源仍反映在名称“应用程序编程接口”中。如今，术语 API 的范围更广，不仅包括实用程序软件，甚至包括硬件接口。[4]&lt;/p>
&lt;p>API 的概念比该术语要古老得多。英国计算机科学家 Wilkes 和 Wheeler 在 1940 年代为 EDSAC 计算机开发了模块化软件库。约书亚·布洛赫（Joshua Bloch）声称威尔克斯和惠勒（Wilker and Wheeler）“潜在地发明”了该 API，因为它更多地是被发现而不是被发明的概念。[4]&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/folw44/1616163705346-76236d7f-ccd5-42d5-81dd-04fdda266f7a.jpeg" alt="">&lt;/p>
&lt;p>尽管创造 API 一词的人是在 Univac 1108 上实现软件，但他们的 API 的目标是使独立于硬件的程序成为可能。[5]&lt;/p>
&lt;p>术语“应用程序接口”（没有_-ing_后缀）首先被记录在称为纸张_数据结构和技术对于远程计算机图形_在呈现 AFIPS 在 1968 年会议[6] [4]所述的本文使用的作者该术语描述应用程序（在这种情况下为图形程序）与计算机系统其余部分的交互。一致的应用程序接口（包括 Fortran 子例程调用）旨在使程序员摆脱处理图形显示设备的特性，并在更换计算机或显示器时提供硬件独立性。[5]&lt;/p>
&lt;p>术语被引入到的场数据库由 CJ 日期[7]中称为 1974 纸_的关系和网络途径：应用程序编程接口的比较_。[8] API 成为用于数据库管理系统的 ANSI / SPARC 框架的一部分。该框架将应用程序编程接口与其他接口（例如查询接口）分开对待。1970 年代的数据库专业人员发现，这些不同的接口可以组合在一起。一个足够丰富的应用程序接口也可以支持其他接口。[3]&lt;/p>
&lt;p>这种观察导致 API 支持所有类型的编程，而不仅是应用程序编程。到 1990 年，API 被技术专家 Carl Malamud 定义为“程序员可以用来执行某些任务的一组服务” 。[9]&lt;/p>
&lt;p>随着 Web API 的出现，API 的概念再次得到扩展。罗伊·菲尔丁（Roy Fielding）的论文《_建筑风格》和_2000 年在加州大学欧文分校（UC Irvine）_的基于网络的软件体系结构设计_概述了代表性状态转移（REST），并描述了“菲林丁”与传统的“图书馆应用程序接口”的“基于网络的应用程序编程接口”的概念。基于”的 API。[10] XML 和 JSON Web API 于 2000 年开始得到广泛的商业采用，并一直持续到 2020 年。&lt;/p>
&lt;p>现在，Web API 是术语 API 的最常见含义。[11]以这种方式使用时，术语“ API”与术语“通信协议”和“远程过程调用”在含义上有一些重叠。&lt;/p>
&lt;h2 id="用法">用法&lt;/h2>
&lt;h3 id="库和框架">库和框架&lt;/h3>
&lt;p>API 通常与软件库有关。当库是这套规则的“实际实现”时，API 描述并规定了“预期行为”（一种规范）。&lt;/p>
&lt;p>单个 API 可以采用共享同一编程接口的不同库的形式进行多种实现（或者没有一种实现是抽象的）。&lt;/p>
&lt;p>将 API 与实现分开，可以允许以一种语言编写的程序使用以另一种语言编写的库。例如，由于 Scala 和 Java 可以编译为兼容的字节码，因此 Scala 开发人员可以利用任何 Java API。[12]&lt;/p>
&lt;p>API 的使用取决于所涉及的编程语言的类型。诸如 Lua 之类的过程语言的 API 可以主要由执行代码，操纵数据或处理错误的基本例程组成，而诸如 Java 之类的面向对象语言的 API 则可以提供类及其类方法的规范。[13] [14]&lt;/p>
&lt;p>语言绑定也是 API。通过将一种语言的特性和功能映射到以另一种语言实现的接口，语言绑定允许在以另一种语言进行开发时使用以一种语言编写的库或服务。[15]诸如 SWIG 和 F2PY（一种从 Fortran 到 Python 的接口生成器）之类的工具有助于创建此类接口。[16]&lt;/p>
&lt;p>API 也可以与软件框架相关：框架可以基于实现了多个 API 的多个库，但是与 API 的正常使用不同，对框架内建行为的访问是通过使用新类扩展其内容来实现的插入框架本身。&lt;/p>
&lt;p>而且，整个控制程序流程可以通过控制反转或类似的机制而不受调用者的控制，而不受框架的控制。[17] [18]&lt;/p>
&lt;h3 id="操作系统">操作系统&lt;/h3>
&lt;p>API 可以指定应用程序和操作系统之间的接口。[19] 例如，POSIX 指定一组通用 API，这些 API 旨在使为 POSIX 兼容操作系统编写的应用程序能够为另一个 POSIX 兼容操作系统编译。&lt;/p>
&lt;p>Linux 和 Berkeley 软件发行版是实现 POSIX API 的操作系统的示例。[20]&lt;/p>
&lt;p>Microsoft 已显示出对向后兼容 API 的坚定承诺，尤其是在其 Windows API（Win32）库中，因此较旧的应用程序可以使用称为“兼容模式”的可执行程序特定设置在新版 Windows 上运行。[21]&lt;/p>
&lt;p>API 与应用程序二进制接口（ABI）的不同之处在于，API 是基于源代码的，而 ABI 是基于二进制的。例如，POSIX 提供 API，而 Linux Standard Base 提供 ABI。[22] [23]&lt;/p>
&lt;h3 id="远程-api">远程 API&lt;/h3>
&lt;p>远程 API 允许开发人员通过协议（特定于通信的标准）来操纵远程资源，该协议允许不同的技术一起工作，而不论语言或平台如何。例如，Java 数据库连接 API 允许开发人员使用相同的功能集查询许多不同类型的数据库，而 Java 远程方法调用 API 使用 Java 远程方法协议来允许调用可远程操作但在本地运行的功能开发人员。[24] [25]&lt;/p>
&lt;p>因此，远程 API 对于维护面向对象程序设计中的对象抽象很有用。在代理对象上本地执行的方法调用，使用远程协议在远程对象上调用相应的方法，并获取要在本地用作返回值的结果。&lt;/p>
&lt;p>代理对象的修改也将导致远程对象的相应修改。[26]&lt;/p>
&lt;h3 id="web-api">Web API&lt;/h3>
&lt;p>主要文章：Web API&lt;/p>
&lt;p>Web API 是企业和使用其资产的应用程序之间进行交互的已定义接口，这也是服务水平协议（SLA），用于指定功能提供者并为其 API 用户公开服务路径或 URL。API 方法是一种体系结构方法，它围绕为服务于不同类型消费者的不同应用程序提供一组服务的程序接口而发展。[27]&lt;/p>
&lt;p>当在 Web 开发的上下文中使用 API 时，通常将其定义为一组规范，例如超文本传输协议（HTTP）请求消息以及响应消息的结构定义，通常以可扩展标记语言（XML））或 JavaScript 对象符号（JSON）格式。例如运输公司的 API，可以将其添加到以电子商务为中心的网站上，以方便订购运输服务，并自动包括当前的运输价格，而站点开发人员不必在网络数据库中输入运输者的价格表。尽管“ Web API”在历史上实际上是 Web 服务的代名词，但最近的趋势（所谓的 Web 2.0）已从基于简单对象访问协议（SOAP）的 Web 服务和面向服务的体系结构（SOA）转向更直接的表示状态转移（REST）样式的 Web 资源和面向资源的体系结构（ROA）。[28]这种趋势的一部分与语义 Web 向资源描述框架（RDF）的发展有关，RDF 是一种促进基于 Web 的本体工程技术的概念。Web API 允许将多个 API 组合到称为 mashup 的新应用程序中。[29] 在社交媒体领域，Web API 使 Web 社区可以促进在社区和应用程序之间共享内容和数据。这样，可以将在一个地方动态创建的内容发布并更新到 Web 上的多个位置。[30]例如，Twitter 的 REST API 允许开发人员访问 Twitter 的核心数据，而 Search API 为开发人员提供了与 Twitter 搜索和趋势数据进行交互的方法。[31]&lt;/p>
&lt;h2 id="设计">设计&lt;/h2>
&lt;p>API 的设计对其使用有重大影响。[2]信息隐藏的原理将编程接口的作用描述为通过隐藏模块的实现细节来实现模块化编程，从而使模块用户无需了解模块内部的复杂性。[32]因此，API 的设计试图仅提供用户期望的工具。[2]编程接口的设计是软件体系结构的重要组成部分，是复杂软件的组织。[33]&lt;/p>
&lt;h2 id="发布政策">发布政策&lt;/h2>
&lt;p>API 是技术公司更常见的集成方式之一。提供和使用 API 的组件被视为业务生态系统的成员。[34]&lt;/p>
&lt;p>发布 API 的主要策略是：[35]&lt;/p>
&lt;ul>
&lt;li>
&lt;p>私有：该 API 仅供内部公司使用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>合作伙伴：只有特定的业务合作伙伴可以使用 API。例如，Uber 和 Lyft 等租用公司的车辆允许经过批准的第三方开发人员直接在其应用程序内订购游乐设施。这使公司可以通过选择哪些应用程序可以访问 API 来进行质量控制，并为其提供额外的收入来源。[36]&lt;/p>
&lt;/li>
&lt;li>
&lt;p>公开：该 API 供公众使用。例如，Microsoft 公开了 Windows API，Apple 发行了其 API Cocoa，因此可以为其平台编写软件。通常，并非所有人都能访问所有公共 API。例如，Cloudflare 或 Voxility 等 Internet 服务提供商使用 RESTful API，以允许客户和转售商访问其基础结构信息，DDoS 统计信息，网络性能或仪表板控件。[37]可以通过“ API 令牌”或客户身份验证来授予对此类 API 的访问权限。[38]&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="公共-api-的含义">公共 API 的含义&lt;/h3>
&lt;p>API 公开时的重要因素是其“接口稳定性”。对 API 的更改（例如，向函数调用添加新参数）可能会破坏与依赖该 API 的客户端的兼容性。[39]&lt;/p>
&lt;p>当公开展示的 API 的某些部分可能发生更改并因此不稳定时，应将特定 API 的这些部分明确记录为“不稳定”。例如，在 Google Guava 库中，被视为不稳定的部分或可能即将更改的部分都标有 Java 注释 &lt;code>@Beta&lt;/code>。[40]&lt;/p>
&lt;p>公共 API 有时可以声明其自身的某些部分_已弃用_或废除。这通常意味着应将 API 的一部分视为要删除或以向后不兼容的方式进行修改的候选对象。因此，这些更改使开发人员可以脱离 API 的某些部分，这些部分将来将被删除或不再受支持。[41]&lt;/p>
&lt;p>客户端代码可能包含 API 设计人员不打算使用的创新用法或机会用法。换句话说，对于具有大量用户基础的库，当元素成为公共 API 的一部分时，可以多种方式使用它。[42] 2020 年 2 月 19 日，Akamai 发布了他们的年度“互联网状况”报告，展示了针对全球金融服务中针对公共 API 平台的网络犯罪分子的增长趋势。从 2017 年 12 月到 2019 年 11 月，Akamai 见证了 854.2 亿次凭证违规攻击。大约 20％（即 165.5 亿）与定义为 API 端点的主机名相对。其中，4.735 亿针对金融服务部门组织。[43]&lt;/p>
&lt;h2 id="文档">文档&lt;/h2>
&lt;p>API 文档描述了 API 提供的服务以及如何使用这些服务，旨在涵盖客户出于实际目的需要了解的所有内容。&lt;/p>
&lt;p>文档对于使用 API 开发和维护应用程序至关重要。[44] API 文档通常在文档文件中找到，但也可以在社交媒体（例如博客，论坛和问答网站）中找到。[45]&lt;/p>
&lt;p>传统的文档文件通常通过具有一致外观和结构的文档系统（例如 Javadoc 或 Pydoc）来呈现。但是，文档中包含的内容类型因 API 而异。[46]&lt;/p>
&lt;p>为了清楚起见，API 文档可能包括对 API 中的类和方法的描述以及“典型的使用场景，代码段，设计原理，性能讨论和合同”，但是 API 服务本身的实现细节通常是省略。&lt;/p>
&lt;p>该文档还涵盖了如何使用 API 的限制和限制。例如，对于一个 API 函数文档可以注意到，它的参数不能为 null，该函数本身没有线程安全的，[47]因为 API 文档往往是全面的，它是作家保持更新文档和挑战用户仔细阅读它，可能会产生错误。[39]&lt;/p>
&lt;p>API 文档可以使用 Java 注释之类的元数据信息来丰富。编译器，工具和_运行时_环境可以使用此元数据来实现自定义行为或自定义处理。[48]&lt;/p>
&lt;p>可以以数据驱动的方式生成 API 文档。通过观察使用给定 API 的许多程序，可以推断出典型用法以及所需的合同和指令。[49]然后，可以使用模板从挖掘的数据生成自然语言。&lt;/p></description></item><item><title>Docs: Apifox</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/api%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3/api-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/apifox/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/api%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3/api-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/apifox/</guid><description>
&lt;h1 id="自带的动态变量">自带的动态变量&lt;/h1>
&lt;p>参考：&lt;a href="https://learning.postman.com/docs/writing-scripts/script-references/variables-list/">Postman 官方文档&lt;/a>、&lt;a href="https://www.apifox.cn/help/app/api-manage/dynamic-variables/">ApiFox 官方文档&lt;/a>&lt;/p>
&lt;ul>
&lt;li>{{$timestamp}} # 当前时间戳&lt;/li>
&lt;/ul>
&lt;p>程序脚本&lt;/p>
&lt;p>参考：&lt;a href="https://learning.postman.com/docs/writing-scripts/intro-to-scripts/">Postman 官方文档&lt;/a>、&lt;a href="https://www.apifox.cn/help/app/scripts/">ApiFox 官方文档&lt;/a>&lt;/p>
&lt;h2 id="gdas-签名">Gdas 签名&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">用于&lt;/span> &lt;span style="color:#a6e22e">Apifox&lt;/span> &lt;span style="color:#a6e22e">进行&lt;/span> &lt;span style="color:#a6e22e">Gdas&lt;/span> &lt;span style="color:#a6e22e">签名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 随机数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">nonce&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">pm&lt;/span>.&lt;span style="color:#a6e22e">variables&lt;/span>.&lt;span style="color:#a6e22e">replaceIn&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;{{$randomPassword}}&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 随机数反序
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">nonceReverse&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">nonce&lt;/span>.&lt;span style="color:#a6e22e">split&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>).&lt;span style="color:#a6e22e">reverse&lt;/span>().&lt;span style="color:#a6e22e">join&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 接入渠道标识
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">appkey&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;wo-obs&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">secretKey&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;obs123456&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 毫秒时间戳
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">stimestamp&lt;/span> &lt;span style="color:#f92672">=&lt;/span>Date.&lt;span style="color:#a6e22e">parse&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> Date());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 组合签名
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">signOriginal&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">secretKey&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">nonce&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">stimestamp&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">nonceReverse&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">cryptoJs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">require&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;crypto-js&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 使用 sha256 加密签名并转换为字符串
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">signature&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">cryptoJs&lt;/span>.&lt;span style="color:#a6e22e">SHA256&lt;/span>(&lt;span style="color:#a6e22e">signOriginal&lt;/span>).&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 输出上面生成的变量的值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;标识符：&amp;#34;&lt;/span>,&lt;span style="color:#a6e22e">appkey&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;时间戳：&amp;#34;&lt;/span>,&lt;span style="color:#a6e22e">stimestamp&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;随机数：&amp;#34;&lt;/span>,&lt;span style="color:#a6e22e">nonce&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;随机数反序：&amp;#34;&lt;/span>,&lt;span style="color:#a6e22e">nonceReverse&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;签名：&amp;#34;&lt;/span>,&lt;span style="color:#a6e22e">signature&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">pm&lt;/span>.&lt;span style="color:#a6e22e">variables&lt;/span>.&lt;span style="color:#a6e22e">set&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;appkey&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">appkey&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">pm&lt;/span>.&lt;span style="color:#a6e22e">variables&lt;/span>.&lt;span style="color:#a6e22e">set&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;stimestamp&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">stimestamp&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">pm&lt;/span>.&lt;span style="color:#a6e22e">variables&lt;/span>.&lt;span style="color:#a6e22e">set&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;nonce&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">nonce&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">pm&lt;/span>.&lt;span style="color:#a6e22e">variables&lt;/span>.&lt;span style="color:#a6e22e">set&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;signature&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">signature&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用其他编程语言的脚本&lt;/p>
&lt;h3 id="go-代码调用示例">go 代码调用示例&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;bytes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;crypto/sha256&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;encoding/hex&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;encoding/json&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;math/rand&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;strconv&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;time&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">header&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Appkey&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;appkey&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Stimestamp&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;stimestamp&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Nonce&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;nonce&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Signature&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;signature&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 接入渠道标识
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">appkey&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;wo-obs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">secretKey&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;obs123456&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 毫秒时间戳
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">stimestamp&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">strconv&lt;/span>.&lt;span style="color:#a6e22e">FormatInt&lt;/span>(&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Now&lt;/span>().&lt;span style="color:#a6e22e">UnixNano&lt;/span>()&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">1e6&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 随机字符串
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">char&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">NewSource&lt;/span>(&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Now&lt;/span>().&lt;span style="color:#a6e22e">UnixNano&lt;/span>()) &lt;span style="color:#75715e">// 产生随机种子
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#a6e22e">bytes&lt;/span>.&lt;span style="color:#a6e22e">Buffer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &amp;lt; &lt;span style="color:#ae81ff">20&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">WriteByte&lt;/span>(&lt;span style="color:#a6e22e">char&lt;/span>[&lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Int63&lt;/span>()&lt;span style="color:#f92672">%&lt;/span>int64(len(&lt;span style="color:#a6e22e">char&lt;/span>))])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">nonce&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">String&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//nonce 逆序
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">bytes&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span> = []byte(&lt;span style="color:#a6e22e">nonce&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &amp;lt; len(&lt;span style="color:#a6e22e">nonce&lt;/span>)&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tmp&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">bytes&lt;/span>[len(&lt;span style="color:#a6e22e">nonce&lt;/span>)&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">bytes&lt;/span>[len(&lt;span style="color:#a6e22e">nonce&lt;/span>)&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] = &lt;span style="color:#a6e22e">bytes&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">bytes&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>] = &lt;span style="color:#a6e22e">tmp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">nonceReverse&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> string(&lt;span style="color:#a6e22e">bytes&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 签名 secretKey+nonce+stime+nonce的倒序拼接再SHA256加密
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">signOriginal&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">secretKey&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">nonce&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">stimestamp&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">nonceReverse&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// SHA256加密
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">h&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">h&lt;/span>.&lt;span style="color:#a6e22e">Write&lt;/span>([]byte(&lt;span style="color:#a6e22e">signOriginal&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">signEncrypt&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">h&lt;/span>.&lt;span style="color:#a6e22e">Sum&lt;/span>(&lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">signature&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">hex&lt;/span>.&lt;span style="color:#a6e22e">EncodeToString&lt;/span>(&lt;span style="color:#a6e22e">signEncrypt&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">hd&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">header&lt;/span>{&lt;span style="color:#a6e22e">appkey&lt;/span>, &lt;span style="color:#a6e22e">stimestamp&lt;/span>, &lt;span style="color:#a6e22e">nonce&lt;/span>, &lt;span style="color:#a6e22e">signature&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">j&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">json&lt;/span>.&lt;span style="color:#a6e22e">Marshal&lt;/span>(&lt;span style="color:#a6e22e">hd&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(string(&lt;span style="color:#a6e22e">j&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对应的 Apifox 中的 JS 代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 执行 go 代码，代码输出的内容作为 test 变量的值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">header&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">fox&lt;/span>.&lt;span style="color:#a6e22e">execute&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;consoler_proxy_gen_header.go&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">header&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 解析 JSON
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">json&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">JSON&lt;/span>.&lt;span style="color:#a6e22e">parse&lt;/span>(&lt;span style="color:#a6e22e">header&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 设置变量 stime 和 enctyptSing。可以在参数中调用这些变量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">pm&lt;/span>.&lt;span style="color:#a6e22e">environment&lt;/span>.&lt;span style="color:#a6e22e">set&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;appkey&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">json&lt;/span>.&lt;span style="color:#a6e22e">appkey&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">pm&lt;/span>.&lt;span style="color:#a6e22e">environment&lt;/span>.&lt;span style="color:#a6e22e">set&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;stimestamp&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">json&lt;/span>.&lt;span style="color:#a6e22e">stimestamp&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">pm&lt;/span>.&lt;span style="color:#a6e22e">environment&lt;/span>.&lt;span style="color:#a6e22e">set&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;nonce&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">json&lt;/span>.&lt;span style="color:#a6e22e">nonce&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">pm&lt;/span>.&lt;span style="color:#a6e22e">environment&lt;/span>.&lt;span style="color:#a6e22e">set&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;signature&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">json&lt;/span>.&lt;span style="color:#a6e22e">signature&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">json&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">catch&lt;/span> (&lt;span style="color:#a6e22e">e&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">error&lt;/span>(&lt;span style="color:#a6e22e">e&lt;/span>.&lt;span style="color:#a6e22e">message&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Arrays(数组) 与 Slices(切片)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/arrays%E6%95%B0%E7%BB%84-%E4%B8%8E-slices%E5%88%87%E7%89%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/arrays%E6%95%B0%E7%BB%84-%E4%B8%8E-slices%E5%88%87%E7%89%87/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;h1 id="array数组">Array(数组)&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://go.dev/tour/moretypes/6">Go 语言之旅，Arrays&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Array(数组)&lt;/strong> 是具有相同的唯一类型的一组 &lt;strong>已编号&lt;/strong>、且&lt;strong>长度固定&lt;/strong> 的数据项序列。每个数据项称为 &lt;strong>element(元素)&lt;/strong>、长度指的是&lt;strong>元素的个数&lt;/strong>、编号指每个元素的 **index(索引)，**索引号从 0 开始。&lt;/p>
&lt;p>&lt;code>[n]T&lt;/code> 用以表示一个数组，该数组包含 n 个 T 类型的值。&lt;/p>
&lt;h2 id="array-的声明">Array 的声明&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">ArrayID&lt;/span> [&lt;span style="color:#a6e22e">LENGTH&lt;/span>]&lt;span style="color:#a6e22e">TYPE&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>ArrayID&lt;/strong> # 标识符(i.e.数组的名字)&lt;/li>
&lt;li>&lt;strong>LENGTH&lt;/strong> # 数组长度(i.e.元素的个数)&lt;/li>
&lt;li>&lt;strong>TYPE&lt;/strong> # 每个元素的数据的类型。&lt;/li>
&lt;li>&lt;code>**[ ]**&lt;/code> # 括号是数组类型的标识符，不要忘记写。&lt;/li>
&lt;/ul>
&lt;p>比如：&lt;code>var arr [10]int&lt;/code>这定义了一个名为 arr 的数组，这个数组由 10 个 int 类型的数据组成。简化点的口头语，声明了一个长度为 10 的整形数组。&lt;/p>
&lt;h2 id="array-的赋值">Array 的赋值&lt;/h2>
&lt;p>&lt;code>arr[0] = &amp;quot;Hello&amp;quot;&lt;/code> 为数组的 0 号元素赋值。&lt;/p>
&lt;h2 id="array-的实例化">Array 的实例化&lt;/h2>
&lt;p>数组声明后，默认初始化每个元素的值为 0，后续可以对每个元素进行赋值。数组可以有两种初始化方式&lt;/p>
&lt;ul>
&lt;li>每次对一个元素进行赋值，一般使用循环来实现&lt;/li>
&lt;li>使用&lt;code>{}&lt;/code>大括号，直接对数组进行初始化
&lt;ul>
&lt;li>e.g.&lt;code>var arr = [5]int{1,5,23,2,10}&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="array-的引用">Array 的引用&lt;/h2>
&lt;h3 id="引用数组的长度">引用数组的长度&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>len(&lt;span style="color:#a6e22e">MapID&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 &lt;code>len()&lt;/code> 函数，括号内为数组标识符。数组的长度也就是元素的数目，必须是固定的并且在声明该数组时就给出，数组长度最大为 2Gb。格式为 &lt;code>len(ARRAYS)&lt;/code> len 是 length 的缩写，ARRAYS 是数组变量的名称。&lt;/p>
&lt;ul>
&lt;li>e.g.对于上面例子中定义的数组，数组的长度为&lt;code>len(arr)&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="引用数组中的元素">引用数组中的元素&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ArrayID&lt;/span>[&lt;span style="color:#a6e22e">INDEX&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>ArrayID&lt;/strong> # 数组标识符&lt;/li>
&lt;li>&lt;strong>INDEX&lt;/strong> # 元素编号&lt;/li>
&lt;/ul>
&lt;p>数组的元素可以通过&lt;strong>索引&lt;/strong>(数组的位置，索引有时候也叫作数组中元素的&lt;strong>编号&lt;/strong>)来读取(或修改)，索引从 0 开始，第一个元素的索引为 0，第二个索引为 1，以此类推(长度为 3 的数组，元素的索引为 0、1、2)。&lt;/p>
&lt;ul>
&lt;li>e.g.对于上面例子中定义的数组，第一个元素是&lt;code>arr[0]&lt;/code>,第二个元素是&lt;code>arr[1]&lt;/code>&amp;hellip;..第五个元素是&lt;code>arr[4]&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="多维数组">多维数组&lt;/h2>
&lt;p>数组通常是一维的，但是可以用来组装成多维数组。e.g.&lt;code>[3][5]int&lt;/code>有行有列,&lt;code>[2][2][2]float64&lt;/code>立体效果。代码示例：multidim_array.go&lt;/p>
&lt;h1 id="slice切片">Slice(切片)&lt;/h1>
&lt;p>&lt;strong>Slice(切片)&lt;/strong> 是一个&lt;strong>长度可变的数组&lt;/strong>，是&lt;strong>数组的一部分&lt;/strong>；是对数组一个连续片段的&lt;strong>引用&lt;/strong>。这个片段可以是整个数组、或是由起始和终止索引标识中间的元素子集，注意：终止索引标识符的元素不包括在切片内。&lt;/p>
&lt;p>切片的由来：Go 中的数组是一个值，数组变量表示整个数组，而不是指向数组第一个元素的指针。这就意味，将一个数组当作参数传递时，会完全拷贝数组中的内容(当数组非常大的时候，会非常占用资源，使用起来也不便利)，这时候就可以是使用切片来作为参数进行传递。**可以把数组当成一个存储元素的地方，具有索引，有着固定的大小。而切片则是指向这个存储元素地方的指针。**所以 Golang 中一般使用切片来对数组进行引用和传递参数。&lt;/p>
&lt;p>注意：绝对不要用指针指向切片。切片本身已经是一个引用类型，所以它本身就是一个指针！&lt;/p>
&lt;h2 id="slice-的声明">Slice 的声明&lt;/h2>
&lt;p>&lt;code>var SliceID []TYPE&lt;/code>。MapID 为该切片的名字，[]中括号内不指明长度&lt;/p>
&lt;h2 id="slice-的实例化">Slice 的实例化&lt;/h2>
&lt;p>&lt;code>var SliceID []TYPE = ARR[START:END]&lt;/code>。切片通过数组 ARR 从 START 号索引到 END-1 号索引之间的元素构成自己(切分数组，&lt;code>START:END&lt;/code>被称为 slice 表达式)。切片的长度为 &lt;code>END-START&lt;/code>，切片的容量为&lt;code>从所引用的数组索引号START这个元素到这个数组最后一个元素的所有元素的个数&lt;/code>&lt;/p>
&lt;ul>
&lt;li>e.g.如果定义了一个数组 &lt;code>var arr1 [7]int&lt;/code>
&lt;ul>
&lt;li>&lt;code>var slice1 []type = arr1[2:5]&lt;/code>。&lt;code>slice1[0]&lt;/code>等于&lt;code>arr1[2]&lt;/code>。&lt;code>len(slice1)&lt;/code>切片长度为 3,&lt;code>cap(slice1)&lt;/code>切片容量为 5&lt;/li>
&lt;li>&lt;code>var slice2 []type = arr1[:]&lt;/code> 切片 slice2 等于完整的 arr1 数组。另一种表示方式：&lt;code>slice2 = &amp;amp;arr1&lt;/code>&lt;/li>
&lt;li>&lt;code>arr1[2:]&lt;/code> 和 &lt;code>arr1[2:len(arr1)]&lt;/code> 相同，表示包含了数组的 2 号索引到最后最一个索引的所有元素。&lt;/li>
&lt;li>&lt;code>arr1[:3]&lt;/code> 和 &lt;code>arr1[0:3]&lt;/code> 相同，表示包含了从数组的 0 号索引到 2 号索引的所有元素(不包括 3 号索引的元素)。&lt;/li>
&lt;li>&lt;code>s := [3]int{1,2,3}[:]&lt;/code>和&lt;code>s := []int{1,2,3}&lt;/code> 相同，表示由数字 1、2、3 组成的切片&lt;/li>
&lt;li>&lt;code>s2 := s[:]&lt;/code>使用切片组成的切片，拥有相同的元素，但是仍然指向相同的相关数组&lt;/li>
&lt;li>&lt;code>var x = []int{2,3,4,5,11}&lt;/code> 创建了一个长度为 5 的数组且创建了一个相关切片。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="使用make函数来创建一个切片同时创建好相关数组">使用&lt;code>make()&lt;/code>函数来创建一个切片，同时创建好相关数组。&lt;/h3>
&lt;p>格式：&lt;code>var SliceID []TYPE = make([]TYPE, LEN, CAP)&lt;/code>也可以简写为&lt;code>SliceD ：= make([]TYPE, LEN, CAP)&lt;/code>（其中 CAP 是可省的，默认与 LEN 相同）。&lt;code>MapID&lt;/code>为切片名；&lt;code>TYPE&lt;/code>为该切片的数据类型；&lt;code>LEN&lt;/code>为该切片的长度；&lt;code>CAP&lt;/code>为该切片的总容量。CAP 可以理解为切片所引用的数组的长度，切片的长度不能超过容量 i.e.不能超过所引用的数组的长度。make()函数接受 2 个参数：元素的类型、切片的个数。&lt;/p>
&lt;ul>
&lt;li>e.g.&lt;code>s2 := make([]int, 10)&lt;/code>。定义了一个名为 s2，长度与容量都为 10 的整型切片
&lt;ul>
&lt;li>这个例子可以拆解为两句，首先会声明一个数组&lt;code>var XX [10]int&lt;/code>，然后使用该数组初始化一个切片&lt;code>var s2 []int = XX[:]&lt;/code>Note:使用 make，而不是直接使用&lt;code>var persons []Person&lt;/code>的声明方式。还是有所差别的，使用 make 的方式，当数组切片没有元素的时候，Json 会返回[]。如果直接声明，json 会返回 null&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="slice-的引用">Slice 的引用&lt;/h2>
&lt;h3 id="for-range-结构">for-range 结构&lt;/h3>
&lt;p>使用该结构可以对数组或切片中的索引和元素的值进行相关操作，该结构可以返回索引与元素的值&lt;/p>
&lt;p>格式：&lt;code>for INDEX,VAL := range SliceID {...}&lt;/code>。&lt;/p>
&lt;p>返回值 INDEX 为数组或切片的索引；返回值 VAL 为该索引位置的值；MapID 为该数组或切片的名字代码示例：for-range.go\&lt;/p>
&lt;h2 id="slice-的-reslice重组">Slice 的 reslice(重组)&lt;/h2>
&lt;p>在使用 &lt;code>make()&lt;/code> 函数创建切片的时候，LEN 作为切片的初始长度，而 CAP 作为所切片所相关的数组的长度。这么做的好处是切片在达到 LEN 所定义的上限后，可以扩容，直到扩容到 CAP 定义的容量。改变切片长度的过程称之为&lt;strong>切片的重组(reslicinig)&lt;/strong>。&lt;/p>
&lt;h2 id="slice-的追加-append-与复制-copy">Slice 的追加 append() 与复制 copy()&lt;/h2>
&lt;p>&lt;code>append()&lt;/code> 格式 1：&lt;code>SLICE2 := append(SLICE1, X1, X2...)&lt;/code>
df
把 X1,X2 等元素追加给切片 SLICE1，追加的元素必须和原切片的元素类型相同。如果 SLICE1 的容量不足以存储新增的元素，append 会分配新的切片来保证已有切片元素和新增元素的存储。因此，返回的切片可能已经指向一个不同的相关数组了。append 方法总是返回成功，除非系统内存耗尽了。&lt;/p>
&lt;p>append 格式 2：&lt;code>SLICE2 := append(SLICE1, SLICE3)&lt;/code>&lt;/p>
&lt;p>可以将切片 SLICE3 追加到 SLICE1 的后面&lt;/p>
&lt;p>copy 格式：&lt;code>copy(SLICE1, SLICE2)&lt;/code>把切片 2 复制给切片 1&lt;/p>
&lt;h2 id="slice-的删除">Slice 的删除&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.jianshu.com/p/604ba2ff5e67">https://www.jianshu.com/p/604ba2ff5e67&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Go 语言并没有对删除切片元素提供专用的语法或者接口，需要使用切片本身的特性来删除元素，根据要删除元素的位置有三种情况，分别是从开头位置删除、从中间位置删除和从尾部删除，其中删除切片尾部的元素速度最快。&lt;/p>
&lt;p>Go 语言中切片删除元素的本质是：以被删除元素为分界点，将前后两个部分的内存重新连接起来。&lt;/p>
&lt;p>Go 语言中切片元素的删除过程并没有提供任何的语法糖或者方法封装，无论是初学者学习，还是实际使用都是极为麻烦的。&lt;/p>
&lt;p>连续容器的元素删除无论是在任何语言中，都要将删除点前后的元素移动到新的位置。随着元素的增加，这个过程将会变得极为耗时。因此，当业务需要大量、频繁地从一个切片中删除元素时，如果对性能要求较高，就需要反思是否需要更换其他的容器（如双链表等能快速从删除点删除元素）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">seq&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>{&lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;b&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;c&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;d&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;e&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 指定删除位置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 查看删除位置之前的元素和之后的元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">seq&lt;/span>[:&lt;span style="color:#a6e22e">index&lt;/span>], &lt;span style="color:#a6e22e">seq&lt;/span>[&lt;span style="color:#a6e22e">index&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>:])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 将删除点前后的元素连接起来
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">seq&lt;/span> = append(&lt;span style="color:#a6e22e">seq&lt;/span>[:&lt;span style="color:#a6e22e">index&lt;/span>], &lt;span style="color:#a6e22e">seq&lt;/span>[&lt;span style="color:#a6e22e">index&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>:]&lt;span style="color:#f92672">...&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">seq&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>代码输出结果：
[a b] [d e]
[a b d e]
第 1 行，声明一个整型切片，保存含有从 a 到 e 的字符串。
第 4 行，为了演示和讲解方便，使用 index 变量保存需要删除的元素位置。
第 7 行中：seq[:index] 表示的就是被删除元素的前半部分，值为：
[1 2]
seq[index+1:] 表示的是被删除元素的后半部分，值为：
[4 5]
第 10 行使用 append() 函数将两个切片连接起来。
第 12 行，输出连接好的新切片。此时，索引为 2 的元素已经被删除。
代码的删除过程可以使用下图来描述。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sky27i/1666685042618-499422dc-7970-4f11-93d5-72f67a8321bd.png" alt="image.png">&lt;/p>
&lt;h1 id="排序">排序&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://pkg.go.dev/sort">Go 包，标准库，sort&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Go 的 sort 包可以对内置的数据类型以及自定义数据类型进行排序。通常都是作用在对应类型的数组、切片中。&lt;/p></description></item><item><title>Docs: ASN.1</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/asn.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/asn.1/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.itu.int/en/ITU-T/asn1/Pages/asn1_project.aspx">ITU 官网,ITU-T-ASN.1 项目&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/ASN.1">Wiki,ASN.1&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/X.690#DER_encoding">Wiki,X.690-DER_encoding&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.txrzx.com/i4477.html">http://www.txrzx.com/i4477.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://threelambda.com/2020/11/08/asn-1/">http://threelambda.com/2020/11/08/asn-1/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://lapo.it/asn1js">https://lapo.it/asn1js&lt;/a>&lt;/li>
&lt;li>《抽象语法记法 asn.1 原理与应用》&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>**Abstract Syntax Notation One(抽象语法表示法，简称 ASN.1) **是一个形式化的标准，用于定义抽象数据类型的规范。它广泛用于计算机网络中，用于描述 telecommunications protocols(电信协议) 传输数据时所使用的 &lt;strong>formal notation(正式表示法)&lt;/strong>。&lt;/p>
&lt;p>通信设备需要相互传输数据，但是设备可能是由不同厂家生产的，其硬件体系结构、程序语言的语法定义和程序功能实现一般是不相同的。例如，在一台设备中，整形数据类型是 16 位表示，而在另一台则可能用 32 位表示。这些差异导致了同一数据对象在不同的设备上被表示为不同的符号串。为了解决以上问题，ISO 组织推出了抽象语法表符号 1（ASN.1，Abstract Syntax Notation One）。ASN.1 通过定义若干简单类型和复合类型，使得各个设备对其间交换消息的数据类型有了一致的认识。系统的消息发送方采用编码规则（BER、PER）将 ASN.1 描述的消息编码成二进制字节流；消息接受方对收到的字节流进行解码，再转化为符合其自身语法的消息格式。这样，经过 ASN.1 处理的消息独立于应用环境，就不会因为系统终端的区别而产生歧义。基于 H.323 协议的视频会议系统的信令消息就是采用 ASN.1 来表示的。&lt;/p>
&lt;p>80 年代初，当时的国际电报电话咨询委员会（CCITT）将应用于 E-mail MHS 协议的基本记法和解码格式进行了标准化，形成了 X.409 方案，这是 ASN.1 的前身。该标准后来被 ISO 组织采用并将其分为抽象语法记法和传输语法，形成了 ISO/IEC 8824 和 ISO/IEC 8825 两个系列标准，且版本在不断更新之中（目前是 2015 年版本）。CCITT 于 1989 年相应地发布了 X.208（ASN.1）和 X.209（BER）取代了 X.409。但后来由国际电信联盟（ITU）在 1994 年颁布的数据结构基本描述 X.680（Specification of basic notation）、信息对象描述 X.681（Information object specification）、约束描述 X.682（Constraint specification）和规范的参数化 X.683（Parameters of ASN.1 specification）等系列标准代替了 X.208；X.209 也被 ITU 在 1994 年的 X.690~ X.696 所代替。X.680 系列和 X.690 系列又分别于 1997 年、2002 年和 2015 年更新了版本。ITU-T 的 X.680 系列和 X.690 系列分别与 ISO 的 8824 系列和 8825 系列相对应；我国从 1996 年开始也陆续颁布了相应的国家标准。欲进一步了解我国关于 ASN.1 的相关标准索引的&lt;a href="http://www.txrzx.com/i4748.html">请进入&lt;/a>。&lt;/p>
&lt;p>ASN.1 这种表示法提供了一定数量的预定义的基本类型，比如：&lt;/p>
&lt;ul>
&lt;li>INTEGER(整数)&lt;/li>
&lt;li>BOOLEAN(布尔)&lt;/li>
&lt;li>IA5String(字符串)&lt;/li>
&lt;li>BIT STRING(比特字符串)&lt;/li>
&lt;li>等等&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>并且还可以定义构造类型，比如：&lt;/p>
&lt;ul>
&lt;li>SEQUENCE(序列) # 其实就是 map&lt;/li>
&lt;li>SEQUENCE OF(顺序) # 其实就是列表
&lt;ul>
&lt;li>这就好比 yaml 中使用 &lt;code>-&lt;/code> 符号表示列表，ASN.1 用一串字母表示。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CHOICE(选择)&lt;/li>
&lt;li>等等&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>ASN.1 是 ITU-T 第 17 研究组和 ISO/IEC 中国际电信联盟电信标准化部门（ITU-T）的联合标准，最初于 1984 年定义为 CCITT X.409：1984 的一部分。1988 年，由于广泛适用，ASN.1 移至其自己的标准 &lt;em>X.208&lt;/em>。_X.680 _系列涵盖了经过实质性修订的 1995 年版本。X.680 系列建议的最新版本是 2015 年发布的 5.0 版。&lt;/p>
&lt;p>ASN.1 已经融入了人们生活的方方面面，当我们使用手机、从 ATM 取款、管理网络、在线购物、接受包裹、发送邮件、通过互联网打电话看电影听音乐，都在使用 ASN.1。每天，从 RFID、VoIP、生物识别和许多其他新兴领域，ASN.1 被选为基础技术。&lt;/p>
&lt;h1 id="encodings-rules编码规则">Encodings Rules(编码规则)&lt;/h1>
&lt;p>从计算机的角度看 ASN.1 是 abstract(抽象的)，计算机无法理解字符串，所以需要一种 Encodings Rules(编码规则)，将 ASN.1 格式的内容表示为 bits 和 bytes。这些编码规则规范了如何将 ASN.1 数据结构表示为 Bytes。&lt;strong>ASN.1 与 Encoding Rules 的关系有点像 unicode 与 utf-8 的关系&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>备注：ASN.1 与 PEM 是完全没有关系的。但是 ASN.1 编码后是二进制的数据，这不利于复制黏贴，所以，通常都需要将二进制数据再转换为便于复制黏贴的字符串，所以通常使用 DER 编码的 ASN.1 数据还会再通过 PEM 标准进行编码。
为什么要套娃？很奇怪，莫名其妙~~~~从 文本——二进制——文本，不累么。。。。。o(╯□╰)o&lt;/p>
&lt;/blockquote>
&lt;h2 id="itu-x690-标准">ITU X.690 标准&lt;/h2>
&lt;p>ITU-T X.690 标准，指定了几种 ASN.1 编码格式：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/X.690#BER_encoding">Basic Encoding Rules&lt;/a>(基本编码规则，简称 BER)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/X.690#CER_encoding">Canonical Encoding Rules&lt;/a>(规范编码规则，简称 CER)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/X.690#DER_encoding">Distinguished Encoding Rules&lt;/a>(杰出编码规则，简称 DER)&lt;/li>
&lt;/ul>
&lt;h3 id="der-编码规则">DER 编码规则&lt;/h3>
&lt;p>&lt;strong>Distinguished Encoding Rules(专用编码规则，简称 DER)&lt;/strong> 是 BER 的一种受限制变体，用于为 ASN.1 所描述的数据结构生成明确的传输语法。像 CER 一样，DER 编码是有效的 BER 编码。 DER 与 BER 相同，只是删除了一个发送者的所有选项。&lt;/p>
&lt;p>用白话说： DER 是一种以二进制形式编码 ASN.1 语法的方法&lt;/p>
&lt;p>&lt;strong>DER，是对 &lt;strong>&lt;a href="https://www.yuque.com/go/doc/33220231">&lt;strong>ASN.1&lt;/strong>&lt;/a>&lt;/strong> 这种语言进行编码的一种规则&lt;/strong>，也是最常用的一种。所谓对某种语言编码，就是类似编译器的效果。所以也可以称为 &lt;strong>ASN.1 的 DER 规则&lt;/strong>。&lt;/p>
&lt;h2 id="编码示例">编码示例&lt;/h2>
&lt;p>这是定义虚构&lt;a href="https://en.wikipedia.org/wiki/Foo">Foo&lt;/a>协议的消息（数据结构）的示例 ASN.1 模块：&lt;/p>
&lt;pre>&lt;code>FooProtocol 定义 ::= BEGIN
FooQuestion ::= SEQUENCE {
trackingNumber INTEGER,
question IA5String
}
FooAnswer ::= SEQUENCE {
questionNumber INTEGER,
answer BOOLEAN
}
END
&lt;/code>&lt;/pre>
&lt;p>这可能是 Foo 协议的创建者发布的规范。ASN.1 中没有定义会话流、交易交换和状态，而是留给协议的其他符号和文本描述。
假设一条消息符合 Foo 协议并且将被发送到接收方，这个特定的消息（&lt;a href="https://en.wikipedia.org/wiki/Protocol_data_unit">协议数据单元&lt;/a>（PDU））是：&lt;/p>
&lt;pre>&lt;code>myQuestion FooQuestion ::= {
trackingNumber 5,
question “有人在吗？”
}
&lt;/code>&lt;/pre>
&lt;p>ASN.1 支持对值和大小以及可扩展性的约束。上述规格可改为&lt;/p>
&lt;pre>&lt;code>FooProtocol DEFINITIONS ::= BEGIN
FooQuestion ::= SEQUENCE {
trackingNumber INTEGER(0..199),
question IA5String
}
FooAnswer ::= SEQUENCE {
questionNumber INTEGER(10..20),
answer BOOLEAN
}
FooHistory ::= SEQUENCE {
questions SEQUENCE (SIZE(0..10)) OF FooQuestion,
回答 SEQUENCE(SIZE(1..10)) OF FooAnswer,
anArray SEQUENCE(SIZE(100)) OF INTEGER(0..1000),
...
}
END
&lt;/code>&lt;/pre>
&lt;p>此更改将 trackingNumbers 限制为介于 0 和 199 之间的值，并将 questionNumbers 限制为介于 10 和 20 之间的值。问题数组的大小可以在 0 到 10 个元素之间，答案数组的大小可以在 1 到 10 个元素之间。anArray 字段是一个固定长度的 100 个元素的整数数组，必须在 0 到 1000 的范围内。“&amp;hellip;”扩展性标记意味着 FooHistory 消息规范在规范的未来版本中可能会有其他字段；兼容一个版本的系统应该能够接收和传输来自更高版本的事务，但只能处理早期版本中指定的字段。好的 ASN.1 编译器将生成（在 C、C++、Java 等中）源代码，这些代码将自动检查事务是否在这些约束范围内。不应从应用程序接受或向应用程序提交违反约束的事务。这一层的约束管理显着简化了协议规范，因为应用程序将免受约束违反，降低风险和成本。
为了通过网络发送 myQuestion 消息，使用其中一个&lt;a href="https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One#Encodings">编码规则&lt;/a>将消息序列化（编码）为一系列&lt;a href="https://en.wikipedia.org/wiki/Byte">字节&lt;/a>。Foo 协议规范应该明确命名要使用的一组编码规则，以便 Foo 协议的用户知道他们应该使用和期望使用哪一个。&lt;/p>
&lt;h3 id="在-der-中编码的示例编辑httpsenwikipediaorgwindexphptitleasn1actioneditsection7">在 DER 中编码的示例[&lt;a href="https://en.wikipedia.org/w/index.php?title=ASN.1&amp;amp;action=edit&amp;amp;section=7">编辑&lt;/a>]&lt;/h3>
&lt;p>下面是上面显示的 FooQuestion 以&lt;a href="https://en.wikipedia.org/wiki/X.690#DER_encoding">DER 格式&lt;/a>编码的数据结构（所有数字均为十六进制）：
30 13 02 01 05 16 0e 41 6e 79 62 6f 64 79 20 74 68 65 72 65 3f
DER 是&lt;a href="https://en.wikipedia.org/wiki/Type%E2%80%93length%E2%80%93value">类型-长度-值&lt;/a>编码，所以上面的序列可以解释，参考标准的 SEQUENCE、INTEGER 和 IA5String 类型，如下：
30 — 指示 SEQUENCE 的类型标记 13 — 以八位字节为单位的值的长度 02 — 指示整数的类型标记 01 — 以八位字节为单位的跟随值的长度 05 — 值 (5) 16 — 指示&lt;a href="https://en.wikipedia.org/wiki/IA5String">IA5String 的&lt;/a> 类型标记 （IA5 表示完整的 7 位 ISO 646 集，包括变体， 但通常是 US-ASCII） 0e — 41 6e 79 62 6f 64 79 20 74 68 65 72 65 3f — 值（“有人吗？”）&lt;/p>
&lt;h3 id="以-xer-编码的示例编辑httpsenwikipediaorgwindexphptitleasn1actioneditsection8">以 XER 编码的示例[&lt;a href="https://en.wikipedia.org/w/index.php?title=ASN.1&amp;amp;action=edit&amp;amp;section=8">编辑&lt;/a>]&lt;/h3>
&lt;p>或者，可以使用&lt;a href="https://en.wikipedia.org/wiki/XML_Encoding_Rules">XML 编码规则&lt;/a>(XER) 对相同的 ASN.1 数据结构进行&lt;a href="https://en.wikipedia.org/wiki/XML_Encoding_Rules">编码，&lt;/a>以实现更高的“在线”可读性。然后它将显示为以下 108 个八位字节，（空格数包括用于缩进的空格）：
**&lt;!-- raw HTML omitted --> ** &lt;strong>&lt;!-- raw HTML omitted -->&lt;/strong> 5 **&lt;!-- raw HTML omitted --> ** **&lt;!-- raw HTML omitted -->&lt;strong>有人在吗？&lt;/strong>&lt;!-- raw HTML omitted --> ** &lt;strong>&lt;!-- raw HTML omitted -->&lt;/strong>&lt;/p>
&lt;h3 id="以-per-编码的示例未对齐编辑httpsenwikipediaorgwindexphptitleasn1actioneditsection9">以 PER 编码的示例（未对齐）[&lt;a href="https://en.wikipedia.org/w/index.php?title=ASN.1&amp;amp;action=edit&amp;amp;section=9">编辑&lt;/a>]&lt;/h3>
&lt;p>或者，如果采用&lt;a href="https://en.wikipedia.org/wiki/Packed_Encoding_Rules">打包编码规则&lt;/a>，将产生以下 122 位（16 个八位字节等于 128 位，但这里只有 122 位携带信息，最后 6 位只是填充）：
01 05 0e 83 bb ce 2d f9 3c a0 e9 a3 2f 2c af c0
在这种格式中，所需元素的类型标记未编码，因此在不知道用于编码的预期模式的情况下无法对其进行解析。此外，IA5String 值的字节使用 7 位单元而不是 8 位单元进行打包，因为编码器知道编码 IA5String 字节值只需要 7 位。然而，长度字节仍然在此处编码，即使对于第一个整数标记 01（但 PER 打包器也可以省略它，如果它知道允许的值范围适合 8 位，它甚至可以用更少的值压缩单个值字节 05 比 8 位，如果它知道允许的值只能适合更小的范围）。
编码的 PER 中的最后 6 位在最后一个字节 c0 的 6 个最低有效位中用空位填充：如果此序列作为较长未对齐的一部分插入，则这些额外位可能不会被传输或用于编码其他内容 PER 序列。
这意味着未对齐的 PER 数据本质上是一个有序的位流，而不是像对齐的 PER 那样的有序字节流，并且在普通处理器上通过软件解码会更复杂一些，因为它需要额外的上下文位 -移位和掩码，而不是直接字节寻址（但对于现代处理器和最小可寻址单元大于 1 个八位字节的内存/存储单元，同样的评论也是正确的）。然而，现代处理器和信号处理器包括对比特流的快速内部解码的硬件支持，自动处理跨越可寻址存储单元边界的计算单元（这是在数据编解码器中进行有效处理以进行压缩/解压缩或某些加密/解密算法）。
如果需要在八位字节边界上对齐，对齐的 PER 编码器将产生：
01 05 0e 41 6e 79 62 6f 64 79 20 74 68 65 72 65 3f
（在这种情况下，每个八位字节在其未使用的最高有效位上单独填充空位）。&lt;/p>
&lt;h2 id="以一个证书分析-asn1-语法">以一个证书分析 ASN.1 语法&lt;/h2>
&lt;p>以下是一个&lt;code>PEM&lt;/code>格式的证书。&lt;/p>
&lt;pre>&lt;code>-----BEGIN CERTIFICATE-----
MIIFwTCCA6mgAwIBAgIUNQk34EiXUjqgxnfhOZtv6zxIiekwDQYJKoZIhvcNAQEN
BQAwcDELMAkGA1UEBhMCQ04xEDAOBgNVBAgMB0JlaWppbmcxEDAOBgNVBAcMB0Jl
aWppbmcxEDAOBgNVBAoMB2V4YW1wbGUxETAPBgNVBAsMCFBlcnNvbmFsMRgwFgYD
VQQDDA9yZXBvLmVubmlvdC5uZXQwHhcNMjAwODExMDMwMzE0WhcNMzAwODA5MDMw
MzE0WjBwMQswCQYDVQQGEwJDTjEQMA4GA1UECAwHQmVpamluZzEQMA4GA1UEBwwH
QmVpamluZzEQMA4GA1UECgwHZXhhbXBsZTERMA8GA1UECwwIUGVyc29uYWwxGDAW
BgNVBAMMD3JlcG8uZW5uaW90Lm5ldDCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCC
AgoCggIBAN6xDFkixeboRBjaVLi1/IjCfHvGS2xGihWrx2dN9jXIZWQqU2Lw8rLy
yzrnzSEJDRcUFGaXpRagHTYJPhcr31Sa4OkCsoorwElagcOOPQXAc1A87vBk1+r/
3eQu+IPGjr+3DU/yqNNuaq0CZgDDww9ttbyTb8JxZweXdAMjK0D7LiNCkpvwM1l6
ylVl9o5+ACA34qb81IyVAsGFSHP/ukcFIaC79Zf/7p3Tjm4uRkAdtQYJGwA0Oafk
HbPaPLOHPJdi+3+a/OmmBJamxyWXF9pJ/BRrxFrqtssnAhIyPsNqKsPDCknJOzwS
6vdTVsuMkLMUbc0OK1dSIulXxZaea+jXcZMYWUA4ZDNdo1SrMg3Vvj/CrLWgm7b0
T1Wb8tXsr2NUNoacMzDgN41Kz7Ht57LQURaFf9rzjqACHVYfj/Ad8/PmgA6V3Dc3
gvMvqOoyp2iic1xQ2GcIItHvqD4YwBSdtyxJc1N5llNBF7A6+JWVc0kJpOQCDKVb
U+0Py6ugnbb/pQ89/4zXXWyuTQO0BGULoHCo0++eF+pLcW6LstQNSUYxYRr4tmLr
sbUJFPoFcHXdQ9F8I2rBXdKCePHDBPQ2HexhANUWnRQdjtnYG9UQRQaDVKiCXUMj
9f6ixjN9DAz+SqndPksE0Ux0cgfkTEfi9N+5c7rCxzZYgH8UlFiDAgMBAAGjUzBR
MB0GA1UdDgQWBBRaOW9HUg7eACHGDuPMcc/k7nPmbjAfBgNVHSMEGDAWgBRaOW9H
Ug7eACHGDuPMcc/k7nPmbjAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBDQUA
A4ICAQCu1kx2rnRp9oiPw3Y2WuJ2hnzkMTUGPv4rpX0hgVSLNAEiDEvujz/pnHaJ
83+JZuMHebAQnWHXVaUdmzn7Yw9WsZoXu15st0WMOAC8cUZ4uD0t1osPJTSuc3hA
F0ZG3tHzuJBpX4T6pVrZ3jJvuY5vGJGCMwRdS4V7e6wQmLjzqf3oq05y9JlvKBYX
JdU69BynZ1vEtUuC91WJTTvlqLtbAS6LTSmnSYWscNpP4KOTXNfdf8HlKFRKGR2e
cVyAXu9bA89HeEeG8ztceyD2GO+S7xBNuZRV11Oi2xO59rJJAzzrIO1W8oda5lac
JVRI+n8w+hLG+bbq+24s9tVB0MBZj3/honpYRLOYMAT507YlOvDPjreudYHWJSLG
cTjRH0dtIgqbi8uTH3iJ2yWTq92OfGSSERofVdSOPrlzH5GpkpeIoRcYlP1KLnIy
wxlI4E7W50PX5rMKMIp4/p6ALgA7psuC7ZTzk3f7R/tmHBSNb5JiSbp7MjI+iVRE
zZX73VW1nLf4YaSS+MYNudAQl0ZoUvK3f0QEj4NwzRjDkdsUKI+X7Q2p03foBMCU
4ijSDMvjyn3JEvT878Fxh7KB4IbZKh3kj9RetGaGEljjgv/Pg3h2gu+GNPgk30xJ
TfK5QkRaYenm9aWKpHHf4hpUQlMKawxdS1k+3gVGwWu8YM/a0A==
-----END CERTIFICATE-----
&lt;/code>&lt;/pre>
&lt;p>对这个证书进行解析的方法是用一个在线的工具 &lt;a href="http://lapo.it/asn1js/">http://lapo.it/asn1js/&lt;/a>。&lt;/p>
&lt;p>可以把上面 base64 编码的证书复制到网站解码之后，可以看到类似如下的结果。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ylqsbb/1639220174069-639f8b9d-ae40-485a-bece-8e3ae158f746.png" alt="image.png">
ASN.1 的编码基本上遵循的是&lt;code>type+length+value&lt;/code>的方式。&lt;/p>
&lt;p>ASN.1 的数据 tag 大概有以下几种，&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>type&lt;/th>
&lt;th>tagNumber&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Boolean&lt;/td>
&lt;td>0x01&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Integer&lt;/td>
&lt;td>0x02&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>BitString&lt;/td>
&lt;td>0x03&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OctetString&lt;/td>
&lt;td>0x04&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Null&lt;/td>
&lt;td>0x05&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ObjectIdentifier&lt;/td>
&lt;td>0x06&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Enumerated&lt;/td>
&lt;td>0x0a&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UTF8String&lt;/td>
&lt;td>0x0c&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Sequence&lt;/td>
&lt;td>0x10&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Set&lt;/td>
&lt;td>0x11&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PrintableString&lt;/td>
&lt;td>0x13&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IA5String&lt;/td>
&lt;td>0x16&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UTCTime&lt;/td>
&lt;td>0x17&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UnicodeString&lt;/td>
&lt;td>0x1e&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>那么具体看一下以上 ca 证书的前四个字节是什么含义。&lt;/p>
&lt;pre>&lt;code>30 82 05 C1
&lt;/code>&lt;/pre>
&lt;ol>
&lt;li>首先看是什么 type。第一个字节&lt;code>0x30&lt;/code>描述了 type 信息。tagClass = 0x30 &amp;raquo; 6 = 0 ，表示&lt;code>universal isConstructed = 0x30 &amp;amp; 0x20 = True&lt;/code>，对于&lt;code>sequence&lt;/code>基本都是 true, &lt;code>tagNumber = 0x30 &amp;amp; 0x1F = 0x10&lt;/code> ，因此对应的&lt;code>Sequence&lt;/code>&lt;/li>
&lt;li>接下来计算长度。 第二个字节为&lt;code>0x82&lt;/code>, 分两种情况，判断表达式，&lt;code>byte &amp;amp; 0x7F == byte&lt;/code> 如果为 true 就是小于 127。否则就是大于 127。&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>长度是小于 127(short form) 那么该该字节就是 length，之后就是 value 的内容。&lt;/li>
&lt;li>长度大于 127(long form)， byte &amp;amp; 0x7F 表示 length 的编码长度。&lt;/li>
&lt;/ul>
&lt;p>对于以上的例子，&lt;code>0x82&lt;/code>是 long form 因为&lt;/p>
&lt;pre>&lt;code>( 0x82 == (0x82 &amp;amp; 0x7F) = False
&lt;/code>&lt;/pre>
&lt;p>那么表示长度的字节数量是&lt;/p>
&lt;pre>&lt;code>0x82 &amp;amp; 0x7F = 0x2
&lt;/code>&lt;/pre>
&lt;p>因此’0x82’之后的两个字节’0x05’和’0xC1’组成长度。&lt;/p>
&lt;pre>&lt;code>0x05C1 = 1473
&lt;/code>&lt;/pre>
&lt;p>两个字节表示 value 的长度 1473。&lt;/p>
&lt;p>因此，&lt;/p>
&lt;pre>&lt;code>30 82 05 C1
&lt;/code>&lt;/pre>
&lt;p>这个头四个字节的含义是，这个是&lt;code>Sequence&lt;/code>类型， 长度是 1473，这四节之后的 1473 个字节就是&lt;code>Sequence&lt;/code>类型的值。&lt;/p></description></item><item><title>Docs: C</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/c/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/c/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/C_(programming_language)">Wiki,C Programming Language&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.open-std.org/jtc1/sc22/wg14/">ISO C 工作组官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wangdoc.com/clang/">网道,C&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.learn-c.org/">https://www.learn-c.org/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="hello-world">Hello World&lt;/h1>
&lt;p>代码：&lt;code>hello_world.c&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello World&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>编译&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ gcc hello_world.c
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ ./a.out
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Hello World
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: C Library(C库)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/c-libraryc%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/c-libraryc%E5%BA%93/</guid><description/></item><item><title>Docs: Cobra</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/cli/cobra/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/cli/cobra/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/spf13/cobra">GitHub 项目，spf13/cobra&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cobra.dev/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhangguanzhang.github.io/2019/06/02/cobra/">https://zhangguanzhang.github.io/2019/06/02/cobra/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Cobra 是一个 golang 的库，其提供简单的接口来创建强大现代的 CLI 接口，类似于 git 或者 go 工具。同时，它也是一个应用，用来生成个人应用框架，从而开发以 Cobra 为基础的应用。热门的 docker 和 k8s 源码中都使用了 Cobra
Cobra 结构由三部分组成：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Command(命令)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Args(参数)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Flag(标志)&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Command&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Use&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#75715e">// The one-line usage message.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Short&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#75715e">// The short description shown in the &amp;#39;help&amp;#39; output.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Long&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#75715e">// The long message shown in the &amp;#39;help&amp;lt;this-command&amp;gt;&amp;#39; output.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Run&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">cmd&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Command&lt;/span>, &lt;span style="color:#a6e22e">args&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#75715e">// Run runs the command.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>传统 Linux 和 unix 的话命令规范为情况为下面几种&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 单独命令,例如date&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 带选项的命令&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ls -l
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 选项有值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>last -n &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 短选项合起来写,注意合起来写的时候最后一个选项以外的选项都必须是无法带值的，例如last -n 3 -R只能合起来写成下面的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>last -Rn &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 无值的长选项&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rm --force
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 带值的长选项&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>last --num &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>last --num&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>find -type f
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 值能追加的命令&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>command --host ip1 --host ip2 &lt;span style="color:#75715e">#命令内部能完整读取所有host做处理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 带args的命令&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rm file1 file2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cat -n file1 file2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 多级命令&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip addr show
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip addr delete xxx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 所有情况的命令&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cmd sub_cmd1 subcmd2 --host 10.0.0.2 -nL3 -d &lt;span style="color:#e6db74">&amp;#39;:&amp;#39;&lt;/span> --username&lt;span style="color:#f92672">=&lt;/span>admin &lt;span style="color:#e6db74">&amp;#39;^a&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;^b&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>而 cobra 是针对长短选项和多级命令都支持的库，单独或者混合都是支持的，不过大多数还是用来写多级命令的 cli tool 用的。命令的格式为下列&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>rootCommand subcommand1 subcommand2 -X value --XXXX value -Y a -Y b --ZZ c --ZZ d args1 args2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前三个是不同场景下的说明，最后一个是要执行的函数&lt;/p>
&lt;h2 id="使用-cobra-编写的典型项目">使用 Cobra 编写的典型项目&lt;/h2>
&lt;p>Cobra 用于许多 Go 项目，例如 &lt;a href="https://kubernetes.io/">Kubernetes&lt;/a>、 &lt;a href="https://gohugo.io/">Hugo&lt;/a> 和 &lt;a href="https://github.com/cli/cli">GitHub CLI&lt;/a> 等等。&lt;a href="https://github.com/spf13/cobra/blob/main/projects_using_cobra.md">此列表&lt;/a>包含更广泛的使用 Cobra 的项目列表。
&lt;a href="https://github.com/gohugoio/hugo">https://github.com/gohugoio/hugo&lt;/a>
&lt;a href="https://github.com/containerd/nerdctl">https://github.com/containerd/nerdctl&lt;/a>&lt;/p>
&lt;h1 id="安装与导入">安装与导入&lt;/h1>
&lt;p>安装&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>go get -u github.com/spf13/cobra@latest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>导入&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;github.com/spf13/cobra&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="cobra-命令行工具">Cobra 命令行工具&lt;/h2>
&lt;p>cobra-cli 是一个命令行程序，用于生成 Cobra 应用程序和命令文件。它将引导您的应用程序脚手架以快速开发基于 Cobra 的应用程序。这是将 Cobra 合并到您的应用程序中的最简单方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>go install github.com/spf13/cobra-cli@latest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安装后会创建一个可执行文件 cobra-cli 位于 &lt;code>${GOPATH}/bin&lt;/code> 目录中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ go env | grep GOPATH
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GOPATH&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/home/lichenhao/go&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ which cobra-cli
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/home/lichenhao/go/bin/cobra-cli
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="cobra-的基本使用">Cobra 的基本使用&lt;/h1>
&lt;p>我们使用 &lt;code>go mod init github.com/DesistDaydream/go-cobra&lt;/code> 初始化一个项目。
Cobra 的应用程序目录结构通常如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ tree
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── LICENSE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── cmd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── root.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── go.mod
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── go.sum
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── main.go
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>cobra-cli 默认情况下，Cobra 将添加 Apache 许可证。如果您不想这样，可以将标志添加 &lt;code>-l none&lt;/code> 到所有生成器命令。但是，它会在每个文件顶部添加 &lt;code>Copyright © 2022 NAME HERE &amp;lt;EMAIL ADDRESS&amp;gt;&lt;/code> 这样的添加版权声明。如果通过选项 &lt;code>-a YOUR NAME&lt;/code> 则索赔将包含您的姓名。
&lt;strong>注意：使用 cobra-cli 生成的目录结构在真正使用时并不灵活，我们通常会将 XXXCmd 变量封装到函数数，以便可以对变量进行更多的处理。灵活性更大。下面的使用示例并不是生产推荐的结构和用法。&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>main.go&lt;/code> 文件非常简单，只有一个目的，初始化 Cobra&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;github.com/DesistDaydream/go-cobra/cmd&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">cmd&lt;/span>.&lt;span style="color:#a6e22e">Execute&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="创建命令">创建命令&lt;/h2>
&lt;p>&lt;code>Command{}&lt;/code> 是 Cobra 命令的&lt;strong>核心结构体&lt;/strong>，只有有了这个结构体，才能围绕命令执行方法、设置命令行标志等。&lt;/p>
&lt;h3 id="创建根命令rootcmd">创建根命令(rootCmd)&lt;/h3>
&lt;p>根命令通常放在 &lt;code>cmd/root.go&lt;/code> 文件中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// rootCmd 表示在没有任何子命令调用的情况时的基本命令
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">rootCmd&lt;/span> = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">cobra&lt;/span>.&lt;span style="color:#a6e22e">Command&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Use&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;go-cobra&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Short&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;这个应用简要的描述&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Long&lt;/span>: &lt;span style="color:#e6db74">`横跨多行的较长描述，可能包含示例和使用应用程序的用法。 例如：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">当我运行程序时，会显示该描述内容
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> 如果使用缩进，这行在界面展示时有缩进。`&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Run&lt;/span>: &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">cmd&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">cobra&lt;/span>.&lt;span style="color:#a6e22e">Command&lt;/span>, &lt;span style="color:#a6e22e">args&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 如果这个应用没有任何子命令，直接使用 go-cobra 执行的话，将会执行这里面的代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="创建子命令">创建子命令&lt;/h3>
&lt;p>使用 &lt;code>Command.AddCommand()&lt;/code> 方法将一个或多个命令添加到父命令中，下面的示例可以为根命令添加一个 version 子命令。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rootCmd&lt;/span>.&lt;span style="color:#a6e22e">AddCommand&lt;/span>(&lt;span style="color:#a6e22e">versionCmd&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">versionCmd&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">cobra&lt;/span>.&lt;span style="color:#a6e22e">Command&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Use&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;version&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Short&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;这个命令的简要描述&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Long&lt;/span>: &lt;span style="color:#e6db74">`横跨多行的较长描述，可能包含示例和使用命令的用法。`&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Run&lt;/span>: &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">cmd&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">cobra&lt;/span>.&lt;span style="color:#a6e22e">Command&lt;/span>, &lt;span style="color:#a6e22e">args&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;version called&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="flag命令行标志">Flag(命令行标志)&lt;/h2>
&lt;p>标志可以是“持久的”，这意味着该标志将可用于分配给它的命令以及该命令下的每个命令。对于全局标志，将标志分配为根上的持久标志。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">rootCmd&lt;/span>.&lt;span style="color:#a6e22e">PersistentFlags&lt;/span>().&lt;span style="color:#a6e22e">StringVarP&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">rootFlags&lt;/span>.&lt;span style="color:#a6e22e">CfgFile&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;config&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;c&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;指定配置文件&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以在本地分配一个标志，它只适用于该特定命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">rootCmd&lt;/span>.&lt;span style="color:#a6e22e">Flags&lt;/span>().&lt;span style="color:#a6e22e">BoolP&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;toggle&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;t&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;关于toggle标志的帮助信息&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>实际命令都有选项，分为持久和本地，持久例如&lt;code>kubectl&lt;/code>的&lt;code>-n&lt;/code>可以用在很多二级命令下，本地命令选项则不会被继承到子命令。我们给 remove 添加一个移除指定名字的选项，修改&lt;code>cmd/remove.go&lt;/code>的 init 函数：
添加 Flags 使用 &lt;code>Command.Flags()&lt;/code> 或 &lt;code>cmd.PersistentFlags()&lt;/code> 方法，具体有以下使用规律&lt;/p>
&lt;ul>
&lt;li>
&lt;!-- raw HTML omitted -->
&lt;/li>
&lt;li>&lt;!-- raw HTML omitted -->P&lt;/li>
&lt;li>&lt;!-- raw HTML omitted -->Var&lt;/li>
&lt;li>&lt;!-- raw HTML omitted -->VarP&lt;/li>
&lt;/ul>
&lt;p>带 P 的相对没带 P 的多了个短选项,没带 P 的选项只能用&lt;code>--long-iotion&lt;/code>这样，而不能使用 &lt;code>-l&lt;/code> 这种。&lt;/p>
&lt;ul>
&lt;li>获取选项的值用&lt;code>cmd.Flags().GetString(&amp;quot;name&amp;quot;)&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>不带 Var 的获取值使用&lt;code>Get&amp;lt;type&amp;gt;(&amp;quot;FlagName&amp;quot;)&lt;/code>，这样似乎非常麻烦，实际中都是用后面俩种 Var 直接传入地址自动注入的，例如&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">dates&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">cmd&lt;/span>.&lt;span style="color:#a6e22e">Flags&lt;/span>().&lt;span style="color:#a6e22e">Int32VarP&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">dates&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;date&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;d&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">1234&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;this is var test&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>type 有 &lt;code>Slice&lt;/code>，&lt;code>Count&lt;/code>，&lt;code>Duration&lt;/code>,&lt;code>IP&lt;/code>,&lt;code>IPMask&lt;/code>,&lt;code>IPNet&lt;/code> 之类的类型,Slice 类型可以多个传入，直接获取就是一个切片，例如 &lt;code>--master ip1 --master ip2&lt;/code>&lt;/li>
&lt;li>类似 &lt;code>--force&lt;/code> 这样的开关型选项，实际上用 Bool 类型即可，默认值设置为 false，单独给选项不带值就是 true，也可以手动传入 false 或者 true&lt;/li>
&lt;li>MarkDeprecated 告诉用户放弃这个标注位，应该使用新标志位，MarkShorthandDeprecated 是只放弃短的，长标志位依然可用。MarkHidden 隐藏标志位&lt;/li>
&lt;li>&lt;code>MarkFlagRequired(&amp;quot;region&amp;quot;)&lt;/code> 表示 region 是必须的选项，不设置下选项都是可选的&lt;/li>
&lt;/ul>
&lt;h2 id="读取配置文件">读取配置文件&lt;/h2>
&lt;p>~~类似~~&lt;code>~~kubectl~~&lt;/code>~~ 的~~&lt;code>~~~/.kube/config~~&lt;/code>~~ 和 ~~&lt;code>~~gcloud~~&lt;/code>&lt;del>这些 &lt;del>&lt;code>~~cli~~&lt;/code>&lt;/del> 都会读取一些配置信息，也可以从命令行指定信息。细心观察的话可以看到这个是一直存在在命令帮助上的&lt;/del>&lt;/p>
&lt;pre>&lt;code>Global Flags:
--config string config file (default is $HOME/.cli.yaml)
&lt;/code>&lt;/pre>
&lt;p>~~spf13 里的 viper 包的几个方法就是干这个的，viper 是 cobra 集成的配置文件读取的库
可以通过环境变量读取~~&lt;/p>
&lt;pre>&lt;code>removeCmd.Flags().StringP(&amp;quot;name&amp;quot;, &amp;quot;n&amp;quot;, viper.GetString(&amp;quot;ENVNAME&amp;quot;), &amp;quot;The application to be executed&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>~~默认可以在 &lt;del>&lt;code>~~cmd/root.go~~&lt;/code>&lt;/del> 文件里看到默认配置文件是家目录下的.应用名，这里我是~~&lt;code>~~$HOME/.cli.yaml~~&lt;/code>&lt;del>，创建并添加下面内容&lt;/del>&lt;/p>
&lt;pre>&lt;code>name: &amp;quot;Billy&amp;quot;
greeting: &amp;quot;Howdy&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>~~Command 的 Run 里提取字段~~&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Run&lt;/span>: &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">cmd&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">cobra&lt;/span>.&lt;span style="color:#a6e22e">Command&lt;/span>, &lt;span style="color:#a6e22e">args&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">greeting&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">cmd&lt;/span>.&lt;span style="color:#a6e22e">Flags&lt;/span>().&lt;span style="color:#a6e22e">GetString&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;World&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">viper&lt;/span>.&lt;span style="color:#a6e22e">GetString&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>)&lt;span style="color:#f92672">!=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span> = &lt;span style="color:#a6e22e">viper&lt;/span>.&lt;span style="color:#a6e22e">GetString&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">viper&lt;/span>.&lt;span style="color:#a6e22e">GetString&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;greeting&amp;#34;&lt;/span>)&lt;span style="color:#f92672">!=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">greeting&lt;/span> = &lt;span style="color:#a6e22e">viper&lt;/span>.&lt;span style="color:#a6e22e">GetString&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;greeting&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">greeting&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>},
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以将配置文件中的值绑定到命令行 Flag 里。在下面的示例中，通过 viper 包获取到的 author 的值将会绑定到命令行 Flag 的 author 中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">author&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rootCmd&lt;/span>.&lt;span style="color:#a6e22e">PersistentFlags&lt;/span>().&lt;span style="color:#a6e22e">StringVar&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">author&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;author&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;YOUR NAME&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Author name for copyright attribution&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">viper&lt;/span>.&lt;span style="color:#a6e22e">BindPFlag&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;author&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">rootCmd&lt;/span>.&lt;span style="color:#a6e22e">PersistentFlags&lt;/span>().&lt;span style="color:#a6e22e">Lookup&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;author&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 不想使用的话相关可以注释掉 viper 相关的，编译出来的程序能小几M
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="rootgo-文件简单示例">root.go 文件简单示例&lt;/h1>
&lt;p>&lt;code>rootCmd&lt;/code> 的声明通常会被封装在一个函数中，这个封装函数会被 Execute() 执行。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">Copyright © 2022 NAME HERE &amp;lt;EMAIL ADDRESS&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">cmd&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;os&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vipercmd&lt;/span> &lt;span style="color:#e6db74">&amp;#34;github.com/DesistDaydream/go-cobra/cmd/viper&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;github.com/DesistDaydream/go-cobra/config&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;github.com/spf13/cobra&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">RootFlags&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 这里定义的变量，可以在下面的 init 函数中，通过 rootCmd.PersistentFlags().StringVar(&amp;amp;CfgFile, &amp;#34;config&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;指定配置文件(默认在$HOME/.cobracli.yaml)&amp;#34;) 进行绑定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 也可以通过 viper 进行绑定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">CfgFile&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">rootFlags&lt;/span> &lt;span style="color:#a6e22e">RootFlags&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Execute 将所有子命令添加到根命令并设置 Flags。这由 main.main() 调用。它只需要对 rootCmd 发生一次。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Execute&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">app&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">newApp&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">app&lt;/span>.&lt;span style="color:#a6e22e">Execute&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Exit&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">newApp&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">cobra&lt;/span>.&lt;span style="color:#a6e22e">Command&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// rootCmd 表示在没有任何子命令调用的情况时的基本命令。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">rootCmd&lt;/span> = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">cobra&lt;/span>.&lt;span style="color:#a6e22e">Command&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Use&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;go-cobra&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Short&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;这个应用简要的描述&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Long&lt;/span>: &lt;span style="color:#e6db74">`横跨多行的较长描述，可能包含示例和使用应用程序的用法。 例如：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">当我运行程序时，会显示该描述内容
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> 如果使用缩进，这行在界面展示时有缩进。`&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 如果这个应用没有任何子命令，直接使用 go-cobra 执行的话，将会执行下面 Run 字段指定的函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Run&lt;/span>: &lt;span style="color:#a6e22e">rootRun&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 我们可以在这里定义命令行 Flags 和 配置设置。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 这里可以做一些初始化的工作，比如初始化数据库连接、初始化日志、读取配置文件等等
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ######## 添加 命令行Flags ########
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Cobra 支持 持久性flags (i.e. Global Flags)，如果在这个位置定义，则这些 flags 对应用程序来说是全局的。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 第一个参数是变量，用于存储该flag的值；第二个参数为该flag的名字；第三个参数为该flag的默认值,无默认值可以为空；第四个参数是该flag的描述信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 比如我现在使用如下命令: go-cobra --config abc 。那么 cfgFile 的值为abc。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">rootCmd&lt;/span>.&lt;span style="color:#a6e22e">PersistentFlags&lt;/span>().&lt;span style="color:#a6e22e">StringVarP&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">rootFlags&lt;/span>.&lt;span style="color:#a6e22e">CfgFile&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;config&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;c&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;指定配置文件&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Cobra 还支持本地 flags ，仅在直接调用此命令时才有意义。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">rootCmd&lt;/span>.&lt;span style="color:#a6e22e">Flags&lt;/span>().&lt;span style="color:#a6e22e">BoolP&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;toggle&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;t&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;关于toggle标志的帮助信息&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ######## 添加 配置 ########
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// ！！！注意！！！：Cobra 只有在上面的 Run 字段定义的函数运行之前才会解析手动指定的命令行 Flags，否则只能获取到代码中设置的 Flags 默认值。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 比如运行 go run main.go --config=&amp;#34;abc.yaml&amp;#34; 时，rootFlags.CfgFile 并不会被赋值为 abc.yaml，而是默认值。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 此时有两种方式解决这个问题：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 1. 使用 Prase() 函数，提前解析 Flags：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// rootCmd.PersistentFlags().Parse(os.Args)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 2. 使用 OnInitialize() 函数，该函数会在 Command.Run 字段指定的函数执行前，先执行 initConfig 函数。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 查看 Cobra 源码，OnInitialize() 中的 initializers 变量会在 preRun() 函数中被执行。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">cobra&lt;/span>.&lt;span style="color:#a6e22e">OnInitialize&lt;/span>(&lt;span style="color:#a6e22e">initConfig&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 假如我现在在这里执加了一行 config.NewConfig(rootFlags.CfgFile)，那么这个函数其实是会在 OnInitialize 函数执行之前执行的。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// config.NewConfig(rootFlags.CfgFile)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ######## 添加 子命令 ########
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 为了更好的管理子命令，我们通常会将子命令放在不同的文件中，然后在这里进行注册
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">rootCmd&lt;/span>.&lt;span style="color:#a6e22e">AddCommand&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">NewVersionCmd&lt;/span>(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vipercmd&lt;/span>.&lt;span style="color:#a6e22e">NewViperCmd&lt;/span>(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">rootCmd&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">initConfig&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用 Viper 简化处理配置文件的过程。Viper 可以从 JSON、TOML、YAML、HCL、环境变量和命令行参数等等地方中读取配置。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">config&lt;/span>.&lt;span style="color:#a6e22e">NewConfig&lt;/span>(&lt;span style="color:#a6e22e">rootFlags&lt;/span>.&lt;span style="color:#a6e22e">CfgFile&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">rootRun&lt;/span>(&lt;span style="color:#a6e22e">cmd&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">cobra&lt;/span>.&lt;span style="color:#a6e22e">Command&lt;/span>, &lt;span style="color:#a6e22e">args&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;主程序运行后执行的代码块。如果注销 Run，则运行主程序会显示上面Long上的信息&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;在 Run 字段指定的函数中，我们可以获取到 Flags 的值：&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">rootFlags&lt;/span>.&lt;span style="color:#a6e22e">CfgFile&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="cobracommand-结构体解析">cobra.Command 结构体解析&lt;/h1>
&lt;h3 id="别名aliases">别名(Aliases)&lt;/h3>
&lt;p>现在我们想添加一个别名&lt;/p>
&lt;pre>&lt;code>cli
|----app
|----remove|rm
&lt;/code>&lt;/pre>
&lt;p>我们修改下初始化值即可&lt;/p>
&lt;pre>&lt;code>var removeCmd = &amp;amp;cobra.Command{
Use: &amp;quot;remove&amp;quot;,
Aliases: []string{&amp;quot;rm&amp;quot;},
&lt;/code>&lt;/pre>
&lt;h3 id="命令帮助添加示例example">命令帮助添加示例(Example)&lt;/h3>
&lt;p>我们修改下 remove 的 Run 为下面&lt;/p>
&lt;pre>&lt;code>Run: func(cmd *cobra.Command, args []string) {
if len(args) == 0 {
cmd.Help()
return
}
},
&lt;/code>&lt;/pre>
&lt;p>运行输出里 example 是空的&lt;/p>
&lt;pre>&lt;code>[root@k8s-m1 cli]# go run main.go app remove
A longer description that spans multiple lines and likely contains examples
and usage of using your command. For example:
Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.
Usage:
cli app remove [flags]
Aliases:
remove, rm
Flags:
-h, --help help for remove
-n, --name string The application to be executed
Global Flags:
--config string config file (default is $HOME/.cli.yaml)
&lt;/code>&lt;/pre>
&lt;p>添加 example&lt;/p>
&lt;pre>&lt;code>var removeCmd = &amp;amp;cobra.Command{
Use: &amp;quot;remove&amp;quot;,
Aliases: []string{&amp;quot;rm&amp;quot;},
Example: `
cli remove -n test
cli remove --name test
`,
&lt;/code>&lt;/pre>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>go run main.go app remove
A longer description that spans multiple lines and likely contains examples
and usage of using your command. For example:
Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.
Usage:
cli app remove [flags]
Aliases:
remove, rm
Examples:
cli remove -n test
cli remove --name test
Flags:
-h, --help help for remove
-n, --name string The application to be executed
Global Flags:
--config string config file (default is $HOME/.cli.yaml)
&lt;/code>&lt;/pre>
&lt;h3 id="参数验证器args">参数验证器(Args)&lt;/h3>
&lt;p>该字段接收类型为&lt;code>type PositionalArgs func(cmd *Command, args []string) error&lt;/code>
内置的为下面几个:&lt;/p>
&lt;ul>
&lt;li>&lt;code>NoArgs&lt;/code>: 如果存在任何位置参数，该命令将报告错误。&lt;/li>
&lt;li>&lt;code>ArbitraryArgs&lt;/code>: 该命令将接受任何 args。&lt;/li>
&lt;li>&lt;code>OnlyValidArgs&lt;/code>: 如果存在任何不在 ValidArgs 字段中的位置参数，该命令将报告错误 Command。&lt;/li>
&lt;li>&lt;code>MinimumNArgs(int)&lt;/code>: 如果没有至少 N 个位置参数，该命令将报告错误。&lt;/li>
&lt;li>&lt;code>MaximumNArgs(int)&lt;/code>: 如果有多于 N 个位置参数，该命令将报告错误。&lt;/li>
&lt;li>&lt;code>ExactArgs(int)&lt;/code>: 如果没有确切的 N 位置参数，该命令将报告错误。&lt;/li>
&lt;li>&lt;code>RangeArgs(min, max):&lt;/code> 如果 args 的数量不在预期 args 的最小和最大数量之间，则该命令将报告错误。&lt;/li>
&lt;li>自己写的话传入符合类型定义的函数即可```plaintext
Args: func(cmd *cobra.Command, args []string) error {
if len(args) &amp;lt; 1 {
return errors.New(&amp;ldquo;requires at least one arg&amp;rdquo;)
}
if myapp.IsValidColor(args[0]) {
return nil
}
return fmt.Errorf(&amp;ldquo;invalid color specified: %s&amp;rdquo;, args[0])
},&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>
前面说的没传递选项和任何值希望打印命令帮助也可以用`MinimumNArgs(1)`来触发
### [](#Run的hook &amp;#34;Run的hook&amp;#34;)Run的hook[](#Run的hook)
Run功能的执行先后顺序如下：
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>PersistentPreRun&lt;/li>
&lt;li>PreRun&lt;/li>
&lt;li>Run&lt;/li>
&lt;li>PostRun&lt;/li>
&lt;li>PersistentPostRun
接收&lt;code>func(cmd *Command, args []string)&lt;/code>类型的函数，Persistent 的能被下面的子命令继承
RunE 功能的执行先后顺序如下：&lt;/li>
&lt;li>PersistentPreRunE&lt;/li>
&lt;li>PreRunE&lt;/li>
&lt;li>RunE&lt;/li>
&lt;li>PostRunE&lt;/li>
&lt;li>PersistentPostRunE&lt;/li>
&lt;/ul>
&lt;p>接收&lt;code>func(cmd *Command, args []string) error&lt;/code>的函数&lt;/p>
&lt;h3 id="自定义-helpusage-输出">自定义 help,usage 输出&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>help```plaintext
command.SetHelpCommand(cmd *Command)
command.SetHelpFunc(f func(*Command, []string))
command.SetHelpTemplate(s string)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>usage```plaintext
command.SetUsageFunc(f func(*Command) error)
command.SetUsageTemplate(s string)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>
[http://www.xtgxiso.com/golang%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%85%B3%E6%B3%A8%E5%93%8D%E5%BA%94%E7%9A%84http%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1/](http://www.xtgxiso.com/golang%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%85%B3%E6%B3%A8%E5%93%8D%E5%BA%94%E7%9A%84http%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1/)
[https://blog.csdn.net/cs380637384/article/details/81231817](https://blog.csdn.net/cs380637384/article/details/81231817)
[https://studygolang.com/articles/7588](https://studygolang.com/articles/7588)
[https://www.cppentry.com/bencandy.php?fid=78&amp;amp;aid=213235&amp;amp;page=2](https://www.cppentry.com/bencandy.php?fid=78&amp;amp;aid=213235&amp;amp;page=2)
[https://ordina-jworks.github.io/development/2018/10/20/make-your-own-cli-with-golang-and-cobra.html#getting-started](https://ordina-jworks.github.io/development/2018/10/20/make-your-own-cli-with-golang-and-cobra.html#getting-started)
&lt;/code>&lt;/pre>&lt;h1 id="run-的-hook">Run 的 hook&lt;/h1>
&lt;p>Run 功能的执行先后顺序如下：&lt;/p>
&lt;ul>
&lt;li>PersistentPreRun&lt;/li>
&lt;li>PreRun&lt;/li>
&lt;li>Run&lt;/li>
&lt;li>PostRun&lt;/li>
&lt;li>PersistentPostRun&lt;/li>
&lt;/ul>
&lt;p>接收 &lt;code>func(cmd *Command, args []string)&lt;/code> 类型的函数，Persistent 的能被下面的子命令继承
RunE 功能的执行先后顺序如下：&lt;/p>
&lt;ul>
&lt;li>PersistentPreRunE&lt;/li>
&lt;li>PreRunE&lt;/li>
&lt;li>RunE&lt;/li>
&lt;li>PostRunE&lt;/li>
&lt;li>PersistentPostRunE&lt;/li>
&lt;/ul>
&lt;p>接收 &lt;code>func(cmd *Command, args []string) error&lt;/code> 的函数&lt;/p>
&lt;h3 id="注意">注意&lt;/h3>
&lt;p>当具有多级子命令时，&lt;code>PersistentXXX()&lt;/code> 相关函数只会执行一次
比如现在创建了一个 cobra 命令，具有如下几个子命令&lt;/p>
&lt;ul>
&lt;li>add
&lt;ul>
&lt;li>command&lt;/li>
&lt;li>args&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>del&lt;/li>
&lt;/ul>
&lt;p>如果在 cobra 和 add 中都使用了 PersistentPreRun() 函数的话，只会有第一个执行，并且是子命令的方法优先
参考 Issue：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/spf13/cobra/issues/216">https://github.com/spf13/cobra/issues/216&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/spf13/cobra/issues/252">https://github.com/spf13/cobra/issues/252&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>可以在最底层的子命令中，通过如下方式执行父命令的 &lt;code>PersistenXXX()&lt;/code> 函数&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">CreateCommand&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">cobra&lt;/span>.&lt;span style="color:#a6e22e">Command&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">subCmd&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">cobra&lt;/span>.&lt;span style="color:#a6e22e">Command&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">PersistentPreRun&lt;/span>: &lt;span style="color:#a6e22e">subPersistentPreRun&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">subCmd&lt;/span>.&lt;span style="color:#a6e22e">AddCommand&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">CreateSubSubCommand&lt;/span>(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">subCmd&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">subPersistentPreRun&lt;/span>(&lt;span style="color:#a6e22e">cmd&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">cobra&lt;/span>.&lt;span style="color:#a6e22e">Command&lt;/span>, &lt;span style="color:#a6e22e">args&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 执行父命令的预运行逻辑
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">parent&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">cmd&lt;/span>.&lt;span style="color:#a6e22e">Parent&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">parent&lt;/span>.&lt;span style="color:#a6e22e">PersistentPreRun&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">parent&lt;/span>.&lt;span style="color:#a6e22e">PersistentPreRun&lt;/span>(&lt;span style="color:#a6e22e">parent&lt;/span>, &lt;span style="color:#a6e22e">args&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 本子命令的预运行逻辑
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="注意-2">注意 2：&lt;/h3>
&lt;p>&lt;code>parent.PersistentPreRun(parent, args)&lt;/code> 函数只会让下面一层子命令集成，也就是说，如果有这么一个命令 &lt;code>cmd c1 c2 c3 c4&lt;/code>，此时我们在 c1 出执行 &lt;code>parent.PersistentPreRun(parent, args)&lt;/code>，那么执行 c3 或 c4 时，上述继承效果将不会生效。如果想要让 c4 也继承 c1 的，则需要在 c2 和 c3 出也执行 &lt;code>parent.PersistentPreRun(parent, args)&lt;/code> 函数&lt;/p>
&lt;h2 id="自定义-helpusage-输出-1">自定义 help,usage 输出&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>help&lt;/p>
&lt;pre>&lt;code> command.SetHelpCommand(cmd *Command)command.SetHelpFunc(f func(*Command, []string))command.SetHelpTemplate(s string)
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>usage&lt;/p>
&lt;pre>&lt;code> command.SetUsageFunc(f func(*Command) error)command.SetUsageTemplate(s string)
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="http://www.xtgxiso.com/golang%25E5%25AE%259E%25E7%258E%25B0%25E7%259A%2584%25E4%25B8%2580%25E4%25B8%25AA%25E4%25B8%258D%25E5%2585%25B3%25E6%25B3%25A8%25E5%2593%258D%25E5%25BA%2594%25E7%259A%2584http%25E4%25BB%25A3%25E7%2590%2586%25E6%259C%258D%25E5%258A%25A1/">http://www.xtgxiso.com/golang%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%85%B3%E6%B3%A8%E5%93%8D%E5%BA%94%E7%9A%84http%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1/&lt;/a>
&lt;a href="https://blog.csdn.net/cs380637384/article/details/81231817">https://blog.csdn.net/cs380637384/article/details/81231817&lt;/a>
&lt;a href="https://studygolang.com/articles/7588">https://studygolang.com/articles/7588&lt;/a>
&lt;a href="https://www.cppentry.com/bencandy.php?fid=78&amp;amp;aid=213235&amp;amp;page=2">https://www.cppentry.com/bencandy.php?fid=78&amp;amp;aid=213235&amp;amp;page=2&lt;/a>
&lt;a href="https://ordina-jworks.github.io/development/2018/10/20/make-your-own-cli-with-golang-and-cobra.html#getting-started">https://ordina-jworks.github.io/development/2018/10/20/make-your-own-cli-with-golang-and-cobra.html#getting-started&lt;/a>&lt;/p></description></item><item><title>Docs: Contexts 与 Variables</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/github/github-actions/contexts-%E4%B8%8E-variables/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/github/github-actions/contexts-%E4%B8%8E-variables/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.github.com/en/actions/learn-github-actions/contexts">官方文档，学习 GitHub Actions-上下文&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.github.com/en/actions/learn-github-actions/environment-variables">官方文档，学习 GitHub Actions-环境变量&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>GitHub Actions 中可以通过 &lt;strong>Contexts(上下文)&lt;/strong> 与 &lt;strong>Environment Variables(环境变量)&lt;/strong> 来暴露工作流的信息或引用工作流的信息。就像下面的示例一样：&lt;/p>
&lt;p>这是一个环境变量的示例：&lt;/p>
&lt;blockquote>
&lt;p>GitHub Action 中的环境变量本质上是 Shell 中的变量，引用方式也是一样的。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Greeting on variable day&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">on&lt;/span>: &lt;span style="color:#ae81ff">workflow_dispatch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">env&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">DAY_OF_WEEK&lt;/span>: &lt;span style="color:#ae81ff">Monday&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">jobs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">greeting_job&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">runs-on&lt;/span>: &lt;span style="color:#ae81ff">ubuntu-latest&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">env&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">Greeting&lt;/span>: &lt;span style="color:#ae81ff">Hello&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">steps&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Say Hello Mona it&amp;#39;s Monday&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">run&lt;/span>: &lt;span style="color:#ae81ff">echo &amp;#34;$Greeting $First_Name. Today is $DAY_OF_WEEK!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">env&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">First_Name&lt;/span>: &lt;span style="color:#ae81ff">Mona&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是一个上下文的示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Greeting on variable day&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">on&lt;/span>: &lt;span style="color:#ae81ff">workflow_dispatch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">env&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">DAY_OF_WEEK&lt;/span>: &lt;span style="color:#ae81ff">Monday&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">jobs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">greeting_job&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">runs-on&lt;/span>: &lt;span style="color:#ae81ff">ubuntu-latest&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">env&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">Greeting&lt;/span>: &lt;span style="color:#ae81ff">Hello&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">steps&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Say Hello Mona it&amp;#39;s Monday&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">run&lt;/span>: &lt;span style="color:#ae81ff">echo &amp;#34;${{ env.Greeting }} ${{ env.First_Name }}. Today is ${{ env.DAY_OF_WEEK }}!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">env&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">First_Name&lt;/span>: &lt;span style="color:#ae81ff">Mona&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从示例中可以看到，想要使用 &lt;strong>Context(上下文)&lt;/strong>，需要使用一种特殊的语法，这种语法称为 &lt;strong>Expressions(表达式)&lt;/strong>。&lt;/p>
&lt;h2 id="expressions表达式">Expressions(表达式)&lt;/h2>
&lt;p>在 GitHub Actions 的 Workflow 文件中，我们可以使用 &lt;strong>Expressions(表达式)&lt;/strong> 设置和访问** 环境变量 &lt;strong>或访问&lt;/strong>上下文 **信息。表达式可以是 &lt;em>字面量、上下文引用、函数&lt;/em> 的任意组合。&lt;/p>
&lt;p>以 &lt;code>$&lt;/code> 开口，&lt;code>{{ }}&lt;/code> 括起来的内容即为表达式的语法，当 GitHub Action 运行时，Workflow 中的 &lt;code>${{ &amp;lt;EXPRESSION&amp;gt; }}&lt;/code> 内容会被解析为表达式进行处理，表达式就像模板一样，解析完成后，使用实际的值替换表达式。以实现以变成的方式设置 Workflow 文件。&lt;/p>
&lt;blockquote>
&lt;p>注意：
Workflow 中的 if 字段，会自动将其下的值解析为表达式，所以可以省略 &lt;code>${{ }}&lt;/code> 符号。&lt;/p>
&lt;/blockquote>
&lt;p>表达式 Fiterals(字面量)&lt;/p>
&lt;p>表达式 Operators(运算符)&lt;/p>
&lt;p>表达式 Functions(函数)&lt;/p>
&lt;ul>
&lt;li>contains&lt;/li>
&lt;li>startsWith&lt;/li>
&lt;li>endsWith&lt;/li>
&lt;li>format&lt;/li>
&lt;li>join&lt;/li>
&lt;li>toJSON&lt;/li>
&lt;li>fromJSON&lt;/li>
&lt;li>hashFiles&lt;/li>
&lt;li>状态检查函数
&lt;ul>
&lt;li>success&lt;/li>
&lt;li>always&lt;/li>
&lt;li>cancelled&lt;/li>
&lt;li>failure&lt;/li>
&lt;li>Evaluate Status Explicitly&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>函数使用示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">print&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">on&lt;/span>: &lt;span style="color:#ae81ff">push&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">env&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">continue&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">time&lt;/span>: &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">jobs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">job1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">runs-on&lt;/span>: &lt;span style="color:#ae81ff">ubuntu-latest&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">steps&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">continue-on-error&lt;/span>: &lt;span style="color:#ae81ff">${{ fromJSON(env.continue) }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">timeout-minutes&lt;/span>: &lt;span style="color:#ae81ff">${{ fromJSON(env.time) }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">run&lt;/span>: &lt;span style="color:#ae81ff">echo ...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="context上下文">Context(上下文)&lt;/h2>
&lt;p>GitHub Action 中的上下文，是一种功能更丰富的环境变量，并且我们可以通过上下文的语法引用环境变量。&lt;/p>
&lt;p>在 Expressions(表达式) 中使用 Context(上下文)，可以让我们在 Workflow 文件中访问工作流运行信息、运行器环境信息、Job 信息、每个 Job 下的 Step 信息。&lt;/p>
&lt;p>每个上下文都是一个包含 &lt;strong>Properties(属性)&lt;/strong> 的 &lt;strong>Object(对象&lt;/strong>)，Properties 可以是字符串或其他 Objects&lt;/p>
&lt;p>在表达式语中使用上下文的语法为：&lt;code>${{ Object.Properties }}&lt;/code>。每个 Object 可以提供丰富的信息。&lt;/p>
&lt;p>现阶段 Action 有多个上下文可用：&lt;/p>
&lt;ul>
&lt;li>GitHub 本身信息相关的上下文
&lt;ul>
&lt;li>&lt;strong>github&lt;/strong> # Information about the workflow run.&lt;/li>
&lt;li>&lt;strong>secrets&lt;/strong> # Contains the names and values of secrets that are available to a workflow run.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Job 信息相关的上下文
&lt;ul>
&lt;li>&lt;strong>needs&lt;/strong> # Contains the outputs of all jobs that are defined as a dependency of the current job&lt;/li>
&lt;li>&lt;strong>env&lt;/strong> # Contains environment variables set in a workflow, job, or step.&lt;/li>
&lt;li>&lt;strong>job&lt;/strong> # Information about the currently running job.&lt;/li>
&lt;li>&lt;strong>steps&lt;/strong> # Information about the steps that have been run in the current job.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>runner&lt;/strong> # Information about the runner that is running the current job.&lt;/li>
&lt;li>&lt;strong>strategy&lt;/strong> # Information about the matrix execution strategy for the current job.&lt;/li>
&lt;li>&lt;strong>matrix&lt;/strong> # Contains the matrix properties defined in the workflow that apply to the current job.&lt;/li>
&lt;li>&lt;strong>inputs&lt;/strong> # Contains the inputs of a reusable workflow. For more information, see inputscontext&lt;/li>
&lt;/ul>
&lt;h1 id="github-本身信息相关的上下文">GitHub 本身信息相关的上下文&lt;/h1>
&lt;h2 id="github-上下文">github 上下文&lt;/h2>
&lt;p>github 上下文包含本次工作流的事件信息，还有很多 GitHub 信息，比如 &lt;code>github.actor&lt;/code> 属性表示发起工作流的用户名，如果这个项目只有自己一个人，那就是这个仓库的拥有者名称~&lt;/p>
&lt;h2 id="secrets-上下文">secrets 上下文&lt;/h2>
&lt;p>对于工作流程运行中的每个 Job，此上下文都是相同的。 您可以从 Job 中的任何步骤访问此上下文。 此对象包含下面列出的所有属性。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性名称&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>secrets.GITHUB_TOKEN&lt;/td>
&lt;td>String&lt;/td>
&lt;td>为每个工作流程运行自动创建的令牌。 更多信息请参阅“&lt;a href="https://docs.github.com/cn/actions/security-guides/automatic-token-authentication">自动令牌身份验证&lt;/a>”。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>secrets.&lt;!-- raw HTML omitted -->&lt;/td>
&lt;td>String&lt;/td>
&lt;td>特定 Secret 的值&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>SecretName 可以在在一个项目的设置中添加，如下图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qaf8qw/1652758616297-59e0ad52-f622-4d41-9235-b36a995ee87d.png" alt="image.png">
我们为本仓库添加了一个 SecretName 为 DOCKER_REGISTRY_PASSWORD 的 Secret，那么，在 Actions 中，可以使用 &lt;code>${{ secrets.DOCKER_REGISTRY_PASSWORD }}&lt;/code> 引用 DOCKER_REGISTRY_PASSWORD 的值。&lt;/p>
&lt;p>这个上下文常用在登录行为，以防止将密码以明文形式呈现，比如下面的示例，我们将会通过 secrets 上下文登录容器镜像仓库，并推送构建的镜像到仓库中。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">jobs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 推送到 docker.io&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">push-docker&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">needs&lt;/span>: [&lt;span style="color:#ae81ff">generate-tags]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">runs-on&lt;/span>: &lt;span style="color:#ae81ff">ubuntu-latest&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">steps&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Check out repository code&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">actions/checkout@v2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">登录镜像仓库网站&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">docker/login-action@v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">with&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">registry&lt;/span>: &lt;span style="color:#ae81ff">docker.io&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">username&lt;/span>: &lt;span style="color:#ae81ff">${{ secrets.DOCKER_REGISTRY_USERNAME }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">password&lt;/span>: &lt;span style="color:#ae81ff">${{ secrets.DOCKER_REGISTRY_PASSWORD }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">构建并推送容器镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">docker/build-push-action@v2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">with&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">context&lt;/span>: &lt;span style="color:#ae81ff">.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">file&lt;/span>: &lt;span style="color:#ae81ff">Dockerfile&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">push&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">tags&lt;/span>: &lt;span style="color:#ae81ff">docker.io/lchdzh/e37-exporter:${{needs.generate-tags.outputs.tag}}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="job-信息相关的上下文">Job 信息相关的上下文&lt;/h1>
&lt;h2 id="needs-上下文">needs 上下文&lt;/h2>
&lt;p>needs 上下文中包含了由 jobs.JOB_ID.needs 字段定义的依赖 Job 中的信息。包含如下属性：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>needs.&amp;lt;JOB_ID&amp;gt;&lt;/th>
&lt;th>OBJECT&lt;/th>
&lt;th>A single job that the current job depends on.&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>needs.&amp;lt;JOB_ID&amp;gt;.outputs&lt;/td>
&lt;td>OBJECT&lt;/td>
&lt;td>The set of outputs of a job that the current job depends on.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>needs.&amp;lt;JOB_ID&amp;gt;.outputs.&amp;lt;OUTPUT_NAME&amp;gt;&lt;/td>
&lt;td>STRING&lt;/td>
&lt;td>当前 Job 所依赖的 Job 的输出中，OUTPUT_NAME 输出的值。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>needs.&amp;lt;JOB_ID&amp;gt;.result&lt;/td>
&lt;td>STRING&lt;/td>
&lt;td>当前 Job 所依赖的 Job 的运行结果。可能的值有：success, failure, cancelled, or skipped。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="steps-上下文">steps 上下文&lt;/h2>
&lt;p>此上下文针对作业中的每个步骤而改变。 您可以从作业中的任何步骤访问此上下文。 此对象包含下面列出的所有属性。
steps 上下文中包含了已指定 JOB_ID 且已运行的 Job 中的每个 step 的信息，包含如下属性&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性名称&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>steps.&amp;lt;step_id&amp;gt;.outputs&lt;/td>
&lt;td>对象&lt;/td>
&lt;td>为步骤定义的输出集。 更多信息请参阅“&lt;a href="https://docs.github.com/cn/articles/metadata-syntax-for-github-actions#outputs-for-docker-container-and-javascript-actions">GitHub Actions 的元数据语法&lt;/a>”。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>steps.&amp;lt;step_id&amp;gt;.conclusion&lt;/td>
&lt;td>字符串&lt;/td>
&lt;td>在 &lt;a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions#jobsjob_idstepscontinue-on-error">continue-on-error&lt;/a> 应用之后完成的步骤的结果。 可能的值包括 success、failure、cancelled 或 skipped。 当 continue-on-error 步骤失败时，outcome 为 failure，但最终的 conclusion 为 success。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>steps.&amp;lt;step_id&amp;gt;.outcome&lt;/td>
&lt;td>字符串&lt;/td>
&lt;td>在 &lt;a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions#jobsjob_idstepscontinue-on-error">continue-on-error&lt;/a> 应用之前完成的步骤的结果。 可能的值包括 success、failure、cancelled 或 skipped。 当 continue-on-error 步骤失败时，outcome 为 failure，但最终的 conclusion 为 success。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>steps.&amp;lt;step_id&amp;gt;.outputs.&amp;lt;output_name&amp;gt;&lt;/td>
&lt;td>字符串&lt;/td>
&lt;td>指定 StepIP 步骤中指定的 OutputName 输出的值。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="示例">示例&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Generate random failure&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">on&lt;/span>: &lt;span style="color:#ae81ff">push&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">jobs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">randomly-failing-job&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">runs-on&lt;/span>: &lt;span style="color:#ae81ff">ubuntu-latest&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">steps&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">id&lt;/span>: &lt;span style="color:#ae81ff">checkout&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">actions/checkout@v3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Generate 0 or 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">id&lt;/span>: &lt;span style="color:#ae81ff">generate_number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">run&lt;/span>: &lt;span style="color:#ae81ff">echo &amp;#34;::set-output name=random_number::$(($RANDOM % 2))&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Pass or fail&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">run&lt;/span>: |&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &lt;/span> &lt;span style="color:#ae81ff">if [[ ${{ steps.generate_number.outputs.random_number }} == 0 ]]; then exit 0; else exit 1; fi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过 &lt;code>${{ steps.generate_number.outputs.random_number }}&lt;/code> 引用了当前 Job 中 ID 为 generate_number 这个步骤的输出中，random_number 的值。&lt;/p></description></item><item><title>Docs: Control Structures(控制结构)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/control-structures%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/control-structures%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>当我们需要只在满足一些特定情况时才执行某些代码的时候，也就是说在代码里进行条件判断。针对这个需求，Go 语言提供了 4 中条件结构和分支结构。&lt;/p>
&lt;p>在结构中，可以使用&lt;code>break&lt;/code>和&lt;code>continue&lt;/code>这样的关键字来中途改变结构的状态。还可以使用&lt;code>return&lt;/code>来结束某个函数的执行，或使用&lt;code>goto&lt;/code>和标签来调整程序的执行位置&lt;/p>
&lt;h1 id="for-循环">For 循环&lt;/h1>
&lt;p>用于测试某个条件(布尔型或逻辑型)的语句，初始化语句执行完成之后；如果该条件成立，则会执行 if 后由大括号括起来的代码块，然后执行修饰语句，之后再次判断条件语句是否成立，如此循环；直到条件语句不成立时，就忽略该代码块继续执行后续的代码。&lt;/p>
&lt;ul>
&lt;li>基本格式：for 初始化语句;条件语句;修饰语句 {代码块}&lt;/li>
&lt;/ul>
&lt;h1 id="if-else-判断">If-else 判断&lt;/h1>
&lt;h1 id="switch-判断">Switch 判断&lt;/h1>
&lt;p>给定一个变量，当该变量满足某个条件时执行某个代码。&lt;/p>
&lt;h1 id="select">select&lt;/h1>
&lt;h1 id="break-与-continue">break 与 continue&lt;/h1>
&lt;ul>
&lt;li>&lt;code>break&lt;/code> 用于退出当前当前代码块&lt;/li>
&lt;li>&lt;code>continue&lt;/code> 用于忽略当前循环，继续执行后续循环，只用于 for 结构体中 Note：注意！是退出当前代码块，如果循环有多层嵌套，那么只是退出当前循环；如果循环中套用 select 等，则也是退出当前控制结构。&lt;/li>
&lt;/ul>
&lt;h1 id="标签与-goto">标签与 goto&lt;/h1>
&lt;ul>
&lt;li>标签用于在出现标签关键字的时候，代码回到标签定义行再继续执行下面的代码。某一行以&lt;code>:&lt;/code>冒号结尾的单词即可定义标签。标签区分大小写&lt;/li>
&lt;/ul></description></item><item><title>Docs: Coroutine(协程)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/coroutine%E5%8D%8F%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/coroutine%E5%8D%8F%E7%A8%8B/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Coroutine">Wiki,Coroutine&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/xGe51EVn2qw2Gojh7cZqUg">协程，被我玩会了！&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Coroutine(协程)&lt;/strong> 是计算机程序组件，通过允许暂停和恢复执行来概括非抢占式多任务处理的子程序。协程非常适合实现熟悉的程序组件，例如协作任务、异常、事件循环、迭代器、无限列表和管道。&lt;/p>
&lt;h1 id="协程被我玩会了">协程，被我玩会了&lt;/h1>
&lt;p>前言&lt;/p>
&lt;p>大家好，我的朋友们！&lt;/p>
&lt;p>干了这么年后端，写过 C/C++、Python、Go，每次说到协程的时候，脑海里就只能浮现一些关键字 yeild、async、go 等等。&lt;/p>
&lt;p>但是对于协程这个知识点，我理解的一直比较模糊，于是决定搞清楚。&lt;/p>
&lt;p>全文阅读预计耗时 10 分钟，少刷几个小视频的时间，多学点知识，想想就很划算噻！&lt;/p>
&lt;h2 id="协程概念的诞生">协程概念的诞生&lt;/h2>
&lt;p>先抛一个粗浅的结论：&lt;strong>协程从广义来说是一种设计理念，我们常说的只是具体的实现&lt;/strong>。&lt;/p>
&lt;p>理解好思想，技术点就很简单了，关于协程道与术的区别：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cca25e20-fc2c-4409-961f-2cac27b433fe/640" alt="">&lt;/p>
&lt;h3 id="上古神器-cobol">上古神器 COBOL&lt;/h3>
&lt;p>协程概念的出现比线程更早，甚至可以追溯到 20 世纪 50 年代，提协程就必须要说到一门生命力极强的最早的高级编程语言 COBOL。&lt;/p>
&lt;p>最开始我以为 COBOL 这门语言早就消失在历史长河中，但是我错了。&lt;/p>
&lt;blockquote>
&lt;p>COBOL 语言，是一种面向过程的高级程序设计语言，主要用于数据处理，是国际上应用最广泛的一种高级语言。COBOL 是英文 Common Business-Oriented Language 的缩写，原意是面向商业的通用语言。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>截止到今年在全球范围内大约有 1w 台大型机中有 3.8w + 遗留系统中约 2000 亿行代码是由 COBOL 写的，占比高达 65%，同时在美国很多政府和企业机构都是基于 COBOL 打造的，影响力巨大。&lt;/p>
&lt;/blockquote>
&lt;p>时间拉回 1958 年，美国计算机科学家梅尔文 · 康威 (Melvin Conway) 就开始钻研&lt;strong>基于磁带存储的 COBOL 的编译器优化问题&lt;/strong>，这在当时是个非常热门的话题，不少青年才俊都扑进去了，包括图灵奖得主唐纳德 · 尔文 · 克努斯教授 (Donald Ervin Knuth) 也写了一个优化后的编译器。&lt;/p>
&lt;p>看看这两位的简介，我沉默了：&lt;/p>
&lt;blockquote>
&lt;p>梅尔文 · 康威 (Melvin Conway) 也是一位超级大佬，著名的康威定律提出者。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cca25e20-fc2c-4409-961f-2cac27b433fe/640" alt="">&lt;/p>
&lt;blockquote>
&lt;p>唐纳德 · 尔文 · 克努斯是算法和程序设计技术的先驱者，1974 年的图灵奖得主，计算机排版系统 TeX 和字型设计系统 METAFONT 的发明者，他因这些成就和大量创造性的影响深远的著作而誉满全球，《计算机程序设计的艺术》被《美国科学家》杂志列为 20 世纪最重要的 12 本物理科学类专著之一。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cca25e20-fc2c-4409-961f-2cac27b433fe/640" alt="">
那究竟是什么问题让这群天才们投入这么大的精力呢？快来看看！&lt;/p>
&lt;h3 id="cobol-编译器的技术难题">COBOL 编译器的技术难题&lt;/h3>
&lt;p>我们都是知道高级编程语言需要借助编译器来生成二进制可执行文件，编译器的基本步骤包括：&lt;strong>读取字符流、词法分析、语法分析、语义分析、代码生成器、代码优化器等&lt;/strong>。&lt;/p>
&lt;p>这种管道式的流程，上一步的输出作为下一步的输入，将中间结果存储在内存即可，这在现代计算机上毫无压力，但是受限于软硬件水平，在几十年前的 COBOL 语言却是很难的。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cca25e20-fc2c-4409-961f-2cac27b433fe/640" alt="">
在 1958 年的时候，当时的存储还不发达，磁带作为存储器是 1951 年在计算机中得到应用的，所以那个时代的 COBOL 很依赖于磁带。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cca25e20-fc2c-4409-961f-2cac27b433fe/640" alt="">
其实，我在网上找了很多资料去看当时的编译器有什么问题，只找到了一条：编译器无法做到读一次磁带就可以完成整个编译过程，也就是所谓的 one-pass 编译器还没有产生。&lt;/p>
&lt;blockquote>
&lt;p>当时的 COBOL 程序被写在一个磁带上，而磁带不支持随机读写，只能顺序读，而当时的内存又不可能把整个磁带的内容都装进去，所以一次读取没编译完就要再从头读。&lt;/p>
&lt;/blockquote>
&lt;p>于是，我脑补了 COBOL 编译器和磁带之间可能的两种 multi-pass 形式的交互情况：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>可能情况一&lt;/strong>
对于 COBOL 的编译器来说，要完成词法分析、语法分析就要从磁带上读取程序的源代码，在之前的编译器中词法分析和语法分析是相互独立的，这就意味着：&lt;/li>
&lt;li>词法分析时需要将磁带从头到尾过一遍&lt;/li>
&lt;li>语法分析时需要将磁带从头到尾过一遍&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cca25e20-fc2c-4409-961f-2cac27b433fe/640" alt="">&lt;/li>
&lt;li>&lt;strong>可能情况二&lt;/strong>
听过磁带的朋友们一定知道磁带的两个基本操作：倒带和快进。
在完成编译器的词法分析和语法分析两件事情时，需要磁带反复的倒带和快进去寻找两类分析所需的部分，类似于磁盘的寻道，磁头需要反复移动横跳，并且当时的磁带不一定支持随机读写。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cca25e20-fc2c-4409-961f-2cac27b433fe/640" alt="">&lt;/li>
&lt;/ul>
&lt;p>从一些资料可以看到，COBOL 当时编译器各个环节相互独立的，这种软硬件的综合限制导致无法实现 one-pass 编译。&lt;/p>
&lt;h3 id="协同式解决方案">协同式解决方案&lt;/h3>
&lt;p>在梅尔文 · 康威的编译器设计中&lt;strong>将词法分析和语法分析合作运行，而不再像其他编译器那样相互独立，两个模块交织运行，编译器的控制流在词法分析和语法分析之间来回切换&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>当词法分析模块基于词素产生足够多的词法单元 Token 时就控制流转给语法分析&lt;/li>
&lt;li>当语法分析模块处理完所有的词法单元 Token 时将控制流转给词法分析模块&lt;/li>
&lt;li>词法分析和语法分析各自维护自身的运行状态，并且具备主动让出和恢复的能力&lt;/li>
&lt;/ul>
&lt;p>可以看到这个方案的核心思想在于：&lt;/p>
&lt;blockquote>
&lt;p>梅尔文 · 康威构建的这种协同工作机制，需要参与者让出（yield）控制流时，记住自身状态，以便在控制流返回时能从上次让出的位置恢复（resume）执行。简言之，&lt;code>协程的全部精神就在于控制流的主动让出和恢复&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cca25e20-fc2c-4409-961f-2cac27b433fe/640" alt="">
这种协作式的任务流和计算机中断非常像，在当时条件的限制下，由梅尔文 · 康威提出的这种让出 / 恢复模式的协作程序被认为是最早的协程概念，并且基于这种思想可以打造新的 COBOL 编译器。&lt;/p>
&lt;p>在 1963 年，梅尔文 · 康威也发表了一篇论文来说明自己的这种思想，虽然半个多世纪过去了，有幸我还是找到了这篇论文：&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://melconway.com/Home/pdf/compiler.pdf">https://melconway.com/Home/pdf/compiler.pdf&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cca25e20-fc2c-4409-961f-2cac27b433fe/640" alt="">
说实话这 paper 真是有点难，时间过于久远，很难有共鸣，最后我放弃了，要不然我或许能搞明白之前编译器的具体问题了。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cca25e20-fc2c-4409-961f-2cac27b433fe/640" alt="">&lt;/p>
&lt;h2 id="怀才不遇的协程">怀才不遇的协程&lt;/h2>
&lt;p>虽然协程概念出现的时间比线程还要早，但是协程一直都没有正是登上舞台，真是有点怀才不遇的赶脚。&lt;/p>
&lt;p>我们上学的时候，老师就讲过一些软件设计思想，其中主流语言崇尚自顶向下 top-down 的编程思想:&lt;/p>
&lt;blockquote>
&lt;p>对要完成的任务进行分解，先对最高层次中的问题进行定义、设计、编程和测试，而将其中未解决的问题作为一个子任务放到下一层次中去解决。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>这样逐层、逐个地进行定义、设计、编程和测试，直到所有层次上的问题均由实用程序来解决，就能设计出具有层次结构的程序。&lt;/p>
&lt;/blockquote>
&lt;p>C 语言就是典型的 top-down 思想的代表，在 main 函数作为入口，各个模块依次形成层次化的调用关系，同时各个模块还有下级的子模块，同样有层次调用关系。&lt;/p>
&lt;p>但是&lt;strong>协程这种相互协作调度的思想和 top-down 是不合的，在协程中各个模块之间存在很大的耦合关系，并不符合高内聚低耦合的编程思想&lt;/strong>，相比之下 top-down 使程序结构清晰、层次调度明确，代码可读性和维护性都很不错。&lt;/p>
&lt;p>与线程相比，协作式任务系统让调用者自己来决定什么时候让出，比操作系统的抢占式调度所需要的时间代价要小很多，后者为了能恢复现场会在切换线程时保存相当多的状态，并且会非常频繁地进行切换，资源消耗更大。&lt;/p>
&lt;p>综合来说，&lt;strong>协程完全是用户态的行为，由程序员自己决定什么时候让出控制权，保存现场和切换恢复使用的资源也非常少，同时对提高处理器效率来说也是完全符合的&lt;/strong>。&lt;/p>
&lt;p>那么不禁要问：协程看着不错，为啥没成为主流呢？&lt;/p>
&lt;ul>
&lt;li>&lt;strong>协程的思想和当时的主流不符合&lt;/strong>&lt;/li>
&lt;li>&lt;strong>抢占式的线程可以解决大部分的问题，让使用者感受的痛点不足&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>换句话说：协程能干的线程干得也不错，线程干的不好的地方，使用者暂时也不太需要，所以协程就这样怀才不遇了。&lt;/p>
&lt;blockquote>
&lt;p>其实，协程虽然在 x86 架构上没有折腾出大风浪，由于抢占式任务系统依赖于 CPU 硬件的支持，对硬件要求比较高，对于一些嵌入式设备来说，协同调度再合适不过了，所以协程在另外一个领域也施展了拳脚。&lt;/p>
&lt;/blockquote>
&lt;h2 id="协程的雄起">协程的雄起&lt;/h2>
&lt;p>&lt;strong>我们对于 CPU 的压榨从未停止。&lt;/strong>&lt;/p>
&lt;p>对于 CPU 来说，任务分为两大类：&lt;strong>计算密集型和 IO 密集型&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cca25e20-fc2c-4409-961f-2cac27b433fe/640" alt="">&lt;/p>
&lt;p>计算密集型已经可以最大程度发挥 CPU 的作用，但是 IO 密集型一直是提高 CPU 利用率的难点。&lt;/p>
&lt;h3 id="io-密集型任务之痛">IO 密集型任务之痛&lt;/h3>
&lt;p>对于 IO 密集型任务，在抢占式调度中也有对应的解决方案：&lt;strong>异步 + 回调&lt;/strong>。&lt;/p>
&lt;p>也就是遇到 IO 阻塞，比如下载图片时会立即返回，等待下载完成将结果进行回调处理，交付给发起者。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cca25e20-fc2c-4409-961f-2cac27b433fe/640" alt="">&lt;/p>
&lt;blockquote>
&lt;p>就像你常去早餐店，油条还没好，你和老板很熟悉就先交了钱去座位玩手机了，等你的油条好了，服务员就端过去了，这就是典型的异步 + 回调。&lt;/p>
&lt;/blockquote>
&lt;p>虽然异步 + 回调在现实生活中看着也很简单，但是在程序设计上却很让人头痛，在某些场景下会让整个程序的可读性非常差，而且也不好写，相反同步 IO 虽然效率低，但是很好写，&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cca25e20-fc2c-4409-961f-2cac27b433fe/640" alt="">&lt;/p>
&lt;p>还是以为异步图片下载为例，图片服务中台提供了异步接口，发起者请求之后立即返回，图片服务此时给了发起者一个唯一标识 ID，等图片服务完成下载后把结果放到一个消息队列，此时需要发起者不断消费这个 MQ 才能拿到下载结果。&lt;/p>
&lt;p>整个过程相比同步 IO 来说，&lt;strong>原来整体的逻辑被拆分为好几个部分，各个子部分有状态的迁移，对大部分程序员来说维护状态简直就是噩梦，日后必然是 bug 的高发地&lt;/strong>。&lt;/p>
&lt;h3 id="用户态协同调度">用户态协同调度&lt;/h3>
&lt;p>随着网络技术的发展和高并发要求，对于抢占式调度对 IO 型任务处理的低效逐渐受到重视，终于协程的机会来了。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cca25e20-fc2c-4409-961f-2cac27b433fe/640" alt="">&lt;/p>
&lt;p>协程将 IO 的处理权交给了程序员，遇到 IO 被阻塞时就交出控制权给其他协程，等其他协程处理完再把控制权交回来。&lt;/p>
&lt;p>&lt;strong>通过 yield 方式转移执行权的多个协程之间并非调用者和被调用者的关系，而是彼此平等、对称、合作的关系。&lt;/strong>&lt;/p>
&lt;p>协程一直没有占上风的原因，除了设计思想的矛盾，还有一些其他原因，毕竟协程也不是银弹，来看看协程有什么问题：&lt;/p>
&lt;ul>
&lt;li>协程无法利用多核，需要配合进程来使用才可以在多 CPU 上发挥作用&lt;/li>
&lt;li>线程的回调机制仍然有巨大生命力，协程无法全部替代&lt;/li>
&lt;li>控制权需要转移可能造成某些协程的饥饿，抢占式更加公平&lt;/li>
&lt;li>协程的控制权由用户态决定可能转移给某些恶意的代码，抢占式由操作系统来调度更加安全&lt;/li>
&lt;/ul>
&lt;p>综上来说，&lt;strong>协程和线程并非矛盾，协程的威力在于 IO 的处理，恰好这部分是线程的软肋，由对立转换为合作才能开辟新局面&lt;/strong>。&lt;/p>
&lt;h2 id="拥抱协程的编程语言">拥抱协程的编程语言&lt;/h2>
&lt;p>网络操作、文件操作、数据库操作、消息队列操作等重 IO 操作，是任何高级编程语言无法避开的问题，也是提高程序效率的关键。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cca25e20-fc2c-4409-961f-2cac27b433fe/640" alt="">&lt;/p>
&lt;p>像 Java、C/C++、Python 这些老牌语言也陆续开始借助于第三方包来支持协程，来解决自身语言的不足。&lt;/p>
&lt;p>像 Golang 这种新生选手，在语言层面原生支持了协程，可以说是彻底拥抱协程，这也造就了 Go 的高并发能力。&lt;/p>
&lt;p>我们来分别看看它们是怎么实现协程的，以及实现协程的关键点是什么。&lt;/p>
&lt;h3 id="python">Python&lt;/h3>
&lt;p>Python 对协程的支持也经历了多个版本，从部分支持到完善支持一直在演进：&lt;/p>
&lt;ul>
&lt;li>Python2.x 对协程的支持比较有限，生成器 yield 实现了一部分但不完全&lt;/li>
&lt;li>第三方库 gevent 对协程的实现有比较好，但不是官方的&lt;/li>
&lt;li>Python3.4 加入了 asyncio 模块&lt;/li>
&lt;li>在 Python3.5 中又提供了 async/await 语法层面的支持&lt;/li>
&lt;li>Python3.6 中 asyncio 模块更加完善和稳&lt;/li>
&lt;li>Python3.7 开始 async/await 成为保留关键字&lt;/li>
&lt;/ul>
&lt;p>我们以最新的 async/await 来说明 Python 的协程是如何使用的：&lt;/p>
&lt;p>`import asyncio
from pathlib import Path
import logging
from urllib.request import urlopen, Request
import os
from time import time
import aiohttp&lt;/p>
&lt;p>logging.basicConfig(level=logging.INFO, format=&amp;rsquo;%(asctime)s - %(name)s - %(levelname)s - %(message)s&amp;rsquo;)
logger = logging.getLogger(&lt;strong>name&lt;/strong>)&lt;/p>
&lt;p>CODEFLEX_IMAGES_URLS = [&amp;rsquo;&lt;a href="https://codeflex.co/wp-content/uploads/2021/01/pandas-dataframe-python-1024x512.png">https://codeflex.co/wp-content/uploads/2021/01/pandas-dataframe-python-1024x512.png&lt;/a>&amp;rsquo;,
                        &amp;lsquo;&lt;a href="https://codeflex.co/wp-content/uploads/2021/02/github-actions-deployment-to-eks-with-kustomize-1024x536.jpg">https://codeflex.co/wp-content/uploads/2021/02/github-actions-deployment-to-eks-with-kustomize-1024x536.jpg&lt;/a>&amp;rsquo;,
                        &amp;lsquo;&lt;a href="https://codeflex.co/wp-content/uploads/2021/02/boto3-s3-multipart-upload-1024x536.jpg">https://codeflex.co/wp-content/uploads/2021/02/boto3-s3-multipart-upload-1024x536.jpg&lt;/a>&amp;rsquo;,
                        &amp;lsquo;&lt;a href="https://codeflex.co/wp-content/uploads/2018/02/kafka-cluster-architecture.jpg">https://codeflex.co/wp-content/uploads/2018/02/kafka-cluster-architecture.jpg&lt;/a>&amp;rsquo;,
                        &amp;lsquo;&lt;a href="https://codeflex.co/wp-content/uploads/2016/09/redis-cluster-topology.png">https://codeflex.co/wp-content/uploads/2016/09/redis-cluster-topology.png&lt;/a>&amp;rsquo;]&lt;/p>
&lt;p>async def download_image_async(session, dir, img_url):
    download_path = dir / os.path.basename(img_url)
    async with session.get(img_url) as response:
        with download_path.open(&amp;lsquo;wb&amp;rsquo;) as f:
            while True:
                chunk = await response.content.read(512)
                if not chunk:
                    break
                f.write(chunk)
    logger.info(&amp;lsquo;Downloaded:&amp;rsquo; + img_url)&lt;/p>
&lt;p>async def main():
    images_dir = Path(&amp;ldquo;codeflex_images&amp;rdquo;)
    Path(&amp;ldquo;codeflex_images&amp;rdquo;).mkdir(parents=False, exist_ok=True)&lt;/p>
&lt;p>async with aiohttp.ClientSession() as session:
        tasks = [(download_image_async(session, images_dir, img_url)) for img_url in CODEFLEX_IMAGES_URLS]
        await asyncio.gather(*tasks, return_exceptions=True)&lt;/p>
&lt;p>if &lt;strong>name&lt;/strong> == &amp;lsquo;&lt;strong>main&lt;/strong>&amp;rsquo;:
    start = time()&lt;/p>
&lt;p>event_loop = asyncio.get_event_loop()
    try:
        event_loop.run_until_complete(main())
    finally:
        event_loop.close()&lt;/p>
&lt;p>logger.info(&amp;lsquo;Download time: %s seconds&amp;rsquo;, time() - start)&lt;/p>
&lt;p>`&lt;/p>
&lt;p>这段代码展示了如何使用 async/await 来实现图片的并发下载功能。&lt;/p>
&lt;ul>
&lt;li>在普通的函数 def 前面加 async 关键字就变成异步 / 协程函数，调用该函数并不会运行，而是返回一个协程对象，后续在 event_loop 中执行&lt;/li>
&lt;li>await 表示等待 task 执行完成，也就是 yeild 让出控制权，同时 asyncio 使用事件循环 event_loop 来实现整个过程，await 需要在 async 标注的函数中使用&lt;/li>
&lt;li>event_loop 事件循环充当管理者的角色，将控制权在几个协程函数之间切换&lt;/li>
&lt;/ul>
&lt;h3 id="c">C++&lt;/h3>
&lt;p>在 C++20 引入协程框架，但是很不成熟，换句话说是给写协程库的大佬用的最底层的东西，用起来就很复杂门槛比较高。&lt;/p>
&lt;p>C++ 作为高性能服务器开发语言的无冕之王，各大公司也做了很多尝试来使用协程功能，比如&lt;strong>boost.coroutine、微信的 libco、libgo、云风用 C 实现的协程库&lt;/strong>等。&lt;/p>
&lt;p>说实话，C++ 协程相关的东西有点复杂，后面专门写一下，在此不展开了。&lt;/p>
&lt;h3 id="go">Go&lt;/h3>
&lt;p>go 中的协程被称为 goroutine，被认为是用户态更轻量级的线程，协程对操作系统而言是透明的，也就是操作系统无法直接调度协程，因此必须有个中间层来接管 goroutine。&lt;/p>
&lt;p>goroutine 仍然是基于线程来实现的，因为线程才是 CPU 调度的基本单位，在 go 语言内部维护了一组数据结构和 N 个线程，协程的代码被放进队列中来由线程来实现调度执行，这就是著名的 GMP 模型。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>G:Goroutine&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>每个 Gotoutine 对应一个 G 结构体，G 存储 Goroutine 的运行堆栈，状态，以及任务函数，可重用函数实体 G 需要保存到 P 的队列或者全局队列才能被调度执行。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>M:machine&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>M 是线程的抽象，代表真正执行计算的资源，在绑定有效的 P 后，进入调度执行循环，M 会从 P 的本地队列来执行，&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>P:Processor&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>P 是一个抽象的概念，不是物理上的 CPU 而是表示逻辑处理器。当一个 P 有任务，需要创建或者唤醒一个系统线程 M 去处理它队列中的任务。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>P 决定同时执行的任务的数量，GOMAXPROCS 限制系统线程执行用户层面的任务的数量。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>对 M 来说，P 提供了相关的执行环境，入内存分配状态，任务队列等。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cca25e20-fc2c-4409-961f-2cac27b433fe/640" alt="">&lt;/p>
&lt;p>&lt;strong>GMP 模型运行的基本过程&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>首先创建一个 G 对象，然后 G 被保存在 P 的本地队列或者全局队列&lt;/li>
&lt;li>这时 P 会唤醒一个 M，M 寻找一个空闲的 P 将 G 移动到它自己，然后 M 执行一个调度循环：调用 G 对象 -&amp;gt; 执行 -&amp;gt; 清理线程 -&amp;gt; 继续寻找 Goroutine。&lt;/li>
&lt;li>在 M 的执行过程中，上下文切换随时发生。当切换发生，任务的执行现场需要被保护，这样在下一次调度执行可以进行现场恢复。&lt;/li>
&lt;li>M 的栈保存在 G 对象，只有现场恢复需要的寄存器 (SP,PC 等)，需要被保存到 G 对象。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cca25e20-fc2c-4409-961f-2cac27b433fe/640" alt="">&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本文通过 1960 年对 COBOL 语言编译器的 one-pass 问题的介绍，让大家看到了协同式程序的最早背景以及主动让出 / 恢复的重要理念。&lt;/p>
&lt;p>紧接着介绍了主流的自顶向下的软件设计思想和协程思想的矛盾所在，并且抢占式程序调度的蓬勃发展，以及存在的问题。&lt;/p>
&lt;p>继续介绍了关于 IO 密集型任务对于提升 CPU 效率的阻碍，抢占式调度对于 IO 密集型问题的异步 + 回调的解决方案，以及协程的处理，展示了协程在 IO 密集型任务上处理的重大优势。&lt;/p>
&lt;p>最后说明了当前抢占式调度 + 协程 IO 密集型处理的方案，包括 Python、C++ 和 go 的语言层面对于协程的支持和实现。&lt;/p>
&lt;p>本文特别具体的内容并不多，旨在介绍协程思想及其优势所在，对于各个语言的协程实现细节并未展开。&lt;/p>
&lt;p>最后依然是感谢大家的耐心阅读，我们下期见！&lt;/p></description></item><item><title>Docs: crypto 库</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/crypto-%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/crypto-%E5%BA%93/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://pkg.go.dev/crypto">Go crypto 库&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pkg.go.dev/crypto/rsa">Go crypto/rsa 库&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pkg.go.dev/crypto/x509">Go crypto/x509 库&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pkg.go.dev/encoding/pem">Go encoding/pem 库&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jianshu.com/p/54c20cc008c5">简书&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>crypto 库中主要有 rand、rsa、x509 这几个常用的子库。&lt;/p>
&lt;h1 id="rsa-库">RSA 库&lt;/h1>
&lt;p>rsa 库大体分为 加密/解密 与 签名/验签 这两大类。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>rsa.EncryptOAEP() 等&lt;/strong> # 加密方法&lt;/li>
&lt;li>&lt;strong>rsa.DecryptOAEP() 等&lt;/strong> # 解密方法&lt;/li>
&lt;li>&lt;strong>rsa.SignPKCS1v15() 等&lt;/strong> # 签名方法&lt;/li>
&lt;li>&lt;strong>rsa.VerifyPKCS1v15() 等&lt;/strong> # 验签方法&lt;/li>
&lt;/ul>
&lt;h2 id="生成密钥">生成密钥&lt;/h2>
&lt;p>可以通过 &lt;strong>rsa.GenerateKey()&lt;/strong> 函数来生成一个密钥对。私钥的类型为 &lt;code>*rsa.PrivateKey&lt;/code>，其中公钥在该私钥当中，类型是 &lt;code>*rsa.PublicKey&lt;/code>。示例如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RSA 是公钥和私钥两个组成一组的密钥对
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">RSA&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">PrivateKey&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rsaPublicKey&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">PublicKey&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// NewRSA 生成密钥对
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewRSA&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RSA&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 随机生成一个给定大小的 RSA 密钥对。可以使用 crypto 包中的 rand.Reader 来随机。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">privateKey&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">GenerateKey&lt;/span>(&lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#ae81ff">2048&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 从私钥中，获取公钥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">publicKey&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">privateKey&lt;/span>.&lt;span style="color:#a6e22e">PublicKey&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">RSA&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>: &lt;span style="color:#a6e22e">privateKey&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>: &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">publicKey&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="加密与解密">加密与解密&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RSAEncrypt 使用 RSA 算法，加密指定明文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RSA&lt;/span>) &lt;span style="color:#a6e22e">RSAEncrypt&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) []&lt;span style="color:#66d9ef">byte&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用公钥加密 plaintext(明文，也就是准备加密的消息)。并返回 ciphertext(密文)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 其中 []byte(&amp;#34;DesistDaydream&amp;#34;) 是加密中的标签，解密时标签需与加密时的标签相同，否则解密失败
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">ciphertext&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">EncryptOAEP&lt;/span>(&lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(), &lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>, &lt;span style="color:#a6e22e">plaintext&lt;/span>, []byte(&lt;span style="color:#e6db74">&amp;#34;DesistDaydream&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">ciphertext&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RSADecrypt 使用 RSA 算法，解密指定密文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RSA&lt;/span>) &lt;span style="color:#a6e22e">RSADecrypt&lt;/span>(&lt;span style="color:#a6e22e">ciphertext&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) []&lt;span style="color:#66d9ef">byte&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用私钥解密 ciphertext(密文，也就是加过密的消息)。并返回 plaintext(明文)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 其中 []byte(&amp;#34;DesistDaydream&amp;#34;) 是加密中的标签，解密时标签需与加密时的标签相同，否则解密失败
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">plaintext&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">DecryptOAEP&lt;/span>(&lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(), &lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>, &lt;span style="color:#a6e22e">ciphertext&lt;/span>, []byte(&lt;span style="color:#e6db74">&amp;#34;DesistDaydream&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">plaintext&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="签名与验签">签名与验签&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RSASign RSA 签名
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RSA&lt;/span>) &lt;span style="color:#a6e22e">RSASign&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) []&lt;span style="color:#66d9ef">byte&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 只有小消息可以直接签名； 因此，对消息的哈希进行签名，而不能对消息本身进行签名。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 这要求哈希函数必须具有抗冲突性。 SHA-256是编写本文时(2016年)应使用的最低强度的哈希函数。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">hashed&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">Sum256&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用私钥签名，必须要将明文hash后才可以签名，当验证时，同样需要对明文进行hash运算。签名于验签并不用于加密消息或消息传递，仅仅作为验证传递消息方的真实性。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">signature&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">SignPKCS1v15&lt;/span>(&lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>, &lt;span style="color:#a6e22e">crypto&lt;/span>.&lt;span style="color:#a6e22e">SHA256&lt;/span>, &lt;span style="color:#a6e22e">hashed&lt;/span>[:])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Fprintf&lt;/span>(&lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Stderr&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Error from signing: %s\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Signature: %x\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">signature&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">signature&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RSAVerify RSA 验签
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RSA&lt;/span>) &lt;span style="color:#a6e22e">RSAVerify&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>, &lt;span style="color:#a6e22e">signature&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 与签名一样，只可以对 hash 后的消息进行验证。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">hashed&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">Sum256&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用公钥、已签名的信息，验证签名的真实性
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">VerifyPKCS1v15&lt;/span>(&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>, &lt;span style="color:#a6e22e">crypto&lt;/span>.&lt;span style="color:#a6e22e">SHA256&lt;/span>, &lt;span style="color:#a6e22e">hashed&lt;/span>[:], &lt;span style="color:#a6e22e">signature&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Fprintf&lt;/span>(&lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Stderr&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Error from verification: %s\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="rsa-示例">RSA 示例&lt;/h1>
&lt;p>main.go&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 生成rsa的密钥对, 并且保存到磁盘文件中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">NewRSA&lt;/span>(&lt;span style="color:#ae81ff">4096&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 该消息有两个作用：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 1. 使用公钥加密的的信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 2. 验证签名时所用的消息。当该消息用于签名时，通常还需要将该消息，以及用私钥签名后的消息一起发送给对方。以便对方可以根据该消息验证签名的有效性。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">messages&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []byte(&lt;span style="color:#e6db74">&amp;#34;你好 DesistDaydream！...这是一串待加密的字符串，如果你能看到，那么说明功能实现了！&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用公钥加密，私钥解密
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">encryptedMessages&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">RSAEncrypt&lt;/span>(&lt;span style="color:#a6e22e">messages&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">decryptedMessages&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">RSADecrypt&lt;/span>(&lt;span style="color:#a6e22e">encryptedMessages&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;解密后的字符串为：%v\n&amp;#34;&lt;/span>, string(&lt;span style="color:#a6e22e">decryptedMessages&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用私钥签名，公钥验签
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 注意，验证签名需要使用签名时发送的消息作为对比，只有消息一致，才算验证通过
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">signature&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">RSASign&lt;/span>(&lt;span style="color:#a6e22e">messages&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">RSAVerify&lt;/span>(&lt;span style="color:#a6e22e">messages&lt;/span>, &lt;span style="color:#a6e22e">signature&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;验证成功&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>rsa_key_handler.go&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;crypto&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;crypto/rand&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;crypto/sha256&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;os&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;crypto/rsa&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RSA 是公钥和私钥两个组成一组的密钥对
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">RSA&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">PrivateKey&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rsaPublicKey&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">PublicKey&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// NewRSA 生成密钥对
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewRSA&lt;/span>(&lt;span style="color:#a6e22e">bits&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RSA&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 随机生成一个给定大小的 RSA 密钥对。可以使用 crypto 包中的 rand.Reader 来随机。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">privateKey&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">GenerateKey&lt;/span>(&lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#a6e22e">bits&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 从私钥中，获取公钥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">publicKey&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">privateKey&lt;/span>.&lt;span style="color:#a6e22e">PublicKey&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">RSA&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>: &lt;span style="color:#a6e22e">privateKey&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>: &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">publicKey&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RSAEncrypt 使用 RSA 算法，加密指定明文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RSA&lt;/span>) &lt;span style="color:#a6e22e">RSAEncrypt&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) []&lt;span style="color:#66d9ef">byte&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用公钥加密 plaintext(明文，也就是准备加密的消息)。并返回 ciphertext(密文)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 其中 []byte(&amp;#34;DesistDaydream&amp;#34;) 是加密中的标签，解密时标签需与加密时的标签相同，否则解密失败
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">ciphertext&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">EncryptOAEP&lt;/span>(&lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(), &lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>, &lt;span style="color:#a6e22e">plaintext&lt;/span>, []byte(&lt;span style="color:#e6db74">&amp;#34;DesistDaydream&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">ciphertext&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RSADecrypt 使用 RSA 算法，解密指定密文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RSA&lt;/span>) &lt;span style="color:#a6e22e">RSADecrypt&lt;/span>(&lt;span style="color:#a6e22e">ciphertext&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) []&lt;span style="color:#66d9ef">byte&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用私钥解密 ciphertext(密文，也就是加过密的消息)。并返回 plaintext(明文)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 其中 []byte(&amp;#34;DesistDaydream&amp;#34;) 是加密中的标签，解密时标签需与加密时的标签相同，否则解密失败
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">plaintext&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">DecryptOAEP&lt;/span>(&lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(), &lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>, &lt;span style="color:#a6e22e">ciphertext&lt;/span>, []byte(&lt;span style="color:#e6db74">&amp;#34;DesistDaydream&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">plaintext&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RSASign RSA 签名
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RSA&lt;/span>) &lt;span style="color:#a6e22e">RSASign&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) []&lt;span style="color:#66d9ef">byte&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 只有小消息可以直接签名； 因此，对消息的哈希进行签名，而不能对消息本身进行签名。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 这要求哈希函数必须具有抗冲突性。 SHA-256是编写本文时(2016年)应使用的最低强度的哈希函数。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">hashed&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">Sum256&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用私钥签名，必须要将明文hash后才可以签名，当验证时，同样需要对明文进行hash运算。签名于验签并不用于加密消息或消息传递，仅仅作为验证传递消息方的真实性。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">signature&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">SignPKCS1v15&lt;/span>(&lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>, &lt;span style="color:#a6e22e">crypto&lt;/span>.&lt;span style="color:#a6e22e">SHA256&lt;/span>, &lt;span style="color:#a6e22e">hashed&lt;/span>[:])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Fprintf&lt;/span>(&lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Stderr&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Error from signing: %s\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Signature: %x\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">signature&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">signature&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RSAVerify RSA 验签
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RSA&lt;/span>) &lt;span style="color:#a6e22e">RSAVerify&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>, &lt;span style="color:#a6e22e">signature&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 与签名一样，只可以对 hash 后的消息进行验证。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">hashed&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">Sum256&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用公钥、已签名的信息，验证签名的真实性
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">VerifyPKCS1v15&lt;/span>(&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>, &lt;span style="color:#a6e22e">crypto&lt;/span>.&lt;span style="color:#a6e22e">SHA256&lt;/span>, &lt;span style="color:#a6e22e">hashed&lt;/span>[:], &lt;span style="color:#a6e22e">signature&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Fprintf&lt;/span>(&lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Stderr&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Error from verification: %s\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: crypto 库进阶示例</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/crypto-%E5%BA%93%E8%BF%9B%E9%98%B6%E7%A4%BA%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/crypto-%E5%BA%93%E8%BF%9B%E9%98%B6%E7%A4%BA%E4%BE%8B/</guid><description>
&lt;h1 id="生成密钥数据">生成密钥数据&lt;/h1>
&lt;h2 id="1rsa_base">1.rsa_base&lt;/h2>
&lt;h3 id="maingo">main.go&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 生成rsa的密钥对
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">NewRSA&lt;/span>(&lt;span style="color:#ae81ff">4096&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 该消息有两个作用：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 1. 使用公钥加密的的信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 2. 验证签名时所用的消息。当该消息用于签名时，通常还需要将该消息，以及用私钥签名后的消息一起发送给对方。以便对方可以根据该消息验证签名的有效性。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">messages&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []byte(&lt;span style="color:#e6db74">&amp;#34;你好 DesistDaydream！...这是一串待加密的字符串，如果你能看到，那么说明功能实现了！&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用公钥加密，私钥解密
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">encryptedMessages&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">RSAEncrypt&lt;/span>(&lt;span style="color:#a6e22e">messages&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">decryptedMessages&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">RSADecrypt&lt;/span>(&lt;span style="color:#a6e22e">encryptedMessages&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;解密后的字符串为：%v\n&amp;#34;&lt;/span>, string(&lt;span style="color:#a6e22e">decryptedMessages&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用私钥签名，公钥验签
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 注意，验证签名需要使用签名时发送的消息作为对比，只有消息一致，才算验证通过
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">signed&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">RSASign&lt;/span>(&lt;span style="color:#a6e22e">messages&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">RSAVerify&lt;/span>(&lt;span style="color:#a6e22e">messages&lt;/span>, &lt;span style="color:#a6e22e">signed&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;验证成功&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="rsa_key_handlergo">rsa_key_handler.go&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;crypto&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;crypto/rand&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;crypto/sha256&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;os&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;crypto/rsa&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RsaKey 是公钥和私钥两个组成一组的密钥对
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">RsaKey&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">PrivateKey&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rsaPublicKey&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">PublicKey&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// NewRSA 生成密钥对
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewRSA&lt;/span>(&lt;span style="color:#a6e22e">bits&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RsaKey&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 随机生成一个给定大小的 RSA 密钥对。可以使用 crypto 包中的 rand.Reader 来随机。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">privateKey&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">GenerateKey&lt;/span>(&lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#a6e22e">bits&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 从私钥中，获取公钥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">publicKey&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">privateKey&lt;/span>.&lt;span style="color:#a6e22e">PublicKey&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">RsaKey&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>: &lt;span style="color:#a6e22e">privateKey&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>: &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">publicKey&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RSAEncrypt 使用 RSA 算法，加密指定明文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RsaKey&lt;/span>) &lt;span style="color:#a6e22e">RSAEncrypt&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) []&lt;span style="color:#66d9ef">byte&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用公钥加密 plaintext(明文，也就是准备加密的消息)。并返回 ciphertext(密文)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 其中 []byte(&amp;#34;DesistDaydream&amp;#34;) 是加密中的标签，解密时标签需与加密时的标签相同，否则解密失败
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">ciphertext&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">EncryptOAEP&lt;/span>(&lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(), &lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>, &lt;span style="color:#a6e22e">plaintext&lt;/span>, []byte(&lt;span style="color:#e6db74">&amp;#34;DesistDaydream&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">ciphertext&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RSADecrypt 使用 RSA 算法，解密指定密文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RsaKey&lt;/span>) &lt;span style="color:#a6e22e">RSADecrypt&lt;/span>(&lt;span style="color:#a6e22e">ciphertext&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) []&lt;span style="color:#66d9ef">byte&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用私钥解密 ciphertext(密文，也就是加过密的消息)。并返回 plaintext(明文)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 其中 []byte(&amp;#34;DesistDaydream&amp;#34;) 是加密中的标签，解密时标签需与加密时的标签相同，否则解密失败
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">plaintext&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">DecryptOAEP&lt;/span>(&lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(), &lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>, &lt;span style="color:#a6e22e">ciphertext&lt;/span>, []byte(&lt;span style="color:#e6db74">&amp;#34;DesistDaydream&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">plaintext&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RSASign RSA 签名
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RsaKey&lt;/span>) &lt;span style="color:#a6e22e">RSASign&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) []&lt;span style="color:#66d9ef">byte&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 只有小消息可以直接签名； 因此，对消息的哈希进行签名，而不能对消息本身进行签名。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 这要求哈希函数必须具有抗冲突性。 SHA-256是编写本文时(2016年)应使用的最低强度的哈希函数。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">hashed&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">Sum256&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用私钥签名，必须要将明文hash后才可以签名，当验证时，同样需要对明文进行hash运算。签名于验签并不用于加密消息或消息传递，仅仅作为验证传递消息方的真实性。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">signed&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">SignPKCS1v15&lt;/span>(&lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>, &lt;span style="color:#a6e22e">crypto&lt;/span>.&lt;span style="color:#a6e22e">SHA256&lt;/span>, &lt;span style="color:#a6e22e">hashed&lt;/span>[:])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Fprintf&lt;/span>(&lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Stderr&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Error from signing: %s\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;已签名的消息为: %x\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">signed&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">signed&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RSAVerify RSA 验签
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RsaKey&lt;/span>) &lt;span style="color:#a6e22e">RSAVerify&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>, &lt;span style="color:#a6e22e">signed&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 与签名一样，只可以对 hash 后的消息进行验证。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">hashed&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">Sum256&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用公钥、已签名的信息，验证签名的真实性
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">VerifyPKCS1v15&lt;/span>(&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>, &lt;span style="color:#a6e22e">crypto&lt;/span>.&lt;span style="color:#a6e22e">SHA256&lt;/span>, &lt;span style="color:#a6e22e">hashed&lt;/span>[:], &lt;span style="color:#a6e22e">signed&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Fprintf&lt;/span>(&lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Stderr&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Error from verification: %s\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="生成-pem-格式的密钥数据">生成 PEM 格式的密钥数据&lt;/h1>
&lt;h2 id="2rsa_pem">2.rsa_pem&lt;/h2>
&lt;h3 id="maingo-1">main.go&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 生成rsa的密钥对，并以 PEM 格式保存
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">NewRsaKey&lt;/span>(&lt;span style="color:#ae81ff">2048&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 待加密的信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">messages&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []byte(&lt;span style="color:#e6db74">&amp;#34;你好 DesistDaydream！...这是一串待加密的字符串，如果你能看到，那么说明功能实现了！&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用公钥加密，私钥解密
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">encryptedMessages&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">RsaPemEncrypt&lt;/span>(&lt;span style="color:#a6e22e">messages&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">decryptedMessages&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">RsaPemDecrypt&lt;/span>(&lt;span style="color:#a6e22e">encryptedMessages&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;解密后的字符串为：%v\n&amp;#34;&lt;/span>, string(&lt;span style="color:#a6e22e">decryptedMessages&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用私钥签名，公钥验签
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 注意，验证签名需要使用签名时发送的消息作为对比，只有消息一致，才算验证通过
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">signed&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">RsaPemSign&lt;/span>(&lt;span style="color:#a6e22e">messages&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">RsaPemVerify&lt;/span>(&lt;span style="color:#a6e22e">messages&lt;/span>, &lt;span style="color:#a6e22e">signed&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;验证成功&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="rsa_key_pem_handlergo">rsa_key_pem_handler.go&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;bytes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;crypto&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;crypto/rand&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;crypto/sha256&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;crypto/x509&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;os&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;crypto/rsa&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;encoding/pem&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RsaKey 是公钥和私钥两个组成一组的密钥对的二进制格式。可以通过二进制转换为文件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">RsaKey&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">bytePrivateKey&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">bytePublicKey&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// NewRsaKey 生成密钥对
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewRsaKey&lt;/span>(&lt;span style="color:#a6e22e">bits&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RsaKey&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 随机生成一个给定大小的 RSA 密钥对。可以使用 crypto 包中的 rand.Reader 来随机。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">GenerateKey&lt;/span>(&lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#a6e22e">bits&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 从私钥中，获取公钥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">rsaPublicKey&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>.&lt;span style="color:#a6e22e">PublicKey&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ======================================================
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// ======== 比创建基本 RSA 密钥对多出来的行为，开始 ========
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// ======================================================
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 将密钥转为二进制流，以便使用 PEM 包将其编码。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// bytePrivateKey := rsaPrivateKey.D.Bytes()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// bytePublicKey := rsaPublicKey.N.Bytes()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 为什么不能直接转换而必须使用 X.509 呢，因为 go 的标准库中，无法直接将 []byte 格式的数据转换为 *rsa.PrivateKey 和 *rsa.PublicKey 类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 这样会导致后面在使用 rsa 加密/解密，签名/验签时，无法正确获取使用 *rsa.PrivateKey 和 *rsa.PublicKey 类型的密钥。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 因为 go 没有函数或方法，可以将密钥从 []byte 类型转换为 *rsa.PrivateKey 或 *rsa.PublicKey 类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// =================================================================================================================
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// ！！！！！注意！！！！！在正常情况下，无需将密钥先编码为 DER 格式。这是 go 语言的强制要求。*****也是 PKCS 这个标准搞的*****
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// go 在处理密钥时，需要先将密钥先转换成 DER 格式再使用 PEM 编码的，是 go 的需求！！！！！！！！！！！！！！！！注意！！！！！！！！！！！！！！！！！！！！！！
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// ==================================================================================================================
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 因此，只能先使用 x509 包中的方法，将密钥对转换为 PKCS#1,ASN.1 DER 的形式，并以 []byte 的数据类型保存，以供 PEM 包将其编码。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">bytePrivateKey&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">x509&lt;/span>.&lt;span style="color:#a6e22e">MarshalPKCS1PrivateKey&lt;/span>(&lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">bytePublicKey&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">x509&lt;/span>.&lt;span style="color:#a6e22e">MarshalPKCS1PublicKey&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 将密钥对转换为 PEM 格式，并在密钥对中添加用于标识类型的页眉与页脚
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 1.首先，声明两个 bytes.Buffer 类型的变量，用于存放编码后的 PEM 格式密钥。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">bufPemPrivateKey&lt;/span> &lt;span style="color:#a6e22e">bytes&lt;/span>.&lt;span style="color:#a6e22e">Buffer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">bufPemPublicKey&lt;/span> &lt;span style="color:#a6e22e">bytes&lt;/span>.&lt;span style="color:#a6e22e">Buffer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 2.然后，使用 pem 包将密钥对编码为 PEM 格式的数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 因为 bytes.Buffer 这个类型的结构体实现了 pem.Encode 第一个参数的 io.Writer 接口，所以可以通过 pem 包，将 PEM 的标签和二进制类型的编码内容，再编码为 PEM 格式的数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Encode&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">bufPemPrivateKey&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Block&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Type&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;RSA PRIVATE KEY&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Bytes&lt;/span>: &lt;span style="color:#a6e22e">bytePrivateKey&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Encode&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">bufPemPublicKey&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Block&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Type&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;RSA PUBLIC KEY&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Bytes&lt;/span>: &lt;span style="color:#a6e22e">bytePublicKey&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 这里就可以看到平时看到的带页眉页脚的 PEM 格式的编码后的密钥内容了。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;======== PEM 格式私钥内容：========\n%s&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">bufPemPrivateKey&lt;/span>.&lt;span style="color:#a6e22e">String&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;======== PEM 格式公钥内容：========\n%s&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">bufPemPublicKey&lt;/span>.&lt;span style="color:#a6e22e">String&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// =====================================================
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// ======== 比创建基本 RSA 密钥对多出来的行为，结束 =======
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// =====================================================
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">RsaKey&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">bytePrivateKey&lt;/span>: &lt;span style="color:#a6e22e">bufPemPrivateKey&lt;/span>.&lt;span style="color:#a6e22e">Bytes&lt;/span>(), &lt;span style="color:#75715e">// 返回 PEM 格式的二进制私钥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">bytePublicKey&lt;/span>: &lt;span style="color:#a6e22e">bufPemPublicKey&lt;/span>.&lt;span style="color:#a6e22e">Bytes&lt;/span>(), &lt;span style="color:#75715e">// 返回 PEM 格式的二进制公钥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RsaPemEncrypt 使用 RSA 算法，加密指定明文，其中私钥是 PEM 编码后的格式
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RsaKey&lt;/span>) &lt;span style="color:#a6e22e">RsaPemEncrypt&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) []&lt;span style="color:#66d9ef">byte&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 由于这次要通过 PEM 格式编码的公钥进行加密，所以需要先解码 PEM 格式，再将解码后的数据转换为 *rsa.PublicKey 类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">block&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Decode&lt;/span>(&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">bytePublicKey&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 之前在编码时，使用了 x509 进行了编码，所以同样，需要使用 x509 解码以获得 *rsa.PublicKey 类型的公钥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">x509&lt;/span>.&lt;span style="color:#a6e22e">ParsePKCS1PublicKey&lt;/span>(&lt;span style="color:#a6e22e">block&lt;/span>.&lt;span style="color:#a6e22e">Bytes&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用公钥加密 plaintext(明文，也就是准备加密的消息)。并返回 ciphertext(密文)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 其中 []byte(&amp;#34;DesistDaydream&amp;#34;) 是加密中的标签，解密时标签需与加密时的标签相同，否则解密失败
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">ciphertext&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">EncryptOAEP&lt;/span>(&lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(), &lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>, &lt;span style="color:#a6e22e">plaintext&lt;/span>, []byte(&lt;span style="color:#e6db74">&amp;#34;DesistDaydream&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">ciphertext&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RsaPemDecrypt 使用 RSA 算法，解密指定密文，其中公钥是 PEM 编码后的格式
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RsaKey&lt;/span>) &lt;span style="color:#a6e22e">RsaPemDecrypt&lt;/span>(&lt;span style="color:#a6e22e">ciphertext&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) []&lt;span style="color:#66d9ef">byte&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用私钥解密 ciphertext(密文，也就是加过密的消息)。并返回 plaintext(明文)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 其中 []byte(&amp;#34;DesistDaydream&amp;#34;) 是加密中的标签，解密时标签需与加密时的标签相同，否则解密失败
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">block&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Decode&lt;/span>(&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">bytePrivateKey&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">x509&lt;/span>.&lt;span style="color:#a6e22e">ParsePKCS1PrivateKey&lt;/span>(&lt;span style="color:#a6e22e">block&lt;/span>.&lt;span style="color:#a6e22e">Bytes&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">plaintext&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">DecryptOAEP&lt;/span>(&lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(), &lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>, &lt;span style="color:#a6e22e">ciphertext&lt;/span>, []byte(&lt;span style="color:#e6db74">&amp;#34;DesistDaydream&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">plaintext&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RsaPemSign RSA 签名
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RsaKey&lt;/span>) &lt;span style="color:#a6e22e">RsaPemSign&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) []&lt;span style="color:#66d9ef">byte&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 只有小消息可以直接签名； 因此，对消息的哈希进行签名，而不能对消息本身进行签名。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 这要求哈希函数必须具有抗冲突性。 SHA-256是编写本文时(2016年)应使用的最低强度的哈希函数。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">hashed&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">Sum256&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 由于这次要通过 PEM 格式编码的公钥进行加密，所以需要先解码 PEM 格式，再将解码后的数据转换为 *rsa.PublicKey 类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">block&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Decode&lt;/span>(&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">bytePrivateKey&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 之前在编码时，使用了 x509 进行了编码，所以同样，需要使用 x509 解码以获得 *rsa.PublicKey 类型的公钥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">x509&lt;/span>.&lt;span style="color:#a6e22e">ParsePKCS1PrivateKey&lt;/span>(&lt;span style="color:#a6e22e">block&lt;/span>.&lt;span style="color:#a6e22e">Bytes&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用私钥签名，必须要将明文hash后才可以签名，当验证时，同样需要对明文进行hash运算。签名于验签并不用于加密消息或消息传递，仅仅作为验证传递消息方的真实性。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">signed&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">SignPKCS1v15&lt;/span>(&lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>, &lt;span style="color:#a6e22e">crypto&lt;/span>.&lt;span style="color:#a6e22e">SHA256&lt;/span>, &lt;span style="color:#a6e22e">hashed&lt;/span>[:])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Fprintf&lt;/span>(&lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Stderr&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Error from signing: %s\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;已签名的消息为: %x\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">signed&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">signed&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RsaPemVerify RSA 验签
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RsaKey&lt;/span>) &lt;span style="color:#a6e22e">RsaPemVerify&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>, &lt;span style="color:#a6e22e">signed&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 与签名一样，只可以对 hash 后的消息进行验证。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">hashed&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">Sum256&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">block&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Decode&lt;/span>(&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">bytePublicKey&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">x509&lt;/span>.&lt;span style="color:#a6e22e">ParsePKCS1PublicKey&lt;/span>(&lt;span style="color:#a6e22e">block&lt;/span>.&lt;span style="color:#a6e22e">Bytes&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用公钥、已签名的信息，验证签名的真实性
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">VerifyPKCS1v15&lt;/span>(&lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>, &lt;span style="color:#a6e22e">crypto&lt;/span>.&lt;span style="color:#a6e22e">SHA256&lt;/span>, &lt;span style="color:#a6e22e">hashed&lt;/span>[:], &lt;span style="color:#a6e22e">signed&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Fprintf&lt;/span>(&lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Stderr&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Error from verification: %s\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="生成-pem-格式的密钥文件">生成 PEM 格式的密钥文件&lt;/h1>
&lt;h2 id="3rsa_pem_file">3.rsa_pem_file&lt;/h2>
&lt;h3 id="maingo-2">main.go&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 生成rsa的密钥对, 并且保存到 PEM 格式的文件中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">NewRsaKey&lt;/span>(&lt;span style="color:#ae81ff">2048&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;./cryptography/private.pem&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;./cryptography/public.pem&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 待加密的信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">messages&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []byte(&lt;span style="color:#e6db74">&amp;#34;你好 DesistDaydream！...这是一串待加密的字符串，如果你能看到，那么说明功能实现了！&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用公钥加密，私钥解密
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">encryptedMessages&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">RsaPemEncrypt&lt;/span>(&lt;span style="color:#a6e22e">messages&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">decryptedMessages&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">RsaPemDecrypt&lt;/span>(&lt;span style="color:#a6e22e">encryptedMessages&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;解密后的字符串为：%v\n&amp;#34;&lt;/span>, string(&lt;span style="color:#a6e22e">decryptedMessages&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用私钥签名，公钥验签
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 注意，验证签名需要使用签名时发送的消息作为对比，只有消息一致，才算验证通过
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">signed&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">RsaPemSign&lt;/span>(&lt;span style="color:#a6e22e">messages&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">RsaPemVerify&lt;/span>(&lt;span style="color:#a6e22e">messages&lt;/span>, &lt;span style="color:#a6e22e">signed&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;验证成功&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="rsa_key_pem_handlergo-1">rsa_key_pem_handler.go&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;crypto&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;crypto/rand&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;crypto/sha256&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;crypto/x509&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;io/ioutil&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;os&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;crypto/rsa&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;encoding/pem&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// GetKeyByteFromFile 读取密钥文件并转换为二进制流。该行为用于在 加密/解密，签名/验签 中。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">GetKeyByteFromFile&lt;/span>(&lt;span style="color:#a6e22e">fileName&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) []&lt;span style="color:#66d9ef">byte&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fileByte&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ioutil&lt;/span>.&lt;span style="color:#a6e22e">ReadFile&lt;/span>(&lt;span style="color:#a6e22e">fileName&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">fileByte&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RsaKey 是公钥和私钥两个组成一组的密钥对的二进制格式。可以通过二进制转换为文件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">RsaKey&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">filePrivateKey&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">File&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">filePublicKey&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">File&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// NewRsaKey 生成密钥对
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewRsaKey&lt;/span>(&lt;span style="color:#a6e22e">bits&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">privateKeyFile&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">publicKeyFile&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RsaKey&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 随机生成一个给定大小的 RSA 密钥对。可以使用 crypto 包中的 rand.Reader 来随机。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">GenerateKey&lt;/span>(&lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#a6e22e">bits&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 从私钥中，获取公钥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">rsaPublicKey&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>.&lt;span style="color:#a6e22e">PublicKey&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ======================================================
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// ======== 比创建基本 RSA 密钥对多出来的行为，开始 ========
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// ======================================================
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 将密钥对转换为 PKCS#1,ASN.1 DER 的形式，并以 []byte 的数据类型保存，以供 PEM 包将其编码。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">bytePrivateKey&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">x509&lt;/span>.&lt;span style="color:#a6e22e">MarshalPKCS1PrivateKey&lt;/span>(&lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">bytePublicKey&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">x509&lt;/span>.&lt;span style="color:#a6e22e">MarshalPKCS1PublicKey&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 将密钥对转换为 PEM 格式，并在密钥对中添加用于标识类型的页眉与页脚
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 1.首先，创建两个文件，用于存放编码后的 PEM 格式密钥，在 go 中，这俩文件是 os.file 类型的变量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">filePrivateKey&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Create&lt;/span>(&lt;span style="color:#a6e22e">privateKeyFile&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">filePrivateKey&lt;/span>.&lt;span style="color:#a6e22e">Close&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">filePublicKey&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Create&lt;/span>(&lt;span style="color:#a6e22e">publicKeyFile&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">filePublicKey&lt;/span>.&lt;span style="color:#a6e22e">Close&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 2.然后，使用 pem 包将密钥对编码为 PEM 格式的数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 因为 os.file 这个类型的结构体实现了 pem.Encode 第一个参数的 io.Writer 接口，所以可以通过 pem 包，将 PEM 的标签和二进制类型的编码内容，再编码为 PEM 格式的数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Encode&lt;/span>(&lt;span style="color:#a6e22e">filePrivateKey&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Block&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Type&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;RSA PRIVATE KEY&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Bytes&lt;/span>: &lt;span style="color:#a6e22e">bytePrivateKey&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Encode&lt;/span>(&lt;span style="color:#a6e22e">filePublicKey&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Block&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Type&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;RSA PUBLIC KEY&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Bytes&lt;/span>: &lt;span style="color:#a6e22e">bytePublicKey&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 这里就可以看到平时看到的带页眉页脚的 PEM 格式的编码后的密钥内容了。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">privateKeyFileBuf&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ioutil&lt;/span>.&lt;span style="color:#a6e22e">ReadFile&lt;/span>(&lt;span style="color:#a6e22e">privateKeyFile&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;======== PEM 格式私钥内容：========\n%s&amp;#34;&lt;/span>, string(&lt;span style="color:#a6e22e">privateKeyFileBuf&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">publicKeyFileBuf&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ioutil&lt;/span>.&lt;span style="color:#a6e22e">ReadFile&lt;/span>(&lt;span style="color:#a6e22e">publicKeyFile&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;======== PEM 格式公钥内容：========\n%s&amp;#34;&lt;/span>, string(&lt;span style="color:#a6e22e">publicKeyFileBuf&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// =====================================================
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// ======== 比创建基本 RSA 密钥对多出来的行为，结束 =======
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// =====================================================
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">RsaKey&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">filePrivateKey&lt;/span>: &lt;span style="color:#a6e22e">filePrivateKey&lt;/span>, &lt;span style="color:#75715e">// 返回 PEM 格式的 os.File 类型私钥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">filePublicKey&lt;/span>: &lt;span style="color:#a6e22e">filePublicKey&lt;/span>, &lt;span style="color:#75715e">// 返回 PEM 格式的 os.File 类型公钥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RsaPemEncrypt 使用 RSA 算法，加密指定明文，其中私钥是 PEM 编码后的格式
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RsaKey&lt;/span>) &lt;span style="color:#a6e22e">RsaPemEncrypt&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) []&lt;span style="color:#66d9ef">byte&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 由于这次要通过 PEM 格式编码的公钥进行加密，所以需要先解码 PEM 格式，再将解码后的数据转换为 *rsa.PublicKey 类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fileByte&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ioutil&lt;/span>.&lt;span style="color:#a6e22e">ReadFile&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;./cryptography/public.pem&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// 获取 PEM 格式文件的二进制类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">block&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Decode&lt;/span>(&lt;span style="color:#a6e22e">fileByte&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 之前在编码时，使用了 x509 进行了编码，所以同样，需要使用 x509 解码以获得 *rsa.PublicKey 类型的公钥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">x509&lt;/span>.&lt;span style="color:#a6e22e">ParsePKCS1PublicKey&lt;/span>(&lt;span style="color:#a6e22e">block&lt;/span>.&lt;span style="color:#a6e22e">Bytes&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用公钥加密 plaintext(明文，也就是准备加密的消息)。并返回 ciphertext(密文)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 其中 []byte(&amp;#34;DesistDaydream&amp;#34;) 是加密中的标签，解密时标签需与加密时的标签相同，否则解密失败
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">ciphertext&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">EncryptOAEP&lt;/span>(&lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(), &lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>, &lt;span style="color:#a6e22e">plaintext&lt;/span>, []byte(&lt;span style="color:#e6db74">&amp;#34;DesistDaydream&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">ciphertext&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RsaPemDecrypt 使用 RSA 算法，解密指定密文，其中公钥是 PEM 编码后的格式
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RsaKey&lt;/span>) &lt;span style="color:#a6e22e">RsaPemDecrypt&lt;/span>(&lt;span style="color:#a6e22e">ciphertext&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) []&lt;span style="color:#66d9ef">byte&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 由于这次要通过 PEM 格式编码的公钥进行解密或签名，所以需要先解码 PEM 格式，再将解码后的数据转换为 *rsa.PrivateKey 类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fileByte&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ioutil&lt;/span>.&lt;span style="color:#a6e22e">ReadFile&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;./cryptography/private.pem&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// 获取 PEM 格式文件的二进制类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">block&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Decode&lt;/span>(&lt;span style="color:#a6e22e">fileByte&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 之前在编码时，使用了 x509 进行了编码，所以同样，需要使用 x509 解码以获得 *rsa.PrivateKey 类型的公钥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">x509&lt;/span>.&lt;span style="color:#a6e22e">ParsePKCS1PrivateKey&lt;/span>(&lt;span style="color:#a6e22e">block&lt;/span>.&lt;span style="color:#a6e22e">Bytes&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用私钥解密 ciphertext(密文，也就是加过密的消息)。并返回 plaintext(明文)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 其中 []byte(&amp;#34;DesistDaydream&amp;#34;) 是加密中的标签，解密时标签需与加密时的标签相同，否则解密失败
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">plaintext&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">DecryptOAEP&lt;/span>(&lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(), &lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>, &lt;span style="color:#a6e22e">ciphertext&lt;/span>, []byte(&lt;span style="color:#e6db74">&amp;#34;DesistDaydream&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">plaintext&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RsaPemSign RSA 签名
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RsaKey&lt;/span>) &lt;span style="color:#a6e22e">RsaPemSign&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) []&lt;span style="color:#66d9ef">byte&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 只有小消息可以直接签名； 因此，对消息的哈希进行签名，而不能对消息本身进行签名。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 这要求哈希函数必须具有抗冲突性。 SHA-256是编写本文时(2016年)应使用的最低强度的哈希函数。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">hashed&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">Sum256&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fileByte&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ioutil&lt;/span>.&lt;span style="color:#a6e22e">ReadFile&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;./cryptography/private.pem&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">block&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Decode&lt;/span>(&lt;span style="color:#a6e22e">fileByte&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">x509&lt;/span>.&lt;span style="color:#a6e22e">ParsePKCS1PrivateKey&lt;/span>(&lt;span style="color:#a6e22e">block&lt;/span>.&lt;span style="color:#a6e22e">Bytes&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用私钥签名，必须要将明文hash后才可以签名，当验证时，同样需要对明文进行hash运算。签名于验签并不用于加密消息或消息传递，仅仅作为验证传递消息方的真实性。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">signed&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">SignPKCS1v15&lt;/span>(&lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>, &lt;span style="color:#a6e22e">crypto&lt;/span>.&lt;span style="color:#a6e22e">SHA256&lt;/span>, &lt;span style="color:#a6e22e">hashed&lt;/span>[:])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Fprintf&lt;/span>(&lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Stderr&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Error from signing: %s\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;已签名的消息为: %x\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">signed&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">signed&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RsaPemVerify RSA 验签
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RsaKey&lt;/span>) &lt;span style="color:#a6e22e">RsaPemVerify&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>, &lt;span style="color:#a6e22e">signed&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 与签名一样，只可以对 hash 后的消息进行验证。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">hashed&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">Sum256&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fileByte&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ioutil&lt;/span>.&lt;span style="color:#a6e22e">ReadFile&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;./cryptography/public.pem&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">block&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Decode&lt;/span>(&lt;span style="color:#a6e22e">fileByte&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">x509&lt;/span>.&lt;span style="color:#a6e22e">ParsePKCS1PublicKey&lt;/span>(&lt;span style="color:#a6e22e">block&lt;/span>.&lt;span style="color:#a6e22e">Bytes&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用公钥、已签名的信息，验证签名的真实性
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">VerifyPKCS1v15&lt;/span>(&lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>, &lt;span style="color:#a6e22e">crypto&lt;/span>.&lt;span style="color:#a6e22e">SHA256&lt;/span>, &lt;span style="color:#a6e22e">hashed&lt;/span>[:], &lt;span style="color:#a6e22e">signed&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Fprintf&lt;/span>(&lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Stderr&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Error from verification: %s\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: crypto 库进阶示例 README</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/crypto-%E5%BA%93%E8%BF%9B%E9%98%B6%E7%A4%BA%E4%BE%8B-readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/crypto-%E5%BA%93%E8%BF%9B%E9%98%B6%E7%A4%BA%E4%BE%8B-readme/</guid><description>
&lt;h1 id="1rsa_pem-示例">1.rsa_pem 示例&lt;/h1>
&lt;p>生成密钥对很简单&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 随机生成一个给定大小的 RSA 密钥对。可以使用 crypto 包中的 rand.Reader 来随机。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">privateKey&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">GenerateKey&lt;/span>(&lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#a6e22e">bits&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 从私钥中，获取公钥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">publicKey&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">privateKey&lt;/span>.&lt;span style="color:#a6e22e">PublicKey&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>加密&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用公钥加密 plaintext(明文，也就是准备加密的消息)。并返回 ciphertext(密文)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 其中 []byte(&amp;#34;DesistDaydream&amp;#34;) 是加密中的标签，解密时标签需与加密时的标签相同，否则解密失败
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">ciphertext&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">EncryptOAEP&lt;/span>(&lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(), &lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>, &lt;span style="color:#a6e22e">plaintext&lt;/span>, []byte(&lt;span style="color:#e6db74">&amp;#34;DesistDaydream&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>解密&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用私钥解密 ciphertext(密文，也就是加过密的消息)。并返回 plaintext(明文)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 其中 []byte(&amp;#34;DesistDaydream&amp;#34;) 是加密中的标签，解密时标签需与加密时的标签相同，否则解密失败
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">plaintext&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">DecryptOAEP&lt;/span>(&lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(), &lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>, &lt;span style="color:#a6e22e">ciphertext&lt;/span>, []byte(&lt;span style="color:#e6db74">&amp;#34;DesistDaydream&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>签名&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 只有小消息可以直接签名； 因此，对消息的哈希进行签名，而不能对消息本身进行签名。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 这要求哈希函数必须具有抗冲突性。 SHA-256是编写本文时(2016年)应使用的最低强度的哈希函数。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">hashed&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">Sum256&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用私钥签名，必须要将明文hash后才可以签名，当验证时，同样需要对明文进行hash运算。签名于验签并不用于加密消息或消息传递，仅仅作为验证传递消息方的真实性。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">signed&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">SignPKCS1v15&lt;/span>(&lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>, &lt;span style="color:#a6e22e">crypto&lt;/span>.&lt;span style="color:#a6e22e">SHA256&lt;/span>, &lt;span style="color:#a6e22e">hashed&lt;/span>[:])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>验签&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">hashed&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">sha256&lt;/span>.&lt;span style="color:#a6e22e">Sum256&lt;/span>(&lt;span style="color:#a6e22e">plaintext&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用公钥、已签名的信息，验证签名的真实性
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rsa&lt;/span>.&lt;span style="color:#a6e22e">VerifyPKCS1v15&lt;/span>(&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>, &lt;span style="color:#a6e22e">crypto&lt;/span>.&lt;span style="color:#a6e22e">SHA256&lt;/span>, &lt;span style="color:#a6e22e">hashed&lt;/span>[:], &lt;span style="color:#a6e22e">signed&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="2rsa_pem-示例中比-1rsa_pem-多了这些内容">2.rsa_pem 示例中，比 1.rsa_pem 多了这些内容&lt;/h1>
&lt;p>在生成 []byte 类型的 PEM 格式的密钥对时多了以下内容&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 将密钥转为二进制流，以便使用 PEM 包将其编码。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// bytePrivateKey := rsaPrivateKey.D.Bytes()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// bytePublicKey := rsaPublicKey.N.Bytes()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 为什么不能直接转换而必须使用 X.509 呢，因为 go 的标准库中，无法直接将 []byte 格式的数据转换为 *rsa.PrivateKey 和 *rsa.PublicKey 类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 这样会导致后面在使用 rsa 加密/解密，签名/验签时，无法正确获取使用 *rsa.PrivateKey 和 *rsa.PublicKey 类型的密钥。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 因为 go 没有函数或方法，可以将密钥从 []byte 类型转换为 *rsa.PrivateKey 或 *rsa.PublicKey 类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// =================================================================================================================
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// ！！！！！注意！！！！！在正常情况下，无需将密钥先编码为 DER 格式。这是 go 语言的强制要求。*****也是 PKCS 这个标准搞的*****
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// go 在处理密钥时，需要先将密钥先转换成 DER 格式再使用 PEM 编码的，是 go 的需求！！！！！！！！！！！！！！！！注意！！！！！！！！！！！！！！！！！！！！！！
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// ==================================================================================================================
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 因此，只能先使用 x509 包中的方法，将密钥对转换为 PKCS#1,ASN.1 DER 的形式，并以 []byte 的数据类型保存，以供 PEM 包将其编码。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">bytePrivateKey&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">x509&lt;/span>.&lt;span style="color:#a6e22e">MarshalPKCS1PrivateKey&lt;/span>(&lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">bytePublicKey&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">x509&lt;/span>.&lt;span style="color:#a6e22e">MarshalPKCS1PublicKey&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 将密钥对转换为 PEM 格式，并在密钥对中添加用于标识类型的页眉与页脚
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 1.首先，声明两个 bytes.Buffer 类型的变量，用于存放编码后的 PEM 格式密钥。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">bufPemPrivateKey&lt;/span> &lt;span style="color:#a6e22e">bytes&lt;/span>.&lt;span style="color:#a6e22e">Buffer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">bufPemPublicKey&lt;/span> &lt;span style="color:#a6e22e">bytes&lt;/span>.&lt;span style="color:#a6e22e">Buffer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 2.然后，使用 pem 包将密钥对编码为 PEM 格式的数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 因为 bytes.Buffer 这个类型的结构体实现了 pem.Encode 第一个参数的 io.Writer 接口，所以可以通过 pem 包，将 PEM 的标签和二进制类型的编码内容，再编码为 PEM 格式的数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Encode&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">bufPemPrivateKey&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Block&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Type&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;RSA PRIVATE KEY&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Bytes&lt;/span>: &lt;span style="color:#a6e22e">bytePrivateKey&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Encode&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">bufPemPublicKey&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Block&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Type&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;RSA PUBLIC KEY&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Bytes&lt;/span>: &lt;span style="color:#a6e22e">bytePublicKey&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>加密/解密，签名/验签 则需要多一些解码相关的内容&lt;/p>
&lt;p>加密与验签&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 由于这次要通过 PEM 格式编码的公钥进行加密或验签，所以需要先解码 PEM 格式，再将解码后的数据转换为 *rsa.PublicKey 类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">block&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Decode&lt;/span>(&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">bytePublicKey&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 之前在编码时，使用了 x509 进行了编码，所以同样，需要使用 x509 解码以获得 *rsa.PublicKey 类型的公钥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">x509&lt;/span>.&lt;span style="color:#a6e22e">ParsePKCS1PublicKey&lt;/span>(&lt;span style="color:#a6e22e">block&lt;/span>.&lt;span style="color:#a6e22e">Bytes&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>解密与签名&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 由于这次要通过 PEM 格式编码的公钥进行解密或签名，所以需要先解码 PEM 格式，再将解码后的数据转换为 *rsa.PrivateKey 类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">block&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Decode&lt;/span>(&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">bytePrivateKey&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 之前在编码时，使用了 x509 进行了编码，所以同样，需要使用 x509 解码以获得 *rsa.PrivateKey 类型的公钥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">x509&lt;/span>.&lt;span style="color:#a6e22e">ParsePKCS1PrivateKey&lt;/span>(&lt;span style="color:#a6e22e">block&lt;/span>.&lt;span style="color:#a6e22e">Bytes&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="3rsa_pem_file-示例中比-1rsa_pem-多了这些内容">3.rsa_pem_file 示例中，比 1.rsa_pem 多了这些内容&lt;/h1>
&lt;p>在生成 PEM 格式的密钥对文件时多了以下内容&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 将密钥对转换为 PKCS#1,ASN.1 DER 的形式，并以 []byte 的数据类型保存，以供 PEM 包将其编码。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">bytePrivateKey&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">x509&lt;/span>.&lt;span style="color:#a6e22e">MarshalPKCS1PrivateKey&lt;/span>(&lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">bytePublicKey&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">x509&lt;/span>.&lt;span style="color:#a6e22e">MarshalPKCS1PublicKey&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 将密钥对转换为 PEM 格式，并在密钥对中添加用于标识类型的页眉与页脚
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 1.首先，创建两个文件，用于存放编码后的 PEM 格式密钥，在 go 中，这俩文件是 os.file 类型的变量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">filePrivateKey&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Create&lt;/span>(&lt;span style="color:#a6e22e">privateKeyFile&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">filePrivateKey&lt;/span>.&lt;span style="color:#a6e22e">Close&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">filePublicKey&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Create&lt;/span>(&lt;span style="color:#a6e22e">publicKeyFile&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">filePublicKey&lt;/span>.&lt;span style="color:#a6e22e">Close&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 2.然后，使用 pem 包将密钥对编码为 PEM 格式的数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 因为 os.file 这个类型的结构体实现了 pem.Encode 第一个参数的 io.Writer 接口，所以可以通过 pem 包，将 PEM 的标签和二进制类型的编码内容，再编码为 PEM 格式的数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Encode&lt;/span>(&lt;span style="color:#a6e22e">filePrivateKey&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Block&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Type&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;RSA PRIVATE KEY&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Bytes&lt;/span>: &lt;span style="color:#a6e22e">bytePrivateKey&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Encode&lt;/span>(&lt;span style="color:#a6e22e">filePublicKey&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Block&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Type&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;RSA PUBLIC KEY&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Bytes&lt;/span>: &lt;span style="color:#a6e22e">bytePublicKey&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 这里就可以看到平时看到的带页眉页脚的 PEM 格式的编码后的密钥内容了。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">privateKeyFileBuf&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ioutil&lt;/span>.&lt;span style="color:#a6e22e">ReadFile&lt;/span>(&lt;span style="color:#a6e22e">privateKeyFile&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;======== PEM 格式私钥内容：========\n%s&amp;#34;&lt;/span>, string(&lt;span style="color:#a6e22e">privateKeyFileBuf&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">publicKeyFileBuf&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ioutil&lt;/span>.&lt;span style="color:#a6e22e">ReadFile&lt;/span>(&lt;span style="color:#a6e22e">publicKeyFile&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;======== PEM 格式公钥内容：========\n%s&amp;#34;&lt;/span>, string(&lt;span style="color:#a6e22e">publicKeyFileBuf&lt;/span>))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>加密/解密，签名/验签 则需要多一些解码相关的内容&lt;/p>
&lt;p>加密与验签&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 由于这次要通过 PEM 格式编码的公钥进行加密，所以需要先解码 PEM 格式，再将解码后的数据转换为 *rsa.PublicKey 类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fileByte&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ioutil&lt;/span>.&lt;span style="color:#a6e22e">ReadFile&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;./cryptography/public.pem&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// 获取 PEM 格式文件的二进制类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">block&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Decode&lt;/span>(&lt;span style="color:#a6e22e">fileByte&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 之前在编码时，使用了 x509 进行了编码，所以同样，需要使用 x509 解码以获得 *rsa.PublicKey 类型的公钥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">rsaPublicKey&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">x509&lt;/span>.&lt;span style="color:#a6e22e">ParsePKCS1PublicKey&lt;/span>(&lt;span style="color:#a6e22e">block&lt;/span>.&lt;span style="color:#a6e22e">Bytes&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>解密与签名&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 由于这次要通过 PEM 格式编码的公钥进行解密或签名，所以需要先解码 PEM 格式，再将解码后的数据转换为 *rsa.PrivateKey 类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fileByte&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ioutil&lt;/span>.&lt;span style="color:#a6e22e">ReadFile&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;./cryptography/private.pem&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// 获取 PEM 格式文件的二进制类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">block&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">pem&lt;/span>.&lt;span style="color:#a6e22e">Decode&lt;/span>(&lt;span style="color:#a6e22e">fileByte&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 之前在编码时，使用了 x509 进行了编码，所以同样，需要使用 x509 解码以获得 *rsa.PrivateKey 类型的公钥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">rsaPrivateKey&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">x509&lt;/span>.&lt;span style="color:#a6e22e">ParsePKCS1PrivateKey&lt;/span>(&lt;span style="color:#a6e22e">block&lt;/span>.&lt;span style="color:#a6e22e">Bytes&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: CSS</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/html-%E4%B8%8E-css/css/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/html-%E4%B8%8E-css/css/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/CSS">Wiki,CSS&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Cascading Style Sheets(层叠样式表，简称 CSS)&lt;/strong> 是一种 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/StyleSheet">样式表&lt;/a> 语言，用来描述 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML">HTML&lt;/a> 或 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/XML/XML_Introduction">XML&lt;/a>（包括如 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG">SVG&lt;/a>、&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/MathML">MathML&lt;/a>、&lt;a href="https://developer.mozilla.org/zh-CN/docs/Glossary/XHTML">XHTML&lt;/a> 之类的 XML 分支语言）文档的呈现。CSS 描述了在屏幕、纸质、音频等其它媒体上的元素应该如何被渲染的问题。
CSS 是开放网络的核心语言之一，由 &lt;a href="https://w3.org/Style/CSS/#specs">W3C 规范&lt;/a> 实现跨浏览器的标准化。CSS 节省了大量的工作。样式可以通过定义保存在外部.css 文件中，同时控制多个网页的布局，这意味着开发者不必经历在所有网页上编辑布局的麻烦。CSS 被分为不同等级：CSS1 现已废弃，CSS2.1 是推荐标准， &lt;a href="https://developer.mozilla.org/zh-CN/docs/CSS/CSS3">CSS3&lt;/a> 分成多个小模块且正在标准化中。&lt;/p>
&lt;h1 id="学习资料">学习资料&lt;/h1>
&lt;p>&lt;a href="https://developer.mozilla.org/en-US/docs/Web">MDN 官方文档，Web 开发技术&lt;/a>(通常指的是网站首页的 References 标签中的文档)&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.mozilla.org/docs/Web/CSS">CSS&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>菜鸟教程&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.runoob.com/css/css-tutorial.html">CSS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.runoob.com/css3/css3-tutorial.html">CSS3&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: Data Type(数据类型)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/typescript-%E6%A0%87%E5%87%86%E5%BA%93/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/typescript-%E6%A0%87%E5%87%86%E5%BA%93/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html">官方文档，常见类型&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: Data Type(数据类型)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://go.dev/ref/spec#Types">官方文档，参考-规范-类型&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>**Data Type(数据类型) **用来对一组相关值进行分类，描述可对其执行的操作并定义它们的存储方式。 通常也会称为 &lt;strong>Literal(字面量)&lt;/strong>&lt;/p>
&lt;p>Go 语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。虽然数据类型有很多，但是这些数据类型都是对程序中一个变量或状态的间接引用。这意味着对任一引用类型数据的修改都会影响所有该引用的拷贝。所谓的引用，是对值的引用。注意引用与指针的区别，详见 pointer.go&lt;/p>
&lt;h2 id="underlying-type基本类型">Underlying Type(基本类型)&lt;/h2>
&lt;p>数据中最基本的类型，是构成其余数据类型以及对象的最小单位，当定义其他数据类型时，同样需要定义基础数据类型。基础数据类型也是 Go 语言的&lt;strong>内置数据类型&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Numeric(数字类型)&lt;/strong>
&lt;ul>
&lt;li>Integer Type(整数类型)&lt;/li>
&lt;li>Floating Point Numbers(浮点数型)&lt;/li>
&lt;li>complex 复数共两种复数，complex64 和 complex128，分别对应 float32 和 float64 两种浮点数精度。内置的 complex 函数用于构建复数，内建的 real 和 imag 函数分别返回复数的实部和虚部&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**Strings(字符类型) **# 格式化标识&lt;code>%s&lt;/code>&lt;/li>
&lt;li>&lt;strong>Booleans(布尔类型)&lt;/strong> #
&lt;ul>
&lt;li>注意：很多时候，Booleans 类型的值可以用数字表示
&lt;ul>
&lt;li>1 表示 true(真)&lt;/li>
&lt;li>0 表示 false(假)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="composite-type复合类型">Composite Type(复合类型)&lt;/h2>
&lt;p>是通过组合基础数据类型，来表达更复杂的数据结构&lt;/p>
&lt;ul>
&lt;li>Arrays(数组) # 多个相同基础类型的数据组合在一起&lt;/li>
&lt;li>Slices(切片)&lt;/li>
&lt;li>Maps(字典)&lt;/li>
&lt;li>Functions(函数，这里面主要指的是函数的参数的数据类型)&lt;/li>
&lt;li>Structs(结构体) #&lt;/li>
&lt;li>Interfaces(接口)&lt;/li>
&lt;li>Channels(通道)&lt;/li>
&lt;li>Pointers(指针)&lt;/li>
&lt;/ul>
&lt;h2 id="自定义数据类型类型定义">自定义数据类型(类型定义)&lt;/h2>
&lt;p>变量或表达式的 Type 定义了对应存储值的属性特征，例如数值在内存的存储大小（或者是元素的 bit 个数），它们在内部是如何表达的，是否支持一些操作符，以及它们自己关联的方法集等。&lt;/p>
&lt;p>在任何程序中都会存在一些变量有着相同的内部结构，但是却表示完全不同的概念。例如，一个 int 类型的变量可以用来表示一个循环的迭代索引、或者一个时间戳、或者一个文件描述符、或者一个月份；一个 float64 类型的变量可以用来表示每秒移动几米的速度、或者是不同温度单位下的温度；一个字符串可以用来表示一个密码或者一个颜色的名称。这些基于基本数据类型所生成的新数据类型都叫数据类型。再比如数组、切片、字典等，虽然在有的时候他们的基础数据类型可以使一样的，但是他们本身所表示的数据类型是不同的含义。&lt;/p>
&lt;p>一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。&lt;/p>
&lt;p>格式：&lt;code>type TypeID BaseType&lt;/code>&lt;/p>
&lt;p>如果自定义数据类型的 BaseType 是由零个或多个任意类型的值(每个值对应一个类型)聚合成的实体，则需要使用 [Struct](✏IT 学习笔记/👨‍💻2.编程/高级编程语言/Go/Go%20 标准库/Maps(映射)%20 与%20Struct(结构体).md 与 Struct(结构体).md)&lt;/p>
&lt;p>&lt;strong>Type Definition(类型定义)&lt;/strong> 是 Go 实现面向对象编程的最基本要素&lt;/p>
&lt;h1 id="类型检测">类型检测&lt;/h1>
&lt;p>详见 [反射](&amp;lt;✏IT 学习笔记/👨‍💻2.编程/高级编程语言/Go/Go%20 标准库/Method(方法)、Interface(接口).md&amp;raquo;) 特性&lt;/p>
&lt;h1 id="类型转换">类型转换&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://go.dev/tour/basics/13">官方 Tour，基础-13&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>语法：&lt;code>Type(Expression)&lt;/code>&lt;/p>
&lt;ul>
&lt;li>将 Expression 获取到的值转换为 Type 类型。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>注意：这种语法属于强制类型转换，若出现错误将会 panic。如果想要处理错误，可以使用 strconv 库等&lt;/p>
&lt;/blockquote>
&lt;p>注意：若 Type 为指针类型，最好写成这样：&lt;code>(Type)(Expression)&lt;/code>，比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">stringValue&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> new(&lt;span style="color:#66d9ef">string&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">stringValue&lt;/span>)(&lt;span style="color:#a6e22e">p&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="格式化占位符">格式化占位符&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://pkg.go.dev/fmt#hdr-Printing">Go 包，标准库-fmt&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cnblogs.com/qing123/articles/4353353.html">博客园，情三-golang fmt 格式“占位符”&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>格式化占位符，也可以称为 &lt;strong>format verbs(格式化动词)&lt;/strong>。这些动词可以在输出时，告诉数据应该以什么类型、样式输出。这类似于 C 语言的 printf 和 scanf，但是更简洁。&lt;/p>
&lt;p>以下面的代码为例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Human&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">people&lt;/span> = &lt;span style="color:#a6e22e">Human&lt;/span>{&lt;span style="color:#a6e22e">Name&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;zhangsan&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="普通占位符">普通占位符&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>占位符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>%v&lt;/td>
&lt;td>根据值来自动推断类型的默认格式&lt;/td>
&lt;td>Printf(&amp;quot;%v&amp;quot;, people)&lt;/td>
&lt;td>{zhangsan}，&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%+v&lt;/td>
&lt;td>打印结构体时，会添加字段名&lt;/td>
&lt;td>Printf(&amp;quot;%+v&amp;quot;, people)&lt;/td>
&lt;td>{Name:zhangsan}&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%#v&lt;/td>
&lt;td>相应值的 Go 语法表示&lt;/td>
&lt;td>Printf(&amp;quot;#v&amp;quot;, people)&lt;/td>
&lt;td>main.Human{Name:&amp;ldquo;zhangsan&amp;rdquo;}&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%T&lt;/td>
&lt;td>相应值的类型的 Go 语法表示&lt;/td>
&lt;td>Printf(&amp;quot;%T&amp;quot;, people)&lt;/td>
&lt;td>main.Human&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%%&lt;/td>
&lt;td>字面上的百分号，并非值的占位符&lt;/td>
&lt;td>Printf(&amp;quot;%%&amp;quot;)&lt;/td>
&lt;td>%&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="布尔占位符">布尔占位符&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>占位符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>%t&lt;/td>
&lt;td>true 或 false。&lt;/td>
&lt;td>Printf(&amp;quot;%t&amp;quot;, true)&lt;/td>
&lt;td>true&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="整数占位符">整数占位符&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>占位符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>%b&lt;/td>
&lt;td>二进制表示&lt;/td>
&lt;td>Printf(&amp;quot;%b&amp;quot;, 5)&lt;/td>
&lt;td>101&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%c&lt;/td>
&lt;td>相应 Unicode 码点所表示的字符&lt;/td>
&lt;td>Printf(&amp;quot;%c&amp;quot;, 0x4E2D)&lt;/td>
&lt;td>中&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%d&lt;/td>
&lt;td>十进制表示&lt;/td>
&lt;td>Printf(&amp;quot;%d&amp;quot;, 0x12)&lt;/td>
&lt;td>18&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%o&lt;/td>
&lt;td>八进制表示&lt;/td>
&lt;td>Printf(&amp;quot;%d&amp;quot;, 10)&lt;/td>
&lt;td>12&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%q&lt;/td>
&lt;td>单引号围绕的字符字面值，由 Go 语法安全地转义&lt;/td>
&lt;td>Printf(&amp;quot;%q&amp;quot;, 0x4E2D)&lt;/td>
&lt;td>&amp;lsquo;中&amp;rsquo;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%x&lt;/td>
&lt;td>十六进制表示，字母形式为小写 a-f&lt;/td>
&lt;td>Printf(&amp;quot;%x&amp;quot;, 13)&lt;/td>
&lt;td>d&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%X&lt;/td>
&lt;td>十六进制表示，字母形式为大写 A-F&lt;/td>
&lt;td>Printf(&amp;quot;%x&amp;quot;, 13)&lt;/td>
&lt;td>D&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%U&lt;/td>
&lt;td>Unicode 格式：U+1234，等同于 &amp;ldquo;U+%04X&amp;rdquo;&lt;/td>
&lt;td>Printf(&amp;quot;%U&amp;quot;, 0x4E2D)&lt;/td>
&lt;td>U+4E2D&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="浮点数和复数的组成部分实部和虚部">浮点数和复数的组成部分(实部和虚部)&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>占位符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>%b&lt;/td>
&lt;td>无小数部分的，指数为二的幂的科学计数法,与 strconv.FormatFloat 的 &amp;lsquo;b&amp;rsquo; 转换格式一致。&lt;/td>
&lt;td>&lt;/td>
&lt;td>-123456p-78&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%e&lt;/td>
&lt;td>科学计数法，例如 -1234.456e+78&lt;/td>
&lt;td>Printf(&amp;quot;%e&amp;quot;, 10.2)&lt;/td>
&lt;td>1.020000e+01&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%E&lt;/td>
&lt;td>科学计数法，例如 -1234.456E+78&lt;/td>
&lt;td>Printf(&amp;quot;%e&amp;quot;, 10.2)&lt;/td>
&lt;td>1.020000E+01&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%f&lt;/td>
&lt;td>有小数点而无指数，例如 123.456&lt;/td>
&lt;td>Printf(&amp;quot;%f&amp;quot;, 10.2)&lt;/td>
&lt;td>10.200000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%g&lt;/td>
&lt;td>根据情况选择 %e 或 %f 以产生更紧凑的(无末尾的 0)输出&lt;/td>
&lt;td>Printf(&amp;quot;%g&amp;quot;, 10.20)&lt;/td>
&lt;td>10.2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%G&lt;/td>
&lt;td>根据情况选择 %E 或 %f 以产生更紧凑的(无末尾的 0)输出&lt;/td>
&lt;td>Printf(&amp;quot;%G&amp;quot;, 10.20+2i)&lt;/td>
&lt;td>(10.2+2i)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="字符串与字节切片">字符串与字节切片&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>占位符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>%s&lt;/td>
&lt;td>输出字符串表示(string 类型或[]byte)&lt;/td>
&lt;td>Printf(&amp;quot;%s&amp;quot;, []byte(&amp;ldquo;Go 语言&amp;rdquo;))&lt;/td>
&lt;td>Go 语言&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%q&lt;/td>
&lt;td>双引号围绕的字符串，由 Go 语法安全地转义&lt;/td>
&lt;td>Printf(&amp;quot;%q&amp;quot;, &amp;ldquo;Go 语言&amp;rdquo;)&lt;/td>
&lt;td>&amp;ldquo;Go 语言&amp;rdquo;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%x&lt;/td>
&lt;td>十六进制，小写字母，每字节两个字符&lt;/td>
&lt;td>Printf(&amp;quot;%x&amp;quot;, &amp;ldquo;golang&amp;rdquo;)&lt;/td>
&lt;td>676f6c616e67&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%X&lt;/td>
&lt;td>十六进制，大写字母，每字节两个字符&lt;/td>
&lt;td>Printf(&amp;quot;%X&amp;quot;, &amp;ldquo;golang&amp;rdquo;)&lt;/td>
&lt;td>676F6C616E67&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="指针">指针&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>占位符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>%p&lt;/td>
&lt;td>十六进制表示，前缀 0x&lt;/td>
&lt;td>Printf(&amp;quot;%p&amp;quot;, &amp;amp;people)&lt;/td>
&lt;td>0x4f57f0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="其它标记">其它标记&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>占位符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>+&lt;/td>
&lt;td>总打印数值的正负号；对于%q(%+q)保证只输出 ASCII 编码的字符。&lt;/td>
&lt;td>Printf(&amp;quot;%+q&amp;quot;, &amp;ldquo;中文&amp;rdquo;)&lt;/td>
&lt;td>&amp;ldquo;\u4e2d\u6587&amp;rdquo;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-&lt;/td>
&lt;td>在右侧而非左侧填充空格(左对齐该区域)&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>#&lt;/td>
&lt;td>备用格式：为八进制添加前导 0(%#o)&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>为十六进制添加前导 0x(%#x)或 0X(%#X)，为 %p(%#p)去掉前导 0x；如果可能的话，%q(%#q)会打印原始 (即反引号围绕的)字符串；如果是可打印字符，%U(%#U)会写出该字符的 Unicode 编码形式(如字符 x 会被打印成 U+0078 &amp;lsquo;x&amp;rsquo;)。&lt;/td>
&lt;td>Printf(&amp;quot;%#U&amp;quot;, &amp;lsquo;中&amp;rsquo;)&lt;/td>
&lt;td>U+4E2D&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;rsquo; '&lt;/td>
&lt;td>(空格)为数值中省略的正负号留出空白(% d)；以十六进制(% x, % X)打印字符串或切片时，在字节之间用空格隔开&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>填充前导的 0 而非空格；对于数字，这会将填充移到正负号之后&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>golang 没有 &amp;lsquo;%u&amp;rsquo; 点位符，若整数为无符号类型，默认就会被打印成无符号的。&lt;/p>
&lt;p>宽度与精度的控制格式以 Unicode 码点为单位。宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。&lt;/p>
&lt;p>操作数的类型为 int 时，宽度与精度都可用字符&lt;code>*&lt;/code>表示。&lt;/p>
&lt;p>对于 %g/%G 而言，精度为所有数字的总数，例如：123.45，%.4g 会打印 123.5，(而 %6.2f 会打印 123.45)。&lt;/p>
&lt;p>%e 和 %f 的默认精度为 6&lt;/p>
&lt;p>对大多数的数值类型而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。&lt;/p>
&lt;p>而以字符串类型，精度为输出的最大字符数，如果必要的话会直接截断。&lt;/p></description></item><item><title>Docs: Data Type(数据类型) 与 Literal(字面量)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-literal%E5%AD%97%E9%9D%A2%E9%87%8F/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-literal%E5%AD%97%E9%9D%A2%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-literal%E5%AD%97%E9%9D%A2%E9%87%8F/data-type%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-literal%E5%AD%97%E9%9D%A2%E9%87%8F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Data_type">Wiki,DataType&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Abstract_data_type">Wiki,Abstract Data Type&lt;/a>(抽象数据类型)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Literal_(computer_programming)">Wiki,Literal(字面量)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在计算机科学和计算机编程中，&lt;strong>Data Type(数据类型，有时也简称 Type)&lt;/strong> 是数据的一个属性，这些属性将会让编译器知道程序员想要如何使用数据。&lt;/p>
&lt;p>在计算机科学中，&lt;strong>Literal(字面量)&lt;/strong> 是表示源代码中固定值的 snotation(表示法)。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如：整数、浮点数以及字符串；而有很多也对布尔类型和字符类型的值也支持字面量表示；还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值也支持字面量表示法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// b 为常量，10为字面量,数据类型为整数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span> = &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// str 为变量，hello world！为字面量，数据类型为字符串
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#a6e22e">str&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;hello world！&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="数据类型的分类">数据类型的分类&lt;/h1>
&lt;ul>
&lt;li>原始数据类型&lt;/li>
&lt;li>复合类型&lt;/li>
&lt;li>抽象数据类型&lt;/li>
&lt;li>其他类型&lt;/li>
&lt;/ul>
&lt;h2 id="primitive-data-types原始数据类型">Primitive Data Types(原始数据类型)&lt;/h2>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Primitive_data_type">原始数据类型&lt;/a>通常是语言实现的内置或基础类型。&lt;/p>
&lt;h4 id="machine-data-type机器数据类型">Machine Data Type(机器数据类型)&lt;/h4>
&lt;p>基于数字电子的计算机中的所有数据都表示为最低级别的&lt;a href="https://en.wikipedia.org/wiki/Bit">位&lt;/a>（替代 0 和 1）。数据的最小可寻址单元通常是一组称为&lt;a href="https://en.wikipedia.org/wiki/Byte">字节&lt;/a>的位（通常是一个&lt;a href="https://en.wikipedia.org/wiki/Octet_(computing)">八位组&lt;/a>，即 8 位）。由&lt;a href="https://en.wikipedia.org/wiki/Machine_code">机器代码&lt;/a>指令处理的单元称为&lt;a href="https://en.wikipedia.org/wiki/Word_(data_type)">字&lt;/a>（截至 2011 年，通常为 32 或 64 位）。大多数指令将字解释为&lt;a href="https://en.wikipedia.org/wiki/Binary_number">二进制数&lt;/a>，因此 32 位字可以表示从 0 到 232 - 1 或有符号整数值来自 -231 到 231 - 1 由于&lt;a href="https://en.wikipedia.org/wiki/Two%27s_complement">二进制补码&lt;/a>，机器语言和机器在大多数情况下不需要区分这些无符号和有符号数据类型。&lt;/p>
&lt;p>用于浮点算术的浮点数对字中的位使用不同的解释。有关详细信息，请参阅&lt;a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic">浮点运算&lt;/a>。&lt;/p>
&lt;p>机器数据类型需要在&lt;a href="https://en.wikipedia.org/wiki/Systems_programming">系统&lt;/a>或&lt;a href="https://en.wikipedia.org/wiki/Low-level_programming_language">低级编程语言中&lt;/a>公开或可用，允许对硬件进行细粒度控制。的&lt;a href="https://en.wikipedia.org/wiki/C_programming_language">C 编程语言&lt;/a>，例如，建筑材料整数类型不同的宽度，如和。如果目标平台上不存在相应的本机类型，编译器将使用确实存在的类型将它们分解为代码。例如，如果在 16 位平台上请求一个 32 位整数，编译器会默认将其视为两个 16 位整数的数组。 shortlong&lt;/p>
&lt;p>在更高级别的编程中，机器数据类型通常被隐藏或_抽象_为一个实现细节，如果暴露，会使代码的可移植性降低。例如，numeric 可以提供泛型类型而不是某些特定位宽的整数。&lt;/p>
&lt;h4 id="boolean-type布尔类型">Boolean Type(布尔类型)&lt;/h4>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Boolean_type">Boolean(布尔)&lt;/a> 类型表示值 &lt;a href="https://en.wikipedia.org/wiki/Logical_truth">true(真)&lt;/a> 和 &lt;a href="https://en.wikipedia.org/wiki/Logical_truth">false(假)&lt;/a>。尽管只有两个值是可能的，但出于效率原因，它们很少被实现为单个二进制数字。许多编程语言没有明确的布尔类型，&lt;strong>而是将 0 解释为 false，将其他值解释为 true&lt;/strong>。布尔数据是指如何将语言解释为机器语言的逻辑结构。在这种情况下，布尔值 0 指的是逻辑 False。True 总是非零，尤其是被称为布尔值 1 的一。&lt;/p>
&lt;h4 id="numeric-type数字类型">Numeric Type(数字类型)&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Integer_(computing)">Integer(整数，简写 int)&lt;/a> 数据类型，或“非分数”。可以根据它们包含负值的能力进行子类型化（例如 unsigned 在 C 和 C++ 中）。也可具有小的预定义数目的亚型（如 short 和 long 在 C / C ++）; 或允许用户自由定义子范围，例如 1..12（例如&lt;a href="https://en.wikipedia.org/wiki/Pascal_(programming_language)">Pascal&lt;/a> / &lt;a href="https://en.wikipedia.org/wiki/Ada_(programming_language)">Ada&lt;/a>）。&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Floating_point">Floating Point(浮点)&lt;/a> 数据类型通常将值表示为高精度分数值（&lt;a href="https://en.wikipedia.org/wiki/Rational_numbers">有理数&lt;/a>，数学上），但有时会误导性地称为实数（令人联想到数学&lt;a href="https://en.wikipedia.org/wiki/Real_numbers">实数&lt;/a>）。它们通常对最大值和精度都有预定义的限制。通常以 a × 2 b 的形式在内部存储（其中 a 和 b 是整数），但以熟悉的&lt;a href="https://en.wikipedia.org/wiki/Decimal">十进制&lt;/a>形式显示。&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fixed_point_(computing)">Fixed Point(定点)&lt;/a> 数据类型便于表示货币值。它们通常在内部实现为整数，从而导致预定义的限制。&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Bignum">Bignum&lt;/a>或&lt;a href="https://en.wikipedia.org/wiki/Arbitrary_precision">任意精度&lt;/a>数字类型缺乏预定义的限制。它们不是原始类型，出于效率原因很少使用。&lt;/li>
&lt;/ul>
&lt;h4 id="enumerations枚举">Enumerations(枚举)&lt;/h4>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Enumerated_type">枚举类型&lt;/a>具有不同的值，其可以被比较和分配，但不一定必须在计算机的存储器中的任何特定的具体表示; 编译器和解释器可以任意表示它们。例如，一副扑克牌中的四个花色可能是名为 CLUB、DIAMOND、HEART、SPADE 的四个枚举数，属于一个名为 suit 的枚举类型。如果变量 V 被声明为具有花色作为它的数据类型，可以为它分配这四个值中的任何一个。一些实现允许程序员为枚举值分配整数值，甚至将它们视为与整数类型等效的。&lt;/p>
&lt;h2 id="composite-types复合类型">Composite Types(复合类型)&lt;/h2>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Composite_type">复合类型&lt;/a>派生自多个原始类型。这可以通过多种方式完成。它们组合的方式称为&lt;a href="https://en.wikipedia.org/wiki/Data_structure">数据结构&lt;/a>。构成一个基本类型为化合物类型通常导致新类型，例如阵列的整数是一个不同类型的整数。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Array_data_type">&lt;strong>Array(数组&lt;/strong>&lt;/a>&lt;strong>，也称为载体，&lt;/strong>&lt;a href="https://en.wikipedia.org/wiki/List_(abstract_data_type)">&lt;strong>列表&lt;/strong>&lt;/a>&lt;strong>，或序列)&lt;/strong> 的存储数量的元件，并提供&lt;a href="https://en.wikipedia.org/wiki/Random_access">随机接入&lt;/a>到单个元件。数组的元素通常（但并非在所有上下文中）需要具有相同的类型。数组可以是固定长度的或可扩展的。数组中的索引通常需要是来自特定范围的整数（如果不是，可以通过谈论&lt;a href="https://en.wikipedia.org/wiki/Associative_array">关联数组&lt;/a>来强调这种放松）（如果不是该范围内的所有索引都对应于元素，则它可能是一个&lt;a href="https://en.wikipedia.org/wiki/Sparse_array">稀疏数组&lt;/a>）。&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Record_(computer_science)">&lt;strong>Record(记录)，也称为 tuple(元组) 或 struct(结构)&lt;/strong>&lt;/a> 是最简单的&lt;a href="https://en.wikipedia.org/wiki/Data_structure">数据结构之一&lt;/a>。记录是包含其他值的值，通常采用固定数量和顺序，通常按 1 名称索引。记录的元素通常称为 &lt;strong>Fields(字段)&lt;/strong> 或 &lt;strong>Members(成员)&lt;/strong>。&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Union_(computer_science)">&lt;strong>Union(联合)&lt;/strong>&lt;/a> 类型定义将指定许多允许的原始类型中的哪一个可以存储在其实例中，例如“浮点数或长整数”。与&lt;a href="https://en.wikipedia.org/wiki/Record_(computer_science)">记录&lt;/a>相反，&lt;a href="https://en.wikipedia.org/wiki/Record_(computer_science)">记录&lt;/a>可以定义为包含一个浮点数和一个整数；而在联合中，一次只允许一种类型。
&lt;ul>
&lt;li>甲&lt;a href="https://en.wikipedia.org/wiki/Tagged_union">标签联合&lt;/a>（也称为&lt;a href="https://en.wikipedia.org/wiki/Variant_type">变体&lt;/a>，变体记录，识别联合，或不相交并）包含一个附加的字段，指示其当前型增强型安全性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)">&lt;strong>Set(集)&lt;/strong>&lt;/a> 是一个&lt;a href="https://en.wikipedia.org/wiki/Abstract_data_structure">抽象的数据结构&lt;/a>可以存储某些值，没有任何特别的&lt;a href="https://en.wikipedia.org/wiki/Sequence">顺序&lt;/a>，并且不重复的值。值本身不是从集合中检索的，而是测试成员资格的值以获得布尔值“in”或“not in”。&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Object_(computer_science)">&lt;strong>Object(对象)&lt;/strong>&lt;/a>** **包含许多数据字段，如 Record，以及许多用于访问或修改它们的子程序，称为 &lt;a href="https://en.wikipedia.org/wiki/Method_(computer_programming)">Methods(方法)&lt;/a>。&lt;/li>
&lt;/ul>
&lt;p>许多其他的都是可能的，但它们往往是上述的进一步变体和化合物。例如，&lt;a href="https://en.wikipedia.org/wiki/Linked_list">链表&lt;/a>可以存储与数组相同的数据，但提供&lt;a href="https://en.wikipedia.org/wiki/Sequential_access">顺序访问&lt;/a>而不是随机&lt;a href="https://en.wikipedia.org/wiki/Sequential_access">访问&lt;/a>，并且由&lt;a href="https://en.wikipedia.org/wiki/Dynamic_memory">动态内存中&lt;/a>的记录组成；虽然可以说是一种数据结构而不是类型本身，但它也很常见且足够独特，因此将其包含在复合类型的讨论中是合理的。&lt;/p>
&lt;h3 id="string字符串-和-text文本-类型">String(字符串) 和 Text(文本) 类型&lt;/h3>
&lt;ul>
&lt;li>一个&lt;a href="https://en.wikipedia.org/wiki/Character_(computing)">字符&lt;/a>，可能是某个&lt;a href="https://en.wikipedia.org/wiki/Alphabet">字母表&lt;/a>中的一个&lt;a href="https://en.wikipedia.org/wiki/Alphabet">字母&lt;/a>、一个数字、一个空格、一个标点符号等。&lt;/li>
&lt;li>一个&lt;a href="https://en.wikipedia.org/wiki/String_(computer_science)">字符串&lt;/a>，它是一个字符序列。字符串通常用于表示单词和文本，尽管除了最琐碎的情况外，所有文本都不仅仅涉及字符序列。&lt;/li>
&lt;/ul>
&lt;p>字符和字符串类型可以存储字符集（例如&lt;a href="https://en.wikipedia.org/wiki/ASCII">ASCII ）中&lt;/a>的字符序列。由于大多数字符集都包含&lt;a href="https://en.wikipedia.org/wiki/Numerical_digit">数字&lt;/a>，因此可以使用数字字符串，例如&amp;quot;1234&amp;quot;. 但是，许多语言将它们视为属于与数值不同的类型 1234。&lt;/p>
&lt;p>根据所需的字符“宽度”，字符和字符串类型可以有不同的子类型。最初的 7 位宽 ASCII 被发现是有限的，并被 8 位和 16 位集取代，它们可以编码各种各样的非拉丁字母（如&lt;a href="https://en.wikipedia.org/wiki/Hebrew">希伯来语&lt;/a>和&lt;a href="https://en.wikipedia.org/wiki/Chinese_language">中文&lt;/a>）和其他符号。字符串可以是适合拉伸的，也可以是固定大小的，即使是在相同的编程语言中。它们也可以按其最大大小进行子类型化。&lt;/p>
&lt;p>注意：字符串不是所有语言中的原始数据类型。例如，在 &lt;a href="https://en.wikipedia.org/wiki/C_(programming_language)">C 语言&lt;/a> 中，它们由字符数组组成。&lt;/p>
&lt;h2 id="abstract-data-types抽象数据类型">Abstract Data Types(抽象数据类型)&lt;/h2>
&lt;p>任何未指定数据具体表示的&lt;a href="https://en.wikipedia.org/wiki/Abstract_data_type">数据类型&lt;/a> 都是 &lt;strong>Abstract Data Type(抽象数据类型，简称 ADT)&lt;/strong>。相反，使用基于数据类型操作的正式规范来描述它。规范的任何实现都必须满足给定的规则。抽象数据类型用于形式&lt;a href="https://en.wikipedia.org/wiki/Semantics_(computer_science)">语义&lt;/a>和程序&lt;a href="https://en.wikipedia.org/wiki/Formal_verification">验证，&lt;/a>并且不太严格地用于&lt;a href="https://en.wikipedia.org/wiki/Design">设计&lt;/a>。&lt;/p>
&lt;p>除了验证之外，规范可能会立即转变为实现。例如，&lt;a href="https://en.wikipedia.org/wiki/OBJ_(programming_language)">OBJ&lt;/a>系列编程语言基于此选项，使用&lt;a href="https://en.wikipedia.org/wiki/Equation">等式&lt;/a>进行规范并&lt;a href="https://en.wikipedia.org/wiki/Rewriting">重写&lt;/a>以运行它们。&lt;a href="https://en.wikipedia.org/wiki/Algebraic_specification">代数规范&lt;/a>&lt;a href="https://en.wikipedia.org/wiki/Data_type#cite_note-3">[3]&lt;/a>是 1980 年左右 CS 的一个重要研究课题，几乎是当时抽象数据类型的同义词。它具有&lt;a href="https://en.wikipedia.org/wiki/Universal_algebra">通用代数&lt;/a>的数学基础。&lt;a href="https://en.wikipedia.org/wiki/Data_type#cite_note-4">[4]&lt;/a>通过允许其他公式而不仅仅是方程，可以使规范语言更具表现力。&lt;/p>
&lt;p>一个典型的例子是&lt;a href="https://en.wikipedia.org/wiki/List_(abstract_data_type)">list&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)#Multiset">bag&lt;/a>和&lt;a href="https://en.wikipedia.org/wiki/Set_(computer_science)">set&lt;/a>数据类型的层次结构。所有这些数据类型都可以通过三个操作声明：null，它构造空容器，single，它从单个元素构造一个容器，append，它组合了两个相同类型的容器。然后，可以通过对这些操作的以下规则来给出三种数据类型的完整规范：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>- null 是左右中性：&lt;/th>
&lt;th>追加（空，A）= A，追加（A，空）= A。&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>- 对于列表，append 是关联的：&lt;/td>
&lt;td>追加（追加（A，B），C）=追加（A，追加（B，C））。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>- 袋子增加交换性：&lt;/td>
&lt;td>追加（B，A）=追加（A，B）。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>- 最后，集合也是幂等的：&lt;/td>
&lt;td>追加（A，A）= A。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>可以通过以下方式指定对数据的访问，例如这些容器的成员函数：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>- 成员（X，单（Y））= eq（X，Y）&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>- 成员（X，空）= 假&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>- 成员(X,append(A,B)) = or(member(X,A), member(X,B))&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="associative-array关联数组也称为-map">Associative array(关联数组，也称为 map)&lt;/h3>
&lt;h2 id="其他类型">其他类型&lt;/h2>
&lt;p>类型可以基于或派生自上述基本类型。在某些语言（例如 C）中，&lt;a href="https://en.wikipedia.org/wiki/Function_(computer_science)">函数&lt;/a>具有从其&lt;a href="https://en.wikipedia.org/wiki/Return_value">返回值&lt;/a>的类型派生的类型。&lt;/p>
&lt;h3 id="pointer指针-和-reference引用">Pointer(指针) 和 Reference(引用)&lt;/h3>
&lt;p>主条目：&lt;a href="https://en.wikipedia.org/wiki/Reference_(computer_science)">引用(计算机科学）&lt;/a>
主要的非复合派生类型是&lt;a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">指针&lt;/a>，这是一种数据类型，其值直接引用（或“指向”）使用其&lt;a href="https://en.wikipedia.org/wiki/Memory_address">地址&lt;/a>存储在&lt;a href="https://en.wikipedia.org/wiki/Computer_memory">计算机内存中&lt;/a>其他位置的另一个值。它是一种原始的&lt;a href="https://en.wikipedia.org/wiki/Reference_(computer_science)">参考&lt;/a>。（在日常生活中，一本书的页码可以被认为是引用另一本书的一段数据）。指针通常以类似于整数的格式存储；但是，尝试取消引用或“查找”其值永远不是有效内存地址的指针会导致程序崩溃。为了改善这个潜在问题，指针被认为是指向它们指向的数据类型的单独类型，即使底层表示相同。&lt;/p>
&lt;h3 id="function函数-类型">Function(函数) 类型&lt;/h3>
&lt;p>主条目：&lt;a href="https://en.wikipedia.org/wiki/Function_type">函数类型&lt;/a>
虽然也可以为函数分配类型，但在本文的设置中，它们的类型不被视为数据类型。在这里，数据被视为不同于&lt;a href="https://en.wikipedia.org/wiki/Algorithm">算法&lt;/a>。在编程中，函数与后者密切相关。但是，因为&lt;a href="https://en.wikipedia.org/wiki/Universal_Turing_machine">通用数据处理的&lt;/a>一个中心原则是算法可以&lt;a href="https://en.wikipedia.org/wiki/G%C3%B6del_numbering#Generalizations">表示为数据&lt;/a>，例如文本描述和二进制程序，数据和函数之间的对比是有限的。其实函数不仅可以用数据来表示，函数也可以用来&lt;a href="https://en.wikipedia.org/wiki/Lambda_calculus#Encoding_datatypes">对数据&lt;/a>进行&lt;a href="https://en.wikipedia.org/wiki/Lambda_calculus#Encoding_datatypes">编码&lt;/a>。许多当代&lt;a href="https://en.wikipedia.org/wiki/Type_systems">类型系统&lt;/a>强烈关注函数类型，许多现代语言允许函数作为&lt;a href="https://en.wikipedia.org/wiki/First-class_citizen">一等公民运行&lt;/a>。
将函数从被视为数据类型的对象中排除在相关领域中并不少见。[&lt;a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">需要引用&lt;/a>] 例如，&lt;a href="https://en.wikipedia.org/wiki/Predicate_logic">谓词逻辑&lt;/a>不允许在函数或谓词名称上应用&lt;a href="https://en.wikipedia.org/wiki/Quantifier_(logic)">量词&lt;/a>。&lt;/p>
&lt;h3 id="meta元-类型">Meta(元) 类型&lt;/h3>
&lt;p>主条目：&lt;a href="https://en.wikipedia.org/wiki/Metaclass">元类&lt;/a>
一些编程语言将类型信息表示为数据，从而实现&lt;a href="https://en.wikipedia.org/wiki/Type_introspection">类型自省&lt;/a>和&lt;a href="https://en.wikipedia.org/wiki/Reflection_(computer_programming)">反射&lt;/a>。相比之下，&lt;a href="https://en.wikipedia.org/wiki/Type_constructor">高阶&lt;/a> &lt;a href="https://en.wikipedia.org/wiki/Type_systems">类型系统&lt;/a>虽然允许从其他类型构造类型并作为值传递给函数，但通常避免基于它们进行&lt;a href="https://en.wikipedia.org/wiki/Computational">计算&lt;/a>决策。[&lt;a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">需要引用&lt;/a>]&lt;/p>
&lt;h3 id="utility实用程序-类型">Utility(实用程序) 类型&lt;/h3>
&lt;p>为方便起见，高级语言可能提供现成的“现实世界”数据类型，例如时间、日期、货币值和内存，即使该语言允许从原始类型构建它们。&lt;/p></description></item><item><title>Docs: DOM(文档对象模型)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/javascript-%E6%A0%87%E5%87%86%E5%BA%93/dom%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/javascript-%E6%A0%87%E5%87%86%E5%BA%93/dom%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction">MDN 官方文档，参考-WebAPIs-DOM-DOM 简介&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Document Ojbect Model(文档对象模型，简称 DOM)&lt;/strong> 是 Web 文档(HTML 和 XML)的编程接口(通常描述为 WebAPI 中的 DOM 接口)。应用程序可以通过该接口更改 Web 文档的 结构、样式、内容 等。DOM 将 Web 文档抽象为 &lt;strong>Node(节点)&lt;/strong> 和 **Ojbect(对象，包含属性和方法的对象) **组成的结构集合。&lt;/p>
&lt;p>一个 Web 页面即是一个文档，这个文档可以在浏览器中作为 HTML 源码展示出来。DOM 则可以将文档表示为另一种形式，以便 JavaScript 等编程语言可以对其进行修改。
比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 我们通过 document.querySelectorAll() 获取 Web 文档中所有 &amp;lt;p&amp;gt; 元素的列表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 将所有 &amp;lt;p&amp;gt; 元素实例化为 paragraphs 变量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">paragraphs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> document.&lt;span style="color:#a6e22e">querySelectorAll&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;p&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 之后，通过代码对 paragraphs 的所有操作都会直接反应到前端 Web 页面上
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 这里表示将将会弹出提示框，并将其中第一个 &amp;lt;p&amp;gt; 元素的名称显示在提示框中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">alert&lt;/span>(&lt;span style="color:#a6e22e">paragraphs&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>].&lt;span style="color:#a6e22e">nodeName&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从上面的示例中可以看到，JavaScript 中使用 &lt;code>**document 类型的对象**&lt;/code>表示 Web 文档本身；document 对象里包含了非常多的方法来控制 Web 文档中的元素，在 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Document">MDN 官方文档，WebAPIs-Document&lt;/a> 中可以看到所有 document 对象下的属性、方法、事件。示例中的 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelectorAll">querySelectorAll()&lt;/a> 方法将会返回匹配到的元素列表。&lt;/p>
&lt;p>DOM 本身并不是一个编程语言，可以说是一种 规范、模型、接口；DOM 可以用任何语言实现，DOM 被内嵌在浏览器中，各种编程语言可以自己实现 DOM 库以便在浏览器中调用 DOM。&lt;/p>
&lt;p>编程语言之于 DOM，有点类似于 runc 等运行时之于 OCI&lt;/p>
&lt;p>我们甚至可以在 Python 中使用 DOM 来控制 Web 文档&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Python DOM example&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> xml.dom.minidom &lt;span style="color:#66d9ef">as&lt;/span> m
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>doc &lt;span style="color:#f92672">=&lt;/span> m&lt;span style="color:#f92672">.&lt;/span>parse(&lt;span style="color:#e6db74">r&lt;/span>&lt;span style="color:#e6db74">&amp;#34;C:\Projects\Py\chap1.xml&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>doc&lt;span style="color:#f92672">.&lt;/span>nodeName &lt;span style="color:#75715e"># DOM property of document object&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>p_list &lt;span style="color:#f92672">=&lt;/span> doc&lt;span style="color:#f92672">.&lt;/span>getElementsByTagName(&lt;span style="color:#e6db74">&amp;#34;para&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: EBNF</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/ebnf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/ebnf/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">Wiki,EBNF&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Metasyntax">Wiki,Metasyntax&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Extended Backus-Naur Form(扩展的 Backus-Naur 格式，简称 EBNF)&lt;/strong> 是一组 &lt;a href="https://en.wikipedia.org/wiki/Metasyntax">Metasyntax(元语法)&lt;/a> 表示法。EBNF 用于对计算机&lt;a href="https://en.wikipedia.org/wiki/Programming_language">编程语言&lt;/a>等&lt;a href="https://en.wikipedia.org/wiki/Formal_language">形式语言&lt;/a>进行形式化描述。EBNF 是基于 BNF 的扩展。&lt;/p>
&lt;p>EBNF 是一种表达形式语言语法的代码。EBNF 由两部分组成&lt;/p>
&lt;ul>
&lt;li>Terminal Symbols(终结符号)&lt;/li>
&lt;li>non-terminal production rules(非终结表达式规则) # 其实就相当于一个表达式&lt;/li>
&lt;/ul>
&lt;p>这两部分组合起来，其实就是一句话，最后跟一个句号~~~一行内容就是一个 EBNF 表示法，比如：&lt;/p>
&lt;pre>&lt;code>digit excluding zero = &amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | &amp;quot;3&amp;quot; | &amp;quot;4&amp;quot; | &amp;quot;5&amp;quot; | &amp;quot;6&amp;quot; | &amp;quot;7&amp;quot; | &amp;quot;8&amp;quot; | &amp;quot;9&amp;quot; ;
digit = &amp;quot;0&amp;quot; | digit excluding zero ;
&lt;/code>&lt;/pre>
&lt;h1 id="symbols符号">Symbols(符号)&lt;/h1>
&lt;p>下面定义的符号意义中，&lt;code>...&lt;/code> 仅仅用来表示符号中可以是任意内容，不属于被定义的符号的一部分。
&lt;code>=&lt;/code> # Definition(定义)
&lt;code>,&lt;/code> # Concatenation(串接)
&lt;code>;&lt;/code> # Termination(终止)
&lt;code>|&lt;/code> # Alternation(交替)，就是“或者”的意思。
&lt;code>[...]&lt;/code> # Optional(可选)
&lt;code>{}&lt;/code> # Repetition(重复)
&lt;code>(...)&lt;/code> # Grouping(分组)
&lt;code>'...'&lt;/code> # Terminal String(终端字符串)
&lt;code>&amp;quot;...&amp;quot;&lt;/code> # Terminal String(终端字符串)
&lt;code>(*...*)&lt;/code> # Comment(注释)
&lt;code>?...?&lt;/code> # Special Sequence(特殊序列)&lt;/p></description></item><item><title>Docs: ECMAScript</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/ECMAScript">Wiki,ECMAScript&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.javascript.com/">JavaScript 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.typescriptlang.org/">TypeScript 官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>ECMAScript 是一种编程语言的&lt;strong>标准&lt;/strong>，起源于 JavaScripts。&lt;/p>
&lt;p>1996 年 8 月，微软模仿 JavaScript 开发了一种相近的语言，取名为 JScript（JavaScript 是 Netscape 的注册商标，微软不能用），首先内置于 IE 3.0。Netscape 公司面临丧失浏览器脚本语言的主导权的局面。&lt;/p>
&lt;p>1996 年 11 月，Netscape 公司决定将 JavaScript 提交给国际标准化组织 ECMA（European Computer Manufacturers Association），希望 JavaScript 能够成为国际标准，以此抵抗微软。ECMA 的 39 号技术委员会（Technical Committee 39）负责制定和审核这个标准，成员由业内的大公司派出的工程师组成，目前共 25 个人。该委员会定期开会，所有的邮件讨论和会议记录，都是公开的。&lt;/p>
&lt;p>1997 年 7 月，ECMA 组织发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript。这个版本就是 ECMAScript 1.0 版。之所以不叫 JavaScript，一方面是由于商标的关系，Java 是 Sun 公司的商标，根据一份授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 已经被 Netscape 公司注册为商标，另一方面也是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规范，后者是前者的一种实现。在日常场合，这两个词是可以互换的。&lt;/p>
&lt;p>ECMAScript 只用来标准化 JavaScript 这种语言的基本语法结构，与部署环境相关的标准都由其他标准规定，比如 DOM 的标准就是由 W3C 组织（World Wide Web Consortium）制定的。&lt;/p>
&lt;p>ECMA-262 标准后来也被另一个国际标准化组织 ISO（International Organization for Standardization）批准，标准号是 ISO-16262。&lt;/p>
&lt;h2 id="es6-标准">ES6 标准&lt;/h2>
&lt;p>ECMAScript 6.0 是 ECMA 的最新标准，于 2015 年 6 月发布，官方称为 ES2015 标准(ES6 的叫法更民间)。&lt;/p>
&lt;p>2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。&lt;/p>
&lt;p>但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。&lt;/p>
&lt;p>但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。&lt;/p>
&lt;p>标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。&lt;/p>
&lt;p>ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的 includes 方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。&lt;/p>
&lt;p>因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。&lt;/p>
&lt;h2 id="ecmascript-的三大核心组成">ECMAScript 的三大核心组成&lt;/h2>
&lt;p>&lt;strong>ECMAScript&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>JS 的书写语法和规则&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Browser Ojbect Model(浏览器对象模型，简称 BOM)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>JS 控制浏览器的属性和方法。
&lt;ul>
&lt;li>比如浏览器右侧的滚动条，可以通过 JS 代码来控制。比如某些网页有个叫回到顶部的按钮，按一下，就等于是 JS 操作滚动条移动到最上面了。&lt;/li>
&lt;li>比如很多手机，我们从屏幕最左侧往右滑，一般返回上一页。这是因为这个滑动行为被 JS 代码捕获后，操作浏览器点击了一下后腿按钮。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Document Object Model(文档对象模型，简称 DOM)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>JS 控制文档流的属性和方法。
&lt;ul>
&lt;li>比如很多网页最上面中间都有一个图片，按一下图片左右两边的箭头，就会换到另一个图片&lt;/li>
&lt;li>也就是说，JS 控制什么时候，让页面元素发生一些变化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="学习资料">学习资料&lt;/h1>
&lt;p>&lt;a href="https://developer.mozilla.org/en-US/docs/Web">MDN 官方文档，Web 开发技术&lt;/a>((通常指的是网站首页的 References 标签中的文档))&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">JavaScript&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#keywords">JavaScript-参考-词汇文法-关键字&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements">JavaScript-参考-语句和声明&lt;/a>(这里就是 JS 的关键字的用法)&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://www.liaoxuefeng.com/wiki/1022910821149312">廖雪峰，JavaScript&lt;/a>
&lt;a href="https://wangdoc.com/javascript/index.html">网道，JavaScript&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://wangdoc.com/javascript/basic/grammar.html">网道，JavaScript-JavaScript 的基本语法&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>电子书&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/javascript-tutorial/zh.javascript.info/tree/master">GitHub 项目，javascript/zh.javascript.info&lt;/a>(现代 JavaScript 教程)&lt;/li>
&lt;/ul>
&lt;h1 id="hello-world">Hello World&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!DOCTYPE html&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">html&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">head&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">meta&lt;/span> &lt;span style="color:#a6e22e">charset&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;UTF-8&amp;#34;&lt;/span> /&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">title&lt;/span>&amp;gt;Hello World&amp;lt;/&lt;span style="color:#f92672">title&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;/&lt;span style="color:#f92672">head&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">body&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 有多种方式可以在书写 JS 代码 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 行内式， JS 代码写在标签上--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- a 标签，书写在 href 属性上 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">a&lt;/span> &lt;span style="color:#a6e22e">href&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;javascript: alert(&amp;#39;Hello World，行内式，a 标签&amp;#39;);&amp;#34;&lt;/span>&amp;gt;点我&amp;lt;/&lt;span style="color:#f92672">a&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 非 a 标签，书写在行为属性上 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">div&lt;/span> &lt;span style="color:#a6e22e">onclick&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;alert(&amp;#39;Hello World，行内式，非 a 标签&amp;#39;)&amp;#34;&lt;/span>&amp;gt;点我&amp;lt;/&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 内嵌式，JS 代码写在 script 标签中 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 在前端页面上显示的内容
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">alert&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello World 内嵌式&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 在后端控制台显示的内容
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello World backend&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;/&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 外链试，JS 代码写在单独的 .js 文件中，并通过 script 标签的 src 属性引入 .js 文件 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">script&lt;/span> &lt;span style="color:#a6e22e">src&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;./hello_world.js&amp;#34;&lt;/span>&amp;gt;&amp;lt;/&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 总结：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 行内式 # 强烈不推荐。不利于代码维护，也会导致 HTML 文件过于臃肿。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 内嵌式 # 一般测试或者学习时，使用这种方式，不用建立很多 .js 文件。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 外链式 # 强烈推荐
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;/&lt;span style="color:#f92672">body&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">html&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="javascript-语言关键字">JavaScript 语言关键字&lt;/h1>
&lt;p>break
case
catch
class
const
continue
debugger
default
delete
do
else
enum
export
extends
false
finally
for
function
if
implements
import
in
instanceof
interface
let
new
null
package
private
protected
public
return
super
switch
static
this
throw
try
true
typeof
var
void
while
with
yield&lt;/p>
&lt;h1 id="javascript-基本语法规范">JavaScript 基本语法规范&lt;/h1>
&lt;h2 id="语句-e8afade58fa5">语句 &lt;a href="#%E8%AF%AD%E5%8F%A5">#&lt;/a>&lt;/h2>
&lt;p>JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。&lt;/p>
&lt;p>语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。&lt;/p>
&lt;pre>&lt;code>var a = 1 + 3;
&lt;/code>&lt;/pre>
&lt;p>这条语句先用&lt;code>var&lt;/code>命令，声明了变量&lt;code>a&lt;/code>，然后将&lt;code>1 + 3&lt;/code>的运算结果赋值给变量&lt;code>a&lt;/code>。&lt;/p>
&lt;p>&lt;code>1 + 3&lt;/code>叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是 JavaScript 语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。&lt;/p>
&lt;p>语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。&lt;/p>
&lt;pre>&lt;code>var a = 1 + 3 ; var b = 'abc';
&lt;/code>&lt;/pre>
&lt;p>分号前面可以没有任何内容，JavaScript 引擎将其视为空语句。&lt;/p>
&lt;pre>&lt;code>;;;
&lt;/code>&lt;/pre>
&lt;p>上面的代码就表示 3 个空语句。&lt;/p>
&lt;p>表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。&lt;/p>
&lt;pre>&lt;code>1 + 3;
'abc';
&lt;/code>&lt;/pre>
&lt;p>上面两行语句只是单纯地产生一个值，并没有任何实际的意义。&lt;/p>
&lt;h2 id="变量-e58f98e9878f">变量 &lt;a href="#%E5%8F%98%E9%87%8F">#&lt;/a>&lt;/h2>
&lt;h3 id="概念-e6a682e5bfb5">概念 &lt;a href="#%E6%A6%82%E5%BF%B5">#&lt;/a>&lt;/h3>
&lt;p>变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。&lt;/p>
&lt;pre>&lt;code>var a = 1;
&lt;/code>&lt;/pre>
&lt;p>上面的代码先声明变量&lt;code>a&lt;/code>，然后在变量&lt;code>a&lt;/code>与数值 1 之间建立引用关系，称为将数值 1“赋值”给变量&lt;code>a&lt;/code>。以后，引用变量名&lt;code>a&lt;/code>就会得到数值 1。最前面的&lt;code>var&lt;/code>，是变量声明命令。它表示通知解释引擎，要创建一个变量&lt;code>a&lt;/code>。&lt;/p>
&lt;p>注意，JavaScript 的变量名区分大小写，&lt;code>A&lt;/code>和&lt;code>a&lt;/code>是两个不同的变量。&lt;/p>
&lt;p>变量的声明和赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样。&lt;/p>
&lt;pre>&lt;code>var a;
a = 1;
&lt;/code>&lt;/pre>
&lt;p>如果只是声明变量而没有赋值，则该变量的值是&lt;code>undefined&lt;/code>。&lt;code>undefined&lt;/code>是一个特殊的值，表示“无定义”。&lt;/p>
&lt;pre>&lt;code>var a;
a
&lt;/code>&lt;/pre>
&lt;p>如果变量赋值的时候，忘了写&lt;code>var&lt;/code>命令，这条语句也是有效的。&lt;/p>
&lt;pre>&lt;code>var a = 1;
a = 1;
&lt;/code>&lt;/pre>
&lt;p>但是，不写&lt;code>var&lt;/code>的做法，不利于表达意图，而且容易不知不觉地创建全局变量，所以建议总是使用&lt;code>var&lt;/code>命令声明变量。&lt;/p>
&lt;p>如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。&lt;/p>
&lt;pre>&lt;code>x
&lt;/code>&lt;/pre>
&lt;p>上面代码直接使用变量&lt;code>x&lt;/code>，系统就报错，告诉你变量&lt;code>x&lt;/code>没有声明。&lt;/p>
&lt;p>可以在同一条&lt;code>var&lt;/code>命令中声明多个变量。&lt;/p>
&lt;pre>&lt;code>var a, b;
&lt;/code>&lt;/pre>
&lt;p>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。&lt;/p>
&lt;pre>&lt;code>var a = 1;
a = 'hello';
&lt;/code>&lt;/pre>
&lt;p>上面代码中，变量&lt;code>a&lt;/code>起先被赋值为一个数值，后来又被重新赋值为一个字符串。第二次赋值的时候，因为变量&lt;code>a&lt;/code>已经存在，所以不需要使用&lt;code>var&lt;/code>命令。&lt;/p>
&lt;p>如果使用&lt;code>var&lt;/code>重新声明一个已经存在的变量，是无效的。&lt;/p>
&lt;pre>&lt;code>var x = 1;
var x;
x
&lt;/code>&lt;/pre>
&lt;p>上面代码中，变量&lt;code>x&lt;/code>声明了两次，第二次声明是无效的。&lt;/p>
&lt;p>但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。&lt;/p>
&lt;pre>&lt;code>var x = 1;
var x = 2;
var x = 1;
var x;
x = 2;
&lt;/code>&lt;/pre>
&lt;h3 id="variables-hoisting变量提升">Variables Hoisting(变量提升)&lt;/h3>
&lt;p>JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。&lt;/p>
&lt;pre>&lt;code>console.log(a);
var a = 1;
&lt;/code>&lt;/pre>
&lt;p>上面代码首先使用&lt;code>console.log&lt;/code>方法，在控制台（console）显示变量&lt;code>a&lt;/code>的值。这时变量&lt;code>a&lt;/code>还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。&lt;/p>
&lt;pre>&lt;code>var a;
console.log(a);
a = 1;
&lt;/code>&lt;/pre>
&lt;p>最后的结果是显示&lt;code>undefined&lt;/code>，表示变量&lt;code>a&lt;/code>已声明，但还未赋值。&lt;/p>
&lt;h2 id="标识符-e6a087e8af86e7aca6">标识符 &lt;a href="#%E6%A0%87%E8%AF%86%E7%AC%A6">#&lt;/a>&lt;/h2>
&lt;p>标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以&lt;code>a&lt;/code>和&lt;code>A&lt;/code>是两个不同的标识符。&lt;/p>
&lt;p>标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript 引擎遇到非法标识符，就会报错。&lt;/p>
&lt;p>简单说，标识符命名规则如下。&lt;/p>
&lt;ul>
&lt;li>第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（&lt;code>$&lt;/code>）和下划线（&lt;code>_&lt;/code>）。&lt;/li>
&lt;li>第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字&lt;code>0-9&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>下面这些都是合法的标识符。&lt;/p>
&lt;pre>&lt;code>arg0
_tmp
$elem
π
&lt;/code>&lt;/pre>
&lt;p>下面这些则是不合法的标识符。&lt;/p>
&lt;pre>&lt;code>1a
23
***
a+b
-d
&lt;/code>&lt;/pre>
&lt;p>中文是合法的标识符，可以用作变量名。&lt;/p>
&lt;pre>&lt;code>var 临时变量 = 1;
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>JavaScript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。&lt;/p>
&lt;/blockquote>
&lt;h2 id="注释-e6b3a8e9878a">注释 &lt;a href="#%E6%B3%A8%E9%87%8A">#&lt;/a>&lt;/h2>
&lt;p>源码中被 JavaScript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。JavaScript 提供两种注释的写法：一种是单行注释，用&lt;code>//&lt;/code>起头；另一种是多行注释，放在&lt;code>/*&lt;/code>和&lt;code>*/&lt;/code>之间。&lt;/p>
&lt;p>此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以&lt;code>&amp;lt;!--&lt;/code>和&lt;code>--&amp;gt;&lt;/code>也被视为合法的单行注释。&lt;/p>
&lt;pre>&lt;code>x = 1; &amp;lt;!-- x = 2;
--&amp;gt; x = 3;
&lt;/code>&lt;/pre>
&lt;p>上面代码中，只有&lt;code>x = 1&lt;/code>会执行，其他的部分都被注释掉了。&lt;/p>
&lt;p>需要注意的是，&lt;code>--&amp;gt;&lt;/code>只有在行首，才会被当成单行注释，否则会当作正常的运算。&lt;/p>
&lt;pre>&lt;code>function countdown(n) {
while (n --&amp;gt; 0) console.log(n);
}
countdown(3)
&lt;/code>&lt;/pre>
&lt;p>上面代码中，&lt;code>n --&amp;gt; 0&lt;/code>实际上会当作&lt;code>n-- &amp;gt; 0&lt;/code>，因此输出 2、1、0。&lt;/p>
&lt;h2 id="区块-e58cbae59d97">区块 &lt;a href="#%E5%8C%BA%E5%9D%97">#&lt;/a>&lt;/h2>
&lt;p>JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。&lt;/p>
&lt;p>对于&lt;code>var&lt;/code>命令来说，JavaScript 的区块不构成单独的作用域（scope）。&lt;/p>
&lt;pre>&lt;code>{
var a = 1;
}
a
&lt;/code>&lt;/pre>
&lt;p>上面代码在区块内部，使用&lt;code>var&lt;/code>命令声明并赋值了变量&lt;code>a&lt;/code>，然后在区块外部，变量&lt;code>a&lt;/code>依然有效，区块对于&lt;code>var&lt;/code>命令不构成单独的作用域，与不使用区块的情况没有任何区别。在 JavaScript 语言中，单独使用区块并不常见，区块往往用来构成其他更复杂的语法结构，比如&lt;code>for&lt;/code>、&lt;code>if&lt;/code>、&lt;code>while&lt;/code>、&lt;code>function&lt;/code>等。&lt;/p>
&lt;h2 id="条件语句-e69da1e4bbb6e8afade58fa5">条件语句 &lt;a href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5">#&lt;/a>&lt;/h2>
&lt;p>JavaScript 提供&lt;code>if&lt;/code>结构和&lt;code>switch&lt;/code>结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。&lt;/p>
&lt;h3 id="if-结构-if-e7bb93e69e84">if 结构 &lt;a href="#if-%E7%BB%93%E6%9E%84">#&lt;/a>&lt;/h3>
&lt;p>&lt;code>if&lt;/code>结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，&lt;code>true&lt;/code>表示“真”，&lt;code>false&lt;/code>表示“伪”。&lt;/p>
&lt;pre>&lt;code>if (布尔值)
语句;
if (布尔值) 语句;
&lt;/code>&lt;/pre>
&lt;p>上面是&lt;code>if&lt;/code>结构的基本形式。需要注意的是，“布尔值”往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为&lt;code>true&lt;/code>，就执行紧跟在后面的语句；如果结果为&lt;code>false&lt;/code>，则跳过紧跟在后面的语句。&lt;/p>
&lt;pre>&lt;code>if (m === 3)
m = m + 1;
&lt;/code>&lt;/pre>
&lt;p>上面代码表示，只有在&lt;code>m&lt;/code>等于 3 时，才会将其值加上 1。&lt;/p>
&lt;p>这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在&lt;code>if&lt;/code>的条件判断之后，加上大括号，表示代码块（多个语句合并成一个语句）。&lt;/p>
&lt;pre>&lt;code>if (m === 3) {
m += 1;
}
&lt;/code>&lt;/pre>
&lt;p>建议总是在&lt;code>if&lt;/code>语句中使用大括号，因为这样方便插入语句。&lt;/p>
&lt;p>注意，&lt;code>if&lt;/code>后面的表达式之中，不要混淆赋值表达式（&lt;code>=&lt;/code>）、严格相等运算符（&lt;code>===&lt;/code>）和相等运算符（&lt;code>==&lt;/code>）。尤其是赋值表达式不具有比较作用。&lt;/p>
&lt;pre>&lt;code>var x = 1;
var y = 2;
if (x = y) {
console.log(x);
}
&lt;/code>&lt;/pre>
&lt;p>上面代码的原意是，当&lt;code>x&lt;/code>等于&lt;code>y&lt;/code>的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将&lt;code>y&lt;/code>赋值给变量&lt;code>x&lt;/code>，再判断变量&lt;code>x&lt;/code>的值（等于 2）的布尔值（结果为&lt;code>true&lt;/code>）。&lt;/p>
&lt;p>这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值。&lt;/p>
&lt;pre>&lt;code>if (x = 2) {
if (2 = x) {
&lt;/code>&lt;/pre>
&lt;p>至于为什么优先采用“严格相等运算符”（&lt;code>===&lt;/code>），而不是“相等运算符”（&lt;code>==&lt;/code>），请参考《运算符》章节。&lt;/p>
&lt;h3 id="ifelse-结构-ifelse-e7bb93e69e84">if&amp;hellip;else 结构 &lt;a href="#ifelse-%E7%BB%93%E6%9E%84">#&lt;/a>&lt;/h3>
&lt;p>&lt;code>if&lt;/code>代码块后面，还可以跟一个&lt;code>else&lt;/code>代码块，表示不满足条件时，所要执行的代码。&lt;/p>
&lt;pre>&lt;code>if (m === 3) {
} else {
}
&lt;/code>&lt;/pre>
&lt;p>上面代码判断变量&lt;code>m&lt;/code>是否等于 3，如果等于就执行&lt;code>if&lt;/code>代码块，否则执行&lt;code>else&lt;/code>代码块。&lt;/p>
&lt;p>对同一个变量进行多次判断时，多个&lt;code>if...else&lt;/code>语句可以连写在一起。&lt;/p>
&lt;pre>&lt;code>if (m === 0) {
} else if (m === 1) {
} else if (m === 2) {
} else {
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>else&lt;/code>代码块总是与离自己最近的那个&lt;code>if&lt;/code>语句配对。&lt;/p>
&lt;pre>&lt;code>var m = 1;
var n = 2;
if (m !== 1)
if (n === 2) console.log('hello');
else console.log('world');
&lt;/code>&lt;/pre>
&lt;p>上面代码不会有任何输出，&lt;code>else&lt;/code>代码块不会得到执行，因为它跟着的是最近的那个&lt;code>if&lt;/code>语句，相当于下面这样。&lt;/p>
&lt;pre>&lt;code>if (m !== 1) {
if (n === 2) {
console.log('hello');
} else {
console.log('world');
}
}
&lt;/code>&lt;/pre>
&lt;p>如果想让&lt;code>else&lt;/code>代码块跟随最上面的那个&lt;code>if&lt;/code>语句，就要改变大括号的位置。&lt;/p>
&lt;pre>&lt;code>if (m !== 1) {
if (n === 2) {
console.log('hello');
}
} else {
console.log('world');
}
&lt;/code>&lt;/pre>
&lt;h3 id="switch-结构-switch-e7bb93e69e84">switch 结构 &lt;a href="#switch-%E7%BB%93%E6%9E%84">#&lt;/a>&lt;/h3>
&lt;p>多个&lt;code>if...else&lt;/code>连在一起使用的时候，可以转为使用更方便的&lt;code>switch&lt;/code>结构。&lt;/p>
&lt;pre>&lt;code>switch (fruit) {
case &amp;quot;banana&amp;quot;:
break;
case &amp;quot;apple&amp;quot;:
break;
default:
}
&lt;/code>&lt;/pre>
&lt;p>上面代码根据变量&lt;code>fruit&lt;/code>的值，选择执行相应的&lt;code>case&lt;/code>。如果所有&lt;code>case&lt;/code>都不符合，则执行最后的&lt;code>default&lt;/code>部分。需要注意的是，每个&lt;code>case&lt;/code>代码块内部的&lt;code>break&lt;/code>语句不能少，否则会接下去执行下一个&lt;code>case&lt;/code>代码块，而不是跳出&lt;code>switch&lt;/code>结构。&lt;/p>
&lt;pre>&lt;code>var x = 1;
switch (x) {
case 1:
console.log('x 等于1');
case 2:
console.log('x 等于2');
default:
console.log('x 等于其他值');
}
&lt;/code>&lt;/pre>
&lt;p>上面代码中，&lt;code>case&lt;/code>代码块之中没有&lt;code>break&lt;/code>语句，导致不会跳出&lt;code>switch&lt;/code>结构，而会一直执行下去。正确的写法是像下面这样。&lt;/p>
&lt;pre>&lt;code>switch (x) {
case 1:
console.log('x 等于1');
break;
case 2:
console.log('x 等于2');
break;
default:
console.log('x 等于其他值');
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>switch&lt;/code>语句部分和&lt;code>case&lt;/code>语句部分，都可以使用表达式。&lt;/p>
&lt;pre>&lt;code>switch (1 + 3) {
case 2 + 2:
f();
break;
default:
neverHappens();
}
&lt;/code>&lt;/pre>
&lt;p>上面代码的&lt;code>default&lt;/code>部分，是永远不会执行到的。&lt;/p>
&lt;p>需要注意的是，&lt;code>switch&lt;/code>语句后面的表达式，与&lt;code>case&lt;/code>语句后面的表示式比较运行结果时，采用的是严格相等运算符（&lt;code>===&lt;/code>），而不是相等运算符（&lt;code>==&lt;/code>），这意味着比较时不会发生类型转换。&lt;/p>
&lt;pre>&lt;code>var x = 1;
switch (x) {
case true:
console.log('x 发生类型转换');
break;
default:
console.log('x 没有发生类型转换');
}
&lt;/code>&lt;/pre>
&lt;p>上面代码中，由于变量&lt;code>x&lt;/code>没有发生类型转换，所以不会执行&lt;code>case true&lt;/code>的情况。这表明，&lt;code>switch&lt;/code>语句内部采用的是“严格相等运算符”，详细解释请参考《运算符》一节。&lt;/p>
&lt;h3 id="三元运算符--e4b889e58583e8bf90e7ae97e7aca6-">三元运算符 ?: &lt;a href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6-">#&lt;/a>&lt;/h3>
&lt;p>JavaScript 还有一个三元运算符（即该运算符需要三个运算子）&lt;code>?:&lt;/code>，也可以用于逻辑判断。&lt;/p>
&lt;pre>&lt;code>(条件) ? 表达式1 : 表达式2
&lt;/code>&lt;/pre>
&lt;p>上面代码中，如果“条件”为&lt;code>true&lt;/code>，则返回“表达式 1”的值，否则返回“表达式 2”的值。&lt;/p>
&lt;pre>&lt;code>var even = (n % 2 === 0) ? true : false;
&lt;/code>&lt;/pre>
&lt;p>上面代码中，如果&lt;code>n&lt;/code>可以被 2 整除，则&lt;code>even&lt;/code>等于&lt;code>true&lt;/code>，否则等于&lt;code>false&lt;/code>。它等同于下面的形式。&lt;/p>
&lt;pre>&lt;code>var even;
if (n % 2 === 0) {
even = true;
} else {
even = false;
}
&lt;/code>&lt;/pre>
&lt;p>这个三元运算符可以被视为&lt;code>if...else...&lt;/code>的简写形式，因此可以用于多种场合。&lt;/p>
&lt;pre>&lt;code>var myVar;
console.log(
myVar ?
'myVar has a value' :
'myVar does not have a value'
)
&lt;/code>&lt;/pre>
&lt;p>上面代码利用三元运算符，输出相应的提示。&lt;/p>
&lt;pre>&lt;code>var msg = '数字' + n + '是' + (n % 2 === 0 ? '偶数' : '奇数');
&lt;/code>&lt;/pre>
&lt;p>上面代码利用三元运算符，在字符串之中插入不同的值。&lt;/p>
&lt;h2 id="循环语句-e5beaae78eafe8afade58fa5">循环语句 &lt;a href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5">#&lt;/a>&lt;/h2>
&lt;p>循环语句用于重复执行某个操作，它有多种形式。&lt;/p>
&lt;h3 id="while-循环-while-e5beaae78eaf">while 循环 &lt;a href="#while-%E5%BE%AA%E7%8E%AF">#&lt;/a>&lt;/h3>
&lt;p>&lt;code>While&lt;/code>语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。&lt;/p>
&lt;pre>&lt;code>while (条件)
语句;
while (条件) 语句;
&lt;/code>&lt;/pre>
&lt;p>&lt;code>while&lt;/code>语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。&lt;/p>
&lt;pre>&lt;code>while (条件) {
语句;
}
&lt;/code>&lt;/pre>
&lt;p>下面是&lt;code>while&lt;/code>语句的一个例子。&lt;/p>
&lt;pre>&lt;code>var i = 0;
while (i &amp;lt; 100) {
console.log('i 当前为：' + i);
i = i + 1;
}
&lt;/code>&lt;/pre>
&lt;p>上面的代码将循环 100 次，直到&lt;code>i&lt;/code>等于 100 为止。&lt;/p>
&lt;p>下面的例子是一个无限循环，因为循环条件总是为真。&lt;/p>
&lt;pre>&lt;code>while (true) {
console.log('Hello, world');
}
&lt;/code>&lt;/pre>
&lt;h3 id="for-循环-for-e5beaae78eaf">for 循环 &lt;a href="#for-%E5%BE%AA%E7%8E%AF">#&lt;/a>&lt;/h3>
&lt;p>&lt;code>for&lt;/code>语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。&lt;/p>
&lt;pre>&lt;code>for (初始化表达式; 条件; 递增表达式)
语句
for (初始化表达式; 条件; 递增表达式) {
语句
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>for&lt;/code>语句后面的括号里面，有三个表达式。&lt;/p>
&lt;ul>
&lt;li>初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。&lt;/li>
&lt;li>条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。&lt;/li>
&lt;li>递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。&lt;/li>
&lt;/ul>
&lt;p>下面是一个例子。&lt;/p>
&lt;pre>&lt;code>var x = 3;
for (var i = 0; i &amp;lt; x; i++) {
console.log(i);
}
&lt;/code>&lt;/pre>
&lt;p>上面代码中，初始化表达式是&lt;code>var i = 0&lt;/code>，即初始化一个变量&lt;code>i&lt;/code>；测试表达式是&lt;code>i &amp;lt; x&lt;/code>，即只要&lt;code>i&lt;/code>小于&lt;code>x&lt;/code>，就会执行循环；递增表达式是&lt;code>i++&lt;/code>，即每次循环结束后，&lt;code>i&lt;/code>增大 1。&lt;/p>
&lt;p>所有&lt;code>for&lt;/code>循环，都可以改写成&lt;code>while&lt;/code>循环。上面的例子改为&lt;code>while&lt;/code>循环，代码如下。&lt;/p>
&lt;pre>&lt;code>var x = 3;
var i = 0;
while (i &amp;lt; x) {
console.log(i);
i++;
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>for&lt;/code>语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。&lt;/p>
&lt;pre>&lt;code>for ( ; ; ){
console.log('Hello World');
}
&lt;/code>&lt;/pre>
&lt;p>上面代码省略了&lt;code>for&lt;/code>语句表达式的三个部分，结果就导致了一个无限循环。&lt;/p>
&lt;h3 id="dowhile-循环-dowhile-e5beaae78eaf">do&amp;hellip;while 循环 &lt;a href="#dowhile-%E5%BE%AA%E7%8E%AF">#&lt;/a>&lt;/h3>
&lt;p>&lt;code>do...while&lt;/code>循环与&lt;code>while&lt;/code>循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。&lt;/p>
&lt;pre>&lt;code>do
语句
while (条件);
do {
语句
} while (条件);
&lt;/code>&lt;/pre>
&lt;p>不管条件是否为真，&lt;code>do...while&lt;/code>循环至少运行一次，这是这种结构最大的特点。另外，&lt;code>while&lt;/code>语句后面的分号注意不要省略。&lt;/p>
&lt;p>下面是一个例子。&lt;/p>
&lt;pre>&lt;code>var x = 3;
var i = 0;
do {
console.log(i);
i++;
} while(i &amp;lt; x);
&lt;/code>&lt;/pre>
&lt;h3 id="break-语句和-continue-语句-break-e8afade58fa5e5928c-continue-e8afade58fa5">break 语句和 continue 语句 &lt;a href="#break-%E8%AF%AD%E5%8F%A5%E5%92%8C-continue-%E8%AF%AD%E5%8F%A5">#&lt;/a>&lt;/h3>
&lt;p>&lt;code>break&lt;/code>语句和&lt;code>continue&lt;/code>语句都具有跳转作用，可以让代码不按既有的顺序执行。&lt;/p>
&lt;p>&lt;code>break&lt;/code>语句用于跳出代码块或循环。&lt;/p>
&lt;pre>&lt;code>var i = 0;
while(i &amp;lt; 100) {
console.log('i 当前为：' + i);
i++;
if (i === 10) break;
}
&lt;/code>&lt;/pre>
&lt;p>上面代码只会执行 10 次循环，一旦&lt;code>i&lt;/code>等于 10，就会跳出循环。&lt;/p>
&lt;p>&lt;code>for&lt;/code>循环也可以使用&lt;code>break&lt;/code>语句跳出循环。&lt;/p>
&lt;pre>&lt;code>for (var i = 0; i &amp;lt; 5; i++) {
console.log(i);
if (i === 3)
break;
}
&lt;/code>&lt;/pre>
&lt;p>上面代码执行到&lt;code>i&lt;/code>等于 3，就会跳出循环。&lt;/p>
&lt;p>&lt;code>continue&lt;/code>语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。&lt;/p>
&lt;pre>&lt;code>var i = 0;
while (i &amp;lt; 100){
i++;
if (i % 2 === 0) continue;
console.log('i 当前为：' + i);
}
&lt;/code>&lt;/pre>
&lt;p>上面代码只有在&lt;code>i&lt;/code>为奇数时，才会输出&lt;code>i&lt;/code>的值。如果&lt;code>i&lt;/code>为偶数，则直接进入下一轮循环。&lt;/p>
&lt;p>如果存在多重循环，不带参数的&lt;code>break&lt;/code>语句和&lt;code>continue&lt;/code>语句都只针对最内层循环。&lt;/p>
&lt;h3 id="标签label-e6a087e7adbelabel">标签（label） &lt;a href="#%E6%A0%87%E7%AD%BElabel">#&lt;/a>&lt;/h3>
&lt;p>JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。&lt;/p>
&lt;pre>&lt;code>label:
语句
&lt;/code>&lt;/pre>
&lt;p>标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。&lt;/p>
&lt;p>标签通常与&lt;code>break&lt;/code>语句和&lt;code>continue&lt;/code>语句配合使用，跳出特定的循环。&lt;/p>
&lt;pre>&lt;code>top:
for (var i = 0; i &amp;lt; 3; i++){
for (var j = 0; j &amp;lt; 3; j++){
if (i === 1 &amp;amp;&amp;amp; j === 1) break top;
console.log('i=' + i + ', j=' + j);
}
}
&lt;/code>&lt;/pre>
&lt;p>上面代码为一个双重循环区块，&lt;code>break&lt;/code>命令后面加上了&lt;code>top&lt;/code>标签（注意，&lt;code>top&lt;/code>不用加引号），满足条件时，直接跳出双层循环。如果&lt;code>break&lt;/code>语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。&lt;/p>
&lt;p>标签也可以用于跳出代码块。&lt;/p>
&lt;pre>&lt;code>foo: {
console.log(1);
break foo;
console.log('本行不会输出');
}
console.log(2);
&lt;/code>&lt;/pre>
&lt;p>上面代码执行到&lt;code>break foo&lt;/code>，就会跳出区块。&lt;/p>
&lt;p>&lt;code>continue&lt;/code>语句也可以与标签配合使用。&lt;/p>
&lt;pre>&lt;code>top:
for (var i = 0; i &amp;lt; 3; i++){
for (var j = 0; j &amp;lt; 3; j++){
if (i === 1 &amp;amp;&amp;amp; j === 1) continue top;
console.log('i=' + i + ', j=' + j);
}
}
&lt;/code>&lt;/pre>
&lt;p>上面代码中，&lt;code>continue&lt;/code>命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果&lt;code>continue&lt;/code>语句后面不使用标签，则只能进入下一轮的内层循环。&lt;/p>
&lt;h2 id="参考链接-e58f82e88083e993bee68ea5">参考链接 &lt;a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">#&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>Axel Rauschmayer, &lt;a href="http://www.2ality.com/2011/10/javascript-overview.html">A quick overview of JavaScript&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: ECMAScript 包管理器</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ecmascript-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ecmascript-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;p>当我们使用包管理命令安装各种第三方库(依赖包)及其衍生物通常会保存在两类地方&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Locally(本地)&lt;/strong> # 这是默认的行为，安装的东西放在当前目录的 &lt;code>./node_modules/&lt;/code> 目录中
&lt;ul>
&lt;li>当我们想要在代码中使用 require() 或 import 导入模块时，通常安装在本地&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Globally(全局)&lt;/strong> # 使用 &lt;code>-g&lt;/code> 选项，将安装的东西放在 &lt;code>${PREFIX}/lib/node_modules/&lt;/code> 目录中；若安装的东西中具有可以在 CLI 执行的工具，则同时会在 &lt;code>${PREFIX}/bin/&lt;/code> 目录下生成指向原始文件的软链接，&lt;code>${PREFIX}/bin/&lt;/code> 目录通常都会加入到 &lt;code>${PATH}&lt;/code> 变量中。
&lt;ul>
&lt;li>当我们想要在命令行上运行安装的命令行工具，通常安装在全局&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>随着时代的发展，出现了 pnpm、(期待有更好的)等 工具，可以让我们将各种不同的项目的依赖放在同一个路径下进行统一管理。&lt;/p>
&lt;h1 id="npm">NPM&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.npmjs.com/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.npmjs.com/cli">官方文档，cli&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Node.js Package Manager(简称 NPM)&lt;/strong> 是 Node.js 自带的包管理工具，通常与 Node.js 一同安装，最初版本于 2010 年 1 月发行。NPM 本质是一个第三方模块，可以在 &lt;strong>${PREFIX}/lib/node_modules/npm/*&lt;/strong> 目录下找到 npm 的所有文件。&lt;/p>
&lt;blockquote>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>&lt;code>${PREFIX}&lt;/code> 指 &lt;strong>Node.js 的安装路径&lt;/strong>，Linux 中通常装在 /usr/local/nodejs 目录下，Windows 则随意了~~&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="npx">npx&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.ruanyifeng.com/blog/2019/02/npx.html">https://www.ruanyifeng.com/blog/2019/02/npx.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>npx 是 NPM 中自带的工具&lt;/p>
&lt;p>通过 &lt;code>npx serve&lt;/code> 命令(与 &lt;code>npm exec serve&lt;/code> 命令类似)可以启动一个 HTTP 服务，以访问当前目录下的所有静态资源文件。便于本地开发调试。&lt;/p>
&lt;h2 id="npm-关联文件与配置">npm 关联文件与配置&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.npmjs.com/cli/v8/configuring-npm/folders">官方文档，cli-配置 npm-文件夹&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.npmjs.com/cli/v8/using-npm/config">官方文档，cli-使用 npm-配置&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>当我们使用 &lt;code>npm install&lt;/code> 命令安装各种第三方库(依赖包)及其衍生物通常会保存在两类地方&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Locally(本地)&lt;/strong> # 这是默认的行为，安装的东西放在当前目录的 &lt;code>./node_modules/&lt;/code> 目录中
&lt;ul>
&lt;li>当我们想要在代码中使用 require() 或 import 导入模块时，通常安装在本地&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Globally(全局)&lt;/strong> # 使用 &lt;code>-g&lt;/code> 选项，将安装的东西放在 &lt;code>${PREFIX}/lib/node_modules/&lt;/code> 目录中；若安装的东西中具有可以在 CLI 执行的工具，则同时会在 &lt;code>${PREFIX}/bin/&lt;/code> 目录下生成指向原始文件的软链接，&lt;code>${PREFIX}/bin/&lt;/code> 目录通常都会加入到 &lt;code>${PATH}&lt;/code> 变量中。
&lt;ul>
&lt;li>当我们想要在命令行上运行安装的命令行工具，通常安装在全局&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>npm 从 命令行、环境变量、npmrc 文件、某些情况下从 package.json 文件 这些地方获取其配置信息&lt;/p>
&lt;p>npm 从以下地方获取其运行时配置&lt;/p>
&lt;ul>
&lt;li>&lt;strong>命令行标志&lt;/strong>&lt;/li>
&lt;li>&lt;strong>环境变量&lt;/strong>&lt;/li>
&lt;li>&lt;strong>npmrc 文件&lt;/strong> # npm 从以下几个地方依次读取 nmrc 文件
&lt;ul>
&lt;li>&lt;strong>/PATH/TO/NPM/npmrc&lt;/strong> # npm 内置的配置文件&lt;/li>
&lt;li>&lt;strong>${PREFIX}/etc/npmrc&lt;/strong> # 全局配置文件，可以通过 &lt;code>--globalconfig&lt;/code> 命令行选项或 &lt;code>${NPM_CONFIG_GLOBALCONFIG}&lt;/code> 环境变量改变其值&lt;/li>
&lt;li>&lt;strong>~/.npmrc&lt;/strong> # 用户&lt;/li>
&lt;li>配置文件，可以通过 &lt;code>--userconfig&lt;/code> 命令行选项或 &lt;code>${NPM_CONFIG_USERCONFIG}&lt;/code> 环境变量改变其值&lt;/li>
&lt;li>&lt;strong>/PATH/TO/MY/PROJECT/.npmrc&lt;/strong> # 每个项目自己的配置&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>**${PREFIX}/lib/node_modules/npm/* **# npm 作为一个第三方模块，跟随 Node.js 一起安装，被放在该目录下。
**${PREFIX}/bin* **# npm 安装的各种依赖包中若包含命令行工具，则会在此目录创建软链接。该目录通常都会加入到 &lt;code>${PATH}&lt;/code> 变量中。&lt;/p>
&lt;h3 id="配置文件详解">配置文件详解&lt;/h3>
&lt;p>所有可供配置的信息可从 &lt;a href="https://docs.npmjs.com/cli/v8/using-npm/config#config-settings">https://docs.npmjs.com/cli/v8/using-npm/config#config-settings&lt;/a> 查看&lt;/p>
&lt;h1 id="pnpm">PNPM&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/pnpm/pnpm">GitHub 项目，pnpm/pnpm&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pnpm.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://juejin.cn/post/7047556067877716004">稀土掘金，pnpm 对比 npm/yarn 好在哪里&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>当使用 npm 或 Yarn 时，如果你有 100 个项目使用了某个依赖（dependency），就会有 100 份该依赖的副本保存在硬盘上。 而在使用 pnpm 时，依赖会被存储在内容可寻址的存储中，所以：&lt;/p>
&lt;ol>
&lt;li>如果你用到了某依赖项的不同版本，只会将不同版本间有差异的文件添加到仓库。 例如，如果某个包有 100 个文件，而它的新版本只改变了其中 1 个文件。那么 pnpm update 时只会向存储中心额外添加 1 个新文件，而不会因为仅仅一个文件的改变复制整新版本包的内容。&lt;/li>
&lt;li>所有文件都会存储在硬盘上的某一位置。 当软件包被被安装时，包里的文件会硬链接到这一位置，而不会占用额外的磁盘空间。 这允许你跨项目地共享同一版本的依赖。&lt;/li>
&lt;/ol>
&lt;p>因此，您在磁盘上节省了大量空间，这与项目和依赖项的数量成正比，并且安装速度要快得多！&lt;/p>
&lt;h2 id="安装-pnpm">安装 pnpm&lt;/h2>
&lt;p>使用 &lt;code>corepack enable&lt;/code> 指令启用 pnpm。
设置包的存储路径：&lt;/p>
&lt;ul>
&lt;li>Windows：&lt;code>pnpm config set store-dir D:\Projects\.pnpm-store&lt;/code>&lt;/li>
&lt;li>Linux：&lt;code>pnpm config set store-dir /mnt/d/Projects/.pnpm-store&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>配置镜像源 &lt;code>pnpm config set registry=&amp;quot;https://registry.npmmirror.com&amp;quot;&lt;/code>&lt;/p>
&lt;p>若 Windows 无法执行 pnpm，报错：&lt;code>pnpm : 无法加载文件 D:\Tools\nodejs\pnpm.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。&lt;/code>&lt;/p>
&lt;ul>
&lt;li>此时需要在 PowerShell 中执行 &lt;code>Set-ExecutionPolicy -Scope CurrentUser RemoteSigned&lt;/code> 指令。详见&lt;a href="https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7.2">微软官网解释&lt;/a>。
&lt;ul>
&lt;li>其中 &lt;code>-Scope CurrentUser&lt;/code> 是指针对当前用户的操作，若使用管理员运行 VSCode 或 PowerShell，则不用加这个选项。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="更新">更新&lt;/h3>
&lt;p>corepack prepare &lt;a href="mailto:pnpm@7.14.1">pnpm@7.14.1&lt;/a> &amp;ndash;activate&lt;/p>
&lt;h2 id="pnpm-关键文件与配置">pnpm 关键文件与配置&lt;/h2>
&lt;p>&lt;strong>/PATH/TO/.pnpm-store&lt;/strong> # 存放各项目依赖的目录&lt;/p>
&lt;h1 id="npm-与-pnpm-syntax语法">npm 与 pnpm Syntax(语法)&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考-1">参考：&lt;/h2>
&lt;/blockquote>
&lt;p>通常，适用于 npm 的选项，也适用于 pnpm&lt;/p>
&lt;p>&lt;strong>npm [OPTIONS] COMMAND [OPTIONS]&lt;/strong>&lt;/p>
&lt;p>&lt;strong>OPTIONS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-g, &amp;ndash;global&lt;/strong> # 指定命令作用范围为全局。默认情况下 npm 的所有子命令作用范围是当前目录&lt;/li>
&lt;/ul>
&lt;h2 id="npm-config">npm config&lt;/h2>
&lt;p>npm config 用来管理 npm 的配置文件，i.e.npmrc 文件。&lt;/p>
&lt;h3 id="syntax语法">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>npm config set &lt;!-- raw HTML omitted -->=&lt;!-- raw HTML omitted --> [&lt;!-- raw HTML omitted -->=&lt;!-- raw HTML omitted --> &amp;hellip;]&lt;/strong>
&lt;strong>npm config get [&lt;!-- raw HTML omitted --> [&lt;!-- raw HTML omitted --> &amp;hellip;]]&lt;/strong>
&lt;strong>npm config delete &lt;!-- raw HTML omitted --> [&lt;!-- raw HTML omitted --> &amp;hellip;]&lt;/strong>
&lt;strong>npm config list [&amp;ndash;json]&lt;/strong>
&lt;strong>npm config edit&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-g, &amp;ndash;global&lt;/strong> # 对全局配置文件(${PREFIX}/etc/npmrc) 执行操作&lt;/li>
&lt;/ul>
&lt;h3 id="example">EXAMPLE&lt;/h3>
&lt;ul>
&lt;li>配置镜像源为淘宝的
&lt;ul>
&lt;li>&lt;code>npm config set registry=&amp;quot;https://registry.npmmirror.com&amp;quot;&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="npm-exec">npm exec&lt;/h2>
&lt;p>从本地或远程 npm 包运行命令&lt;/p>
&lt;h3 id="syntax语法-1">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>npm exec &amp;ndash; &lt;!-- raw HTML omitted -->[@&lt;!-- raw HTML omitted -->] [args&amp;hellip;]&lt;/strong>
&lt;strong>npm exec &amp;ndash;package=&lt;!-- raw HTML omitted -->[@&lt;!-- raw HTML omitted -->] &amp;ndash; &lt;!-- raw HTML omitted --> [args&amp;hellip;]&lt;/strong>
&lt;strong>npm exec -c &amp;lsquo;&lt;!-- raw HTML omitted --> [args&amp;hellip;]&amp;rsquo;&lt;/strong>
&lt;strong>npm exec &amp;ndash;package=foo -c &amp;lsquo;&lt;!-- raw HTML omitted --> [args&amp;hellip;]&amp;rsquo;&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h2 id="npm-install">npm install&lt;/h2>
&lt;h2 id="npm-init">npm init&lt;/h2>
&lt;p>创建一个 package.json 文件。用来初始化一个项目&lt;/p>
&lt;h3 id="syntax语法-2">Syntax(语法)&lt;/h3>
&lt;p>&lt;strong>npm init [&amp;ndash;force|-f|&amp;ndash;yes|-y|&amp;ndash;scope]&lt;/strong>
&lt;strong>npm init &amp;lt;@scope&amp;gt; (same as &lt;code>npx &amp;lt;@scope&amp;gt;/create&lt;/code>)&lt;/strong>
&lt;strong>npm init [&amp;lt;@scope&amp;gt;/]&lt;!-- raw HTML omitted --> (same as &lt;code>npx [&amp;lt;@scope&amp;gt;/]create-&amp;lt;name&amp;gt;&lt;/code>)&lt;/strong>&lt;/p>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h2 id="npm-list">npm list&lt;/h2>
&lt;p>列出所有已经安装的包。默认列出当前项目中已安装的包，通常检查如下目录：&lt;code>node_modules/&lt;/code>&lt;/p>
&lt;h2 id="npm-update">npm update&lt;/h2>
&lt;p>更新已安装的包&lt;/p>
&lt;h1 id="yarn">Yarn&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://yarnpkg.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>管理 Yarn 的首选方式是通过 &lt;a href="https://nodejs.org/dist/latest/docs/api/corepack.html">Corepack&lt;/a>，这是从 16.10 开始随所有 Node.js 版本一起提供的新二进制文件。它充当我们和 Yarn 之间的中介，让我们在多个项目中使用不同的包管理器版本，而无需再签入 Yarn 二进制文件。&lt;/p>
&lt;p>Node.js &amp;gt;=16.10
Corepack 默认包含在所有 Node.js 安装中，但目前是可选的。要启用它，请运行以下命令：
&lt;code>corepack enable&lt;/code>&lt;/p>
&lt;p>Node.js &amp;lt;16.10
在 16.10 之前的版本中，Node.js 不包含 Corepack；为了解决这个问题，运行：
&lt;code>npm i -g corepack&lt;/code>&lt;/p>
&lt;p>配置镜像源以加速下载各种依赖包&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yarn config set registry https://registry.npmmirror.com -g
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置 $PATH 以便可以直接执行通过 yarn 安装的各种工具&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>$PATH:~/.config/yarn/global/node_modules/.bin
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="yarn-关联文件与配置">Yarn 关联文件与配置&lt;/h2>
&lt;p>&lt;strong>~/.yarnrc&lt;/strong> # 配置文件
&lt;strong>~/.config/yarn/*&lt;/strong> #&lt;/p>
&lt;h1 id="yarn-syntax语法">yarn Syntax(语法)&lt;/h1></description></item><item><title>Docs: ECMAScript 第三方库</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</guid><description>
&lt;h1 id="postman">Postman&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 将响应体解析为 JSON 格式
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">respBodyJSON&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">JSON&lt;/span>.&lt;span style="color:#a6e22e">parse&lt;/span>(&lt;span style="color:#a6e22e">responseBody&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">respBodyJSON&lt;/span>.&lt;span style="color:#a6e22e">data&lt;/span>.&lt;span style="color:#a6e22e">forEach&lt;/span>(&lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">item&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">item&lt;/span>.&lt;span style="color:#a6e22e">title&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="axios">Axios&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/axios/axios">GitHub 项目，axios/axios&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://axios-http.com/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Axios 是用于浏览器和 node.js 的基于 Promise 的 HTTP 客户端&lt;/p>
&lt;h1 id="element-plus">Element Plus&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/element-plus/element-plus">GitHub 项目，element-plus/element-plus&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://element-plus.org/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Element Plus 是一个基于 Vue3 的 UI 框架。它是 Element UI 基于 Vue3 的重构版本。&lt;/p></description></item><item><title>Docs: ECMAScript 工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1></description></item><item><title>Docs: ECMAScript 环境安装与使用</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;p>有两种运行时环境可以运行 ECMAScript 代码(Javascript、Typescript)&lt;/p>
&lt;ul>
&lt;li>**Browser **# 浏览器就是 ECMAScript 的运行时环境。&lt;/li>
&lt;li>&lt;strong>Node.js&lt;/strong> # 在服务器或 PC 上安装 Node.js 环境以运行 ECMAScript 代码&lt;/li>
&lt;li>&lt;strong>Deno&lt;/strong> # &lt;a href="https://github.com/denoland/deno">GtiHub 项目，denoland/deno&lt;/a>。据说要替代 Node.js，很尴尬的是。。。早期 18 年的 issue 中被各种国人无意义灌水&lt;/li>
&lt;li>&lt;strong>Bun&lt;/strong> # &lt;a href="https://github.com/oven-sh/bun">GtiHub 项目，oven-sh/bun&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>但是这两者可以提供的 API 能力各不相同&lt;/p>
&lt;ul>
&lt;li>Browser 可以提供的 dockument、window 和其他关于 DOM 或其他 Web 平台 API 的对象。&lt;/li>
&lt;li>Node.js 则可以提供很多操作系统相关的 API，比如文件的读写、进程管理、网络通信等等。&lt;/li>
&lt;/ul>
&lt;p>Node.js 与 Browser 都是基于 Chrome V8 引擎的 ECMAScript 运行时环境&lt;/p>
&lt;p>你也许会想，直接在我的硬盘上创建好 HTML 和 JavaScript 文件，然后用浏览器打开，不就可以看到效果了吗？&lt;/p>
&lt;p>这种方式运行部分 JavaScript 代码没有问题，但由于浏览器的安全限制，以 file:// 开头的地址无法执行如联网等 JavaScript 代码，最终，你还是需要架设一个 Web 服务器，然后以 http:// 开头的地址来正常执行所有 JavaScript 代码。&lt;/p>
&lt;p>所以，想要运行 JavaScript 编写的静态文件，通常都需要一个可以提供 HTTP 服务的程序，以便响应客户端的请求返回这些静态文件。通常在生产环境中，我们都会将静态资源文件放到 Nginx 的目录中，由 Nginx 为客户端提供 HTTP 服务。&lt;/p>
&lt;p>而本地测试时，我们通过 npm 与 yarn 工具即可安装一个简易的 HTTP 服务，这个 HTTP 服务都是由 JS 代码写的，必须要保证本地有 Node.js 环境，即可启动一个 HTTP 服务&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Npm 安装 http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># npm install http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Yarn 安装 http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># yarn add http-server&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>http-server 来源于 &lt;a href="https://github.com/http-party/http-server">GitHub 项目，http-party/http-server&lt;/a>&lt;/p>
&lt;p>通过 &lt;code>npm exec serve&lt;/code> 命令将会安装另一个名为 serve 的库以运行 HTTP 服务，默认在 3000 端口上启动 HTTP 服务，通过浏览器访问 localhost:3000 即可获取到所有自己编写的静态文件，便于让开发人员在本地调试。&lt;/p>
&lt;h2 id="重点运行具有-module模块-功能的静态资源">(重点)运行具有 Module(模块) 功能的静态资源&lt;/h2>
&lt;p>从《ECMAScript 模块》章节可以看到，当我们使用 &lt;code>import name from './one.js'&lt;/code> 导入的模块是一个文件时，那么这个文件将会被响应给浏览器，如果使用 &lt;code>import name from 'one'&lt;/code> 导入的模块是一组文件时，此时浏览器无法直接识别，将会产生报错。因为浏览器想要执行这一组文件需要发起很多次的请求将所有文件都加载到本地，这其中的路由路径将是不可控的。&lt;/p>
&lt;p>所以，此时我们则需要想办法将这一组文件变为一个文件响应给浏览器以便加载代码。这个转换的操作，我们可以使用打包工具(i.e.Webpack、Vite 等等) 将源代码&lt;strong>打包编译&lt;/strong>成新的静态文件即可。&lt;/p>
&lt;p>后面的逻辑，与基本运行 ECMAScript 代码的行为就是一样的了。&lt;/p>
&lt;h2 id="使用-vite-运行-ecmascript-代码">使用 Vite 运行 ECMAScript 代码&lt;/h2>
&lt;p>npm、yarn 的打包后运行代码的速度非常缓慢，才是推荐使用 Vite 工具启动 HTTP 服务并运行 JS/TS 代码，详见：[《Vite》](✏IT 学习笔记/👨‍💻2.编程/高级编程语言/ECMAScript/ECMAScript%20 工具/Vite.md 工具/Vite.md) 章节&lt;/p>
&lt;h2 id="运行-typesript">运行 TypeSript&lt;/h2>
&lt;p>Node.js 和 浏览器都无法直接运行 TypeScript 代码，这是因为 TS 的代码需要先转换为 JS 代码才可以运行。此时就需要一种工具，先转换再运行，或者直接转换运行一体。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>tsc&lt;/strong> # 将 TS 代码转换为 JS 代码。&lt;code>npm install -g typescript&lt;/code>&lt;/li>
&lt;li>&lt;strong>ts-node&lt;/strong> # 可以直接转换并运行 TS 代码，&lt;code>npm install -g ts-node&lt;/code> 安装即可&lt;/li>
&lt;/ul>
&lt;h1 id="nodejs">NodeJS&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://nodejs.org/en/">org 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://nodejs.dev/">dev 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://nodejs.cn/">dev 官网中文翻译&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Node.js">Wiki,Node.js&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Node.js 是基于 Chrome V8 引擎的 ECMAScript 运行时环境，由 RyanDahl 于 2009 年 5 月 27 日发布。转年(i.e.2010 年 1 月)，为 Node.js 环境引入了一个名为 npm 的包管理器。包管理器使程序员更容易发布和共享 Node.js 的源代码，旨在简化包的安装、更新、卸载。&lt;/p>
&lt;p>Browser 和 Node.js 都是 ECMAScript 的运行时环境，但是这两者可以提供的 API 能力各不相同&lt;/p>
&lt;ul>
&lt;li>Browser 可以提供的 dockument、window 和其他关于 DOM 或其他 Web 平台 API 的对象。&lt;/li>
&lt;li>Node.js 则可以提供很多操作系统相关的 API，比如文件的读写、进程管理、网络通信等等。&lt;/li>
&lt;/ul>
&lt;p>通过 Node.js，可以让我们使用一种语言编写前端与后端。我们甚至可以通过 npm 与 yarn 安装第三方库后，使用 Node.js 在本地监听端口并响应给客户端静态资源文件。&lt;/p>
&lt;h2 id="安装-nodejs">安装 NodeJS&lt;/h2>
&lt;h3 id="linux">Linux&lt;/h3>
&lt;p>从&lt;a href="https://nodejs.org/zh-cn/download/">官网&lt;/a>下载 Linux 版的 &lt;code>.tar.xg&lt;/code> 包，并解压&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export NodejsVersion&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;v16.15.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://nodejs.org/dist/&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>/node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64.tar.xz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar -xvf node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64.tar.xz -C /usr/local/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mv /usr/local/node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64 /usr/local/nodejs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置环境变量&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo tee /etc/profile.d/nodejs.sh &amp;gt; /dev/null &amp;lt;&amp;lt;-&lt;span style="color:#e6db74">&amp;#34;EOF&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>$PATH:/usr/local/nodejs/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>EOF
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="windows">Windows&lt;/h3>
&lt;h2 id="nvm">NVM&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/nvm-sh/nvm">GitHub 项目，nvm-sh/nvm&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Node Version Manager(Node.js 版本管理器，简称 NVM)&lt;/strong>&lt;/p>
&lt;h2 id="nodejs-配置与关联文件">Node.js 配置与关联文件&lt;/h2>
&lt;p>&lt;strong>${PREFIX}/*&lt;/strong> # $PREFIX 指 Node.js 的安装路径，个人通常装在 /usr/local/nodejs 目录下&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./bin/*&lt;/strong> # 第三方模块可用的工具以及 node 二进制文件保存路径
&lt;ul>
&lt;li>这个目录下的第三方模块工具通常都是一个软链接，指向 ${PREFIX}/lib/node_modeuls/XX 目录下的某个目录中文件，具体路径由模块自身定义&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>./lib/node_modules/*&lt;/strong> # 通过 npm、yarn 等包管理器安装&lt;strong>全局&lt;/strong>的第三方依赖包的保存路径。通常 Node.js 默认自带 corepack、npm 这两个包
&lt;ul>
&lt;li>&lt;strong>./corepack/*&lt;/strong> # corepack 工具&lt;/li>
&lt;li>&lt;strong>./npm/*&lt;/strong> # npm 工具&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="初始化项目">初始化项目&lt;/h1>
&lt;p>由于现阶段都是各种框架学习，所以通过 npm 等包管理工具下载完框架后，会自动生成项目目录，这些目录是已经初始化完成的项目，包含了很多必要的文件，比如 package.json 等。&lt;/p>
&lt;p>随着学习深入，会逐步总结一个前端项目如果不使用框架从头构建的话会需要什么。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>public/&lt;/strong> 目录存放公共资源&lt;/li>
&lt;li>&lt;strong>src/&lt;/strong> # 所有代码都在 src/ 目录下&lt;/li>
&lt;li>&lt;strong>.eslintrc.cjs&lt;/strong> # ESLint 程序配置&lt;/li>
&lt;li>&lt;strong>.prettierc.json&lt;/strong> # Prettier 插件的配置&lt;/li>
&lt;li>&lt;strong>env.d.ts&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>index.html&lt;/strong> # 程序入口&lt;/li>
&lt;li>[&lt;strong>package.json&lt;/strong>](✏IT 学习笔记/👨‍💻2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/package.json.md 环境安装与使用/package.json.md) # 包管理器配置文件，比如 npm、pnpm 等&lt;/li>
&lt;li>&lt;strong>vite.config.ts&lt;/strong> # Vite 程序给项目打包时使用的配置&lt;/li>
&lt;li>&lt;strong>tsconfig.json&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>tsconfig.config.json&lt;/strong> # [TSConfig](✏IT 学习笔记/👨‍💻2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/TSConfig.md 环境安装与使用/TSConfig.md) 文件&lt;/li>
&lt;/ul>
&lt;h2 id="javascript-项目初始化">JavaScript 项目初始化&lt;/h2>
&lt;p>无&lt;/p>
&lt;h2 id="typescript-项目初始化">TypeScript 项目初始化&lt;/h2>
&lt;p>使用 &lt;code>npm install -g typescript&lt;/code> 安装 tsc 命令。&lt;/p>
&lt;p>使用 &lt;code>tsc init&lt;/code> 命令将会生成 [TSConfig](✏IT 学习笔记/👨‍💻2.编程/高级编程语言/ECMAScript/ECMAScript%20 环境安装与使用/TSConfig.md 环境安装与使用/TSConfig.md) 文件。&lt;/p>
&lt;h1 id="编译与打包">编译与打包&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/webpack/webpack">GitHub 项目，webpack/webpack&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/rollup/rollup">GitHub 项目，rollup/rollup&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>大型项目通常都要打包，打包工具有很多：&lt;/p>
&lt;ul>
&lt;li>Webpack&lt;/li>
&lt;li>Rollup&lt;/li>
&lt;li>Vite&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;等等&lt;/li>
&lt;/ul>
&lt;h1 id="常见问题">常见问题&lt;/h1>
&lt;h2 id="nodejs-无法使用-es6-语法问题">Node.js 无法使用 ES6 语法问题&lt;/h2>
&lt;p>无法使用 import 关键字导入模块。参考 &lt;a href="https://nodejs.org/docs/latest-v16.x/api/esm.html#enabling">https://nodejs.org/docs/latest-v16.x/api/esm.html#enabling&lt;/a>，在 package.json 文件中设置 &lt;code>&amp;quot;type&amp;quot;: &amp;quot;module&amp;quot;&lt;/code> 或者使用 &lt;code>--input-type=module&lt;/code> 命令行参数以告诉 Node.js 使用 ECMAScript 模块加载器。默认情况下，Node.js 使用 CommonJS 模块加载器。&lt;/p></description></item><item><title>Docs: ECMAScript 模块与包</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ecmascript-%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/ecmascript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ecmascript-%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">MDN-参考，JavaScript-JavaScript 指南-JavaScript 模块&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wangdoc.com/es6/module.html">网道，ES6 教程-Module 的语法&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhangxinxu.com/wordpress/2018/08/browser-native-es6-export-import-module/">https://www.zhangxinxu.com/wordpress/2018/08/browser-native-es6-export-import-module/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>历史上，JavaScript 一直没有 Module(模块) 体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的 require、Python 的 import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。&lt;/p>
&lt;p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 2009 年 1 月发起的 CommonJS 和 AMD 两种，前者用于服务器，后者用于浏览器。&lt;/p>
&lt;blockquote>
&lt;p>2013 年 5 月，npm 的作者宣布 Node.js 已经废弃 CommonJS，详见 &lt;a href="https://github.com/nodejs/node-v0.x-archive/issues/5132#issuecomment-15432598">GitHub issue-5132，nodejs/node-v0.x-archive&lt;/a> &amp;gt; &lt;a href="https://en.wikipedia.org/wiki/Asynchronous_module_definition">Wiki,Asynchronous_module_definition&lt;/a>(异步模块定义，简称 AMD)&lt;/p>
&lt;/blockquote>
&lt;p>比如，CommonJS 模块就是对象，输入时必须查找对象属性。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// CommonJS 标准
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> { &lt;span style="color:#a6e22e">stat&lt;/span>, &lt;span style="color:#a6e22e">exists&lt;/span>, &lt;span style="color:#a6e22e">readfile&lt;/span> } &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">require&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;fs&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 等同于 js 代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">_fs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">require&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;fs&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">stat&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">_fs&lt;/span>.&lt;span style="color:#a6e22e">stat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">exists&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">_fs&lt;/span>.&lt;span style="color:#a6e22e">exists&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">readfile&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">_fs&lt;/span>.&lt;span style="color:#a6e22e">readfile&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面代码的实质是整体加载 fs 模块（即加载 fs 的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。&lt;/p>
&lt;h2 id="es6-module">ES6 Module&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://beginor.github.io/2021/08/16/using-es-modules-in-borwser-with-importmaps.html">https://beginor.github.io/2021/08/16/using-es-modules-in-borwser-with-importmaps.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>ES6 Module(ES6 模块，简称 ESM)&lt;/strong>，ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。这种模块功能与 ES6 一起发布于 2015 年&lt;/p>
&lt;p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。&lt;/p>
&lt;p>通常来说，&lt;strong>一个模块指的一组文件的合集&lt;/strong>，只不过在通过编译工具编译后，将合并成一个文件。&lt;/p>
&lt;p>ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ES6 模块
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">import&lt;/span> { &lt;span style="color:#a6e22e">stat&lt;/span>, &lt;span style="color:#a6e22e">exists&lt;/span>, &lt;span style="color:#a6e22e">readFile&lt;/span> } &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面代码的实质是从 fs 模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。&lt;/p>
&lt;blockquote>
&lt;p>只支持相对路径或者绝对路径下的 ES 模块 (./, ../, /, http://, https://) ， 同时也受服务器跨域请求策略、 HTTPS 策略的约束。&lt;/p>
&lt;/blockquote>
&lt;p>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。&lt;/p>
&lt;p>除了静态加载带来的各种好处，ES6 模块还有以下好处。&lt;/p>
&lt;ul>
&lt;li>不再需要 UMD 模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。&lt;/li>
&lt;li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者 navigator 对象的属性。&lt;/li>
&lt;li>不再需要对象作为命名空间（比如 Math 对象），未来这些功能可以通过模块提供。&lt;/li>
&lt;/ul>
&lt;h2 id="import-maps">Import maps&lt;/h2>
&lt;p>&lt;a href="https://beginor.github.io/2021/08/16/using-es-modules-in-borwser-with-importmaps.html">https://beginor.github.io/2021/08/16/using-es-modules-in-borwser-with-importmaps.html&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">script&lt;/span> &lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;importmap&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;imports&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;vue&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;https://unpkg.com/vue@3/dist/vue.esm-browser.js&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">script&lt;/span> &lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;module&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">import&lt;/span> { &lt;span style="color:#a6e22e">createApp&lt;/span> } &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;vue&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="模块的加载方式">模块的加载方式&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://stackoverflow.com/questions/47403478/es6-modules-in-local-files-the-server-responded-with-a-non-javascript-mime-typ">https://stackoverflow.com/questions/47403478/es6-modules-in-local-files-the-server-responded-with-a-non-javascript-mime-typ&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://localcoder.org/es6-modules-in-local-files-the-server-responded-with-a-non-javascript-mime-typ">https://localcoder.org/es6-modules-in-local-files-the-server-responded-with-a-non-javascript-mime-typ&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://axellarsson.com/blog/expected-javascript-module-script-server-response-mimetype-text-html/">https://axellarsson.com/blog/expected-javascript-module-script-server-response-mimetype-text-html/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 Node.js 环境和 Browser 环境中加载 ESM 的方式不太一样&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Node.js&lt;/strong> # 可以使用模块名称。从根目录下的 node_modules 中查找模块&lt;/li>
&lt;li>&lt;strong>Browser&lt;/strong> # 不可以使用模块名称。必须通过编译工具将模块编译成单一文件，并修改 import 指向单一文件，以便可以发起请求获取这个静态资源&lt;/li>
&lt;/ul>
&lt;h2 id="浏览器中使用-esm-的常见问题">浏览器中使用 ESM 的常见问题&lt;/h2>
&lt;p>使用 &lt;code>import * as Vue from 'vue'&lt;/code> 将会产生如下报错：
&lt;code>Failed to resolve module specifier &amp;quot;vue&amp;quot;. Relative references must start with either &amp;quot;/&amp;quot;, &amp;quot;./&amp;quot;, or &amp;quot;../&amp;quot;.&lt;/code>
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mm0ymr/1651724399014-d2052b6f-cd7c-4ec0-b6fc-b748bd5a11ed.png" alt="image.png">
接着修改为 &lt;code>import * as Vue from '../node_modules/vue'&lt;/code> 将会产生如下报错：
&lt;code>Failed to load module script: The server responded with a non-JavaScript MIME type of &amp;quot;text/html&amp;quot;. Strict MIME type checking is enforced for module scripts per HTML spec.&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mm0ymr/1651724430503-b62b86bd-4cc7-48b8-ac73-69fa62564ed5.png" alt="image.png" title="firefox">&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mm0ymr/1651724407422-526db251-775f-40d5-a25e-402791aa38cc.png" alt="image.png" title="chrome">
问题原因：
这个情况的原因是浏览器在处理 import 逻辑时导致的。浏览器在发现 import 语句时，将会请求 from 后面的静态文件，当 from 指定的是模块名称而不是模块文件的路径时时，浏览器无法发起请求，因为浏览器不知道如何获取到模块文件。&lt;/p>
&lt;p>解决方式：&lt;/p>
&lt;ul>
&lt;li>使用配置文件告诉 JavaScript 引擎如何从名为 XX 的模块中获取模块文件&lt;/li>
&lt;li>编译代码，js 代码被编译后，导入的模块的一组文件将会被打包、压缩为一个文件；并且 from 后面的模块名将被修改为模块文件的路径，即可在浏览器中运行&lt;/li>
&lt;/ul>
&lt;p>这几种解决方式通常都是通过编译工具实现的，比如 Webpack、Vite 等工具。&lt;/p></description></item><item><title>Docs: Event(事件)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/javascript-%E6%A0%87%E5%87%86%E5%BA%93/event%E4%BA%8B%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ecmascript/javascript-%E6%A0%87%E5%87%86%E5%BA%93/event%E4%BA%8B%E4%BB%B6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://wangdoc.com/javascript/events/index.html">网道，Javascript 教程-事件&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Event(事件)&lt;/strong> 的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件，&lt;/p>
&lt;p>事件语法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">elementObject&lt;/span>.&lt;span style="color:#a6e22e">onEventType&lt;/span>&lt;span style="color:#f92672">=&lt;/span>Function(){}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>elementObject&lt;/strong> # 元素对象，也就是事件源，通常是通过类似 &lt;code>getElementByID()&lt;/code>之类的方法获取到的 HTML 中的元素&lt;/li>
&lt;li>&lt;strong>onEventType&lt;/strong> # 以&lt;code>on&lt;/code>开头，后面跟一个事件名称&lt;/li>
&lt;li>&lt;strong>Function(){}&lt;/strong> # elementObject 触发 onEventType 时要执行的代码，也就是 HTML 中某一元素触发事件时要执行的操作&lt;/li>
&lt;/ul>
&lt;p>比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">divElement&lt;/span> &lt;span style="color:#f92672">=&lt;/span> document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;event&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// click 点击事件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">divElement&lt;/span>.&lt;span style="color:#a6e22e">onclick&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> () {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">divElement&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;元素，被点击了一下&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="事件类型">事件类型&lt;/h1>
&lt;h2 id="鼠标事件">鼠标事件&lt;/h2>
&lt;ul>
&lt;li>click # 鼠标单击&lt;/li>
&lt;li>dblclick # 鼠标双击&lt;/li>
&lt;li>contextmenu # 左键单击&lt;/li>
&lt;li>mousedown # 鼠标按下&lt;/li>
&lt;li>mouseup # 鼠标抬起&lt;/li>
&lt;li>mousemove # 鼠标移动&lt;/li>
&lt;li>mouseenter # 鼠标移入&lt;/li>
&lt;li>mouseleave # 鼠标移出&lt;/li>
&lt;li>&amp;hellip;&amp;hellip; 等等&lt;/li>
&lt;/ul>
&lt;h2 id="键盘事件">键盘事件&lt;/h2>
&lt;ul>
&lt;li>keydown # 键盘按下&lt;/li>
&lt;li>keyup # 键盘抬起&lt;/li>
&lt;li>keypress # 键盘输入&lt;/li>
&lt;li>&amp;hellip;&amp;hellip; 等等&lt;/li>
&lt;/ul>
&lt;h2 id="浏览器事件">浏览器事件&lt;/h2>
&lt;ul>
&lt;li>load # 加载完毕&lt;/li>
&lt;li>scroll # 滚动&lt;/li>
&lt;li>resize # 尺寸改变&lt;/li>
&lt;li>&amp;hellip;&amp;hellip; 等等&lt;/li>
&lt;/ul>
&lt;h2 id="触摸事件">触摸事件&lt;/h2>
&lt;ul>
&lt;li>touchstart # 触摸开始&lt;/li>
&lt;li>touchmove # 触摸移动&lt;/li>
&lt;li>touchend # 触摸结束&lt;/li>
&lt;li>&amp;hellip;&amp;hellip; 等等&lt;/li>
&lt;/ul>
&lt;h2 id="表单事件">表单事件&lt;/h2>
&lt;ul>
&lt;li>focus # 聚焦&lt;/li>
&lt;li>blue # 失焦&lt;/li>
&lt;li>change # 改变&lt;/li>
&lt;li>input # 输入&lt;/li>
&lt;li>submit # 提交&lt;/li>
&lt;li>reset # 重置&lt;/li>
&lt;li>&amp;hellip;&amp;hellip; 等等&lt;/li>
&lt;/ul>
&lt;h1 id="事件对象">事件对象&lt;/h1>
&lt;p>每个事件触发时，都会记录一组数据，这组数据是事件类型对象，事件对象数据中的数据包括该时间一系列属性信息，比如：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>type&lt;/strong> # 什么事件&lt;/li>
&lt;li>&lt;strong>target&lt;/strong> # 谁触发的&lt;/li>
&lt;li>如果是鼠标事件，那么还会记录
&lt;ul>
&lt;li>&lt;strong>x&lt;/strong> # 光标 x 坐标&lt;/li>
&lt;li>&lt;strong>y&lt;/strong> # 光标 y 坐标&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>等等&amp;hellip;&amp;hellip;&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>比如我们模拟一下鼠标点击事件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">divElement&lt;/span> &lt;span style="color:#f92672">=&lt;/span> document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;event&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// click 触发一个点击事件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">divElement&lt;/span>.&lt;span style="color:#a6e22e">onclick&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">prop&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 事件的属性
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">prop&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个鼠标点击事件具有如下属性：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nzci2k/1641961554049-e88a8221-0593-4b6e-be48-6a093e0d1b0a.png" alt="image.png">
这是一个 PointerEvent 类型的对象&lt;/p>
&lt;h2 id="鼠标事件对象">鼠标事件对象&lt;/h2>
&lt;p>坐标信息&lt;/p>
&lt;ul>
&lt;li>&lt;strong>offsetX 和 offsetY&lt;/strong> # 相对于触发事件元素的坐标
&lt;ul>
&lt;li>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nzci2k/1641961872393-217cf16a-78e5-449c-9e33-d91f52c6dd96.png" alt="image.png">&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**client 和 clientY **# 相对于浏览器可视窗口的坐标
&lt;ul>
&lt;li>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nzci2k/1641961917878-40b8b649-3846-4f31-81f1-9e98e407f320.png" alt="image.png">&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>pageX 和 pageY&lt;/strong> # 相对于页面文档流的坐标
&lt;ul>
&lt;li>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/nzci2k/1641961945785-c13cc660-5702-444f-b6a3-2d21a341341f.png" alt="image.png">&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="键盘事件对象">键盘事件对象&lt;/h2>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul></description></item><item><title>Docs: FIFO与FILO</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/fifo%E4%B8%8Efilo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/fifo%E4%B8%8Efilo/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)">Wiki,FIFO&lt;/a>(先进先出)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">Wiki,Heap(堆)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">Wiki,LIFO(后进先出) 与 Wiki,Stack(栈)&lt;/a> 两个概念被 Wiki 合并了&lt;/li>
&lt;li>知乎，&lt;a href="https://www.zhihu.com/question/438782731">https://www.zhihu.com/question/438782731&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>first in,first out(先进先出，简称 FIFO)&lt;/strong> 与 &lt;strong>last in,firtst out(后进先出，简称 LIFO)&lt;/strong> 在计算机科学中，是两种有组织得操作结构化数据的方法。很多时候，&lt;strong>FIFO 也称为 Stack(栈)&lt;/strong>，&lt;strong>LIFO 也称为 Queue(队列)&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>注意：也可以说是是两种抽象的数据类型。但是这里的抽象数据类型，并不是指编程语言中的抽象数据类型。而是一种设计理念、设计思路。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>FIFO
&lt;ul>
&lt;li>考虑火车票购票系统，我们假设系统同时只能处理 40 个买票请求。那么当系统在处理 40 个请求时，来了第 41 个请求，系统就需要把这个请求缓存起来。同样，在这一过程中如果来了第 42、第 43、……第 1000 个请求，系统也需要把这些请求缓存起来。&lt;/li>
&lt;li>当系统处理完毕一个请求后，有 39 个请求尚在处理，系统能够处理一个新的请求。于是系统就需要从自己的缓存里挑一个请求来处理。而此时缓存里有第 41 至第 1000 个请求，系统应该挑选哪一个请求来处理呢？按照&lt;strong>先到先得的朴素排队的想法&lt;/strong>，系统理应挑选并处理第 41 个请求。&lt;/li>
&lt;li>在这种情况下，如果将系统的缓存设计为 FIFO，就能够很方便地实现上述调度策略。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>LIFO
&lt;ul>
&lt;li>就好像你拿了十页论文，看完一页放桌子上一页，最后一页自然的就在最上面，也就是说你从桌子上拿到的第一张就是最后放在桌子上的一页。&lt;/li>
&lt;li>也可以用叠牌子类比，把盘子叠一摞，那么当需要拿盘子的时候，最后叠上去的盘子是被先拿到的。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: Function(函数)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/function%E5%87%BD%E6%95%B0/function%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/function%E5%87%BD%E6%95%B0/function%E5%87%BD%E6%95%B0/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Subroutine">Wiki,Subroutine(子程序)&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Function_(computer_science)">Wiki,Function&lt;/a> 概念被合并到 Subroutine 中&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Parameter_(computer_programming)">Wiki,Parameter(参数)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Evaluation_strategy">Wiki,Evaluation strategy(评估策略)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/33__rGbvEHUB7nXWPSvz8Q">公众号，码农的荒岛求生-函数调用时底层发生了什么？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在计算机编程中，&lt;strong>Subroutine(子程序)&lt;/strong> 是执行特定任务的程序指令序列，打包为一个单元。然后，该单元可用于应执行特定任务的程序中。&lt;/p>
&lt;p>子程序可以在程序中定义，也可以在可以被许多程序使用的库中单独定义。在不同的编程语言中，子例程可以称为 &lt;strong>Routine(例程)&lt;/strong>、&lt;strong>Subprogram(子程序)&lt;/strong>、&lt;strong>Function(函数)&lt;/strong>、&lt;strong>Method(方法)&lt;/strong> 或 &lt;strong>Procedure(过程)&lt;/strong>。从技术上讲，这些术语都有不同的定义。有时会使用通用的总称 &lt;strong>Callable Unit(可调用单元)&lt;/strong>。&lt;/p>
&lt;h1 id="function-call函数调用">Function call(函数调用)&lt;/h1>
&lt;h2 id="parameter参数">Parameter(参数)&lt;/h2>
&lt;p>在计算机编程中，&lt;strong>Parameter(参数)&lt;/strong> 是函数中使用的一种&lt;strong>特殊变量&lt;/strong>，用于在引用函数时，提供给函数的输入数据。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>actual parameter(实际参数，简称 实参)&lt;/strong> # 一般用 arguments 表示，在调用函数时使用实参&lt;/li>
&lt;li>&lt;strong>formal parameter(形式参数，简称 形参)&lt;/strong> # 一般用 parameter 表示，在定义函数时使用形参&lt;/li>
&lt;/ul>
&lt;p>如何将 Arguments 的值传递给子程序的 Parameters 是由编程语言的 &lt;strong>Evaluation strategy(评估策略)&lt;/strong> 决定的。每次调用子程序时，都会评估本次调用的 Arguments，并将评估结果分配给相应的 Parameters。这种分配机制，称为 &lt;strong>Argument passing(参数传递)&lt;/strong>。&lt;/p>
&lt;p>例如：
现在定义一个名为 &lt;code>add&lt;/code> 的子程序：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>def &lt;span style="color:#a6e22e">add&lt;/span>(x, y){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x &lt;span style="color:#f92672">+&lt;/span> y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的 x 和 y 是 &lt;strong>形式参数&lt;/strong>&lt;/p>
&lt;p>如果要引用这个子程序：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的 2 和 3 是&lt;strong>实际参数&lt;/strong>。&lt;/p>
&lt;p>所以，就跟参数的名字一样，形式参数就是形式上的，没有一个具体的数据，而实际参数之所以称为实际，就是因为这些参数有具体的数据。&lt;/p>
&lt;blockquote>
&lt;p>注意：根据评估策略的不同，所谓的实际参数和形式参数也是相对来说的，比如在很多时候，我们传递的实际参数还可以是 另一个 Function、Pointer(指针) 等等类型的数据。&lt;/p>
&lt;/blockquote>
&lt;h2 id="evaluation-strategy评估策略">Evaluation strategy(评估策略)&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Convention&lt;/th>
&lt;th>Description&lt;/th>
&lt;th>Common use&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>| Call by value(值调用)
值传递 | 将参数的值的副本传递给子程序。
(子程序内修改它们不会影响原始参数) | Default in most Algol-like languages after &lt;a href="https://en.wikipedia.org/wiki/Algol_60">Algol 60&lt;/a>
, such as Pascal, Delphi, Simula, CPL, PL/M, Modula, Oberon, Ada, and many others. C, C++, Java (References to objects and arrays are also passed by value) |
| Call by reference(引用调用)
引用传递 | 将参数的引用地址传递给子程序
(子程序内修改它们会影响原始参数) | Selectable in most Algol-like languages after &lt;a href="https://en.wikipedia.org/wiki/Algol_60">Algol 60&lt;/a>
, such as Algol 68, Pascal, Delphi, Simula, CPL, PL/M, Modula, Oberon, Ada, and many others. C++, Fortran, &lt;a href="https://en.wikipedia.org/wiki/PL/I">PL/I&lt;/a> |
| Call by result | Parameter value is copied back to argument on return from the subroutine | Ada OUT parameters |
| Call by value-result | Parameter value is copied back on entry to the subroutine and again on return | Algol, &lt;a href="https://en.wikipedia.org/wiki/Swift_(programming_language)">Swift&lt;/a>
in-out parameters |
| Call by name | Like a macro – replace the parameters with the unevaluated argument expressions | Algol, &lt;a href="https://en.wikipedia.org/wiki/Scala_(programming_language)">Scala&lt;/a> |
| Call by constant value | Like call by value except that the parameter is treated as a constant | PL/I NONASSIGNABLE parameters, Ada IN parameters |&lt;/p>
&lt;h3 id="call-by-reference通过引用调用-与-call-by-value通过值调用">Call by Reference(通过引用调用) 与 Call by Value(通过值调用)&lt;/h3>
&lt;ul>
&lt;li>通过值调用(Call by value) 意味着，在函数体内修改参数值，不会影响到函数外部。&lt;/li>
&lt;li>通过引用调用(Call by reference) 意味着，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。&lt;/li>
&lt;/ul>
&lt;h1 id="函数调用时底层逻辑">函数调用时底层逻辑&lt;/h1>
&lt;p>有读者问题函数调用是如何实现的，今天就来聊聊这个比较简单的问题。&lt;/p>
&lt;p>大家都应该打包过东西吧，搬家之类的，通常都是找几个箱子一股脑装进去，为了不让箱子占地方，你通常会把它们摞好，就像这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687225-6414f1c8-2f44-4c24-978d-8a4cc6a65ba5.jpeg" alt="">&lt;/p>
&lt;p>注意看上面的箱子，最先被打包好的箱子被摞在最下方，刚打包好的箱子总是放在最上方，这就形成了一种 first in last out 的结构，也就是我们所说的栈，stack，上面的这些箱子就形成了栈。&lt;/p>
&lt;p>如果你懂得用箱子打包东西，你就能明白函数调用是怎么一回事。&lt;/p>
&lt;p>原来，在程序运行时每个被调用的函数都有自己的一个箱子，假设这段代码是这样写的：&lt;/p>
&lt;p>void D() {}
void C() {
  D();
}
void B() {
    C();
}
void A() {
  B();
}&lt;/p>
&lt;p>函数 A 调用函数 B、B 调用 C、C 调用 D，那么当函数 D 在运行时内存中就会有四个箱子，每个函数一个：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687180-74941560-51a7-421b-8cc8-793c48703b11.png" alt="">&lt;/p>
&lt;p>每个函数占据的这个箱子——也就是这块内存，就被称为栈帧，stack frame，只不过由于引力的作用，我们摞箱子时是从下往上增长，而出于内存布局的需要，函数调用时的栈是从高地址向低地址增长。&lt;/p>
&lt;p>这些箱子中都装有什么呢？你在函数中定义的局部变量就装在这里，关于栈帧内容更详细的讲解你可以参考这里《&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&amp;amp;mid=2247485714&amp;amp;idx=1&amp;amp;sn=1a315fe4da87fde2758fc9dd5366ba01&amp;amp;chksm=cfe99592f89e1c84b87ebfbfbbbd9868ddf3e945666168122f57aa793e87787528b513e46e5d&amp;amp;scene=21#wechat_redirect">函数调用是在内存中是什么样子&lt;/a>》，这些不是本文的重点，这里更关心的是这些栈帧是怎样增长以及减少的。&lt;/p>
&lt;p>仔细观察上面这张图，每个箱子最重要的信息有两个，&lt;strong>你至少需要知道箱子的底部以及箱子的顶部在哪里&lt;/strong>！&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687271-bdc684c3-a08f-4654-be59-0bd20b8a9630.png" alt="">&lt;/p>
&lt;p>在计算机中，每个函数栈帧的“底部”和“顶部”的信息——也就是内存地址，分别存放在两个寄存器中：BasePointer(BP)寄存器以及 StackPointer(SP)寄存器，即我们熟悉的 rbp 以及 rsp，32 位下为 ebp 以及 esp，注意本文以 x86_64 为例。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687166-7105bbca-8df4-4044-894f-11e5b13fa005.png" alt="">&lt;/p>
&lt;p>只要确定了 rbp 和 rsp 你就能得到一块栈区，在这块栈区上就可以进行函数调用：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687303-279472cc-ed4a-4525-b4f5-6994ef566265.png" alt="">&lt;/p>
&lt;p>读到这里肯定有的同学可能会问，CPU 中的寄存器不是有限的吗？从这里的讲解看每个栈帧都需要维护一个“栈顶”与“栈底”的信息，每个核心中的 rbp 以及 rsp 寄存器就一个，我们该怎样确保函数运行时相应栈帧使用的 rbp 以及 rsp 是正确的呢？&lt;/p>
&lt;p>方法非常简单，调用函数时会创建新的栈帧，此时需要将原有 rbp 寄存器中的值保存在新的栈帧上，就像这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687582-ed1046b1-c111-4c30-bf2e-310c2bc3c6ac.png" alt="">&lt;/p>
&lt;p>上图就是函数调用时第一件要完成的事情，把 rbp 的值 push 到栈上，rsp 下移，然后呢？然后也很简单，只需要把 rsp 指向的地址也赋值给 rbp 即可，这样就开启了一个新的栈帧：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687685-0e112e19-781f-48d1-8afb-fe172ce5f2a8.png" alt="">&lt;/p>
&lt;p>完成上述操作的有两条机器指令(gcc 编译器)：&lt;/p>
&lt;p>push   %rbp
mov    %rsp,%rbp&lt;/p>
&lt;p>如果你去看编译器为每个函数生成的机器指令，那么开头几乎都是这两条指令，现在你应该明白这两条指令的作用了吧。&lt;/p>
&lt;p>这两条指令就把上一个栈帧的 rbp 的保存到了新的栈帧，由于此时 rsp 已经指向了新的栈帧栈顶，由于此时栈为空，因此栈顶和栈底的地址是一样的，可以直接把 rsp 赋给 rbp，这样一个全新的栈帧就创建出来了。&lt;/p>
&lt;p>如果我们在被调函数内部创建一些局部变量：&lt;/p>
&lt;p>void funcB() {
    int a = 1;
    int b = 2;
    int c = 3;
    &amp;hellip;
}&lt;/p>
&lt;p>那么此时栈会进一步扩大，并把局部变量存放在该函数的栈帧中：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687701-456ca282-1ecb-420c-b487-4702fbb25770.png" alt="">&lt;/p>
&lt;p>现在我们的栈可以随着函数调用而增长，可以看到，栈帧和你搬家时用的纸箱子还是不太一样的，函数栈帧不会一开始就大小固定好，而是随着指令的执行动态增加，也就是如果你往栈上 push 一些数据，栈帧就会相应的增大一点。&lt;/p>
&lt;p>那么函数调用完成时该怎么办呢？这也非常简单，只需要一条机器指令：&lt;/p>
&lt;p>leave&lt;/p>
&lt;p>我们在上一篇《&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&amp;amp;mid=2247486951&amp;amp;idx=1&amp;amp;sn=9ed9294b2248b3287e60d38ac0b7fca4&amp;amp;chksm=cfe99167f89e1871915861369c3f39bf1850754e974da1f9f7367fdb37c64d22fc3425a65c9e&amp;amp;scene=21#wechat_redirect">栈区分配内存快还是堆区分配内存快&lt;/a>》中讲解了一部分，leave 指令的作用是将栈基址赋值给 rsp，这样栈指针指向上一个栈帧的栈顶，然后 pop 出 rbp，这样 rbp 就指向上一个栈帧的栈底：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687723-01062541-9dd2-493f-aaaa-3fe4811c3212.png" alt="">&lt;/p>
&lt;p>看到了吧，执行完 leave 指令后 rbp 以及 rsp 就指向了上一个栈帧，这就相当于栈帧的弹出，这样 stack 1 占用的内存就无效了，没有任何用处了，显然这就是我们常说的内存回收，因此简单的一条 leave 指令即可把栈区中的内存回收掉。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437687846-701d7bbb-5cb3-429c-a9b2-72441062dea5.png" alt="">&lt;/p>
&lt;p>而在 x86 平台，leave 指令后往往跟上一条 ret 指令：&lt;/p>
&lt;p>leave
ret&lt;/p>
&lt;p>我们已经了解了 leave 指令的作用，这条指令让 rbp 以及 rsp 指向上一个栈帧，然后呢？显然 CPU 应该从 funcA 调用函数 funcB 之后的一行代码处继续运行，那么这行代码的地址在哪里呢？显然就在 funcA 栈帧的栈顶：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/qu324i/1648437688059-b40c97fe-0a35-4cee-8590-f072fad8be69.png" alt="">&lt;/p>
&lt;p>当 CPU 执行 call 指令时会把该函数的返回地址 push 到栈中，而 ret 指令的作用正是将栈顶弹出(pop)到 rip 寄存器，rip 寄存器告诉 CPU 接下来该从哪里执行机器指令，这个返回地址是 funcA 调用 funcB 时 push 到栈上的，这样当从函数 funcB()返回后我们就知道该从哪里继续执行机器指令了，这就是 ret 指令的作用，当然这里也是函数调用实现的基本原理。&lt;/p>
&lt;p>关于栈帧更详细的讲解可以参考我写的这篇《&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&amp;amp;mid=2247485714&amp;amp;idx=1&amp;amp;sn=1a315fe4da87fde2758fc9dd5366ba01&amp;amp;chksm=cfe99592f89e1c84b87ebfbfbbbd9868ddf3e945666168122f57aa793e87787528b513e46e5d&amp;amp;scene=21#wechat_redirect">函数调用在内存中是什么样子&lt;/a>》。&lt;/p></description></item><item><title>Docs: Function(函数)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/function%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/function%E5%87%BD%E6%95%B0/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;p>DRY 原则：Don&amp;rsquo;t Repeart Yourself(不要重复你自己)&lt;/p>
&lt;p>Golang 有 3 种类型的函数：&lt;/p>
&lt;ul>
&lt;li>普通的带有名字的函数&lt;/li>
&lt;li>匿名函数或者 lambda 函数&lt;/li>
&lt;li>Methods(方法) 除了 main()、init()函数外，其余所有类型的函数都可以有参数与返回值。函数参数、返回值以及它们的类型统称为&lt;strong>函数签名&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h2 id="function-的声明">Function 的声明&lt;/h2>
&lt;pre>&lt;code>func FunctionName([Parameter]) [(ReturnValue)] {
代码块
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;code>()&lt;/code> 里的 Parameter 以及 returnValue 可以省略，但是至少要包含一个&lt;code>()&lt;/code>，哪怕这个小括号内没有任何内容。i.e.一个函数可以没有参数，与返回值，仅仅执行本身所提供的功能&lt;/li>
&lt;li>Parameter(形式参数) # 这是一个参数列表，包括参数名以及参数类型。参数一般情况是变量、或者另一个函数(这个函数也可以当做变量来使用，是函数类型的变量，在调用时，可以通过实参改变该函数)。&lt;/li>
&lt;li>ReturnValue(返回值) # 同样包括参数名以及参数类型，参数一般是变量。可以直接定义变量名与类型，也可以省略变量名直接指明返回值的类型&lt;/li>
&lt;li>其中 Parameter 与 returnValue 都是可省的，最简化的定义格式为 &lt;code>function Name(){}&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="function-的调用">Function 的调用&lt;/h2>
&lt;p>调用函数 就是指 使用函数&lt;/p>
&lt;p>格式为：
&lt;code>[Pack.]Function([ARG1, ARG2, ..., ARGn])&lt;/code>&lt;/p>
&lt;p>其中 Pack 与 ARG 都是可省的，若在同一个包中，则 Pack 可省，若不用传递参数，则 ARG 可省。&lt;/p>
&lt;p>包名.函数名(实际参数)。&lt;code>Function&lt;/code>是&lt;code>Pack&lt;/code>包里的一个函数，括号里的是被调用函数的实参，这些实参的值被传递给被调用函数的形参，参数的传递是一一对应的，第一位传递给第一位，第二位传递给第二位，以此类推。在引用的时候参数可省略为空，但是括号必须要有&lt;/p>
&lt;ol>
&lt;li>&lt;strong>actual parameter(实际参数，简称 实参)&lt;/strong> # 一般用 arguments 表示，在调用函数时使用实参&lt;/li>
&lt;li>&lt;strong>formal parameter(形式参数，简称 形参)&lt;/strong> # 一般用 parameter 表示，在定义函数时使用形参&lt;/li>
&lt;/ol>
&lt;p>注意：
在使用函数返回值对变量进行赋值的时候，可以使用&lt;code>_&lt;/code>下划线，来把函数的某一个返回值丢弃。详见&lt;a href="https://desistdaydream.github.io/5.Functions/return.go">return.go&lt;/a>中下划线的使用方法&lt;/p>
&lt;p>如果在同一个包下的多个文件之间互相调用函数，在执行 go run XXX.go 命令时，需要指定所有文件，即 go run *.go 只有这样在引用其他文件中的函数时，才可以成功。&lt;/p>
&lt;h3 id="回调函数">回调函数&lt;/h3>
&lt;p>函数可以作为其他函数的参数进行传递，然后在其它函数内调用执行，一般称之为&lt;strong>回调&lt;/strong>。e.g.function_parameter.go&lt;/p>
&lt;h3 id="内置函数">内置函数&lt;/h3>
&lt;p>一些不需要进行导入操作就可以使用的函数就是内置函数。&lt;/p>
&lt;p>通俗来说，是在不使用&lt;code>import&lt;/code>关键字导入任何包，就可以在 main 下直接使用的各种函数。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>名称&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>close&lt;/td>
&lt;td>用于管道通信&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>len、cap&lt;/td>
&lt;td>len 用于返回某个类型的长度或数量(字符串、数组、切片、map 和管道)；cap 是容量的意思，用于返回某个类型的最大容量(只能用于切片和 map)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>new、make&lt;/td>
&lt;td>new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针（详见第 10.1 节）。它也可以被用于基本类型：v := new(int)。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>new()&lt;/code>
是一个函数，不要忘记它的括号 |
| copy、append | 用于复制和连接切片 |
| panic、recover | 两者均用于错误处理机制 |
| print、println | 底层打印函数，在部署环境中建议使用 fmt 包内的打印函数 |
| complex、real imag | 用于创建和操作复数 |&lt;/p>
&lt;h1 id="variadic-functions可变参数函数">Variadic Functions(可变参数函数)&lt;/h1>
&lt;p>代码示例 variadic.go&lt;/p>
&lt;p>如果函数的最后一个参数是采用&lt;code>...type&lt;/code>的形式，那么这个函数就可以处理一个变长的参数，这个长度可以为 0，这样的函数称为 VariadicFunctions。&lt;/p>
&lt;p>格式为：&lt;code>func Funcition(Param1,Param2,...ParamX ...TYPE) {}&lt;/code>。最后一个参数&lt;code>ParamX&lt;/code>类型为&lt;code>TYPE切片&lt;/code>，这个参数称为&lt;code>变长参数&lt;/code>，该参数可接收多个值。&lt;/p>
&lt;p>e.g. 示例函数以及调用&lt;/p>
&lt;pre>&lt;code>func Greeting(prefix string, who ...string)
Greeting(&amp;quot;hello:&amp;quot;, &amp;quot;Joe&amp;quot;, &amp;quot;Anna&amp;quot;, &amp;quot;Eileen&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>该例子中，变量&lt;code>who&lt;/code>的值为&lt;code>[]string{&amp;quot;Joe&amp;quot;, &amp;quot;Anna&amp;quot;, &amp;quot;Eileen&amp;quot;}&lt;/code> 这类函数可以接受&lt;strong>任意数量的形参&lt;/strong>，因为使用的是 &lt;code>...&lt;/code> 作为形参列表&lt;/p>
&lt;h1 id="closure闭包-与-anonymousfunctions匿名函数">Closure(闭包) 与 AnonymousFunctions(匿名函数)&lt;/h1>
&lt;p>&lt;strong>Closure(闭包)&lt;/strong> 通俗得讲，就是函数 a 的内部函数 b，被函数 a 外部的一个变量引用的时候，就创建了一个闭包代码示例 closure.go&lt;/p>
&lt;p>&lt;strong>Anonymous Functions(匿名函数)&lt;/strong>，当我们不希望给函起名字的时候可以使用&lt;code>匿名函数&lt;/code>。&lt;/p>
&lt;p>匿名函数不能够独立存在&lt;/p>
&lt;ul>
&lt;li>可以把匿名函数赋值于某个变量。i.e.保存函数的地址到变量中。
&lt;ul>
&lt;li>&lt;code>fplus := func(x, y int) int { return x+y }&lt;/code>
&lt;ul>
&lt;li>然后可以同通过变量名对函数进行调用 i.e.&lt;code>fplus(3,4)&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>可以让匿名函数仅仅实现自身逻辑即可
&lt;ul>
&lt;li>&lt;code>func(x, y int) { fmt.Println(x + y) }(3, 4)&lt;/code>
&lt;ul>
&lt;li>第一个括号 &lt;code>(x, y int)&lt;/code> 表示该函数的形参&lt;/li>
&lt;li>最后的括号 &lt;code>(3, 4)&lt;/code> 表示调用该函数的实参&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>所谓的匿名函数，其实就是定义时即调用运行，而普通函数，定义后，在定义后不调用之前，是不会运行的。&lt;/p>
&lt;p>&lt;strong>匿名函数 &lt;strong>可以构造&lt;/strong> Closure(闭包)&lt;/strong>。&lt;/p>
&lt;p>闭包的特性：&lt;/p>
&lt;ol>
&lt;li>封闭性：外界无法访问闭包内部的数据，如果在闭包内声明变量，外界是无法访问的，除非闭包主动向外界提供范文接口&lt;/li>
&lt;li>持久性：一般的函数，在调用完毕后，系统自动注销函数，而对于闭包来说，在外部函数被调用之后，闭包的结构依然保存在系统中，闭包中的数据依然存在&lt;/li>
&lt;li>闭包会占用内存资源，过多的使用会导致内存溢出。&lt;/li>
&lt;/ol>
&lt;p>闭包是一个有状态(不消失的私有数据)的函数。闭包是一个有记忆的函数。闭包相当于一个只有一个方法的紧凑对象。&lt;/p>
&lt;h1 id="recursion递归">Recursion(递归)&lt;/h1>
&lt;p>当一个函数在其函数体内调用自身，则称之为&lt;strong>递归&lt;/strong>。最经典的例子是计算斐波那契数列，即前两个数为 1，从第三个数开始每个数均为前两个数之和。\&lt;/p>
&lt;h1 id="make-与-new">make() 与 new()&lt;/h1>
&lt;ul>
&lt;li>&lt;code>make(t Type, size ...IntegerType)&lt;/code> 用于为 &lt;strong>内建类型(map、slice、channel)&lt;/strong> 分配内存。&lt;/li>
&lt;li>&lt;code>new(Type)&lt;/code> 用于为 &lt;strong>各种类型&lt;/strong>_ _分配内存。&lt;/li>
&lt;/ul>
&lt;p>第一个参数是类型，而不是值，返回的值是指向该类型新分配的零值的指针。&lt;/p>
&lt;p>&lt;code>make(T,args)&lt;/code> 与 &lt;code>new(T)&lt;/code> 有着不同的功能，make 只能创建 slice,map,channel，并且返回一个有初始值(非零)的 T 类型，而不是&lt;code>*T&lt;/code>&lt;/p>
&lt;p>&lt;code>new(T)&lt;/code> 分配了零值填充的 &lt;code>T类型&lt;/code> 的内存空间，并且返回其地址，即一个 &lt;code>*T&lt;/code> 类型的值(GO 语言的术语：返回了一个指针，指向新分配的类型 T 的零值)&lt;/p>
&lt;p>&lt;code>new()&lt;/code> 是 go 语言中很重要的一种 &lt;strong>设计思想&lt;/strong>,在原生基础包里，仅仅返回一个类型的指针。而在实际项目中，人们常常将 new() 思想与 struct 相结合。比如下面这个例子：&lt;/p>
&lt;pre>&lt;code>// 声明一个结构体
type MemorySession struct {
sessionID string
data map[string]interface{}
rwlock sync.RWMutex
}
// NewMemorySession 返回一个储存 Session 的内存引擎
func NewMemorySession(id string) *MemorySession {
s := &amp;amp;MemorySession{}
return s
}
&lt;/code>&lt;/pre>
&lt;p>这个例子中，就使用了 new() 的思想，通过一个函数，来生成一个结构体的指针，这个指针通常称为该结构体的 &lt;strong>instance(实例)&lt;/strong>。这样，后续要操作这个结构体属性的值，调用这些指针(i.e.实例)即可&lt;/p>
&lt;pre>&lt;code>s := NeNewMemorySession(&amp;quot;DD&amp;quot;)
s.METHOD1
s.METHOD2
....等等
&lt;/code>&lt;/pre>
&lt;p>再比如在 kubernetes 项目中，也可以在很多地方看到这类&lt;strong>设计思想&lt;/strong>&lt;/p>
&lt;p>这里用 kubelet 的一段代码举例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">HollowKubelet&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">KubeletFlags&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">options&lt;/span>.&lt;span style="color:#a6e22e">KubeletFlags&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">KubeletConfiguration&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">kubeletconfig&lt;/span>.&lt;span style="color:#a6e22e">KubeletConfiguration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">KubeletDeps&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">kubelet&lt;/span>.&lt;span style="color:#a6e22e">Dependencies&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewHollowKubelet&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">flags&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">options&lt;/span>.&lt;span style="color:#a6e22e">KubeletFlags&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>..
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">HollowKubelet&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">KubeletFlags&lt;/span>: &lt;span style="color:#a6e22e">flags&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">KubeletConfiguration&lt;/span>: &lt;span style="color:#a6e22e">config&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">KubeletDeps&lt;/span>: &lt;span style="color:#a6e22e">d&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里用 NewHollowKubelet() 函数实例化了一个 HollowKubelet 结构体。后续想要使用时，调用 New 函数，生成一个实例(指针变量)，然后调用作用在这个结构体上的方法即可。&lt;/p>
&lt;h3 id="总结">&lt;strong>总结：&lt;/strong>&lt;/h3>
&lt;p>&lt;code>new&lt;/code>负责分配内存，&lt;code>new(T)&lt;/code>返回&lt;code>*T&lt;/code>指向一个零值&lt;code>T&lt;/code>的指针&lt;/p>
&lt;p>make 负责初始化值，make(T) 返回初始化后的 T ，而非指针&lt;/p>
&lt;p>最重要的一点：make 仅适用于 slice，map 和 channel&lt;/p>
&lt;p>关于，并非是空值，而是一种“变量未填充前”的默认值，通常为 0，如下&lt;/p>
&lt;pre>&lt;code>int 0
int8 0
int32 0
int64 0
uint 0x0
rune 0 //rune的实际类型是 int32
byte 0x0 //byte的实际类型是uint8
float32 0 //长度为4 byte
float64 0 //长度为8 byte
bool false
string &amp;quot;&amp;quot;
&lt;/code>&lt;/pre>
&lt;h1 id="other">Other&lt;/h1>
&lt;p>展示一个计算过程所消耗的时间：使用 time 包中的&lt;code>Now()&lt;/code>和&lt;code>Sub()&lt;/code>函数，在计算开始之前设置一个起始时间，再由计算结束时的结束时间与起始时间相减，即为执行计算的消耗时间。代码示例:fibonnaci.go&lt;/p></description></item><item><title>Docs: Generic(泛型)</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/generic%E6%B3%9B%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/generic%E6%B3%9B%E5%9E%8B/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Generic_programming">Wiki,Generic proramming&lt;/a>(泛型编程)&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/Ymxs4Z2p62hQ7RA3q23drg">公众号-OSC 开源社区，使用 Go 泛型的最佳时机&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/MVZxoh8pYYUJ1_Dyj8Sh7g">公众号-OSC 开源社区，Go 语言之父介绍泛型&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/Zk24GsvpryB64hlSAp06Iw">公众号-InfoQ，Go 中的泛型：激动人心的突破&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/3Yc7_mvYdr3KtSE0jnAJww">公众号-幼麟实验室，Go 泛型的实现&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>泛型让我们在定义接口、函数、结构体时将其中的类型&lt;strong>参数化&lt;/strong>。我们从古老的 Ada 语言的第一个版本就开始使用泛型了，后来 C++ 的模板中也有泛型，直到 Java 和 C# 中的现代实现都是很常见的例子。&lt;/p>
&lt;p>泛型为 Go 添加了三个新的重要内容：&lt;/p>
&lt;ul>
&lt;li>面向函数和类型的“类型形参” (type parameters)&lt;/li>
&lt;li>将接口类型定义为类型集合，包括没有方法的接口类型&lt;/li>
&lt;li>类型推断：在大多数情况下，在调用泛型函数时可省略“类型实参” (type arguments)&lt;/li>
&lt;/ul>
&lt;h2 id="类型形参与约束">类型形参与约束&lt;/h2>
&lt;p>下面是一个初步理解泛型的最简单例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 泛型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 使用类型形参编写 Go 函数以处理多种类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// comparable 是一个内置 Constraint(约束)，用来表示类型形参可以接收的类型实参的种类，所谓的“约束”就是指，T 被约束为可以使用哪几种类型。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// comparable 包含所有可以比较类型，包括：booleans、numbers、strings、pointers、channels、可比较的 arrays、structs 中的属性
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// comparable 可以改为 any，表示 T 可以是任意类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Index&lt;/span>[&lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#a6e22e">comparable&lt;/span>](&lt;span style="color:#a6e22e">s&lt;/span> []&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>) &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 这里的 v 和 x 都是 T 类型，且 T 类型具有可以比较的约束，因此这里可以使用 ==
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Index() 函数适用于 int 类型的切片
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">si&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>{&lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">20&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">Index&lt;/span>(&lt;span style="color:#a6e22e">si&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Index() 函数同样也使用于 string 类型的切片
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">ss&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>{&lt;span style="color:#e6db74">&amp;#34;foo&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;bar&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;baz&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">Index&lt;/span>(&lt;span style="color:#a6e22e">ss&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，我们将 a、b 的类型&lt;strong>参数化&lt;/strong>了。这里的 T，可以称之为&lt;strong>泛型类型&lt;/strong>，同时也是 Max() 方法的 &lt;strong>Type Parameters(类型形参)&lt;/strong>。当我们调用 Max() 时，可以传递参数告诉 &lt;code>Max()&lt;/code> 当前应该使用类型执行其中的代码&lt;/p>
&lt;p>如果没有泛型，那么我们的 &lt;code>Index()&lt;/code> 函数就要写两遍(有多少种类型，就要写多少遍)：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">IndexInt&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Do Somthing
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">IndexString&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Do Somthing
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>还可以使用 any 关键字，以便让约束变为任意类型&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Do&lt;/span>[&lt;span style="color:#a6e22e">R&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>, &lt;span style="color:#a6e22e">S&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>, &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>](&lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#a6e22e">R&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#a6e22e">S&lt;/span>) &lt;span style="color:#a6e22e">T&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Do Somthing
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">Do&lt;/span>[&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">uint&lt;/span>, &lt;span style="color:#66d9ef">float64&lt;/span>](&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 上面的代码的行为与下面的函数完全相同:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Do(a int, b uint) float64
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="其他">其他&lt;/h1>
&lt;h2 id="类型形参">类型形参&lt;/h2>
&lt;p>现在函数和类型都具有类型形参” (type parameters)，类型形参列表看起来就是一个普通的参数列表，除了它使用的是方括号而不是小括号。&lt;/p>
&lt;p>先从浮点值的基本非泛型 Min 函数开始：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Min&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span>, &lt;span style="color:#a6e22e">y&lt;/span> &lt;span style="color:#66d9ef">float64&lt;/span>) &lt;span style="color:#66d9ef">float64&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">y&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">y&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过添加类型形参列表来使这个函数泛型化——使其适用于不同的类型。在此示例中，添加了一个带有单个类型形参&lt;code>T&lt;/code>的类型参数列表，并替换了&lt;code>float64&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;golang.org/x/exp/constraints&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">GMin&lt;/span>[&lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#a6e22e">constraints&lt;/span>.&lt;span style="color:#a6e22e">Ordered&lt;/span>](&lt;span style="color:#a6e22e">x&lt;/span>, &lt;span style="color:#a6e22e">y&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>) &lt;span style="color:#a6e22e">T&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">y&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">y&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后就可以使用类型实参调用此函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">GMin&lt;/span>[&lt;span style="color:#66d9ef">int&lt;/span>](&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>向  GMin 提供类型参数，在这种情况下&lt;code>int&lt;/code>称为实例化。实例化分两步进行。首先，编译器在泛型函数或泛型类型中用所有类型形参替换它们各自的类型实参。然后，编译器验证每个类型形参是否满足各自的约束。如果第二步失败，实例化就会失败并且程序无效。&lt;/p>
&lt;p>成功实例化后，即可产生非泛型函数，它可以像任何其他函数一样被调用。比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmin&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">GMin&lt;/span>[&lt;span style="color:#66d9ef">float64&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">fmin&lt;/span>(&lt;span style="color:#ae81ff">2.71&lt;/span>, &lt;span style="color:#ae81ff">3.14&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>GMin[float64]&lt;/code>的实例化产生了一个与&lt;code>Min&lt;/code>函数等效的函数，可以在函数调用中使用它。类型形参也可以与类型一起使用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Tree&lt;/span>[&lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{}] &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">left&lt;/span>, &lt;span style="color:#a6e22e">right&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Tree&lt;/span>[&lt;span style="color:#a6e22e">T&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">value&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Tree&lt;/span>[&lt;span style="color:#a6e22e">T&lt;/span>]) &lt;span style="color:#a6e22e">Lookup&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Tree&lt;/span>[&lt;span style="color:#a6e22e">T&lt;/span>] { &lt;span style="color:#f92672">...&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">stringTree&lt;/span> &lt;span style="color:#a6e22e">Tree&lt;/span>[&lt;span style="color:#66d9ef">string&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在上面的例子中，泛型类型&lt;code>Tree&lt;/code>存储了类型形参&lt;code>T&lt;/code>的值。泛型类型也可以有方法，比如本例中的&lt;code>Lookup&lt;/code>。为了使用泛型类型，它必须被实例化；&lt;code>Tree[string]&lt;/code>是使用类型实参&lt;code>string&lt;/code>来实例化&lt;code>Tree&lt;/code>的示例。&lt;/p>
&lt;h2 id="类型推断">类型推断&lt;/h2>
&lt;p>此项功能是最复杂的变更，主要包括：&lt;/p>
&lt;ul>
&lt;li>函数参数类型推断 (Function argument type inference)&lt;/li>
&lt;li>约束类型推断 (Constraint type inference)&lt;/li>
&lt;/ul>
&lt;p>虽然类型推断的工作原理细节很复杂，但使用它并不复杂：类型推断要么成功，要么失败。如果它成功，类型实参可以被省略，调用泛型函数看起来与调用普通函数没有什么不同。如果类型推断失败，编译器将给出错误消息，在这种情况下，只需提供必要的类型实参。&lt;/p>
&lt;hr>
&lt;p>泛型是 Go 1.18 的重要新语言特性，Robert Griesemer 和 Ian Lance Taylor 表示，这个功能实现得很好并且质量很高。虽然他们鼓励在有必要的场景中使用泛型，但在生产环境中部署泛型代码时，请务必谨慎。&lt;/p>
&lt;p>更多介绍查看原文：https://go.dev/blog/intro-generics。&lt;/p>
&lt;h1 id="使用泛型的最佳时机">使用泛型的最佳时机&lt;/h1>
&lt;p>从历史上看，C++、D 乃至 Rust 等系统语言一直采用单态化方法实现泛型。然而，Go 1.18 的泛型实现并不完全依靠单态化 (Monomorphization)，而是采用了一种被称为&amp;quot;GCShape stenciling with Dictionaries&amp;quot;的部分单态化技术。这种方法的好处是可以大幅减少代码量，但在特定情况下，会导致代码速度变慢。&lt;/p>
&lt;p>Ian Lance Taylor 表示，Go 的通用开发准则有要求：开发者应通过编写代码而不是定义类型来编写 Go 程序。当涉及到泛型时，如果通过定义类型参数约束来编写程序，那一开始就走错了路。正解应该是从编写函数开始，当明确了类型参数的作用后，再添加类型参数就很容易了。&lt;/p>
&lt;p>接着，Ian 列举了 4 种类型参数能有效发挥作用的情况：&lt;/p>
&lt;ol>
&lt;li>使用语言定义的特殊容器类型&lt;/li>
&lt;li>通用数据结构&lt;/li>
&lt;li>类型参数首选是函数，而非方法的情况&lt;/li>
&lt;li>不同类型需要实现通用方法&lt;/li>
&lt;/ol>
&lt;p>同时也提醒了不适合使用类型参数的情况：&lt;/p>
&lt;ol>
&lt;li>不要使用类型参数替换接口类型 (Interface Type)&lt;/li>
&lt;li>如果方法实现不同，不要使用类型参数&lt;/li>
&lt;li>在适当的地方使用反射 (reflection)&lt;/li>
&lt;/ol>
&lt;p>最后，Ian 给出了简要的泛型使用方针，当开发者发现自己多次编写完全相同的代码，而这些副本之间的唯一区别仅在于使用了不同类型，这时候便可以考虑使用类型参数。换句话说，即开发者应避免使用类型参数，直到发现自己要多次编写完全相同的代码。&lt;/p>
&lt;h2 id="最佳实践">最佳实践&lt;/h2>
&lt;p>泛型的最佳时机，就是当两个“对象”的某些“方法”的行为完全一样时，我们可以通过泛型来声明这些方法，以防止重复编写完全相同的代码。就像下面这段代码中，ProductGorm 与 UserGorm 的两个方法代码其实是完全相同的，如果使用 interface{}，那么我们需要重复写了 Create() 与 Get() 方法。其实，本质上 ProductGorm 与 UserGorm 所需要执行的 SQL 是完全一样，不一样的只是其中的列名而已。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;github.com/go-gorm/driver/sqlite&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;github.com/go-gorm/gorm&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ProductGorm&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">gorm&lt;/span>.&lt;span style="color:#a6e22e">Model&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Price&lt;/span> &lt;span style="color:#66d9ef">uint&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">UserGorm&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">gorm&lt;/span>.&lt;span style="color:#a6e22e">Model&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">FirstName&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">LastName&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Repository&lt;/span>[&lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>] &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">db&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">gorm&lt;/span>.&lt;span style="color:#a6e22e">DB&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Repository&lt;/span>[&lt;span style="color:#a6e22e">T&lt;/span>]) &lt;span style="color:#a6e22e">Create&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>) &lt;span style="color:#66d9ef">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">db&lt;/span>.&lt;span style="color:#a6e22e">Create&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">t&lt;/span>).&lt;span style="color:#a6e22e">Error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Repository&lt;/span>[&lt;span style="color:#a6e22e">T&lt;/span>]) &lt;span style="color:#a6e22e">Get&lt;/span>(&lt;span style="color:#a6e22e">id&lt;/span> &lt;span style="color:#66d9ef">uint&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">db&lt;/span>.&lt;span style="color:#a6e22e">Where&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;id = ?&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">id&lt;/span>).&lt;span style="color:#a6e22e">First&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">t&lt;/span>).&lt;span style="color:#a6e22e">Error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewProductRepository&lt;/span>(&lt;span style="color:#a6e22e">db&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">gorm&lt;/span>.&lt;span style="color:#a6e22e">DB&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Repository&lt;/span>[&lt;span style="color:#a6e22e">ProductGorm&lt;/span>] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">db&lt;/span>.&lt;span style="color:#a6e22e">AutoMigrate&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">ProductGorm&lt;/span>{})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Repository&lt;/span>[&lt;span style="color:#a6e22e">ProductGorm&lt;/span>]{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">db&lt;/span>: &lt;span style="color:#a6e22e">db&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewUserRepository&lt;/span>(&lt;span style="color:#a6e22e">db&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">gorm&lt;/span>.&lt;span style="color:#a6e22e">DB&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Repository&lt;/span>[&lt;span style="color:#a6e22e">UserGorm&lt;/span>] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">db&lt;/span>.&lt;span style="color:#a6e22e">AutoMigrate&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">UserGorm&lt;/span>{})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Repository&lt;/span>[&lt;span style="color:#a6e22e">UserGorm&lt;/span>]{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">db&lt;/span>: &lt;span style="color:#a6e22e">db&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">db&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">gorm&lt;/span>.&lt;span style="color:#a6e22e">Open&lt;/span>(&lt;span style="color:#a6e22e">sqlite&lt;/span>.&lt;span style="color:#a6e22e">Open&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;test.db&amp;#34;&lt;/span>), &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">gorm&lt;/span>.&lt;span style="color:#a6e22e">Config&lt;/span>{})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#e6db74">&amp;#34;failed to connect database&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">productRepo&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">NewProductRepository&lt;/span>(&lt;span style="color:#a6e22e">db&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">productRepo&lt;/span>.&lt;span style="color:#a6e22e">Create&lt;/span>(&lt;span style="color:#a6e22e">ProductGorm&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;product&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Price&lt;/span>: &lt;span style="color:#ae81ff">100&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">productRepo&lt;/span>.&lt;span style="color:#a6e22e">Get&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">userRepo&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">NewUserRepository&lt;/span>(&lt;span style="color:#a6e22e">db&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">userRepo&lt;/span>.&lt;span style="color:#a6e22e">Create&lt;/span>(&lt;span style="color:#a6e22e">UserGorm&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">FirstName&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;first&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">LastName&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;last&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">userRepo&lt;/span>.&lt;span style="color:#a6e22e">Get&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Out:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// &amp;amp;{{1 2021-11-23 22:50:14.595342 +0100 +0100 2021-11-23 22:50:14.595342 +0100 +0100 {0001-01-01 00:00:00 +0000 UTC false}} 100} &amp;lt;nil&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// &amp;amp;{{1 2021-11-23 22:50:44.802705 +0100 +0100 2021-11-23 22:50:44.802705 +0100
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Gin</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/gin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/gin/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://youngxhui.top/categories/gin/">https://youngxhui.top/categories/gin/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: Git</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/git/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/git/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://git-scm.com/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/YBRdyyxkv3lpNDyqrBiLCA">公众号,Git 各指令的本质&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Git 是一个免费的开源分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有内容。&lt;/p>
&lt;p>Git 易于学习，占地面积小，具有闪电般的快速性能。它具有廉价的本地分支，方便的暂存区域和多个工作流等功能，其性能优于 Subversion，CVS，Perforce 和 ClearCase 等 SCM 工具。&lt;/p>
&lt;h2 id="git-优势">Git 优势&lt;/h2>
&lt;p>Git 是一个分布式代码管理工具，在讨论分布式之前避免不了提及一下什么是中央式代码管理仓库：&lt;/p>
&lt;ul>
&lt;li>中央式：所有的代码保存在中央服务器，所以提交必须依赖网络，并且每次提交都会带入到中央仓库，如果是协同开发可能频繁触发代码合并，进而增加提交的成本和代价。最典型的就是 SVN。&lt;/li>
&lt;li>分布式：可以在本地提交，不需要依赖网络，并且会将每次提交自动备份到本地。每个开发者都可以把远程仓库 clone 一份到本地，并会把提交历史一并拿过来。代表就是 Git。&lt;/li>
&lt;/ul>
&lt;p>那 Git 相比于 SVN 有什么优势呢？打个比方：“巴拉巴拉写了一大堆代码，突然发现写的有问题，我想回到一个小时之前”，对于这种情况 Git 的优势就很明显了，因为 commit 的成本比较小并且本地会保存所有的提交记录，随时随刻可以进行回退。在这并不是说 SVN 的不能完成这种操作，只是 Git 的回退会显得更加的优雅。Git 相比于中央式工具还有很多优点，就不一一列举了&lt;/p>
&lt;h2 id="git-文件状态">Git 文件状态&lt;/h2>
&lt;p>在 Git 中文件大概分为三种状态：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>modified(修改)&lt;/strong> # Git 可以感知到工作目录中哪些文件被修改了，然后把修改的文件加入到 modified 区域&lt;/li>
&lt;li>&lt;strong>staged(暂存)&lt;/strong> # 通过 add 命令将工作目录中修改的文件提交到暂存区，等候被 commit&lt;/li>
&lt;li>&lt;strong>committed(提交)&lt;/strong> # 将暂存区文件 commit 至 Git 目录中永久保存&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>commit 节点&lt;/strong>
为了便于表述，本篇文章我会通过节点代称 commit 提交。
在 Git 中每次提交都会生成一个节点，而每个节点都会有一个哈希值作为唯一标示，多次提交会形成一个线性节点链（不考虑 merge 的情况），如图 1。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sq07re/1622380398088-7ac43710-9863-46af-b3f4-6b30c76a3558.webp" alt="">图 1
节点上方是通过 SHA1 计算的哈希值。
C2 节点包含 C1 提交内容,同样 C3 节点包含 C1、C2 提交内容。
&lt;strong>HEAD&lt;/strong>
HEAD 是 Git 中非常重要的一个概念，你可以称它为指针或者引用，它可以指向任意一个节点，并且指向的节点始终为当前工作目录，换句话说就是当前工作目录(也就是你所看到的代码)就是 HEAD 指向的节点。
还以图 1 举例，如果 HEAD 指向 C2 那工作目录对应的就是 C2 节点。具体如何移动 HEAD 指向后面会讲到，此处不要纠结。
同时 HEAD 也可以指向一个分支，间接指向分支所指向的节点。
&lt;strong>远程仓库&lt;/strong>
虽然 Git 会把代码以及历史保存在本地，但最终还是要提交到服务器上的远程仓库。通过 clone 命令可以把远程仓库的代码下载到本地，同时也会将提交历史、分支、HEAD 等状态一并同步到本地，但这些状态并不会实时更新，需要手动从远程仓库去拉取，至于何时拉、怎么拉后面章节会讲到。
通过远程仓库为中介，你可以和你的同事进行协同开发，开发完新功能后可以申请提交至远程仓库，同时也可以从远程仓库拉取你同事的代码。
注意点：因为你和你的同事都会以远程仓库的代码为基准，所以要时刻保证远程仓库的代码质量，切记不要将未经检验测试的代码提交至远程仓库。&lt;/p>
&lt;h2 id="分支">分支&lt;/h2>
&lt;p>&lt;strong>什么是分支？&lt;/strong>
分支也是 Git 中相当重要的一个概念，当一个分支指向一个节点时，当前节点的内容即是该分支的内容，它的概念和 HEAD 非常接近同样也可以视为指针或引用，不同的是分支可以存在多个，而 HEAD 只有一个。通常会根据功能或版本建立不同的分支。
&lt;strong>那分支有什么用呢？&lt;/strong>
举个例子：你们的 App 经历了千辛万苦终于发布了 v1.0 版本，由于需求紧急 v1.0 上线之后便马不停蹄的开始 v1.1，正当你开发的兴起时，QA 同学说用户反馈了一些 bug，需要修复然后重新发版，修复 v1.0 肯定要基于 v1.0 的代码，可是你已经开发了一部分 v1.1 了，此时怎么搞？
面对上面的问题通过引入分支概念便可优雅的解决，如图 2：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sq07re/1622380397995-e668f4eb-8196-48d8-827e-38b63bb28ad1.webp" alt="">
图 2&lt;/p>
&lt;ul>
&lt;li>先看左边示意图，假设 C2 节点既是 v1.0 版本代码，上线后在 C2 的基础上新建一个分支 ft-1.0&lt;/li>
&lt;li>再看右边示意图，在 v1.0 上线后可在 master 分支开发 v1.1 内容，收到 QA 同学反馈后提交 v1.1 代码生成节点 C3，随后切换到 ft-1.0 分支做 bug 修复，修复完成后提交代码生成节点 C4，然后再切换到 master 分支并合并 ft-1.0 分支，到此我们就解决了上面提出的问题&lt;/li>
&lt;/ul>
&lt;p>除此之外利用分支还可以做很多事情，比如现在有一个需求不确定要不要上线，但是得先做，此时可以单独创建一个分支开发该功能，等到啥时候需要上线直接合并到主分支即可。分支适用的场景很多就不一一列举了。
注意点：当在某个节点创建一个分支后，并不会把该节点对应的代码复制一份出来，只是将新分支指向该节点，因此可以很大程度减少空间上的开销。一定要记着不管是 HEAD 还是分支它们都只是引用而已，量级非常轻。&lt;/p>
&lt;h1 id="git-安装">Git 安装&lt;/h1>
&lt;p>windows 版 git 安装完成后，git config &amp;ndash;global core.autocrlf input 执行该命令让，git 在 pull 时不转换换行符为 CRLF，而在 push 时，所有 CRLF 转换为 LF。&lt;/p>
&lt;p>也可通过配置文件进行修改 ，配置文件在 C:\Users\用户名.gitconfig，修改其中的 autocrlf = input 即可。&lt;/p>
&lt;p>&lt;a href="https://github.com/cssmagic/blog/issues/22">https://github.com/cssmagic/blog/issues/22&lt;/a>&lt;/p>
&lt;p>配置换行符官方文档：&lt;a href="https://docs.github.com/cn/github/using-git/configuring-git-to-handle-line-endings">https://docs.github.com/cn/github/using-git/configuring-git-to-handle-line-endings&lt;/a>&lt;/p>
&lt;h1 id="git-关联文件">Git 关联文件&lt;/h1>
&lt;p>&lt;strong>~/.gitconfig&lt;/strong> # git 通用配置文件
&lt;strong>~/.git-credentials&lt;/strong> # 登录后凭据的保存路径&lt;/p>
&lt;p>gitconfig 配置内容与 git config &amp;ndash;global 命令一一对应&lt;/p>
&lt;p>比如：&lt;/p>
&lt;pre>&lt;code># 执行如下命令
git config --global user.name &amp;quot;DesistDaydream&amp;quot;
# gitconfig 文件中生成如下内容
[user]
name = DesistDaydream
&lt;/code>&lt;/pre>
&lt;p>其中 user 配置环境标识，name 为该配置环境中的关键字。&lt;/p></description></item><item><title>Docs: git clone克隆或下载一个仓库单个文件夹</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/github/git-clone%E5%85%8B%E9%9A%86%E6%88%96%E4%B8%8B%E8%BD%BD%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/github/git-clone%E5%85%8B%E9%9A%86%E6%88%96%E4%B8%8B%E8%BD%BD%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9/</guid><description>
&lt;h1 id="heading">&lt;/h1>
&lt;h1 id="1如果是想克隆别人的项目或者自己的">1、如果是想克隆别人的项目或者自己的&lt;/h1>
&lt;p>很简单的一个网站就解决了。&lt;a href="http://downgit.zhoudaxiaa.com">DownGit&lt;/a>： 只需要找到仓库中对应文件夹的 url,输入之后,点击 download 自动打包下载:&lt;/p>
&lt;p>（这里说明一下，因为原作者的项目无法使用，这是我修改过的新项目吧，把资源链接改到了国内 CDN，所以访问速度很快！）&lt;/p>
&lt;h1 id="2克隆自己的项目">2、克隆自己的项目&lt;/h1>
&lt;p>&lt;strong>注意：本方法会下载整个项目，但是，最后出现在本地项目文件下里只有需要的那个文件夹存在。类似先下载，再过滤。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>有时候因为需要我们只想 gitclone 下仓库的单个或多个文件夹，而不是全部的仓库内容，这样就很省事，所以下面就开始教程啦&lt;/strong>&lt;/p>
&lt;p>在 Git1.7.0 以前，这无法实现，但是幸运的是在 Git1.7.0 以后加入了 Sparse Checkout 模式，这使得 Check Out 指定文件或者文件夹成为可能。&lt;/p>
&lt;p>&lt;strong>举个例子：&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>现在有一个&lt;strong>test&lt;/strong>仓库&lt;a href="https://github.com/mygithub/test">https://github.com/mygithub/test&lt;/a>你要 gitclone 里面的&lt;strong>tt&lt;/strong>子目录：在本地的硬盘位置打开&lt;strong>Git Bash&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code>git init test &amp;amp;&amp;amp; cd test //新建仓库并进入文件夹
git config core.sparsecheckout true //设置允许克隆子目录
echo 'tt*' &amp;gt;&amp;gt; .git/info/sparse-checkout //设置要克隆的仓库的子目录路径 //空格别漏
git remote add origin git@github.com:mygithub/test.git //这里换成你要克隆的项目和库
git pull origin master //下载
复制代码
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>ok，大功告成！！！&lt;/strong>&lt;/p></description></item><item><title>Docs: Git 命令行工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/git-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/git-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>git 工具通过多个子命令来使用&lt;/p>
&lt;p>COMMAND:
add Add file contents to the index
bisect Find by binary search the change that introduced a bug
branch List, create, or delete branches
checkout Checkout a branch or paths to the working tree&lt;/p>
&lt;h2 id="clone--将一个存储库克隆到一个新的目录">clone # 将一个存储库克隆到一个新的目录&lt;/h2>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;branch,-b&lt;/strong> # 指定名为 NAME 的分支&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>git clone -b v1.0 XXXX # 克隆 v1.0 分支的代码&lt;/li>
&lt;/ul>
&lt;p>commit Record changes to the repository&lt;/p>
&lt;h2 id="config--配置-git">config # 配置 git&lt;/h2>
&lt;p>此命令分别设置要与提交一起使用的作者姓名和电子邮件地址。&lt;/p>
&lt;p>diff Show changes between commits, commit and working tree, etc&lt;/p>
&lt;p>fetch Download objects and refs from another repository&lt;/p>
&lt;p>grep Print lines matching a pattern&lt;/p>
&lt;p>init #创建一个空的 Git 存储库或重新初始化现有的存储库&lt;/p>
&lt;h2 id="log-展示所有-commit-的记录默认展示当前分支">log #展示所有 commit 的记录。默认展示当前分支。&lt;/h2>
&lt;p>git log [] [] [[&amp;ndash;] &amp;hellip;]&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>git log -p -2 prometheus-rules.yaml #查看 prometheus-rules.yaml 文件最近两次的修改记录&lt;/li>
&lt;/ul>
&lt;p>merge Join two or more development histories together&lt;/p>
&lt;p>mv Move or rename a file, a directory, or a symlink&lt;/p>
&lt;p>pull Fetch from and merge with another repository or a local branch&lt;/p>
&lt;p>push Update remote refs along with associated objects&lt;/p>
&lt;p>rebase Forward-port local commits to the updated upstream head&lt;/p>
&lt;p>reset Reset current HEAD to the specified state&lt;/p>
&lt;p>rm Remove files from the working tree and from the index&lt;/p>
&lt;p>show Show various types of objects&lt;/p>
&lt;p>status Show the working tree status&lt;/p>
&lt;p>tag Create, list, delete or verify a tag object signed with GPG&lt;/p>
&lt;h1 id="git-命令的应用实例">git 命令的应用实例&lt;/h1>
&lt;p>git 放弃本地修改，强制拉取更新&lt;/p>
&lt;ul>
&lt;li>git fetch &amp;ndash;all #指令是下载远程仓库最新内容，不做合并&lt;/li>
&lt;li>git reset &amp;ndash;hard origin/master #指令把 HEAD 指向 master 最新版本&lt;/li>
&lt;li>git pull #可以省略&lt;/li>
&lt;/ul>
&lt;p>本地所有修改，没有提交的文件，都返回到原来的状态&lt;/p>
&lt;ul>
&lt;li>git checkout . #&lt;/li>
&lt;/ul>
&lt;p>提交修改并上传代码&lt;/p>
&lt;ul>
&lt;li>git add . #&lt;/li>
&lt;li>git commit -a -m &amp;lsquo;XXXX 修改&amp;rsquo; #&lt;/li>
&lt;li>git push #&lt;/li>
&lt;/ul>
&lt;p>git 回滚到之前某一 commit&lt;/p>
&lt;ul>
&lt;li>git log # 查看所有 commit 记录，记录其中的 commit 号，比如 commit 号为：d07466766d46710e54a627f913eea5661382331a&lt;/li>
&lt;li>git reset &amp;ndash;hard d07466766d46710e54a627f913eea5661382331a # 恢复到这次 commit 的状态&lt;/li>
&lt;/ul>
&lt;h2 id="修改-git-commit-信息">修改 git commit 信息&lt;/h2>
&lt;p>对自己的提交进行修改&lt;/p>
&lt;ul>
&lt;li>git commit &amp;ndash;amend&lt;/li>
&lt;/ul>
&lt;p>将修改强制提交，覆盖原先的提交内容&lt;/p>
&lt;ul>
&lt;li>git push -f&lt;/li>
&lt;/ul>
&lt;h2 id="撤销已-push-的-commit">撤销已 push 的 commit&lt;/h2>
&lt;p>查看所有 commit 记录&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># git log&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>commit 3c15aad50ed125938bbedbedffed05a7b9d600da &lt;span style="color:#f92672">(&lt;/span>HEAD -&amp;gt; main, origin/main&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Author: DesistDaydream &amp;lt;373406000@qq.com&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Date: Tue May &lt;span style="color:#ae81ff">17&lt;/span> 14:52:27 &lt;span style="color:#ae81ff">2022&lt;/span> +0800
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Update e37-exporter-workflows.yml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>commit 8251ddbbbffe59e5ddb25bb70874425012aa035e
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Author: DesistDaydream &amp;lt;373406000@qq.com&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Date: Mon May &lt;span style="color:#ae81ff">16&lt;/span> 17:15:07 &lt;span style="color:#ae81ff">2022&lt;/span> +0800
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>回退到指定的版本&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># git reset --hard 8251ddbbbffe59e5ddb25bb70874425012aa035e&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HEAD is now at 8251ddb Update e37-exporter-workflows.yml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>强制推送，覆盖远端的版本信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># git push origin main --force&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Total &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>delta 0&lt;span style="color:#f92672">)&lt;/span>, reused &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>delta 0&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>To https://github.com/DesistDaydream/e37-exporter.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> + 3c15aad...8251ddb main -&amp;gt; main &lt;span style="color:#f92672">(&lt;/span>forced update&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="命令详解">命令详解&lt;/h1>
&lt;p>&lt;strong>提交相关&lt;/strong>
前面我们提到过，想要对代码进行提交必须得先加入到暂存区，Git 中是通过命令 add 实现。
添加某个文件到暂存区：
git add  文件路径
添加所有文件到暂存区：
git add .
同时 Git 也提供了撤销工作区和暂存区命令。
撤销工作区改动：
git checkout &amp;ndash;  文件名
清空暂存区：
git reset HEAD  文件名
提交：
将改动文件加入到暂存区后就可以进行提交了，提交后会生成一个新的提交节点，具体命令如下：
git commit -m &amp;ldquo;该节点的描述信息&amp;rdquo;&lt;/p>
&lt;p>&lt;strong>分支相关&lt;/strong>
创建分支：
创建一个分支后该分支会与 HEAD 指向同一节点，说通俗点就是 HEAD 指向哪创建的新分支就指向哪，命令如下：
git branch  分支名
切换分支：
当切换分支后，默认情况下 HEAD 会指向当前分支，即 HEAD 间接指向当前分支指向的节点。
git checkout  分支名
同时也可以创建一个分支后立即切换，命令如下：
git checkout -b  分支名
删除分支：
为了保证仓库分支的简洁，当某个分支完成了它的使命后应该被删除。比如前面所说的单独开一个分支完成某个功能，当这个功能被合并到主分支后应该将这个分支及时删除。
删除命令如下：
git branch -d  分支名&lt;/p>
&lt;p>&lt;strong>合并相关&lt;/strong>
关于合并的命令是最难掌握同时也是最重要的。我们常用的合并命令大概有三个 merge、rebase、cherry-pick。
merge：
merge 是最常用的合并命令，它可以将某个分支或者某个节点的代码合并至当前分支。具体命令如下：
git merge  分支名/节点哈希值
如果需要合并的分支完全领先于当前分支，如图 3 所示：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/yc1he6/1622380437243-d5cc7b99-b228-4972-a253-f048e1378e68.webp" alt="">
图 3
由于分支 ft-1 完全领先分支 ft-2 即 ft-1 完全包含 ft-2，所以 ft-2 执行了“git merge ft-1”后会触发 fast forward(快速合并)，此时两个分支指向同一节点，这是最理想的状态。但是实际开发中我们往往碰到的是下面这种情况：如图 4（左）。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/yc1he6/1622380437303-d391e621-2e78-48d4-8500-77e2a09964b3.webp" alt="">
图 4
这种情况就不能直接合了，当 ft-2 执行了“git merge ft-1”后 Git 会将节点 C3、C4 合并随后生成一个新节点 C5，最后将 ft-2 指向 C5 如图 4（右）。
注意点：如果 C3、C4 同时修改了同一个文件中的同一句代码，这个时候合并会出错，因为 Git 不知道该以哪个节点为标准，所以这个时候需要我们自己手动合并代码。
rebase：
rebase 也是一种合并指令，命令行如下：
git rebase  分支名/节点哈希值
与 merge 不同的是 rebase 合并看起来不会产生新的节点（实际上是会产生的，只是做了一次复制），而是将需要合并的节点直接累加，如图 5。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/yc1he6/1622380437264-b4959853-9005-408b-b49b-10745896aca3.webp" alt="">
图 5
当左边示意图的 ft-1.0 执行了 git rebase master 后会将 C4 节点复制一份到 C3 后面，也就是 C4&amp;rsquo;，C4 与 C4&amp;rsquo;相对应，但是哈希值却不一样。
rebase 相比于 merge 提交历史更加线性、干净，使并行的开发流程看起来像串行，更符合我们的直觉。既然 rebase 这么好用是不是可以抛弃 merge 了？其实也不是了，下面我罗列一些 merge 和 rebase 的优缺点：
merge 优缺点：&lt;/p>
&lt;ul>
&lt;li>优点：每个节点都是严格按照时间排列。当合并发生冲突时，只需要解决两个分支所指向的节点的冲突即可&lt;/li>
&lt;li>缺点：合并两个分支时大概率会生成新的节点并分叉，久而久之提交历史会变成一团乱麻&lt;/li>
&lt;/ul>
&lt;p>rebase 优缺点：&lt;/p>
&lt;ul>
&lt;li>优点：会使提交历史看起来更加线性、干净&lt;/li>
&lt;li>缺点：虽然提交看起来像是线性的，但并不是真正的按时间排序，比如图 3-3 中，不管 C4 早于或者晚于 C3 提交它最终都会放在 C3 后面。并且当合并发生冲突时，理论上来讲有几个节点 rebase 到目标分支就可能处理几次冲突&lt;/li>
&lt;/ul>
&lt;p>对于网络上一些只用 rebase 的观点，作者表示不太认同，如果不同分支的合并使用 rebase 可能需要重复解决冲突，这样就得不偿失了。但如果是本地推到远程并对应的是同一条分支可以优先考虑 rebase。所以我的观点是 根据不同场景合理搭配使用 merge 和 rebase，如果觉得都行那优先使用 rebase。
cherry-pick：
cherry-pick 的合并不同于 merge 和 rebase，它可以选择某几个节点进行合并，如图 6。
命令行：
git cherry-pick  节点哈希值&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/yc1he6/1622380437213-1e90e77b-8877-4449-a6b7-1dfe7d760ddb.webp" alt="">
图 6
假设当前分支是 master，执行了 git cherry-pick C3(哈希值)，C4(哈希值)命令后会直接将 C3、C4 节点抓过来放在后面，对应 C3&amp;rsquo;和 C4&amp;rsquo;。
&lt;strong>回退相关&lt;/strong>
分离 HEAD：
在默认情况下 HEAD 是指向分支的，但也可以将 HEAD 从分支上取下来直接指向某个节点，此过程就是分离 HEAD，具体命令如下：
git checkout  节点哈希值
//也可以直接脱离分支指向当前节点
git checkout &amp;ndash;detach
由于哈希值是一串很长很长的乱码，在实际操作中使用哈希值分离 HEAD 很麻烦，所以 Git 也提供了 HEAD 基于某一特殊位置（分支/HEAD）直接指向前一个或前 N 个节点的命令，也即相对引用，如下：
//HEAD 分离并指向前一个节点
git checkout  分支名/HEAD^
//HEAD 分离并指向前 N 个节点
git checkout  分支名～ N
将 HEAD 分离出来指向节点有什么用呢？举个例子：如果开发过程发现之前的提交有问题，此时可以将 HEAD 指向对应的节点，修改完毕后再提交，此时你肯定不希望再生成一个新的节点，而你只需在提交时加上&amp;ndash;amend 即可，具体命令如下：
git commit &amp;ndash;amend
回退：
回退场景在平时开发中还是比较常见的，比如你巴拉巴拉写了一大堆代码然后提交，后面发现写的有问题，于是你想将代码回到前一个提交，这种场景可以通过 reset 解决，具体命令如下：
//回退 N 个提交
git reset HEAD~N
reset 和相对引用很像，区别是 reset 会使分支和 HEAD 一并回退。
&lt;strong>远程相关&lt;/strong>
当我们接触一个新项目时，第一件事情肯定是要把它的代码拿下来，在 Git 中可以通过 clone 从远程仓库复制一份代码到本地，具体命令如下：
git clone 仓库地址
前面的章节我也有提到过，clone 不仅仅是复制代码，它还会把远程仓库的引用（分支/HEAD）一并取下保存在本地，如图 7 所示：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/yc1he6/1622380437328-fac36536-b8d8-4ee2-b0cc-9e52d5828b2f.webp" alt="">
图 7
其中 origin/master 和 origin/ft-1 为远程仓库的分支，而远程的这些引用状态是不会实时更新到本地的，比如远程仓库 origin/master 分支增加了一次提交，此时本地是感知不到的，所以本地的 origin/master 分支依旧指向 C4 节点。我们可以通过 fetch 命令来手动更新远程仓库状态。
小提示：并不是存在服务器上的才能称作是远程仓库，你也可以 clone 本地仓库作为远程，当然实际开发中我们不可能把本地仓库当作公有仓库，说这个只是单纯的帮助你更清晰的理解分布式。
fetch：
说的通俗一点，fetch 命令就是一次下载操作，它会将远程新增加的节点以及引用(分支/HEAD)的状态下载到本地，具体命令如下：
git fetch  远程仓库地址/分支名
pull：
pull 命令可以从远程仓库的某个引用拉取代码，具体命令如下：
git pull  远程分支名
其实 pull 的本质就是 fetch+merge，首先更新远程仓库所有状态到本地，随后再进行合并。合并完成后本地分支会指向最新节点。
另外 pull 命令也可以通过 rebase 进行合并，具体命令如下：
git pull &amp;ndash;rebase  远程分支名
push：
push 命令可以将本地提交推送至远程，具体命令如下：
git push  远程分支名
如果直接 push 可能会失败，因为可能存在冲突，所以在 push 之前往往会先 pull 一下，如果存在冲突本地解决。push 成功后本地的远程分支引用会更新，与本地分支指向同一节点。&lt;/p>
&lt;p>综上所述
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/yc1he6/1622380437220-cc136a5f-1d56-4767-85a1-0e16753a3cd0.webp" alt="">&lt;/p>
&lt;ul>
&lt;li>不管是 HEAD 还是分支，它们都只是引用而已，引用+节点是 Git 构成分布式的关键&lt;/li>
&lt;li>merge 相比于 rebase 有更明确的时间历史，而 rebase 会使提交更加线性应当优先使用&lt;/li>
&lt;li>通过移动 HEAD 可以查看每个提交对应的代码&lt;/li>
&lt;li>clone 或 fetch 都会将远程仓库的所有提交、引用保存在本地一份&lt;/li>
&lt;li>pull 的本质其实就是 fetch+merge，也可以加入&amp;ndash;rebase 通过 rebase 方式合并&lt;/li>
&lt;/ul></description></item><item><title>Docs: Git 配置详解</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/git-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/git-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;h1 id="gitconfig-文件配置详解">~./gitconfig 文件配置详解&lt;/h1>
&lt;p>该配置文件可以手动修改，也可以通过 git config &amp;ndash;global XXX 命令修改。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>filter &lt;span style="color:#e6db74">&amp;#34;lfs&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> required &lt;span style="color:#f92672">=&lt;/span> true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clean &lt;span style="color:#f92672">=&lt;/span> git-lfs clean -- %f
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> smudge &lt;span style="color:#f92672">=&lt;/span> git-lfs smudge -- %f
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> process &lt;span style="color:#f92672">=&lt;/span> git-lfs filter-process
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>user&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name &lt;span style="color:#f92672">=&lt;/span> DesistDaydream
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> email &lt;span style="color:#f92672">=&lt;/span> 373406000@qq.com
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>core&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> autocrlf &lt;span style="color:#f92672">=&lt;/span> input
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>credential&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> helper &lt;span style="color:#f92672">=&lt;/span> store
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>git config &amp;ndash;global credential.helper store&lt;/strong>&lt;/p></description></item><item><title>Docs: GitHub</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/github/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/github/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官方文档：&lt;a href="https://docs.github.com/cn">https://docs.github.com/cn&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在代码仓库中，点击 &lt;code>.&lt;/code> 即可进入 Web 版的 VS Code，在线编辑当前仓库的代码。&lt;/p></description></item><item><title>Docs: GitHub Actions</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/github/github-actions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/github/github-actions/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.github.com/cn/actions">官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.github.com/en/actions/learn-github-actions/introduction-to-github-actions">官方文档,学习 GitHub Actions-GitHub Actions 简介&lt;/a>&lt;/li>
&lt;li>GitHub Actions 官方市场：&lt;a href="https://github.com/marketplace?type=actions">Actions Marketplace&lt;/a>&lt;/li>
&lt;li>阮一峰老师的一篇文章：&lt;a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">GitHub Actions 入门教程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/sculpta/article/details/104142607">https://blog.csdn.net/sculpta/article/details/104142607&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>GitHub Actions 是在 GitHub Universe 大会上发布的，被 Github 主管 Sam Lambert 称为 “再次改变软件开发” 的一款重磅功能（“&lt;em>we believe we will once again revolutionize software development.&lt;/em>”）。于 2018 年 10 月推出，内测了一段时间后，于 2019 年 11 月 13 日正式上线&lt;/p>
&lt;p>GitHub 会提供一个以下配置的服务器做为 runner：&lt;/p>
&lt;ul>
&lt;li>2-core CPU&lt;/li>
&lt;li>7 GB of RAM memory&lt;/li>
&lt;li>14 GB of SSD disk space&lt;/li>
&lt;/ul>
&lt;p>（免费额度最多可以同时运行 20 个作业，心动了有木有 💘）&lt;/p>
&lt;p>GitHub Actions 是一个 &lt;code>CI/CD（持续集成/持续部署）&lt;/code>工具，持续集成由很多操作组成，比如 &lt;strong>抓取代码&lt;/strong>、&lt;strong>运行测试&lt;/strong>、&lt;strong>登录远程服务器&lt;/strong>、&lt;strong>发布到第三方服务&lt;/strong> 等等。GitHub 把这些操作统称为 &lt;code>**Actions(操作、行为)**&lt;/code>。&lt;/p>
&lt;p>Actions 是 GitHub Actions 的核心，简单来说，它其实就是一段可以执行的代码，可以用来做很多事情。&lt;/p>
&lt;blockquote>
&lt;p>比如，你在 python 3.7 环境下写了一个 python 项目放到了 GitHub 上，但是考虑到其他用户的生产环境各异，可能在不同的环境中运行结果都不一样，甚至无法安装，这时你总不能在自己电脑上把所有的 python 环境都测试一遍吧
但是如果有了 GitHub Actions，你可以在 runner 服务器上部署一段 actions 代码来自动完成这项任务。你不仅可以指定它的操作系统（支持 Windows Server 2019、Ubuntu 18.04、Ubuntu 16.04 和 macOS Catalina 10.15），还可以指定触发时机、指定 python 版本、安装其他库等等
此外，它还可以用来做很多有趣的事，比如当有人向仓库里提交 issue 时，给你的微信发一条消息；爬取课程表，每天早上准时发到你的邮箱；当向 master 分支提交代码时，自动构建 Docker 镜像并打上标签发布到 Docker Hub 上 ……&lt;/p>
&lt;/blockquote>
&lt;p>慢慢的，你会发现很多操作在不同项目里面是类似的，完全可以共享。GitHub 也注意到了这一点，于是它允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。如果我们需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个 CI/CD 过程，就变成了一个个 action 的组合。这就是 GitHub Actions 最特别的地方。&lt;/p>
&lt;blockquote>
&lt;p>总而言之，GitHub Actions 就是为我们提供了一个高效易用的 CI/CD 工作流，帮助我们自动构建、测试、部署我们的代码&lt;/p>
&lt;/blockquote>
&lt;p>GitHub 做了一个官方市场(暂且称为 Actions Hub)，在这里可以搜索到其他人提交的 Actions。另外，还有一个名为 &lt;a href="https://github.com/shink/actions-bot">awesome-actions&lt;/a> 的仓库，搜罗了不少好用的 actions。&lt;/p>
&lt;p>既然 actions 是代码仓库，就有版本的概念，用户可以引用某个具体版本的 action。比如下面的例子，用的就是 Git 的指针的概念。&lt;/p>
&lt;pre>&lt;code>actions/setup-node@74bc508 # 指向一个 commit
actions/setup-node@v1.0 # 指向一个标签
actions/setup-node@master # 指向一个分支
&lt;/code>&lt;/pre>
&lt;h2 id="actions-基本概念">Actions 基本概念&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>Workflow(工作流程)&lt;/strong> # 持续集成一次运行的过程，就是一个 workflow。
&lt;ul>
&lt;li>&lt;strong>Job(任务)&lt;/strong> # 一个 Workflow 由一个或多个 Jobs 构成，含义是一次持续集成的运行，可以完成多个任务。
&lt;ul>
&lt;li>&lt;strong>Step(步骤)&lt;/strong> # 每个 job 由多个 Step 构成，一步步完成。
&lt;ul>
&lt;li>**Action(动作) **# 每个 step 可以依次执行一个或多个命令（action）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>runner(运行器)&lt;/strong> # 运行 Workflow 中 JOB 的环境。通常由 Workflow 文件中的 &lt;code>.jobs.JOB_ID.runs-on&lt;/code> 字段指定。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Event(事件)&lt;/strong> # 触发 Workflow 的特定活动。比如，推送新的提交到仓库或者创建 PR，甚至可以配置 cron 定时触发 Workflow&lt;/li>
&lt;/ul>
&lt;h3 id="workflow">Workflow&lt;/h3>
&lt;p>与 Jenkins、Drone 这类 CI/CD 工具一样，GitHub Actions 也有一个配置文件，用来定义要执行的操作，这个配置文件叫做 &lt;strong>Workflow 文件&lt;/strong>，需要默认存放在代码仓库的 &lt;strong>.github/workflows&lt;/strong> 目录中。&lt;/p>
&lt;p>Workflow 文件用来定义 GitHub Actions 要执行的操作，需要存放在代码仓库的 &lt;code>.github/workflows/*.yml&lt;/code> 目录中。&lt;/p>
&lt;p>Workflow 文件是 YAML 格式，后缀名必须统一为 &lt;code>.yml&lt;/code>。一个代码库可以有多个 workflow 文件。GitHub 只要发现 .github/workflows 目录中有 .yml 文件，就会自动根据该文件的配置运行工作流 。&lt;/p>
&lt;h1 id="actions-关联文件与配置">Actions 关联文件与配置&lt;/h1>
&lt;p>&lt;strong>./.github/workflows&lt;/strong> #&lt;/p>
&lt;h1 id="简单示例">简单示例&lt;/h1>
&lt;ol>
&lt;li>从 GitHub 上的仓库，在 .github/workflows 目录中创建一个名为 github-actions-demo.yml 的新文件。 更多信息请参阅“&lt;a href="https://docs.github.com/cn/github/managing-files-in-a-repository/creating-new-files">创建新文件&lt;/a>”。&lt;/li>
&lt;li>将以下 YAML 内容复制到 github-actions-demo.yml 文件中：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">GitHub Actions Demo&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">on&lt;/span>: [&lt;span style="color:#ae81ff">push]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">jobs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">Explore-GitHub-Actions&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 指定这个运行这个 job 的操作系统，类似 Dockerfile 中的 FORM 指令。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">runs-on&lt;/span>: &lt;span style="color:#ae81ff">ubuntu-latest&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">steps&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">run&lt;/span>: &lt;span style="color:#ae81ff">echo &amp;#34;🎉 The job was automatically triggered by a ${{ github.event_name }} event.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">run&lt;/span>: &lt;span style="color:#ae81ff">echo &amp;#34;🐧 This job is now running on a ${{ runner.os }} server hosted by GitHub!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">run&lt;/span>: &lt;span style="color:#ae81ff">echo &amp;#34;🔎 The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 该步骤使用一个actions 官方发布的名为 checkout 的 Action。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 这个 Action 用来将指定仓库的代码同步到工作流的 runner 中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 只要 runner 中有代码了，后续如何操作，就可以自己随便搞了~&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Check out repository code&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">actions/checkout@v2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">run&lt;/span>: &lt;span style="color:#ae81ff">echo &amp;#34;💡 The ${{ github.repository }} repository has been cloned to the runner.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">run&lt;/span>: &lt;span style="color:#ae81ff">echo &amp;#34;🖥️ The workflow is now ready to test your code on the runner.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">List files in the repository&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">run&lt;/span>: |&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &lt;/span> &lt;span style="color:#ae81ff">ls ${{ github.workspace }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">run&lt;/span>: &lt;span style="color:#ae81ff">echo &amp;#34;🍏 This job&amp;#39;s status is ${{ job.status }}.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>滚动到页面底部，然后选择 Create a new branch for this commit and start a pull request（为此提交创建一个新分支并开始拉取请求）。 然后，若要创建拉取请求，请单击 Propose new file（提议新文件）。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hd4aro/1627537717320-0a2fe106-9eda-4c6f-a81b-6a5837803589.png" alt="image.png">&lt;/li>
&lt;/ol>
&lt;p>向仓库的分支提交工作流程文件会触发 push 事件并运行工作流程。&lt;/p>
&lt;h2 id="查看工作流程结果">查看工作流程结果&lt;/h2>
&lt;ol>
&lt;li>在 GitHub 上，导航到仓库的主页面。&lt;/li>
&lt;li>在仓库名称下，单击 Actions（操作）。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hd4aro/1627537717252-5a465a80-ace7-4a19-b689-c8a145ed90ee.png" alt="image.png">&lt;/li>
&lt;li>在左侧边栏中，单击您想要查看的工作流程。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hd4aro/1627537717301-b7808d18-7c4f-40cc-85d4-83ef97121511.png" alt="image.png">&lt;/li>
&lt;li>从工作流程运行列表中，单击要查看的运行的名称。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hd4aro/1627537717306-2e079ccf-8130-47fd-9642-f989e7b5fa74.png" alt="image.png">&lt;/li>
&lt;li>在 Jobs（作业）下，单击 Explore-GitHub-Actions 作业。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hd4aro/1627537717287-fecb853f-8ee7-4868-81e3-7c843f665bcd.png" alt="image.png">&lt;/li>
&lt;li>日志显示每个步骤的处理方式。 展开任何步骤以查看其细节。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hd4aro/1627537718475-e6315bfa-71e1-48e5-9514-16a822265b81.png" alt="image.png">&lt;/li>
&lt;/ol>
&lt;h2 id="更多工作流程模板">更多工作流程模板&lt;/h2>
&lt;p>GitHub 提供预配置的工作流程模板，您可以自定义以创建自己的持续集成工作流程。 GitHub 分析代码并显示可能适用于您的仓库的 CI 模板。 例如，如果仓库包含 Node.js 代码，您就会看到 Node.js 项目的建议。 您可以使用工作流程模板作为基础来构建自定义工作流程，或按原样使用模板。
您可以在 &lt;a href="https://github.com/actions/starter-workflows">actions/starter-workflows&lt;/a> 仓库中浏览工作流程模板的完整列表。&lt;/p>
&lt;h2 id="后续步骤">后续步骤&lt;/h2>
&lt;p>每次将代码推送到分支时，您刚刚添加的示例工作流程都会运行，并显示 GitHub Actions 如何处理仓库的内容。 但是，这只是您可以对 GitHub Actions 执行操作的开始：&lt;/p>
&lt;ul>
&lt;li>您的仓库可以包含多个基于不同事件触发不同任务的工作流程。&lt;/li>
&lt;li>您可以使用工作流程安装软件测试应用程序，并让它们自动在 GitHub 的运行器上测试您的代码。&lt;/li>
&lt;/ul>
&lt;p>GitHub Actions 可以帮助您自动执行应用程序开发过程的几乎每个方面。 准备好开始了吗？ 以下是一些帮助您对 GitHub Actions 执行后续操作的有用资源：&lt;/p></description></item><item><title>Docs: GitHub 技巧</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/github/github-%E6%8A%80%E5%B7%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/github/github-%E6%8A%80%E5%B7%A7/</guid><description>
&lt;h1 id="管理所有通知">管理所有通知&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cplu4a/1662610871922-964b6726-be46-4fc9-b450-f3705aed8174.png" alt="image.png">&lt;/p>
&lt;h1 id="管理所有已经订阅的-issue">管理所有已经订阅的 issue&lt;/h1>
&lt;p>&lt;a href="https://github.com/notifications/subscriptions">https://github.com/notifications/subscriptions&lt;/a>&lt;/p>
&lt;h1 id="搜索用户评论过的内容">搜索用户评论过的内容&lt;/h1>
&lt;p>commenter:USERNAME&lt;/p>
&lt;h1 id="明确搜索仓库标题仓库描述readme">明确搜索仓库标题、仓库描述、README&lt;/h1>
&lt;p>GitHub 提供了便捷的搜索方式，可以限定只搜索仓库的标题、或者描述、README 等。&lt;/p>
&lt;p>以 Spring Cloud 为例，一般一个仓库，大概是这样的&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cplu4a/1616903574584-c6483e74-4756-4303-96d8-53ff32e333c1.jpeg" alt="">&lt;/p>
&lt;p>其中，红色箭头指的两个地方，分别是仓库的名称和描述。咱们可以直接限定关键字只查特定的地方。比如咱们只想查找仓库名称包含 spring cloud 的仓库，可以使用语法&lt;/p>
&lt;p>in:name 关键词&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cplu4a/1616903574564-8f67c6a5-a719-4880-8e05-5467aada9b7c.jpeg" alt="">&lt;/p>
&lt;p>如果想查找描述的内容，可以使用这样的方式：&lt;/p>
&lt;p>in:descripton 关键词&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cplu4a/1616903574564-ac24da6d-574a-456b-87fb-507bbe8fc444.jpeg" alt="">&lt;/p>
&lt;p>这里就是搜索上面项目描述的内容。&lt;/p>
&lt;p>一般项目，都会有个 README 文件，如果要查该文件包含特定关键词的话，我想你猜到了&lt;/p>
&lt;p>in:readme 关键词&lt;/p>
&lt;h1 id="明确搜索-starfork-数大于多少的">明确搜索 star、fork 数大于多少的&lt;/h1>
&lt;p>一个项目 star 数的多少，一般代表该项目有受欢迎程度。虽然现在也有垃圾项目刷 star ，但毕竟是少数， star 依然是个不错的衡量标准。&lt;/p>
&lt;p>stars: &amp;gt; 数字 关键字。&lt;/p>
&lt;p>比如咱们要找 star 数大于 3000 的 Spring Cloud 仓库，就可以这样&lt;/p>
&lt;p>stars:&amp;gt;3000 spring cloud&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cplu4a/1616903574567-e0f24105-b02a-46d7-b633-5070170810e8.jpeg" alt="">&lt;/p>
&lt;p>如果不加 &amp;gt;= 的话，是要精确找 star 数等于具体数字的，这个一般有点困难。&lt;/p>
&lt;p>如果要找在指定数字区间的话，使用&lt;/p>
&lt;p>stars: 10..20 关键词&lt;/p>
&lt;p>fork 数同理，将上面的 stars 换成 fork，其它语法相同&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cplu4a/1616903574573-42bb52aa-c87d-454b-bac7-68525db88957.jpeg" alt="">&lt;/p>
&lt;ol start="3">
&lt;li>明确搜索仓库大小的&lt;/li>
&lt;/ol>
&lt;p>比如你只想看个简单的 Demo，不想找特别复杂的且占用磁盘空间较多的，可以在搜索的时候直接限定仓库的 size 。&lt;/p>
&lt;p>使用方式：&lt;/p>
&lt;p>size:&amp;gt;=5000 关键词&lt;/p>
&lt;p>这里注意下，这个数字代表 K, 5000 代表着 5M。&lt;/p>
&lt;h1 id="明确仓库是否还在更新维护">明确仓库是否还在更新维护&lt;/h1>
&lt;p>我们在确认是否要使用一些开源产品，框架的时候，是否继续维护是很重要的一点。如果已经过时没人维护的东西，踩了坑就不好办了。而在 GitHub 上找项目的时候，不再需要每个都点到项目里看看最近 push 的时间，直接在搜索框即可完成。&lt;/p>
&lt;p>元旦刚过，比如咱们要找临近年底依然在勤快更新的项目，就可以直接指定更新时间在哪个时间前或后的&lt;/p>
&lt;p>通过这样一条搜索 pushed:&amp;gt;2019-01-03 spring cloud&lt;/p>
&lt;p>咱们就找到了 1 月 3 号之后，还在更新的项目。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cplu4a/1616903574580-8fddcda2-950e-41a8-9a31-6601402757d4.jpeg" alt="">&lt;/p>
&lt;p>你是想找指定时间之前或之后创建的仓库也是可以的，把 pushed 改成 created 就行。&lt;/p>
&lt;h1 id="明确搜索仓库的-license">明确搜索仓库的 LICENSE&lt;/h1>
&lt;p>咱们经常使用开源软件，一定都知道，开源软件也是分不同的「门派」不同的 LICENSE。开源不等于一切免费，不同的许可证要求也大不相同。 2018 年就出现了 Facebook 修改 React 的许可协议导致各个公司纷纷修改自己的代码，寻找替换的框架。&lt;/p>
&lt;p>例如咱们要找协议是最为宽松的 Apache License 2 的代码，可以这样&lt;/p>
&lt;p>license:apache-2.0 spring cloud&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cplu4a/1616903574564-632dcc34-2b27-41e6-886a-5530636a94ee.jpeg" alt="">&lt;/p>
&lt;p>其它协议就把 apache-2.0 替换一下即可，比如换成 mit 之类的。&lt;/p>
&lt;h1 id="明确搜索仓库的语言">明确搜索仓库的语言&lt;/h1>
&lt;p>比如咱们就找 Java 的库， 除了像上面在左侧点击选择之外，还可以在搜索中过滤。像这样：&lt;/p>
&lt;p>language:java 关键词&lt;/p>
&lt;p>7.明确搜索某个人或组织的仓库&lt;/p>
&lt;p>比如咱们想在 GitHub 上找一下某个大神是不是提交了新的功能，就可以指定其名称后搜索，例如咱们看下 Josh Long 有没有提交新的 Spring Cloud 的代码，可以这样使用&lt;/p>
&lt;p>user:joshlong&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cplu4a/1616903574568-a117b1af-b67c-40c2-869f-7fdaf3b9edb9.jpeg" alt="">&lt;/p>
&lt;p>组合使用一下，把 Java 项目过滤出来，多个查询之间「空格」分隔即可。&lt;/p>
&lt;p>user:joshlong language:java&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cplu4a/1616903574577-960173b0-ec57-4b82-9d35-cb69e28bb633.jpeg" alt="">&lt;/p>
&lt;p>找某个组织的代码话，可以这样：&lt;/p>
&lt;p>org:spring-cloud 就可以列出具体 org 的仓库。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/cplu4a/1616903574593-1a151f42-a735-49ae-8372-5e17bfd2a519.jpeg" alt="">&lt;/p></description></item><item><title>Docs: github上fork了别人的项目后，再同步更新别人的提交.github上fork了别人的项目后，再同步更新别人的提交</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/github/github%E4%B8%8Afork%E4%BA%86%E5%88%AB%E4%BA%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%86%8D%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E5%88%AB%E4%BA%BA%E7%9A%84%E6%8F%90%E4%BA%A4.github%E4%B8%8Afork%E4%BA%86%E5%88%AB%E4%BA%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%86%8D%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E5%88%AB%E4%BA%BA%E7%9A%84%E6%8F%90%E4%BA%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/github/github%E4%B8%8Afork%E4%BA%86%E5%88%AB%E4%BA%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%86%8D%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E5%88%AB%E4%BA%BA%E7%9A%84%E6%8F%90%E4%BA%A4.github%E4%B8%8Afork%E4%BA%86%E5%88%AB%E4%BA%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%86%8D%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E5%88%AB%E4%BA%BA%E7%9A%84%E6%8F%90%E4%BA%A4/</guid><description>
&lt;h1 id="heading">&lt;/h1>
&lt;p>我从 github 网站和用 git 命令两种方式说一下。&lt;/p>
&lt;p>github 网站上操作&lt;/p>
&lt;ol>
&lt;li>
&lt;p>打开自己的仓库，进入 code 下面。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>点击 new pull request 创建。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/np6g3g/1616903559723-76f8c4f1-6c02-4145-829f-4b8ddb92de72.jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>选择 base fork&lt;/p>
&lt;/li>
&lt;li>
&lt;p>选择 head fork&lt;/p>
&lt;/li>
&lt;li>
&lt;p>点击 Create pull request，并填写创建信息。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/np6g3g/1616903559704-28a10f3c-1397-40f9-9c67-0d9bc61da316.jpeg" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/np6g3g/1616903559698-ff01b1e5-f9b9-406a-938b-3fca1309a5c0.jpeg" alt="">&lt;/p>
&lt;ol start="6">
&lt;li>点击 Merge pull request 合并从源 fork 来的代码。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/np6g3g/1616903559689-63e77098-f4a1-4ea4-84c4-f514f4642fec.jpeg" alt="">&lt;/p>
&lt;ol start="7">
&lt;li>完成。&lt;/li>
&lt;/ol>
&lt;p>用 git 命令操作&lt;/p>
&lt;ol>
&lt;li>用 git remote 查看远程主机状态&lt;/li>
&lt;/ol>
&lt;p>git remote -v git remote add upstream &lt;a href="mailto:git@github.com">git@github.com&lt;/a>:xxx/xxx.gitgit fetch upstreamgit merge upstream/mastergit push&lt;/p>
&lt;ul>
&lt;li>
&lt;p>1&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2&lt;/p>
&lt;/li>
&lt;li>
&lt;p>3&lt;/p>
&lt;/li>
&lt;li>
&lt;p>4&lt;/p>
&lt;/li>
&lt;li>
&lt;p>5&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: GitLab</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/gitlab/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/gitlab/</guid><description>
&lt;h1 id="gitlab-介绍">GitLab 介绍&lt;/h1>
&lt;p>&lt;a href="https://www.qikqiak.com/post/gitlab-install-on-k8s/">https://www.qikqiak.com/post/gitlab-install-on-k8s/&lt;/a>&lt;/p>
&lt;p>官方文档：&lt;a href="https://docs.gitlab.com/">https://docs.gitlab.com/&lt;/a>&lt;/p>
&lt;h1 id="gitlab-部署">GitLab 部署&lt;/h1>
&lt;p>官方文档：&lt;a href="https://docs.gitlab.com/ee/install/README.html">https://docs.gitlab.com/ee/install/README.html&lt;/a>&lt;/p>
&lt;h2 id="通过官方的-linux-软件包安装">通过官方的 linux 软件包安装&lt;/h2>
&lt;p>&lt;a href="https://about.gitlab.com/install/">https://about.gitlab.com/install/&lt;/a> 根据该页面选择想要运行 GitLab 的 Linux 发行版，可以通过 yum、apt 等方式直接安装 GitLab 及其所需的依赖。&lt;/p>
&lt;h2 id="使用-docker-运行-gitlab">使用 Docker 运行 GitLab&lt;/h2>
&lt;p>官方文档：&lt;a href="https://docs.gitlab.com/omnibus/docker/">https://docs.gitlab.com/omnibus/docker/&lt;/a>&lt;/p>
&lt;pre>&lt;code>docker run --detach \
--hostname 10.10.100.151 \
--publish 443:443 --publish 80:80 --publish 9022:22 \
--name gitlab \
--restart always \
--volume /root/gitlab/config:/etc/gitlab \
--volume /root/gitlab/logs:/var/log/gitlab \
--volume /root/gitlab/data:/var/opt/gitlab \
gitlab/gitlab-ce:latest
&lt;/code>&lt;/pre>
&lt;p>部署完成后，使用 root 和 第一次打开 web 页面时设置的密码，即可登录管理员账户。&lt;/p></description></item><item><title>Docs: Go</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/golang/go">GitHub 项目，golang/go&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://golang.org/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cs.opensource.google/go">Google 开放源代码&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/avelino/awesome-go">GitHub 项目，avelino/awesome-go&lt;/a>(收录了优秀的 Go 框架、库、软件)
&lt;ul>
&lt;li>&lt;a href="https://github.com/yinggaozhen/awesome-go-cn">中文版，GitHub 项目，yinggaozhen/awesome-go-cn&lt;/a>&lt;/li>
&lt;li>另一个 go awesome: &lt;a href="https://github.com/shockerli/go-awesome">https://github.com/shockerli/go-awesome&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Go 是一种开源编程语言，可以轻松构建 &lt;strong>simple(简单)&lt;/strong>、**reliable(可靠) **和 **efficient(高效) **的软件。&lt;/p>
&lt;h2 id="学习资料">学习资料&lt;/h2>
&lt;p>&lt;a href="https://go.dev/tour">Go 语言之旅&lt;/a>(官方在线教程)
&lt;a href="https://go.dev/doc/faq">Go 官方 FAQ&lt;/a>
&lt;a href="https://gobyexample.com/?tdsourcetag=s_pctim_aiomsg">Go by Example&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://gobyexample-cn.github.io/">中文 Go by Example&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/golang-china">GitHub 组织，golang-china&lt;/a>(Go 语言中国)
&lt;a href="https://mp.weixin.qq.com/s/pAkjxK6N4shTEtHXQbxChg">公众号-HelloGitHub，适合 Go 新手学习的开源项目&lt;/a>
&lt;a href="https://www.topgoer.cn/">地鼠文档&lt;/a>
系列文章&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://coolshell.cn/articles/series/go%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%bc%8f">Go 编程模式&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>电子书&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/unknwon/the-way-to-go_ZH_CN">GitHub 项目，unknowon/the-way-to-go&lt;/a>(Go 入门指南)&lt;/li>
&lt;li>&lt;a href="https://github.com/gopl-zh/gopl-zh.github.com">GitHub 项目，gopl-zh/gopl-zh.github.com&lt;/a>(Go 语言圣经)
&lt;ul>
&lt;li>&lt;a href="https://www.k8stech.net/gopl/chapter0/">The Go Programming Language&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>视频&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1hv411x7we?spm_id_from=333.999.0.0&amp;amp;vd_source=708696360de7266de8f3911eef0f7448">B 站-幼麟实验室-Golang 合辑&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/avelino/awesome-go">
&lt;/a>&lt;/p>
&lt;h1 id="hello-world">Hello World&lt;/h1>
&lt;p>代码：&lt;code>hello_world.go&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello World&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># go run hello_world.go&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Hello World
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="go-语言关键字">Go 语言关键字&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://go.dev/ref/spec#Keywords">官方文档,参考-规范-关键字&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Go 语言非常简单，只有 25 个&lt;code>关键字(Keywords)&lt;/code>可以使用，记住这 25 个关键字，就掌握了最基本的 Go 语言用法。这些关键字是 go 语言保留的，不能用作标识符&lt;/p>
&lt;p>&lt;code>关键字&lt;/code>在编程语言中是指该语言的一个功能，比如下文面的 &lt;code>var&lt;/code>，就是指声明一个变量，&lt;code>func&lt;/code> 就是定义一个函数等等。&lt;/p>
&lt;blockquote>
&lt;p>Note: if-else 算两个关键字所以在这里一共只写了 24 个。&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>&lt;strong>break&lt;/strong> # 控制结构&lt;/li>
&lt;li>&lt;strong>case&lt;/strong> # 控制结构&lt;/li>
&lt;li>&lt;strong>chan&lt;/strong> # 用于 channel 通讯&lt;/li>
&lt;li>&lt;strong>const&lt;/strong> # 语言基础里面的常量申明&lt;/li>
&lt;li>&lt;strong>continue&lt;/strong> # 用在 for 控制结构中，用以忽略本次循环的后续所有逻辑，执行下一次循环&lt;/li>
&lt;li>&lt;strong>default&lt;/strong> # 控制结构&lt;/li>
&lt;li>**defer **# 用于在函数退出之前执行某语句的功能&lt;/li>
&lt;li>&lt;strong>fallthrough&lt;/strong> # 控制结构&lt;/li>
&lt;li>&lt;strong>for&lt;/strong> # 控制结构&lt;/li>
&lt;li>**func **#** **用于定义函数和方法&lt;/li>
&lt;li>**go **# 用于并发&lt;/li>
&lt;li>&lt;strong>goto&lt;/strong> 控制结构&lt;/li>
&lt;li>**if-else **#** **控制结构&lt;/li>
&lt;li>&lt;strong>import&lt;/strong> 用于定义该文件引用某个包&lt;/li>
&lt;li>&lt;strong>interface&lt;/strong> # 用于定义接口&lt;/li>
&lt;li>**map **# 用于声明 map 类型数据&lt;/li>
&lt;li>&lt;strong>package&lt;/strong> # 用于定义该文件所属的包&lt;/li>
&lt;li>&lt;strong>range&lt;/strong> # 用于读取 slice、map、channel 数据&lt;/li>
&lt;li>**return **# 用于从函数返回。有时候也用来直接跳出当前函数，回到主程序继续执行&lt;/li>
&lt;li>&lt;strong>select&lt;/strong> # 用于选择不同类型的通讯&lt;/li>
&lt;li>**struct **# 用于定义抽象数据类型&lt;/li>
&lt;li>&lt;strong>switch&lt;/strong> # 控制结构&lt;/li>
&lt;li>**type **# 用于 Type Declarations(类型声明)，有两种形式：&lt;/li>
&lt;li>Definitions(定义) 自定义类型&lt;/li>
&lt;li>Declarations(声明) 一个类型的别名。
&lt;ol>
&lt;li>其实所谓的类型的别名，也可以当作一种自定义的类型。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>**var **# 用于 Declarations(声明) 变量&lt;/li>
&lt;/ol>
&lt;h1 id="go-语言规范">Go 语言规范&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/golang/go/wiki/CodeReviewComments">GitHub 项目 Wiki，golang/go-Wiki-Go 代码审查&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://go.dev/ref/spec">官方文档,参考-规范&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://github.com/bekcpear/mypelicanconfandarticles/blob/master/content/Tech/gospec.rst">官方文档,参考-规范 的翻译&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://go.dev/doc/effective_go#names">官方文档，有效的 Go-名称&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://makeoptim.com/golang/effective-go">MakeOptim 博客，Effective Go 中文&lt;/a>(官方文档的中文翻译)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://go.dev/blog/package-names">Go 博客，Package names&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cnblogs.com/laud/p/gopher.html">博客园，不一样的 go 语言-gopher&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>gopher 原意地鼠，在 go 语言的世界里解释为地道的 go 程序员。在其他语言的世界里也有 PHPer，Pythonic 的说法，反而 Java 是个例外。虽然也有 Javaer 之类的说法，但似乎并不被认可。而地道或者说道地，说的是 gopher 写的代码无不透露出 go 的独特气息，比如项目结构、命名方式、代码格式、编码风格、构建方式等等。用 gopher 的话说，用 go 编写代码就像是在画一幅中国山水画，成品美不胜收，心旷神怡。&lt;/p>
&lt;h2 id="notation表示法">Notation(表示法)&lt;/h2>
&lt;p>Go 语言的语法遵从 &lt;a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF&lt;/a> 表示法&lt;/p>
&lt;h2 id="环境变量">环境变量&lt;/h2>
&lt;p>gopher 第一条：把东西放对地方。&lt;/p>
&lt;p>go 程序的运行，需要依赖于两个基础的环境变量，GOROOT 与 GOPATH。环境变量几乎在各类编程语言中都存在，比如 java 的 JAVA_HOME，其实也就是编译器及相关工具或标准库所在目录。但 go 除了 GOROOT 之外，还增加了 GOPATH，它指的是 go 程序依赖的第三方库或自有库所在目录，以指示编译器从这些地方找到依赖。GOPATH 支持多个目录，通常一个目录就是一个项目，并且 GOPATH 目录按约定由 src、pkg、bin 三个目录组成。gopher 们的做法是定义 Global GOPATH、Project GOPATH，而更大的项目还会定义 Module GOPATH。当使用 go get 下载依赖时，会选择 GOPATH 环境变量中的第一个目录存放依赖包。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>变量&lt;/th>
&lt;th>含义&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GOROOT&lt;/td>
&lt;td>go 运行环境根目录&lt;/td>
&lt;td>通常指 go sdk 安装目录，包含编译器、官方工具及标准库&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GOPATH&lt;/td>
&lt;td>工作环境目录列表&lt;/td>
&lt;td>通常指第三方库&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="项目结构">项目结构&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/golang-standards/project-layout">GitHub 项目，golang-standards/project-layout&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://makeoptim.com/golang/standards/project-layout">MakeOptim 博客，golang 编程规范-项目目录结构&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/346573562">知乎，该如何组织 Go 项目结构？&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html">Package Oriented Design&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>gopher 第二条：按东西放在约定的地方。&lt;/p>
&lt;p>不论采用何种编程语言，良好的项目组织结构都至关重要，因为这将直接影响项目内部依赖的复杂程度以及项目对外提供 API 等服务的灵活性等。最好在项目初期便制定好项目结构约定，甚至可以为其开发脚手架之类的工具来生成项目模板，让开发者尽量按照统一的规范参与项目。&lt;/p>
&lt;p>一个常见的 Go 应用项目布局，通常有如下结构：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-latex" data-lang="latex">&lt;span style="display:flex;">&lt;span>- my-go-project
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - cmd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - pkg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - internal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - go.mod &amp;amp;&amp;amp; go.sum
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - Makefile
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 cmd 与 pkg 目录是最常见的。一个项目如果具有多个功能，比如 &lt;a href="https://github.com/kubernetes/kubernetes">kubernetes&lt;/a> 项目，具有多个组件，所有组件的入口都在 cmd 目录中，并以组件名命名其下的目录名。而每个组件所调用的各种功能，通常都是放在 pkg 目录下，一个功能一个目录，通常来说，pkg 目录是一个项目中代码量最多的地方。&lt;/p>
&lt;h3 id="cmd">cmd&lt;/h3>
&lt;p>cmd 包是项目的主干，是编译构建的入口，&lt;code>main()&lt;/code> 所在文件通常放置在此处。一个典型的 cmd 包的目录结构如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-latex" data-lang="latex">&lt;span style="display:flex;">&lt;span>- cmd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - app1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - main.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - app2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - main.go
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从上述例子可以看出，cmd 下可以允许挂载多个需要编译的应用，只需要在不同的包下编写 main 文件即可。需要注意的是，cmd 中的代码应该尽量「保持简洁」，&lt;code>main()&lt;/code> 函数中可能仅仅是参数初始化、配置加载、服务启动的操作。&lt;/p>
&lt;h3 id="pkg">pkg&lt;/h3>
&lt;p>pkg 中存放的是可供项目内部/外部所使用的公共性代码，例如：用来连接第三方服务的 client 代码等。也有部分项目将该包命名为 lib，例如：&lt;a href="https://link.zhihu.com/?target=https%3A//github.com/hashicorp/consul">consul 项目&lt;/a> ，所表示的含义其实相同。&lt;/p>
&lt;h3 id="internal">internal&lt;/h3>
&lt;p>internal 包主要用处在于提供一个项目级别的代码保护方式，存放在其中的代码仅供项目内部使用。具体使用的规则是：&amp;hellip;/a/b/c/internal/d/e/f 仅仅可以被&amp;hellip;/a/b/c 下的目录导入，&amp;hellip;/a/b/g 则不允许。internal 是 Go 1.4 版本中引入的特性，更多信息可以参考&lt;a href="https://link.zhihu.com/?target=https%3A//golang.org/doc/go1.4%23internalpackages">这里&lt;/a>。
在 internal 内部可以继续通过命名对目录的共享范围做区分，例如 internal/myapp 表示该目录下的代码是供 myapp 应用使用的；internal/pkg 表示该目录下的代码是可以供项目内多个应用使用的。&lt;/p>
&lt;h3 id="gomod--gosum">go.mod &amp;amp;&amp;amp; go.sum&lt;/h3>
&lt;p>go.mod 与 go.sum 是采用 go modules 进行依赖管理所生成的配置文件。go modules 是 Go 1.11 版本中引入的版本管理功能，目前已经是 go 依赖管理的主流方式，所以此处不再讨论 vendor，dep 等依赖管理方式所生成的目录。&lt;/p>
&lt;h3 id="makefile">Makefile&lt;/h3>
&lt;p>Makefile 文件通常存放项目的编译部署脚本。Go 的编译命令虽然简单，但总是手写命令还是效率低下，因此使用 Makefile 写编译部署脚本是工程实践中常见的方式。&lt;/p>
&lt;h3 id="服务端应用程序目录">服务端应用程序目录&lt;/h3>
&lt;h4 id="api">api&lt;/h4>
&lt;p>项目对外提供和依赖的 API 文件。比如：OpenAPI/Swagger specs, JSON schema 文件, protocol 定义文件等。
比如，&lt;a href="https://github.com/kubernetes/kubernetes/tree/master/api">Kubernetes&lt;/a> 项目的 api 目录结构如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>api
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── api-rules
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── xxx.plist
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── openapi-spec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── swagger.json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因此，在 go 中用的比较多的 gRPC proto 文件，也比较适合放在 api 目录下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>api
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── protobuf-spec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── test.pb.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── test.proto
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="web-应用程序目录">Web 应用程序目录&lt;/h3>
&lt;h4 id="web">web&lt;/h4>
&lt;p>Web 应用程序特定的组件，比如 静态资源、服务器端模板和单页应用&lt;/p>
&lt;h3 id="通用应用程序目录">通用应用程序目录&lt;/h3>
&lt;h4 id="build">build&lt;/h4>
&lt;p>打包和持续集成所需的文件。&lt;/p>
&lt;ul>
&lt;li>build/ci：存放持续集成的配置和脚本，如果持续集成平台对配置文件有路径要求，则可将其 link 到指定位置。&lt;/li>
&lt;li>build/package：存放 AMI、Docker、系统包（deb、rpm、pkg）的配置和脚本等。&lt;/li>
&lt;/ul>
&lt;p>例子：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/cockroachdb/cockroach/tree/master/build">https://github.com/cockroachdb/cockroach/tree/master/build&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="configs">configs&lt;/h4>
&lt;p>配置文件模板或默认配置。&lt;/p>
&lt;h4 id="deployments">deployments&lt;/h4>
&lt;p>IaaS，PaaS，系统和容器编排部署配置和模板（docker-compose，kubernetes/helm，mesos，terraform，bosh）。请注意，在某些存储库中（尤其是使用 kubernetes 部署的应用程序），该目录的名字是 /deploy。&lt;/p>
&lt;h4 id="init">init&lt;/h4>
&lt;p>系统初始化（systemd、upstart、sysv）和进程管理（runit、supervisord）配置。&lt;/p>
&lt;h4 id="scripts">scripts&lt;/h4>
&lt;p>用于执行各种构建，安装，分析等操作的脚本。
这些脚本使根级别的 Makefile 变得更小更简单，例如：&lt;a href="https://github.com/hashicorp/terraform/blob/master/Makefile">https://github.com/hashicorp/terraform/blob/master/Makefile&lt;/a>。&lt;/p>
&lt;h4 id="test">test&lt;/h4>
&lt;p>外部测试应用程序和测试数据。随时根据需要构建 /test 目录。对于较大的项目，有一个数据子目录更好一些。例如，如果需要 Go 忽略目录中的内容，则可以使用 /test/data 或 /test/testdata 这样的目录名字。请注意，Go 还将忽略以“.”或“_”开头的目录或文件，因此可以更具灵活性的来命名测试数据目录。&lt;/p>
&lt;h3 id="其他目录">其他目录&lt;/h3>
&lt;h4 id="assets">assets&lt;/h4>
&lt;p>项目中使用的其他资源（图像、logo 等）。&lt;/p>
&lt;h4 id="docs">docs&lt;/h4>
&lt;p>设计和用户文档（除了 godoc 生成的文档）。&lt;/p>
&lt;h4 id="examples">examples&lt;/h4>
&lt;p>应用程序或公共库的示例程序。&lt;/p>
&lt;h4 id="githooks">githooks&lt;/h4>
&lt;p>Git 钩子。&lt;/p>
&lt;h4 id="third_party">third_party&lt;/h4>
&lt;p>外部辅助工具，fork 的代码和其他第三方工具（例如：Swagger UI）。&lt;/p>
&lt;h4 id="tools">tools&lt;/h4>
&lt;p>此项目的支持工具。请注意，这些工具可以从 /pkg 和 /internal 目录导入代码。
例子：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/istio/istio/tree/master/tools">https://github.com/istio/istio/tree/master/tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/openshift/origin/tree/master/tools">https://github.com/openshift/origin/tree/master/tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/dapr/dapr/tree/master/tools">https://github.com/dapr/dapr/tree/master/tools&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="website">website&lt;/h4>
&lt;p>如果不使用 Github pages，则在这里放置项目的网站数据。
例子：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/hashicorp/vault/tree/master/website">https://github.com/hashicorp/vault/tree/master/website&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/perkeep/perkeep/tree/master/website">https://github.com/perkeep/perkeep/tree/master/website&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="不应该包含的目录">不应该包含的目录&lt;/h3>
&lt;p>项目中不应该包含 src 目录&lt;/p>
&lt;p>在 Java 项目中，会常见 src 目录，但在 Go 项目中，并不推荐这么做。在 Go 1.11 之前，Go 项目是放在 $GOPATH/src 下，如果项目中再包含 src 目录，那么代码结构就会类似： &lt;code>$GOPATH/src/my-project/src/app.go&lt;/code>的结构，容易造成混淆。在 Go 引入 modules 之后，项目可以不用写在 $GOPATH 下，但是依然不推荐项目中采用&lt;code>src&lt;/code> 来命名目录。&lt;/p>
&lt;h2 id="命名规范">命名规范&lt;/h2>
&lt;p>gopher 第三条：把名字起得 go 一点。&lt;/p>
&lt;p>go 语言的命名与其他语言最大的不同在于首字母的大小写。&lt;/p>
&lt;ul>
&lt;li>大写代表公开（导出，可以在其他包内访问）&lt;/li>
&lt;li>小写代表私有（不导出，只能在包内访问）。&lt;/li>
&lt;/ul>
&lt;p>除此之外，与其他语言并无二致，比如不能以数字开头。而由于关键字、保留字的减少，因而减少了一些命名上的忌讳。更为突出的是，go 语言有一些建议性的命名规范，这也是 gophers 的圣经，理应严格遵守。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>约定&lt;/th>
&lt;th>范围&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>示例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>驼峰命名法&lt;/td>
&lt;td>全局&lt;/td>
&lt;td>统一使用驼峰命名法&lt;/td>
&lt;td>var isLive = false&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>大小写一致&lt;/td>
&lt;td>缩写短语，惯用词&lt;/td>
&lt;td>如 HTML，CSS, HTTP 等&lt;/td>
&lt;td>htmlEscape，HTMLEscape&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>简短命名法&lt;/td>
&lt;td>局部变量&lt;/td>
&lt;td>方法内、循环等使用的局部变量可以使用简短命名&lt;/td>
&lt;td>比如 for 循环中的 i，buf 代表 buffer 等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>参数命名法&lt;/td>
&lt;td>函数参数、返回值、方法接收者&lt;/td>
&lt;td>如果参数类型能说明含义，则参数名可以简短，否则应该采用有文档说明能力的命名&lt;/td>
&lt;td>比如 d Duration，t Time&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>通用命名法&lt;/td>
&lt;td>作用域越大或者使用的地方离声明的地方太远，则应采用清晰有意义的命名&lt;/td>
&lt;td>-&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>导出命名法&lt;/td>
&lt;td>导出变量、函数、结构等&lt;/td>
&lt;td>包名与导出名意义不要重复，同时包的命名要与导出的内容相关，不要使用宽泛的名字，如 common，util&lt;/td>
&lt;td>bytes.Buffer 比 bytes.ByteBuffer 要好&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>文件命名&lt;/td>
&lt;td>go 文件，单元测试文件&lt;/td>
&lt;td>go 文件名尽量以一个单词来命名，多个单词使用下线划分隔，单元测试文件以对应 go 文件名加_test 结尾&lt;/td>
&lt;td>proto_test&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>包命名&lt;/td>
&lt;td>包&lt;/td>
&lt;td>包的一级名称应是顶级域名，二级名称则应是项目名称，项目名称单词间以-分隔&lt;/td>
&lt;td>github.com/mysql&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="代码格式">代码格式&lt;/h2>
&lt;p>gopher 第四条：按统一的格式来。&lt;/p>
&lt;p>在多人协作团队中，统一的代码格式化模板是第一要义。在 Java 语言中，检验新人经验的一大法宝就是他有没有主动索要代码模板。而在 go 语言中，则没有这个必要了。因为 go 已经有默认的代码格式化工具了，而且代码格式化在 go 语言中是强制规范。所以这使得所有 go 程序员写出来的代码格式都是一样的。&lt;/p>
&lt;p>go 默认的代码格式化工具是 gofmt。另外还有一个增强工具 goimport，在 gofmt 的基础上增加了自动删除和引入依赖包。而行长则以不超过 80 个字符为佳，超过请主动以多行展示。&lt;/p>
&lt;h2 id="编码风格">编码风格&lt;/h2>
&lt;p>gopher 第五条：请学会约定&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>项&lt;/th>
&lt;th>约定&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>import&lt;/td>
&lt;td>按标准库、内部包、第三方包的顺序导入包&lt;/td>
&lt;td>只引一个包时使用单行模式，否则使用多行模式&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>变量声明&lt;/td>
&lt;td>如果连续声明多个变量，应放在一起&lt;/td>
&lt;td>参见例子&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>错误处理&lt;/td>
&lt;td>不要忽略每一个 error，即使只是打一行日志&lt;/td>
&lt;td>go 的 error 处理方式与 C 同出一辙，通过返回值来标明错误或异常，引来的争议也很多，甚至官方已经开始酝酿在 go2 解决这个问题&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>长语句打印&lt;/td>
&lt;td>使用格式化方式打印&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>注释规范&lt;/td>
&lt;td>变量、方法、结构等的注释直接加上声明前，并且不要加空行。废弃方法加 Deprecated:即可&lt;/td>
&lt;td>其中的第一行注释会被 godoc 识别为简短介绍，第二行开始则被认为是注释详情。注释对 godoc 的生成至关重要，因此关于注释会有一些技巧，我将在后面用专门的章节探讨&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>多变量声明&lt;/p>
&lt;pre>&lt;code>var (
name string
age int
)
&lt;/code>&lt;/pre>
&lt;p>注释规范&lt;/p>
&lt;pre>&lt;code>// Add 两数相加
// 两个整数相加，并返回和。
func Add(n1, n2 int)int{
return n1 + n2
}
&lt;/code>&lt;/pre>
&lt;h2 id="依赖管理">依赖管理&lt;/h2>
&lt;p>gopher 第六条：使用依赖管理工具管理自有依赖与第三方依赖&lt;/p>
&lt;p>一个语言的生态是否完善甚至是否强大，除了 github 上面的开源项目数量之外，还有一大特征就是是否有优秀的依赖管理工具。依赖管理工具在业界已经是无处不在，yum、maven、gradle、pip、npm、cargo 这些工具的大名如雷贯耳。那么 go 有什么呢？&lt;/p>
&lt;p>早期 go 的依赖是混乱的，因为没有一个工具能得到普遍认可，而官方又迟迟不出来解决问题。历数存在的工具包括 godep、glide、govender 等等。甚至早期还需要使用 GOPATH 来管理依赖，即项目的所有依赖都通过 go get 下载到指定的 GOPATH 中去。当然这种方案还可以撑大多数时间，但随着时间的流逝，随着开发人员的变动，这种管理依赖的弊端就慢慢显现出来。其实这些老路早期的 java 也走过，曾几何时，每个 java 项目里面都会有一个叫 lib 或 libs 的目录，这里放的就是当前项目依赖的包。当 GO 采用 GOPATH 来管理依赖时，开发人员只能被倒逼着用 java 的方式在源码库中自行管理依赖。这样相当于给依赖包做了隔离，同时又具备了版本管理（因为放在源码库）。&lt;/p>
&lt;p>后来在 go1.5 的时候，官方引入了 vender 的概念，其实这也没改变多少，只是官方让大家存放依赖包的目录名称不要乱起了，统一叫 vender 吧。这个方案我觉得比依赖 GOPATH 还糟糕，因为 vendor 目录脱离了版本管理，导致更换依赖包版本很困难，在当前项目对依赖包的版本更新可能会影响其他项目的使用（如果新版本的依赖包有较大变动的话），同时如何将依赖包放到 vendor 下呢？等等。当然官方做出的这些变动可能是想像 maven 那样，推动社区来完成这件事，因而直接推动了上文提到的基于 vendor 的依赖管理工具的诞生。直至后来官方默认的社区做出来 dep，这下安静了，尽管刚开始时也不怎么好用，但有总比没有好。&lt;/p>
&lt;p>go1.11 在 vgo 的基础上，官方推出了 go module。在发布前，官方与社区的大神们还为此开吵，认为官方太不厚道且独断专行。完全忽视 dep 社区的存在，无视 dep 在 go 语言中的地位与贡献。喜欢八卦的朋友们，可搜索《关于 Go Module 的争吵》一览大神是怎么吵架的，也可从中学习他们的思想。&lt;/p>
&lt;p>相对于 java 的依赖管理工具 maven 或 gradle 来说，gradle 是 maven 的升级版，同时带来了 DSL 与元编程的特性，这无疑使得 gradle 异常地强大。但 gradle.io 在国内的可达情况也不尽如人意，好就好在其与 maven 仓库标准的兼容，使得从 maven 转到 gradle 几乎没有额外的成本及阻力。&lt;/p>
&lt;p>扯了这么多，依赖管理对于一门语言是必不可少的。c 有 cmake，java 有 maven、gradle，rust 有 cargo，那么 go 的 dep 或者 module 就用起来吧，看完大神吵架之后，喜欢哪个就选哪个。是不可能产生一个能满足所有人要求的依赖管理工具的，就连号称最牛逼的 cargo 也不例外。在一般的项目中，能用到的依赖管理功能也就那常用的几个而已，对大多数项目来说，适用好用就行。&lt;/p>
&lt;h2 id="构建方式">构建方式&lt;/h2>
&lt;p>gopher 第七条：按需构建&lt;/p>
&lt;p>构建的目标是让代码成为可运行程序。构建的过程应该是低成本并且让人愉悦的，显然 C 在这一方面让人抓狂，而 go 确实做得不错。并且能在任何平台下编译出另外一个平台的可执行程序。不管你的 go 程序是 CLI、GUI、WEB 或者其他形式的网络通讯程序，在 go 的世界里都只需要一个命令构建成可执行程序（依赖也一并被打包），即可在目标系统上运行。在这一点上，java 是望尘莫及了。
下面是用来构建 go 程序常用的参数，其他参数可通过 go help environment 命令查看。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>参数&lt;/th>
&lt;th>值&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>CGO_ENABLED&lt;/td>
&lt;td>0 or 1&lt;/td>
&lt;td>是否支持 cgo 命令，如果 go 代码中有 c 代码，需要设置为 1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GOOS&lt;/td>
&lt;td>darwin, freebsd, linux, windows&lt;/td>
&lt;td>可执行程序运行的目标操作系统&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GOARCH&lt;/td>
&lt;td>386, amd64, arm&lt;/td>
&lt;td>可执行程序运行的目标操作系统架构&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Linux下编译Mac 64位可执行程序&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CGO_ENABLED&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> GOOS&lt;span style="color:#f92672">=&lt;/span>darwin GOARCH&lt;span style="color:#f92672">=&lt;/span>amd64 go build main.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Linux下编译windows 64位可执行程序&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CGO_ENABLED&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> GOOS&lt;span style="color:#f92672">=&lt;/span>windows GOARCH&lt;span style="color:#f92672">=&lt;/span>amd64 go build main.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 如果想减少二进制程序的大小，可以加上-ldflags &amp;#34;-s -w&amp;#34;，但同时会丢掉调试信息，即不能用gdb调试了。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 如果想更进一步减少程序大小，可以使用加壳工具，比如upx&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="版本变化">版本变化&lt;/h1>
&lt;p>Go 1.16 将会弃用 io/ioutil 包，ioutil 包中的功能将会由 io 及 os 包所替代。详见：&lt;a href="https://github.com/golang/go/issues/40025">#40025&lt;/a>、&lt;a href="https://golang.org/doc/go1.16#ioutil">Go 1.16 Release Notes&lt;/a>&lt;/p></description></item><item><title>Docs: Go Module</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/go-module/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/go-module/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://go.dev/ref/mod">官方文档，参考-Go Modules 参考&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/6gJkSyGAFR0v6kow2uVklA">公众号，Go Modules 终极入门&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/benben_2015/article/details/82227338">https://blog.csdn.net/benben_2015/article/details/82227338&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Go Moduel(Go 模块)&lt;/strong> 是实现 &lt;a href="https://en.wikipedia.org/wiki/Modular_programming">Modular Programming(模块化编程)&lt;/a> 的工具。是 Go 语言中正式官宣的项目依赖解决方案，Go modules（前身为 vgo）发布于 Go1.11，成长于 Go1.12，丰富于 Go1.13，正式于 Go1.14 已经准备好，并且可以用在生产上（ready for production）了，Go 官方也鼓励所有用户从其他依赖项管理工具迁移到 Go modules。&lt;/p>
&lt;p>module 是一个相关 Go 包的集合，它是源代码更替和版本控制的单元。模块由源文件形成的 go.mod 文件的根目录定义，包含 go.mod 文件的目录也被称为模块根。moudles 取代旧的的基于 GOPATH 方法来指定在工程中使用哪些源文件或导入包。模块路径是导入包的路径前缀，go.mod 文件定义模块路径，并且列出了在项目构建过程中使用的特定版本。&lt;/p>
&lt;p>使用 go module 时，GOPATH 不再用于解析导入。但是，它仍然用于存储下载的源代码（在$GOPATH/pkg/mod 中）和编译的命令（在 GOPATH / bin 中）。&lt;/p>
&lt;p>当程序编译时，会读取 go.mod 文件中的路径，来加载其编译所需的各种库&lt;/p>
&lt;p>Go moudles 目前集成在 Go 的工具链中，只要安装了 Go，自然而然也就可以使用 Go moudles 了，而 Go modules 的出现也解决了在 Go1.11 前的几个常见争议问题：&lt;/p>
&lt;ul>
&lt;li>Go 语言长久以来的依赖管理问题。&lt;/li>
&lt;li>“淘汰”现有的 &lt;a href="https://pkg.go.dev/cmd/go#hdr-GOPATH_environment_variable">GOPATH 的使用模式(即.解析导入能力)&lt;/a>。&lt;/li>
&lt;li>统一社区中的其它的依赖管理工具（提供迁移功能）。&lt;/li>
&lt;/ul>
&lt;h1 id="gopath">GOPATH&lt;/h1>
&lt;p>Go Module 出现后，GOPATH 路径变为纯粹的第三方依赖库的保存路径。目录结构通常如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># tree -L 3 $GOPATH&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── godef
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── gomodifytags
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── go-outline
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── gopkgs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── goplay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── gopls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── gotests
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── staticcheck
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── pkg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── mod
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── 9fans.net
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── cache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── fyne.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── github.com
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── gopkg.in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── gorm.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   └── mvdan.cc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── sumdb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── sum.golang.org
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>bin 下是安装的某些第三方依赖库后生成的二进制文件&lt;/p>
&lt;h2 id="早期-gopath-模式痛点">早期 GOPATH 模式痛点&lt;/h2>
&lt;p>我们先看看第一个问题，GOPATH 是什么，我们可以输入如下命令查看：&lt;/p>
&lt;pre>&lt;code>$ go env
GOPATH=&amp;quot;/root/go&amp;quot;
...
&lt;/code>&lt;/pre>
&lt;p>我们输入 go env 命令行后可以查看到 GOPATH 变量的结果，我们进入到该目录下进行查看，如下：&lt;/p>
&lt;pre>&lt;code>go
├── bin
├── pkg
└── src
├── github.com
├── golang.org
├── google.golang.org
├── gopkg.in
....
&lt;/code>&lt;/pre>
&lt;p>GOPATH 目录下一共包含了三个子目录，分别是：&lt;/p>
&lt;ul>
&lt;li>bin：存储所编译生成的二进制文件。&lt;/li>
&lt;li>pkg：存储预编译的目标文件，以加快程序的后续编译速度。&lt;/li>
&lt;li>src：存储所有项目的源代码。在编写 Go 应用程序，程序包和库时，一般会以$GOPATH/src/github.com/foo/bar 的路径进行存放。&lt;/li>
&lt;/ul>
&lt;p>因此在使用 GOPATH 模式下，我们需要将项目代码存放在固定的$GOPATH/src 目录下，并且如果执行 go get 来拉取外部依赖会自动下载并安装到 $GOPATH 目录下。&lt;/p>
&lt;p>为什么弃用 GOPATH 模式&lt;/p>
&lt;p>在 GOPATH 的 $GOPATH/src 下进行 .go 文件或源代码的存储，我们可以称其为 GOPATH 的模式，这个模式，看起来好像没有什么问题，那么为什么我们要弃用呢，参见如下原因：&lt;/p>
&lt;ul>
&lt;li>GOPATH 模式下没有版本控制的概念，具有致命的缺陷，至少会造成以下问题：
&lt;ul>
&lt;li>在执行 go get 的时候，你无法传达任何的版本信息的期望，也就是说你也无法知道自己当前更新的是哪一个版本，也无法通过指定来拉取自己所期望的具体版本。&lt;/li>
&lt;li>在运行 Go 应用程序的时候，你无法保证其它人与你所期望依赖的第三方库是相同的版本，也就是说在项目依赖库的管理上，你无法保证所有人的依赖版本都一致。&lt;/li>
&lt;li>你没办法处理 v1、v2、v3 等等不同版本的引用问题，因为 GOPATH 模式下的导入路径都是一样的，都是 github.com/foo/bar。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Go 语言官方从 Go1.11 起开始推进 Go modules（前身 vgo），Go1.13 起不再推荐使用 GOPATH 的使用模式，Go modules 也渐趋稳定，因此新项目也没有必要继续使用 GOPATH 模式。&lt;/li>
&lt;/ul>
&lt;p>在 GOPATH 模式下的产物&lt;/p>
&lt;p>Go1 在 2012 年 03 月 28 日发布，而 Go1.11 是在 2018 年 08 月 25 日才正式发布（数据来源：GitHub Tag），在这个空档的时间内，并没有 Go modules 这一个东西，最早期可能还好说，因为刚发布，用的人不多，所以没有明显暴露，但是后期 Go 语言使用的人越来越多了，那怎么办？&lt;/p>
&lt;p>这时候社区中逐渐的涌现出了大量的依赖解决方案，百花齐放，让人难以挑选，其中包括我们所熟知的 vendor 目录的模式，以及曾经一度被认为是“官宣”的 dep 的这类依赖管理工具。&lt;/p>
&lt;p>但为什么 dep 没有正在成为官宣呢，其实是因为随着 Russ Cox 与 Go 团队中的其他成员不断深入地讨论，发现 dep 的一些细节似乎越来越不适合 Go，因此官方采取了另起 proposal 的方式来推进，其方案的结果一开始先是释出 vgo（Go modules 的前身，知道即可，不需要深入了解），最终演变为我们现在所见到的 Go modules，也在 Go1.11 正式进入了 Go 的工具链。&lt;/p>
&lt;p>因此与其说是 “在 GOPATH 模式下的产物”，不如说是历史为当前提供了重要的教训，因此出现了 Go modules。&lt;/p>
&lt;h1 id="go-module-的使用和管理">Go Module 的使用和管理&lt;/h1>
&lt;p>可以这么说，一个自己新建的项目，就是一个模块，一个模块就是一个目录下的所有文件的集合。所以才说一个模块就是一个 Go Package 的合集。&lt;/p>
&lt;h2 id="go-module-相关环境变量">Go Module 相关环境变量&lt;/h2>
&lt;pre>&lt;code>$ go env
GO111MODULE=&amp;quot;auto&amp;quot; #使用module功能必须要让该变量变为on
GOPROXY=&amp;quot;https://proxy.golang.org,direct&amp;quot;
GONOPROXY=&amp;quot;&amp;quot;
GOSUMDB=&amp;quot;sum.golang.org&amp;quot;
GONOSUMDB=&amp;quot;&amp;quot;
GOPRIVATE=&amp;quot;&amp;quot;
...
&lt;/code>&lt;/pre>
&lt;h3 id="go111module">GO111MODULE&lt;/h3>
&lt;p>Go 语言提供了 GO111MODULE 这个环境变量来作为 Go modules 的开关，其允许设置以下参数：&lt;/p>
&lt;ul>
&lt;li>auto：只要项目包含了 go.mod 文件的话启用 Go modules，目前在 Go1.11 至 Go1.14 中仍然是默认值。&lt;/li>
&lt;li>on：启用 Go modules，推荐设置，将会是未来版本中的默认值。&lt;/li>
&lt;li>off：禁用 Go modules，不推荐设置。&lt;/li>
&lt;/ul>
&lt;p>GO111MODULE 的小历史&lt;/p>
&lt;p>你可能会留意到 GO111MODULE 这个名字比较 “奇特”，实际上在 Go 语言中经常会有这类阶段性的变量， GO111MODULE 这个命名代表着 Go 语言在 1.11 版本添加的，针对 Module 的变量。&lt;/p>
&lt;p>像是在 Go1.5 版本的时候，也发布了一个系统环境变量 GO15VENDOREXPERIMENT，作用是用于开启 vendor 目录的支持，当时其默认值也不是开启，仅仅作为 experimental。其随后在 Go1.6 版本时也将默认值改为了开启，并且最后作为了 official，GO15VENDOREXPERIMENT 系统变量就退出了历史舞台。&lt;/p>
&lt;p>而未来 GO111MODULE 这一个系统环境变量也会面临这个问题，也会先调整为默认值为 on（曾经在 Go1.13 想想改为 on，并且已经合并了 PR，但最后因为种种原因改回了 auto），然后再把 GO111MODULE 的支持给去掉，我们猜测应该会在 Go2 将 GO111MODULE 给去掉，因为如果直接去掉 GO111MODULE 的支持，会存在兼容性问题。&lt;/p>
&lt;h3 id="goproxy">GOPROXY&lt;/h3>
&lt;p>这个环境变量主要是用于设置 Go 模块代理（Go module proxy），其作用是用于使 Go 在后续拉取模块版本时能够脱离传统的 VCS 方式，直接通过镜像站点来快速拉取。&lt;/p>
&lt;p>GOPROXY 的默认值是：&lt;a href="https://proxy.golang.org,direct">https://proxy.golang.org,direct&lt;/a>，这有一个很严重的问题，就是 proxy.golang.org 在国内是无法访问的，因此这会直接卡住你的第一步，所以你必须在开启 Go modules 的时，同时设置国内的 Go 模块代理，执行如下命令：&lt;/p>
&lt;pre>&lt;code> $ go env -w GOPROXY=https://goproxy.cn,direct
&lt;/code>&lt;/pre>
&lt;p>GOPROXY 的值是一个以英文逗号 “,” 分割的 Go 模块代理列表，允许设置多个模块代理，假设你不想使用，也可以将其设置为 “off” ，这将会禁止 Go 在后续操作中使用任何 Go 模块代理。&lt;/p>
&lt;p>direct 是什么&lt;/p>
&lt;p>而在刚刚设置的值中，我们可以发现值列表中有 “direct” 标识，它又有什么作用呢？&lt;/p>
&lt;p>实际上 “direct” 是一个特殊指示符，用于指示 Go 回源到模块版本的源地址去抓取（比如 GitHub 等），场景如下：当值列表中上一个 Go 模块代理返回 404 或 410 错误时，Go 自动尝试列表中的下一个，遇见 “direct” 时回源，也就是回到源地址去抓取，而遇见 EOF 时终止并抛出类似 “invalid version: unknown revision&amp;hellip;” 的错误。&lt;/p>
&lt;h3 id="gosumdb">GOSUMDB&lt;/h3>
&lt;p>它的值是一个 Go checksum database，用于在拉取模块版本时（无论是从源站拉取还是通过 Go module proxy 拉取）保证拉取到的模块版本数据未经过篡改，若发现不一致，也就是可能存在篡改，将会立即中止。&lt;/p>
&lt;p>GOSUMDB 的默认值为：sum.golang.org，在国内也是无法访问的，但是 GOSUMDB 可以被 Go 模块代理所代理（详见：Proxying a Checksum Database）。&lt;/p>
&lt;p>因此我们可以通过设置 GOPROXY 来解决，而先前我们所设置的模块代理 goproxy.cn 就能支持代理 sum.golang.org，所以这一个问题在设置 GOPROXY 后，你可以不需要过度关心。&lt;/p>
&lt;p>另外若对 GOSUMDB 的值有自定义需求，其支持如下格式：&lt;/p>
&lt;ul>
&lt;li>格式 1：+。&lt;/li>
&lt;li>格式 2：+ 。&lt;/li>
&lt;/ul>
&lt;p>也可以将其设置为 “off”，也就是禁止 Go 在后续操作中校验模块版本。&lt;/p>
&lt;h3 id="gonoproxygonosumdbgoprivate">GONOPROXY/GONOSUMDB/GOPRIVATE&lt;/h3>
&lt;p>这三个环境变量都是用在当前项目依赖了私有模块，例如像是你公司的私有 git 仓库，又或是 github 中的私有库，都是属于私有模块，都是要进行设置的，否则会拉取失败。&lt;/p>
&lt;p>更细致来讲，就是依赖了由 GOPROXY 指定的 Go 模块代理或由 GOSUMDB 指定 Go checksum database 都无法访问到的模块时的场景。&lt;/p>
&lt;p>而一般建议直接设置 GOPRIVATE，它的值将作为 GONOPROXY 和 GONOSUMDB 的默认值，所以建议的最佳姿势是直接使用 GOPRIVATE。&lt;/p>
&lt;p>并且它们的值都是一个以英文逗号 “,” 分割的模块路径前缀，也就是可以设置多个，例如：&lt;/p>
&lt;pre>&lt;code> $ go env -w GOPRIVATE=&amp;quot;git.example.com,github.com/eddycjy/mquote&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>设置后，前缀为 git.xxx.com 和 github.com/eddycjy/mquote 的模块都会被认为是私有模块。&lt;/p>
&lt;p>如果不想每次都重新设置，我们也可以利用通配符，例如：&lt;/p>
&lt;pre>&lt;code> $ go env -w GOPRIVATE=&amp;quot;*.example.com&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>这样子设置的话，所有模块路径为 example.com 的子域名（例如：git.example.com）都将不经过 Go module proxy 和 Go checksum database，需要注意的是不包括 example.com 本身。&lt;/p>
&lt;p>具体使用步骤：&lt;/p>
&lt;ul>
&lt;li>通过 go 命令行，进入到你当前的工程目录下，在命令行设置临时环境变量 set GO111MODULE=on；&lt;/li>
&lt;li>执行命令 go mod init NAME 在当前目录下生成一个 go.mod 文件，执行这条命令时，当前目录不能存在 go.mod 文件。如果之前生成过，要先删除；&lt;/li>
&lt;li>如果你工程中存在一些不能确定版本的包，那么生成的 go.mod 文件可能就不完整，因此继续执行下面的命令；&lt;/li>
&lt;li>执行 go mod tidy 命令，它会添加缺失的模块以及移除不需要的模块。执行后会生成 go.sum 文件(模块下载条目)。添加参数-v，例如 go mod tidy -v 可以将执行的信息，即删除和添加的包打印到命令行；&lt;/li>
&lt;li>执行命令 go mod verify 来检查当前模块的依赖是否全部下载下来，是否下载下来被修改过。如果所有的模块都没有被修改过，那么执行这条命令之后，会打印 all modules verified。&lt;/li>
&lt;li>执行命令 go mod vendor 生成 vendor 文件夹，该文件夹下将会放置你 go.mod 文件描述的依赖包，文件夹下同时还有一个文件 modules.txt，它是你整个工程的所有模块。在执行这条命令之前，如果你工程之前有 vendor 目录，应该先进行删除。同理 go mod vendor -v 会将添加到 vendor 中的模块打印出来；&lt;/li>
&lt;/ul>
&lt;h2 id="gomod-文件">go.mod 文件&lt;/h2>
&lt;p>go.mod 文件定义 module 路径以及列出其他需要在 build 时引入的模块的特定的版本。例如下面的例子中，go.mod 声明 example.com/m 路径是 module 的根目录，同时也声明了 module 依赖特定版本的 golang.org/x/text 和 gopkg.in/yaml.v2。&lt;/p>
&lt;p>go.mod 文件中有如下几个关键字：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>module&lt;/strong> # 定义 module 路径，该路径不用与当前路径相同，只是 module 所用的一个名称，可以代指当前目录。(比如/root/lichenhao/cobra/目录下，创建一个 go.mod 文件，可以定义 module 路径为 cobratest，这个 cobratest 模块路径名，就表示/root/lichenhao/cobra/这个目录)to define the module path;&lt;/li>
&lt;li>&lt;strong>go&lt;/strong> # to set the expected language version;&lt;/li>
&lt;li>&lt;strong>require&lt;/strong> # to require a particular module at a given version or later;&lt;/li>
&lt;li>&lt;strong>exclude&lt;/strong> # to exclude a particular module version from use; and&lt;/li>
&lt;li>&lt;strong>replace&lt;/strong> # to replace a module version with a different module version.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">module&lt;/span> &lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">module&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">repo&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#ae81ff">1.13&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">require&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.0&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">20200220041913&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">e066a990ce6f&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>go.mod 文件还可以指定要替换和排除的版本，命令行会自动根据 go.mod 文件来维护需求声明中的版本。如果想获取更多的有关 go.mod 文件的介绍，可以使用命令 go help go.mod。&lt;/p>
&lt;p>go.mod 文件用 // 注释，而不用 /**/。文件的每行都有一条指令，由一个动作加上参数组成。例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">module&lt;/span> &lt;span style="color:#a6e22e">my&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">require&lt;/span> &lt;span style="color:#a6e22e">other&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v1&lt;/span>&lt;span style="color:#ae81ff">.0.2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">require&lt;/span> &lt;span style="color:#a6e22e">new&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v2&lt;/span>&lt;span style="color:#ae81ff">.3.4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">exclude&lt;/span> &lt;span style="color:#a6e22e">old&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v1&lt;/span>&lt;span style="color:#ae81ff">.2.3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">replace&lt;/span> &lt;span style="color:#a6e22e">bad&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v1&lt;/span>&lt;span style="color:#ae81ff">.4.5&lt;/span> =&amp;gt; &lt;span style="color:#a6e22e">good&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v1&lt;/span>&lt;span style="color:#ae81ff">.4.5&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面三个动词 require、exclude、replace 分别表示：项目需要的依赖包及版本、排除某些包的特别版本、取代当前项目中的某些依赖包。&lt;/p>
&lt;p>相同动作的命令可以放到一个动词+括号组成的结构中，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">require&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">new&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v2&lt;/span>&lt;span style="color:#ae81ff">.3.4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">old&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v1&lt;/span>&lt;span style="color:#ae81ff">.2.3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="其他命令的支持">其他命令的支持&lt;/h3>
&lt;p>旧的版本，构建编译命令 &lt;code>go build&lt;/code> 中的参数没有 &lt;code>-mod&lt;/code> 参数，最新的版本现在多了这个，用来对 &lt;code>go.mod&lt;/code> 文件进行更新或其他使用控制。形式如：&lt;code>go build -mod [mode]&lt;/code>，其中 mode 有以下几种取值：readonly，release，vendor。当执行 &lt;code>go build -mod=vendor&lt;/code> 的时候，会在生成可执行文件的同时将项目的依赖包放到主模块的 &lt;code>vendor&lt;/code> 目录下。&lt;/p>
&lt;p>&lt;code>go get -m [packages]&lt;/code> 会将下载的依赖包放到 &lt;code>GOPATH/pkg/mod&lt;/code> 目录下，并且将依赖写入到 &lt;code>go.mod&lt;/code> 文件。&lt;code>go get -u=patch&lt;/code> 会更新主模块下的所有依赖包。&lt;/p>
&lt;p>如果遇到不熟悉的导入包，任何可以查找包含该引入包模块的 &lt;code>go&lt;/code> 命令，都会自动将该模块的最新版本添加到 &lt;code>go.mod&lt;/code> 文件中。同时也会添加缺失的模块，以及删除无用的 module。例如：go build, go test 或者 go list 命令。另外，有一个专门的命令 &lt;code>go mod tidy&lt;/code>，用来查看和添加缺失的 module 需求声明以及移除不必要的。&lt;/p>
&lt;p>&lt;code>go.mod&lt;/code> 文件是可读，也是可编辑的。&lt;code>go&lt;/code> 命令行会自动更新 &lt;code>go.mod&lt;/code> 文件来维持一个标准格式以及精确的引入声明。&lt;/p>
&lt;h2 id="gosum-文件">go.sum 文件&lt;/h2>
&lt;p>在第一次拉取模块依赖后，会发现多出了一个 go.sum 文件，其详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了那些模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#ae81ff">4&lt;/span>&lt;span style="color:#a6e22e">QHXKo7J8a6J&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">k8UA6CiHhswJQs0sm2foAQQUq8GFHM&lt;/span>=
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#66d9ef">go&lt;/span>.&lt;span style="color:#a6e22e">mod&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#a6e22e">ZtlkDs7Mriynl7wsDQ4cU23okEtVYqHwl7F1eDh4qPg&lt;/span>=
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">module&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">tour&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#a6e22e">cc&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#a6e22e">pgV0LnR8Fhou0zNHughT7IbSnLvfUZ&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#a6e22e">X3fvshrv8&lt;/span>=
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">module&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">tour&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#66d9ef">go&lt;/span>.&lt;span style="color:#a6e22e">mod&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#a6e22e">uL1FOiQJZ4&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#a6e22e">hzqQ5mv4Sm7nJcwYu41F3nZmkiWx5I&lt;/span>=
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以看到一个模块路径可能有如下两种：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#ae81ff">4&lt;/span>&lt;span style="color:#a6e22e">QHXKo7J8a6J&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">k8UA6CiHhswJQs0sm2foAQQUq8GFHM&lt;/span>=
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#66d9ef">go&lt;/span>.&lt;span style="color:#a6e22e">mod&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#a6e22e">ZtlkDs7Mriynl7wsDQ4cU23okEtVYqHwl7F1eDh4qPg&lt;/span>=
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>h1 hash 是 Go modules 将目标模块版本的 zip 文件开包后，针对所有包内文件依次进行 hash，然后再把它们的 hash 结果按照固定格式和算法组成总的 hash 值。&lt;/p>
&lt;p>而 h1 hash 和 go.mod hash 两者，要不就是同时存在，要不就是只存在 go.mod hash。那什么情况下会不存在 h1 hash 呢，就是当 Go 认为肯定用不到某个模块版本的时候就会省略它的 h1 hash，就会出现不存在 h1 hash，只存在 go.mod hash 的情况。&lt;/p>
&lt;h1 id="go-mod-命令行工具">go mod 命令行工具&lt;/h1>
&lt;p>go mod 提供了一系列操作模块的命令，所有的 go 命令中现在已经内置了对 module 的支持，而不仅仅是 go mod 命令。例如使用 go get 时，会经常自动在后台添加、移除、升级、降级依赖包版本。&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>go mod [ARGUMENTS]&lt;/strong>&lt;/p>
&lt;p>COMMAND：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>download&lt;/strong> # 下载模块到本地缓存，具体可以通过命令 go env 查看，其中环境变量 GOCACHE 就是缓存的地址，如果该文件夹的内容太大，可以通过命令 go clean -cache&lt;/li>
&lt;li>&lt;strong>edit&lt;/strong> # 从工具或脚本中编辑 go.mod 文件&lt;/li>
&lt;li>&lt;strong>graph&lt;/strong> # 打印模块需求图&lt;/li>
&lt;li>&lt;strong>init&lt;/strong> # 在当前目录下初始化新的模块&lt;/li>
&lt;li>&lt;strong>tidy&lt;/strong> # 添加缺失的模块以及移除无用的模块&lt;/li>
&lt;li>&lt;strong>vendor&lt;/strong> #导出项目所有的依赖到 vendor 目录&lt;/li>
&lt;li>**verify **#验证依赖项是否达到预期的目的&lt;/li>
&lt;li>&lt;strong>why&lt;/strong> #查看为什么需要包或模块&lt;/li>
&lt;/ul>
&lt;h2 id="go-mod-download">go mod download&lt;/h2>
&lt;p>&lt;strong>go mod download [-dir] [-json] [modules]&lt;/strong>&lt;/p>
&lt;p>使用此命令来下载指定的模块，模块的格式可以根据主模块依赖的形式或者 path@version 形式指定。如果没有指定参数，此命令会将主模块下的所有依赖下载下来。&lt;/p>
&lt;p>go mod download 命令非常有用，主要用来预填充本地缓存或者计算 Go 模块代理的回答。默认情况下，下载错误会输出到标准输出，正常情况下没有任何输出。-json 参数会以 JSON 的格式打印下载的模块对象，对应的 Go 对象结构是这样。&lt;/p>
&lt;p>type Module struct { Path string //module path Version string //module version Error string //error loading module Info string //absolute path to cached .info file GoMod string //absolute path to cached .mod file Zip string //absolute path to cached .zip file Dir string //absolute path to cached source root directory Sum string //checksum for path, version (as in go.sum) GoModSum string //checksum for go.mod (as in go.sum)}&lt;/p>
&lt;h2 id="go-mod-init">go mod init&lt;/h2>
&lt;p>&lt;strong>go mod init [ModuleName]&lt;/strong>
一般情况 ModuleName 是以后 import 时所使用的路径&lt;/p>
&lt;p>此命令会在当前目录中初始化和创建一个新的 go.mod 文件，当然你也可以手动创建一个 go.mod 文件，然后包含一些 module 声明，这样就比较麻烦。go mod init 命令可以帮助我们自动创建&lt;/p>
&lt;p>例如：&lt;code>go mod init example.com/m&lt;/code>&lt;/p>
&lt;p>使用这条命令时，go.mod 文件必须提前不能存在。初始化会根据引入包声明来推测模块的路径或者如果你工程中之前已经存在一些依赖包管理工具，例如 godep，glide 或者 dep。那么 go mod init 同样也会根据依赖包管理配置文件来推断。&lt;/p>
&lt;h2 id="go-mod-tidy">go mod tidy&lt;/h2>
&lt;p>&lt;strong>go mod tidy [-v]&lt;/strong>&lt;/p>
&lt;p>默认情况下，Go 不会移除 go.mod 文件中的无用依赖。所以当你的依赖中有些使用不到了，可以使用 go mod tidy 命令来清除它。&lt;/p>
&lt;p>它会添加缺失的模块以及移除不需要的模块。执行后会生成 go.sum 文件(模块下载条目)。添加参数-v，例如 go mod tidy -v 可以将执行的信息，即移除的模块打印到标准输出。&lt;/p>
&lt;h2 id="go-mod-vendor">go mod vendor&lt;/h2>
&lt;p>go mod vendor [-v]&lt;/p>
&lt;p>此命令会将 build 阶段需要的所有依赖包放到主模块所在的 vendor 目录中，并且测试所有主模块的包。同理 go mod vendor -v 会将添加到 vendor 中的模块打印到标准输出。&lt;/p>
&lt;h2 id="go-mod-verify">go mod verify&lt;/h2>
&lt;p>此命令会检查当前模块的依赖是否已经存储在本地下载的源代码缓存中，以及检查自从下载下来是否有修改。如果所有的模块都没有修改，那么会打印 all modules verified，否则会打印变化的内容。&lt;/p>
&lt;p>虚拟版本号&lt;/p>
&lt;p>go.mod 文件和 go 命令通常使用语义版本作为描述模块版本的标准形式，这样可以比较不同版本的先后顺序。例如模块的版本是 v1.2.3，那么通过重新对版本号进行标签处理，得到该版本的虚拟版本。形式如：v0.0.0-yyyymmddhhmmss-abcdefabcdef。其中时间是提交时的 UTC 时间，最后的后缀是提交的哈希值前缀。时间部分确保两个虚拟版本号可以进行比较，以确定两者顺序。&lt;/p>
&lt;p>下面有三种形式的虚拟版本号：&lt;/p>
&lt;ul>
&lt;li>vX.0.0-yyyymmddhhmmss-abcdefabcdef，这种情况适合用在在目标版本提交之前 ，没有更早的的版本。（这种形式本来是唯一的形式，所以一些老的 go.mod 文件使用这种形式）&lt;/li>
&lt;li>vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdef，这种情况被用在当目标版本提交之前的最新版本提交是 vX.Y.Z-pre。&lt;/li>
&lt;li>vX.Y.(Z+1)-0.yyyymmddhhmmss-abcdefabcdef，同理，这种情况是当目标版本提交之前的最新版本是 vX.Y.Z。&lt;/li>
&lt;/ul>
&lt;p>虚拟版本的生成不需要你去手动操作，go 命令会将接收的 commit 哈希值自动转化为虚拟版本号。&lt;/p></description></item><item><title>Docs: Go OpenAPI</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%89%A9%E5%B1%95/go-openapi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%89%A9%E5%B1%95/go-openapi/</guid><description>
&lt;h1 id="自动为-go-代码生成-openapi-文档">自动为 Go 代码生成 OpenAPI 文档&lt;/h1>
&lt;p>可选项目：&lt;a href="https://github.com/go-swagger/go-swagger">go-swagger&lt;/a>、&lt;a href="https://github.com/swaggo/swag">swaggo&lt;/a>&lt;/p>
&lt;h1 id="go-swagger">go-swagger&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://cloud.tencent.com/developer/article/1165462">腾讯云社区&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/benben_2015/article/details/100538074">CSDN&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://studygolang.com/articles/12354">go 语言中文网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: Go Profiling 详解</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E5%B7%A5%E5%85%B7/pprofgo%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%99%A8/go-profiling-%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E5%B7%A5%E5%85%B7/pprofgo%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%99%A8/go-profiling-%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;p>原文：&lt;a href="https://mp.weixin.qq.com/s/SveQPLr7abKXccLpYKkNKA">https://mp.weixin.qq.com/s/SveQPLr7abKXccLpYKkNKA&lt;/a>&lt;/p>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;h3 id="read-this">Read This&lt;/h3>
&lt;p>这是一本实用指南，针对的是对使用 profiling、跟踪和其他可观察性技术改进程序感兴趣的忙碌的 gopher。如果你对 Go 的内部实现不熟悉，建议你先阅读整个介绍。之后，你可以自由地跳到你感兴趣的任何章节。&lt;/p>
&lt;h3 id="go-心智模型">Go 心智模型&lt;/h3>
&lt;p>虽然不了解 Go 语言的底层原理，但是你也能熟练地编写 Go 代码。但是当涉及到性能和调试时，你会从内部实现中受益匪浅。我们接下来会概述 Go 基本原理的模型。这个模型应该足以让你避免最常见的错误，但是所有的模型都是错误的[2]，所以我们鼓励你寻找更深入的材料来解决未来的难题。&lt;/p>
&lt;p>Go 的主要工作是对硬件资源进行复用和抽象，类似于操作系统。主要使用两个抽象：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Goroutine Scheduler(goroutine 调度器):&lt;/strong> 管理你的代码如何在 CPU 上执行。&lt;/li>
&lt;li>&lt;strong>Garbage Collector(垃圾回收):&lt;/strong> 提供虚拟内存，在需要时自动释放。&lt;/li>
&lt;/ol>
&lt;h4 id="goroutine-调度器">Goroutine 调度器&lt;/h4>
&lt;p>让我们先用下面的例子来谈谈调度器 :&lt;/p>
&lt;p>&lt;code>func main() {     res, err := http.Get(&amp;quot;https://example.org/&amp;quot;)     if err != nil {         panic(err)     }     fmt.Printf(&amp;quot;%d\n&amp;quot;, res.StatusCode) }&lt;/code>&lt;/p>
&lt;p>这里我们有一个 goroutine，我们称之为 &lt;code>G1&lt;/code>，它运行 &lt;code>main&lt;/code> 函数。下图显示了这个 goroutine 如何在单个 CPU 上执行的简化的时间线。最初 &lt;code>G1&lt;/code> 在 CPU 上运行以准备 http 请求。然后 CPU 变得空闲，因为 goroutine 需要网络等待。最后它再次被调度到 CPU 上，打印出状态代码。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/4aaac374-ac48-48d4-8190-b524f880bf2f/640" alt="">&lt;/p>
&lt;p>从调度器的角度来看，上述程序的执行情况如下所示。一开始，&lt;code>G1&lt;/code> 在 &lt;code>CPU 1&lt;/code> 上 &lt;code>Executing&lt;/code>。然后，在 &lt;code>Waiting&lt;/code> 网络的过程中，goroutine 被从 CPU 上取出。一旦调度器注意到网络已经返回（使用非阻塞 I/O，类似于 Node.js），它就把 goroutine 标记为 &lt;code>Runnable&lt;/code>。一旦有 CPU 核心可用，goroutine 就会再次开始 &lt;code>Executing&lt;/code>。在我们的例子中，所有的 cpu 核都是可用的，所以 &lt;code>G1&lt;/code> 可以立即回到其中一个 CPU 上 &lt;code>Executing&lt;/code>  &lt;code>fmt.Printf()&lt;/code> 函数，而无需在 &lt;code>Runnable&lt;/code> 状态下花费任何时间。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/4aaac374-ac48-48d4-8190-b524f880bf2f/640" alt="">&lt;/p>
&lt;p>大多数时候，Go 程序都在运行多个 goroutine，所以你会有一些 goroutine 在一些 CPU 核心上 &lt;code>Executing&lt;/code>，大量 goroutine 由于各种原因 &lt;code>Waiting&lt;/code>，理想情况下没有 goroutine &lt;code>Runnable&lt;/code>，除非你的程序显示非常高的 CPU 负载。下面就是一个例子。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/4aaac374-ac48-48d4-8190-b524f880bf2f/640" alt="">&lt;/p>
&lt;p>当然，上面的模型掩盖了许多细节。Go 调度器是在操作系统管理的线程之上运行的，甚至 CPUs 本身也能够实现超线程，这可以看作是一种调度形式。所以如果你感兴趣的话，可以通过 Ardan labs 的 Scheduling in Go[3] 或其他资料继续深入这个主题。&lt;/p>
&lt;p>但是，上面的模型应该足以理解本指南的其余部分。特别是，各种 Go profilers 所测量的时间基本上是 goroutines 在 &lt;code>Executing&lt;/code> 和 &lt;code>Waiting&lt;/code> 状态中所花费的时间，如下图所示。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/4aaac374-ac48-48d4-8190-b524f880bf2f/640" alt="">&lt;/p>
&lt;h4 id="垃圾收集器">垃圾收集器&lt;/h4>
&lt;p>Go 的另一个主要抽象是垃圾收集器。在 C 语言中，程序员需要使用 &lt;code>malloc()&lt;/code> 和 &lt;code>free()&lt;/code> 手动分配和释放内存。这提供了很好的控制，但在实践中很容易出错。垃圾收集器可以减少这种负担，但内存的自动管理很容易成为性能瓶颈。本指南将为 Go 的 GC 提供一个简单模型，这个模型对于识别和优化内存管理相关问题非常有用。&lt;/p>
&lt;h5 id="the-stack">The Stack&lt;/h5>
&lt;p>让我们从最基础开始。Go 可以将内存分配到堆栈或者堆的任意一个位置。每个 goroutine 都有自己的堆栈，栈是一个连续的内存区域。此外，goroutine 之间还有一大块内存共享区域，这就是堆。如下所示。&lt;/p>
&lt;p>当一个函数调用另一个函数时，它会在堆栈中获得自己的部分，称为 stack frame(堆栈帧) ，在这里它可以创建局部变量等。堆栈指针用于标识帧中的下一个空闲位置。当一个函数返回时，通过简单地将堆栈指针移回到前一帧的末尾，最后一帧中的数据就会被丢弃。帧的数据本身可以留在堆栈中，并被下一个函数调用覆盖。这是非常简单和有效的，因为 Go 不需要跟踪每个变量。&lt;/p>
&lt;p>为了让这个更直观一点，让我们看看下面的例子 :&lt;/p>
&lt;p>`func main() {
 sum := 0
 sum = add(23, 42)
 fmt.Println(sum)
}&lt;/p>
&lt;p>func add(a, b int) int {
 return a + b
}&lt;/p>
&lt;p>`&lt;/p>
&lt;p>我们有一个 &lt;code>main()&lt;/code> 函数，它一开始就在堆栈中为变量 &lt;code>sum&lt;/code> 创建了空间。当调用 &lt;code>add()&lt;/code> 函数时，它获得自己的帧来保存本地的 &lt;code>a&lt;/code> 和 &lt;code>b&lt;/code> 参数。一旦 &lt;code>add()&lt;/code> 返回，通过将堆栈指针移回 &lt;code>main()&lt;/code> 函数帧末尾，它的数据就会被丢弃，&lt;code>sum&lt;/code> 变量就会得到更新。同时，&lt;code>add()&lt;/code> 的旧值逗留在堆栈指针之外，以便被下一个函数调用覆盖。下面是这个过程的可视化图 :&lt;/p>
&lt;p>上面的例子是高度简化了，省略了许多关于返回值、帧指针、返回地址和函数内联的细节。实际上，在 Go 1.17 中，上面的程序甚至可能不需要堆栈上的任何空间，因为少量的数据可以由编译器使用 CPU 寄存器来管理。但这也没关系。这个模型应该还是能让你对简单的 Go 程序在堆栈上分配和丢弃局部变量的方式有一个直观认识。&lt;/p>
&lt;p>此时你可能会想，如果堆栈上的空间用完了会怎么样。在像 C 这样的语言中，这会导致堆栈溢出错误。而 Go 会自动处理这个问题，扩容成两倍堆栈。所以一般 goroutine 开始都是很小的，通常是 2 KiB，这也是 goroutine 比操作系统线程更具可伸缩性的关键因素[4]之一。&lt;/p>
&lt;h5 id="the-heap">The Heap&lt;/h5>
&lt;p>堆栈分配很 nice，但是在很多情况下 Go 不能全部都使用它们。最常见比如函数返回指针。把上面的 &lt;code>add()&lt;/code> 函数示例修改一下，如下 :&lt;/p>
&lt;p>`func main() {
 fmt.Println(*add(23, 42))
}&lt;/p>
&lt;p>func add(a, b int) *int {
 sum := a + b
 return &amp;amp;sum
}&lt;/p>
&lt;p>`&lt;/p>
&lt;p>通常 Go 可以把 &lt;code>add()&lt;/code> 函数内部的 &lt;code>sum&lt;/code> 变量分配到堆栈中。我们已经知道当 &lt;code>add()&lt;/code> 函数返回时，这些数据将被丢弃。因此，为了安全返回 &lt;code>&amp;amp;sum&lt;/code> 指针，Go 必须从堆栈外为其分配内存。这就是堆的作用。&lt;/p>
&lt;p>堆用于存储可能比创建它的函数存活时间更长的数据，以及任何使用指针在 goroutine 之间共享数据。然而，这就提出了一个问题 : 这些内存是如何被释放的。因为与堆栈分配不同，当创建堆分配的函数返回时，堆分配是不能被丢弃。&lt;/p>
&lt;p>Go 使用其内置的垃圾收集器解决了这个问题。其实现的细节非常复杂，但是从宏观角度来看，它可以跟踪你的内存，如下图所示。在这里你可以看到三个 goroutines，它们具有指向堆上绿色分配的指针。其中一些分配还有指向其他分配的指针，用绿色显示。此外，灰色分配可能指向绿色分配或相互指向，但它们本身并不被绿色分配引用。这些分配曾经是可到达的，但现在被认为是垃圾。如果在堆栈上分配它们的指针的函数返回，或者它们的值被覆盖，就会发生这种情况。GC 负责自动识别和释放这些分配。&lt;/p>
&lt;p>执行 GC 涉及大量开销很大的图遍历和缓冲区的处理。它甚至需要定期 stop-the-world 阶段来停止整个程序执行。Go 现在的版本已经把 GC 的过程打到很恐怖的速度了 (毫秒级)，剩余的大部分开销都是任何 GC 算法都跑不掉的的。事实上，Go 程序执行中 20-30% 的时间都开销在内存管理上并不罕见。&lt;/p>
&lt;p>一般来说，GC 的成本与程序执行的堆分配量成正比。因此，在优化程序的内存开销时，需要注意的是 :&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Reduce&lt;/strong>: 尝试将堆分配转换为堆栈分配，或者干脆避免它们。把堆上的指针数量打下来也会有帮助。&lt;/li>
&lt;li>&lt;strong>Reuse:&lt;/strong> 复用堆分配，而不是用新的堆分配来替换它们。&lt;/li>
&lt;li>&lt;strong>Recycle:&lt;/strong> 有些堆分配是无法避免的。让 GC 自动回收它们，并关注其他问题。&lt;/li>
&lt;/ul>
&lt;p>与本指南中之前的心智模型一样，上面的流程都是对实际的情况做了简化。但是希望它能够很好地帮你理解本指南的其余部分，并激励你阅读更多关于这个主题的文章。推荐你必读的一篇文章《Getting to Go: The Journey of Go&amp;rsquo;s Garbage Collector[5]》 ，它让你很好地了解 Go 的 GC 多年来是如何进步的，以及它的改进速度。&lt;/p>
&lt;h2 id="go-profilers">Go Profilers&lt;/h2>
&lt;p>以下是 Go runtime 内置 profilers 的概述。有关更多详细信息，请点击链接。&lt;/p>
&lt;p>|&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>CPU&lt;/th>
&lt;th>Memory&lt;/th>
&lt;th>Block&lt;/th>
&lt;th>Mutex&lt;/th>
&lt;th>Goroutine&lt;/th>
&lt;th>ThreadCreate&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Production Safety&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>⚠️ (1.)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Safe Rate&lt;/td>
&lt;td>default&lt;/td>
&lt;td>default&lt;/td>
&lt;td>&lt;code>10000&lt;/code>&lt;/td>
&lt;td>&lt;code>10&lt;/code>&lt;/td>
&lt;td>&lt;code>1000&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td> goroutines&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Accuracy&lt;/td>
&lt;td>⭐️⭐&lt;/td>
&lt;td>⭐⭐⭐&lt;/td>
&lt;td>⭐⭐⭐&lt;/td>
&lt;td>⭐⭐⭐&lt;/td>
&lt;td>⭐⭐⭐&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Max Stack Depth&lt;/td>
&lt;td>&lt;code>64&lt;/code>&lt;/td>
&lt;td>&lt;code>32&lt;/code>&lt;/td>
&lt;td>&lt;code>32&lt;/code>&lt;/td>
&lt;td>&lt;code>32&lt;/code>&lt;/td>
&lt;td>&lt;code>32&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p> - &lt;code>100&lt;/code>
(3.) |&lt;/p>
&lt;ol>
&lt;li>一个 O(N) stop-the-world 的暂停，其中 N 是 goroutine 的数量。预计每个 goroutine 会有 ~1-10 微妙的暂停。&lt;/li>
&lt;li>完全坏了，不要尝试使用它。&lt;/li>
&lt;li>取决于 API 的情况。&lt;/li>
&lt;/ol>
&lt;h3 id="cpu-profiler">CPU Profiler&lt;/h3>
&lt;p>Go 的 CPU profiler 可以帮助你确定代码的哪些部分占用了大量的 CPU 时间。&lt;/p>
&lt;p>⚠️ 请注意，CPU 时间跟我们体验的实际时间是不同的。例如，一个典型的 http 请求可能需要 &lt;code>100ms&lt;/code> 才能完成，但是在数据库上等待 &lt;code>95ms&lt;/code> 时只消耗 &lt;code>5ms&lt;/code> 的 CPU 时间。一个请求也有可能 &lt;code>100ms&lt;/code>，但是如果两个 goroutine 并行地执行 CPU 密集型工作，则需要花费 &lt;code>200ms&lt;/code> 的 CPU。如果你对此感到困惑，请参阅 Goroutine Scheduler[6] 部分。&lt;/p>
&lt;p>你可以通过各种 APIs 来控制 CPU profiler:&lt;/p>
&lt;ul>
&lt;li>&lt;code>go test -cpuprofile cpu.pprof&lt;/code> 将运行你的测试并将 CPU profile 写入名为 &lt;code>cpu.pprof&lt;/code> 的文件。&lt;/li>
&lt;li>&lt;code>pprof.StartCPUProfile(w)&lt;/code> 将 CPU profile 抓取到 &lt;code>w&lt;/code>，涵盖的时间跨度直到 &lt;code>pprof.StopCPUProfile()&lt;/code> 被调用。&lt;/li>
&lt;li>&lt;code>import _ &amp;quot;net/http/pprof&amp;quot;&lt;/code> 允许你通过点击默认 http 服务器的 &lt;code>GET /debug/pprof/profile?seconds=30&lt;/code> 来请求 30s CPU profile，你可以通过 &lt;code>http.ListenAndServe(&amp;quot;localhost:6060&amp;quot;, nil)&lt;/code> 来启动。&lt;/li>
&lt;li>&lt;code>runtime.SetCPUProfileRate()&lt;/code> 可以让你控制 CPU profile 的采样率。&lt;/li>
&lt;li>&lt;code>runtime.SetCgoTraceback()&lt;/code> 可以用来获取 cgo 代码中的堆栈痕迹。benesch/cgosymbolizer[7] 有一个针对 Linux 和 macOS 的实现。&lt;/li>
&lt;/ul>
&lt;p>如果你需要一个可以立马看到效果的代码贴到 &lt;code>main()&lt;/code> 函数里，你可以使用下面的代码 :&lt;/p>
&lt;p>&lt;code>file, _ := os.Create(&amp;quot;./cpu.pprof&amp;quot;) pprof.StartCPUProfile(file) defer pprof.StopCPUProfile()&lt;/code>&lt;/p>
&lt;p>无论如何激活 CPU profiler，最终的 profile 文件本质上都是一个以二进制 pprof[8] 格式的堆栈跟踪表。这种表的简化版本如下 :&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>stack trace&lt;/th>
&lt;th>samples/count&lt;/th>
&lt;th>cpu/nanoseconds&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>main;foo&lt;/td>
&lt;td>5&lt;/td>
&lt;td>50000000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main;foo;bar&lt;/td>
&lt;td>3&lt;/td>
&lt;td>30000000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main;foobar&lt;/td>
&lt;td>4&lt;/td>
&lt;td>40000000&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>CPU profiler 通过请求操作系统监视应用程序的 CPU 使用情况来捕获这些数据，并为每占用 &lt;code>10ms&lt;/code> 的 CPU 时间发送一个 &lt;code>SIGPROF&lt;/code> 信号。操作系统还将内核代表应用程序所消耗的时间包括在这个监测中。由于信号传输速率取决于 CPU 的消耗，因此它是动态的，可以达到 &lt;code>N * 100Hz&lt;/code>，其中 &lt;code>N&lt;/code> 是系统上逻辑 CPU 核心的数量。当 &lt;code>SIGPROF&lt;/code> 信号到达时，Go 的信号处理程序捕获当前活动 goroutine 的堆栈跟踪，并在 profile 中增加相应的值。&lt;code>cpu/nanoseconds&lt;/code> 的值目前是直接从样本计数中推导出来的，因此它是冗余的，但很方便。&lt;/p>
&lt;h4 id="cpu-profiler-标签">CPU Profiler 标签&lt;/h4>
&lt;p>Go 的 CPU profiler 的一个很吊的特性是你可以将任意键值对附加到 goroutine。这些标签将由从这个 goroutine 产生的任何 goroutine 继承，并显示在产生的 profile 文件中。&lt;/p>
&lt;p>让我们考虑下面的示例[9]，它代表 &lt;code>user&lt;/code> 执行一些 CPU &lt;code>work()&lt;/code>。通过使用 pprof.Labels()[10]和 pprof.Labels()[11] API，我们可以将 &lt;code>user&lt;/code> 与执行 &lt;code>work()&lt;/code> 函数的 goroutine 关联起来。此外，同一块代码中产生任何 goroutine 都会自动继承这些标签，例如 &lt;code>backgroundWork()&lt;/code> goroutine。&lt;/p>
&lt;p>&lt;code>func work(ctx context.Context, user string) {  labels := pprof.Labels(&amp;quot;user&amp;quot;, user)  pprof.Do(ctx, labels, func(_ context.Context) {   go backgroundWork()   directWork()  }) }&lt;/code>&lt;/p>
&lt;p>得到的 profile 将包括一个新的标签列，可能看起来像这样 :&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>stack trace&lt;/th>
&lt;th>label&lt;/th>
&lt;th>samples/count&lt;/th>
&lt;th>cpu/nanoseconds&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>main.childWork&lt;/td>
&lt;td>user:bob&lt;/td>
&lt;td>5&lt;/td>
&lt;td>50000000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main.childWork&lt;/td>
&lt;td>user:alice&lt;/td>
&lt;td>2&lt;/td>
&lt;td>20000000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main.work;main.directWork&lt;/td>
&lt;td>user:bob&lt;/td>
&lt;td>4&lt;/td>
&lt;td>40000000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main.work;main.directWork&lt;/td>
&lt;td>user:alice&lt;/td>
&lt;td>3&lt;/td>
&lt;td>30000000&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>使用 pprof’s Graph 视图查看相同的档案也会包括以下标签 :&lt;/p>
&lt;p>如何使用这些标签取决于你。你可以包含一些东西比如 &lt;code>user ids&lt;/code>、&lt;code>request ids&lt;/code>、 &lt;code>http endpoints&lt;/code>, &lt;code>subscription plan&lt;/code> 或其他数据，这些东西可以让你更好地理解哪些类型的请求导致了高 CPU 利用率，即使它们是由相同的代码路径处理的。也就是说，使用标签会增加 pprof 文件的大小。因此，你可能应该先从低 cardinality 标签（比如 endpoints）开始，一旦你确信它们不会影响你的应用程序的性能，就应该转向高 cardinality 标签。&lt;/p>
&lt;h4 id="cpu-利用率">CPU 利用率&lt;/h4>
&lt;p>由于 CPU profiler 的采样速率适应程序消耗的 CPU 数量，因此可以从 CPU profile 中获得 CPU 利用率。事实上，pprof 会自动为你做这件事。例如，下面的 profile 取自一个平均 CPU 利用率为 &lt;code>147.77%&lt;/code> 的程序 :&lt;/p>
&lt;p>&lt;code>$ go tool pprof guide/cpu-utilization.pprof Type: cpu Time: Sep 9, 2021 at 11:34pm (CEST) Duration: 1.12s, Total samples = 1.65s (147.77%) Entering interactive mode (type &amp;quot;help&amp;quot; for commands, &amp;quot;o&amp;quot; for options) (pprof)&lt;/code>&lt;/p>
&lt;p>另一种流行的表示 CPU 利用率的方法是 CPU 核心。在上面的例子中，程序在 profiling 期间平均使用了 &lt;code>1.47&lt;/code> 个 CPU 核心。&lt;/p>
&lt;p>⚠️ 如果这个数值接近或高于 &lt;code>250%&lt;/code> ，那么你不应该过于信任这个数值。但是，如果你看到的数字非常低，比如 &lt;code>10%&lt;/code> ，这通常表明 CPU 消耗对你的应用程序来说是小 case。一个常见的错误是忽略这个数字，并开始担心某个特定的函数占用了相对于 profile 文件其余部分的很长时间。当总体 CPU 利用率较低时，这通常是浪费时间，因为通过优化这个函数不会获得太多好处。&lt;/p>
&lt;h4 id="cpu-profiles-的系统调用">CPU Profiles 的系统调用&lt;/h4>
&lt;p>如果你看到诸如 &lt;code>syscall.Read()&lt;/code> 或 &lt;code>syscall.Write()&lt;/code> 这样的系统调用在你的 CPU profiles 中使用了大量的时间，请注意这只是内核中这些函数中占用的 CPU 时间。I/O 时间本身没有被跟踪。在系统调用上花费大量时间通常表明调用过多，因此增加缓冲区大小可能会有所帮助。对于这种更复杂的情况，你应该考虑使用 Linux perf，因为它还可以向你显示内核堆栈跟踪，从而可能为你提供更多的线索。&lt;/p>
&lt;h4 id="cpu-profiler-局限">CPU Profiler 局限&lt;/h4>
&lt;p>有一些已知的问题和 CPU profiler 的局限性，需要注意的是 :&lt;/p>
&lt;ul>
&lt;li>🐞 在 Linux 上的一个已知问题是 CPU profile 难以实现超过 &lt;code>250Hz&lt;/code> 的采样率。这通常不是问题，但如果你的 CPU 利用率非常高，就会导致偏差。有关这方面的更多信息，可以看看 GitHub issue[12]。同时你可以使用支持更高采样频率的 Linux perf。&lt;/li>
&lt;li>⚠️️ 你可以在调用 runtime.SetCPUProfileRate()[13] 之前调用 &lt;code>runtime.StartCPUProfile()&lt;/code> 来调整 CPU profile 的速率。这将打印一个警告：&lt;code>runtime: cannot set cpu profile rate until previous profile has finished&lt;/code>。然而，它仍然在上述 bug 的限制下工作。这个问题最初是在 这里[14] 提出的，并且有一个 被接受的改进 API 的建议[15]。&lt;/li>
&lt;li>⚠️ 目前，CPU profile 可以在堆栈跟踪中捕获的嵌套函数调用的最大数量是 64[16]。如果你的程序使用了大量的递归或其他导致调用函数堆栈的方法，你的 CPU profile 将包括堆栈跟踪被截断。这意味着你将错过调用链中导致采样时处于活动状态的函数的部分。&lt;/li>
&lt;/ul>
&lt;h3 id="memory-profiler">Memory Profiler&lt;/h3>
&lt;p>Go memory(内存) profiler 可以帮助你识别代码中哪些部分执行了大量堆分配，以及在上一次垃圾收集期间有多少分配是仍可访问的。因此，memory profiler 生成的 profile 通常也称为 heap(堆) profile。&lt;/p>
&lt;p>堆内存管理相关的活动通常占用 Go 进程消耗的 CPU 时间的 20-30% 。此外，由于减少了垃圾收集器扫描堆时发生的缓存抖动，干掉堆分配会产生二阶效应，从而加快代码的其他部分。这意味着优化内存分配通常比优化程序中与 cpu 绑定的代码路径更好使。&lt;/p>
&lt;p>⚠️memory profiler 不显示堆栈分配，因为这些分配通常比堆分开销小得多。有关详细信息，请参阅本指南的 GC 章节。&lt;/p>
&lt;p>你可以通过各种 api 来控制 memory profiler:&lt;/p>
&lt;ul>
&lt;li>&lt;code>go test -memprofile mem.pprof&lt;/code> 将运行你的测试并将 memory profile 写进 &lt;code>mem.pprof&lt;/code>。&lt;/li>
&lt;li>&lt;code>pprof.Lookup(&amp;quot;allocs&amp;quot;).WriteTo(w, 0)&lt;/code> 将一个涵盖进程开始以来的时间的 memory profile 写入到 &lt;code>w&lt;/code>。&lt;/li>
&lt;li>&lt;code>import _ &amp;quot;net/http/pprof&amp;quot;&lt;/code> 允许你通过点击默认的 http 服务器 &lt;code>GET /debug/pprof/allocs?seconds=30&lt;/code> 来请求 30 秒的 memory profile，你可以通过 &lt;code>http.ListenAndServe(&amp;quot;localhost:6060&amp;quot;, nil)&lt;/code> 启动。这在内部也被称为 delta profile 。&lt;/li>
&lt;li>&lt;code>runtime.MemProfileRate&lt;/code> 允许你控制 memory profilee 的采样率。&lt;/li>
&lt;/ul>
&lt;p>如果你需要一个可以立马看到效果的代码贴到 &lt;code>main()&lt;/code> 函数里，你可以使用下面的代码 :&lt;/p>
&lt;p>&lt;code>file, _ := os.Create(&amp;quot;./mem.pprof&amp;quot;) defer pprof.Lookup(&amp;quot;allocs&amp;quot;).WriteTo(file, 0) defer runtime.GC()&lt;/code>&lt;/p>
&lt;p>无论如何激活 memory profiler，得到的 profile 文件本质上都是一个二进制 pprof 格式的格式化的堆栈跟踪表。这种表的简化版本如下 :&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>stack trace&lt;/th>
&lt;th>alloc_objects/count&lt;/th>
&lt;th>alloc_space/bytes&lt;/th>
&lt;th>inuse_objects/count&lt;/th>
&lt;th>inuse_space/bytes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>main;foo&lt;/td>
&lt;td>5&lt;/td>
&lt;td>120&lt;/td>
&lt;td>2&lt;/td>
&lt;td>48&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main;foo;bar&lt;/td>
&lt;td>3&lt;/td>
&lt;td>768&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main;foobar&lt;/td>
&lt;td>4&lt;/td>
&lt;td>512&lt;/td>
&lt;td>1&lt;/td>
&lt;td>128&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>memory profile 包含两条主要信息 :&lt;/p>
&lt;ul>
&lt;li>&lt;code>alloc_*&lt;/code>: 程序从进程最开始以来所有的分配。&lt;/li>
&lt;li>&lt;code>insue_*&lt;/code>: 程序从上次 GC 完到现在分配。&lt;/li>
&lt;/ul>
&lt;p>你可以将此信息用于各种用途。例如，你可以使用 &lt;code>alloc_*&lt;/code> 数据来确定哪些代码路径可能会产生大量 GC 处理，并且随着时间的推移查看 &lt;code>inuse_*&lt;/code> 数据可以帮助你调查程序的内存泄漏或内存使用率过高。&lt;/p>
&lt;h4 id="allocs-vs-heap-profile">Allocs vs Heap Profile&lt;/h4>
&lt;p>pprof.Lookup()[17] 函数以及 net/http/pprof[18] 包使用两个名称 (&lt;code>allocs&lt;/code> 和 &lt;code>heap&lt;/code>) 公开 memory profile。两个 profile 都包含相同的数据，唯一的区别是 &lt;code>allocs&lt;/code> profile 将 &lt;code>alloc_space/bytes&lt;/code> 设置为默认的样本类型，而 &lt;code>heap&lt;/code> profile 默认设置为 &lt;code>inuse_space/bytes&lt;/code>。pprof 工具使用它来决定默认情况下显示哪个示例类型。&lt;/p>
&lt;h4 id="memory-profiler-采样">Memory Profiler 采样&lt;/h4>
&lt;p>为了保持比较低的开销，内存 profiler 使用泊松采样，因此平均每 &lt;code>512KiB&lt;/code> 只有一次分配触发堆栈跟踪并将其添加到 profile 中。然而，在将 profile 写入最终的 pprof 文件之前，runtime 将收集到的样本值除以抽样概率，从而对其进行扩展。这意味着报告的分配数量应该是对实际分配数量的很好的估算。而不管你使用的是 runtime.MemProfileRate[19]。&lt;/p>
&lt;p>对于生产中的分析，通常不必修改取样速率。这样做的唯一原因是，如果你担心在很少进行分配的情况下没有收集到足够的样本。&lt;/p>
&lt;h4 id="memory-inuse-vs-rss">Memory Inuse vs RSS&lt;/h4>
&lt;p>一个常见的混淆是查看 &lt;code>inuse_space/bytes&lt;/code> 样本类型的内存总量，并注意到它与操作系统报告的 RSS 内存使用量不匹配。有多种原因可能导致 :&lt;/p>
&lt;ul>
&lt;li>根据定义，RSS 包括了很多不仅仅是 Go 堆内存的使用，例如 goroutine 堆栈、程序可执行文件、共享库以及 C 函数分配的内存所使用的内存。&lt;/li>
&lt;li>GC 可能不会立把空闲内存返回给操作系统，但在 Go 1.16 的 runtime[20] 改回来了，这个就算小问题了。&lt;/li>
&lt;li>Go 使用 non-moving GC，因此在某些情况下，空闲堆内存可能会碎片化，从而阻止 Go 将其释放到操作系统。&lt;/li>
&lt;/ul>
&lt;h4 id="memory-profiler-implementation">Memory Profiler Implementation&lt;/h4>
&lt;p>下面的伪代码应该捕获 memory profiler 实现的基本东西，让你有个大概的印象。如下所示，Go runtime 中的 &lt;code>malloc()&lt;/code> 函数使用 &lt;code>poisson_sample(size)&lt;/code> 来确定是否应该对分配进行取样。如果是，则以堆栈跟踪 &lt;code>s&lt;/code> 作为 &lt;code>mem_profile&lt;/code> 哈希表中的 key，用来增加 &lt;code>allocs&lt;/code> 和 &lt;code>alloc_bytes&lt;/code> 计数器。此外，&lt;code>track_profiled(object, s)&lt;/code> 调用将 &lt;code>object&lt;/code> 标记为堆上的采样分配，并将堆栈跟踪 &lt;code>s&lt;/code> 与其关联。&lt;/p>
&lt;p>`func malloc(size):
  object = &amp;hellip; // allocation magic&lt;/p>
&lt;p>if poisson_sample(size):
    s = stacktrace()
    mem_profile[s].allocs++
    mem_profile[s].alloc_bytes += size
    track_profiled(object, s)&lt;/p>
&lt;p>return object&lt;/p>
&lt;p>`&lt;/p>
&lt;p>当 GC 确定是时候释放分配的对象时，它调用 &lt;code>sweep()&lt;/code> ，使用 &lt;code>is_profiled(object)&lt;/code> 来检查 &lt;code>object&lt;/code> 是否被标记为采样对象。如果是，它将检索导致分配的堆栈跟踪 &lt;code>s&lt;/code>，并在 &lt;code>mem_profile&lt;/code> 内为它增加 &lt;code>frees&lt;/code> 和 &lt;code>free_bytes&lt;/code> 计数器。&lt;/p>
&lt;p>`func sweep(object):
  if is_profiled(object)
    s = alloc_stacktrace(object)
    mem_profile[s].frees++
    mem_profile[s].free_bytes += sizeof(object)&lt;/p>
&lt;p>// deallocation magic&lt;/p>
&lt;p>`&lt;/p>
&lt;p>&lt;code>free_*&lt;/code> 计数器本身不包含在最终 memory profile 中。相反，它们通过简单的 &lt;code>allocs - frees&lt;/code> 减法计算 profile 中的 &lt;code>insue_*&lt;/code> 计数器。另外，最终的输出值是通过取样概率除以它们的比例而得到的。&lt;/p>
&lt;h4 id="memory-profiler-的局限">Memory Profiler 的局限&lt;/h4>
&lt;p>memory profiler 有一些已知的问题还有局限性，需要注意的是 :&lt;/p>
&lt;ul>
&lt;li>⚠️ &lt;code>runtime.MemProfileRate&lt;/code> 必须尽可能早地在程序启动时修改一次，例如在 &lt;code>main()&lt;/code> 的开头。写入这个值本质上是一个产生的数据竞争很小，在程序执行期间多次更改它会产生不正确的配置文件。&lt;/li>
&lt;li>⚠ 在调试潜在的内存泄漏时，memory profiler 可以显示这些分配的是哪里创建的，但它无法告诉你哪些指针还在保持引用。这么些年，一直有人想解决掉这个问题，但没有一个适用于最新版本的 Go。如果你知道有什么好使的工具，请告诉 我[21]。&lt;/li>
&lt;li>⚠ CPU Profiler Labels[22] 或者其他类似的东西不受 memory profiler 支持。在目前的实现中很难添加这个功能，因为它可能会在保存 memory profiler 数据的内部哈希映射中造成内存泄漏。&lt;/li>
&lt;li>⚠ cgo C 代码所做的分配不会显示在 memory profile 文件中。&lt;/li>
&lt;li>⚠ Memory profile 可能是两个垃圾收集周期前的数据。如果你想要一个更一致的时间点快照，可以考虑在请求内存配置文件之前调用 &lt;code>runtime.GC()&lt;/code> 。net/http/pprof[23] 接受 &lt;code>?gc=1&lt;/code> 的参数。更多信息请参阅 runtime.MemProfile()[24] 文档， 以及 &lt;code>mprof.go&lt;/code> 中关于 &lt;code>memRecord&lt;/code> 的注释。&lt;/li>
&lt;li>⚠️ memory profiler 可以在堆栈跟踪中捕获的嵌套函数调用的最大数量目前是 &lt;code>32&lt;/code>, 有关超过此限制时会发生什么情况的更多信息，请参阅 CPU Profiler Limitations[25]。&lt;/li>
&lt;li>⚠️ 保存 memory profile 文件的内部哈希表没有大小限制。这意味着它的大小会不断增长，直到它涵盖您的代码库中的所有分配代码路径。这在实践中不是问题，但如果您正在观察进程的内存使用情况，它可能看起来像一个比较小的内存泄漏。&lt;/li>
&lt;/ul>
&lt;h3 id="threadcreate-profiler">ThreadCreate Profiler&lt;/h3>
&lt;p>🐞 Threadcreate profile 旨在显示导致创建新 OS 线程的堆栈跟踪。然而，它从 2013 年[26]就已经不好使了，所以大家记得不要用。&lt;/p>
&lt;h2 id="免责声明">免责声明&lt;/h2>
&lt;p>原作者是 felixge[27]，在 Datadog[28] 做 Go 的 Continuous Profiling[29]。同时公司也在招人[30] : ).&lt;/p>
&lt;p>欢迎对此指南[31]进行反馈！&lt;/p>
&lt;h3 id="引用链接">引用链接&lt;/h3>
&lt;p>[1]&lt;/p>
&lt;p>twitter: &lt;a href="https://twitter.com/felixge/status/1435537024388304900">&lt;em>https://twitter.com/felixge/status/1435537024388304900&lt;/em>&lt;/a>&lt;/p>
&lt;p>[2]&lt;/p>
&lt;p>所有的模型都是错误的: &lt;a href="https://en.wikipedia.org/wiki/All_models_are_wrong">&lt;em>https://en.wikipedia.org/wiki/All_models_are_wrong&lt;/em>&lt;/a>&lt;/p>
&lt;p>[3]&lt;/p>
&lt;p>Scheduling in Go: &lt;a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html">&lt;em>https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html&lt;/em>&lt;/a>&lt;/p>
&lt;p>[4]&lt;/p>
&lt;p>伸缩性的关键因素: &lt;a href="https://golang.org/doc/faq#goroutines">&lt;em>https://golang.org/doc/faq#goroutines&lt;/em>&lt;/a>&lt;/p>
&lt;p>[5]&lt;/p>
&lt;p>Getting to Go: The Journey of Go&amp;rsquo;s Garbage Collector: &lt;a href="https://go.dev/blog/ismmkeynote">&lt;em>https://go.dev/blog/ismmkeynote&lt;/em>&lt;/a>&lt;/p>
&lt;p>[6]&lt;/p>
&lt;p>Goroutine Scheduler: &lt;a href="https://github.com/DataDog/go-profiler-notes/blob/main/guide/README.md#goroutine-scheduler">&lt;em>https://github.com/DataDog/go-profiler-notes/blob/main/guide/README.md#goroutine-scheduler&lt;/em>&lt;/a>&lt;/p>
&lt;p>[7]&lt;/p>
&lt;p>benesch/cgosymbolizer: &lt;a href="https://github.com/benesch/cgosymbolizer">&lt;em>https://github.com/benesch/cgosymbolizer&lt;/em>&lt;/a>&lt;/p>
&lt;p>[8]&lt;/p>
&lt;p>pprof: &lt;a href="https://github.com/DataDog/go-profiler-notes/blob/main/pprof.md">&lt;em>https://github.com/DataDog/go-profiler-notes/blob/main/pprof.md&lt;/em>&lt;/a>&lt;/p>
&lt;p>[9]&lt;/p>
&lt;p>示例: &lt;a href="https://github.com/DataDog/go-profiler-notes/blob/main/guide/cpu-profiler-labels.go">&lt;em>https://github.com/DataDog/go-profiler-notes/blob/main/guide/cpu-profiler-labels.go&lt;/em>&lt;/a>&lt;/p>
&lt;p>[10]&lt;/p>
&lt;p>pprof.Labels(): &lt;a href="https://pkg.go.dev/runtime/pprof#Labels">&lt;em>https://pkg.go.dev/runtime/pprof#Labels&lt;/em>&lt;/a>&lt;/p>
&lt;p>[11]&lt;/p>
&lt;p>pprof.Labels(): &lt;a href="https://pkg.go.dev/runtime/pprof#Labels">&lt;em>https://pkg.go.dev/runtime/pprof#Labels&lt;/em>&lt;/a>&lt;/p>
&lt;p>[12]&lt;/p>
&lt;p>GitHub issue: &lt;a href="https://github.com/golang/go/issues/35057">&lt;em>https://github.com/golang/go/issues/35057&lt;/em>&lt;/a>&lt;/p>
&lt;p>[13]&lt;/p>
&lt;p>runtime.SetCPUProfileRate(): &lt;a href="https://pkg.go.dev/runtime#SetCPUProfileRate">&lt;em>https://pkg.go.dev/runtime#SetCPUProfileRate&lt;/em>&lt;/a>&lt;/p>
&lt;p>[14]&lt;/p>
&lt;p>这里: &lt;a href="https://github.com/golang/go/issues/40094">&lt;em>https://github.com/golang/go/issues/40094&lt;/em>&lt;/a>&lt;/p>
&lt;p>[15]&lt;/p>
&lt;p>被接受的改进 API 的建议: &lt;a href="https://github.com/golang/go/issues/42502">&lt;em>https://github.com/golang/go/issues/42502&lt;/em>&lt;/a>&lt;/p>
&lt;p>[16]&lt;/p>
&lt;p>64: &lt;a href="https://sourcegraph.com/search?q=context:global+repo:github.com/golang/go+file:src/">&lt;em>https://sourcegraph.com/search?q=context:global+repo:github.com/golang/go+file:src/&lt;/em>&lt;/a>+maxCPUProfStack+%3D&amp;amp;patternType=literal*&lt;/p>
&lt;p>[17]&lt;/p>
&lt;p>pprof.Lookup(): &lt;a href="https://pkg.go.dev/runtime/pprof#Lookup">&lt;em>https://pkg.go.dev/runtime/pprof#Lookup&lt;/em>&lt;/a>&lt;/p>
&lt;p>[18]&lt;/p>
&lt;p>net/http/pprof: &lt;a href="https://pkg.go.dev/net/http/pprof">&lt;em>https://pkg.go.dev/net/http/pprof&lt;/em>&lt;/a>&lt;/p>
&lt;p>[19]&lt;/p>
&lt;p>runtime.MemProfileRate: &lt;a href="https://pkg.go.dev/runtime#MemProfileRate">&lt;em>https://pkg.go.dev/runtime#MemProfileRate&lt;/em>&lt;/a>&lt;/p>
&lt;p>[20]&lt;/p>
&lt;p>Go 1.16 的 runtime: &lt;a href="https://golang.org/doc/go1.16#runtime">&lt;em>https://golang.org/doc/go1.16#runtime&lt;/em>&lt;/a>&lt;/p>
&lt;p>[21]&lt;/p>
&lt;p>我: &lt;a href="https://github.com/DataDog/go-profiler-notes/issues">&lt;em>https://github.com/DataDog/go-profiler-notes/issues&lt;/em>&lt;/a>&lt;/p>
&lt;p>[22]&lt;/p>
&lt;p>CPU Profiler Labels: &lt;em>#cpu-profiler-labels&lt;/em>&lt;/p>
&lt;p>[23]&lt;/p>
&lt;p>net/http/pprof: &lt;a href="https://pkg.go.dev/net/http/pprof">&lt;em>https://pkg.go.dev/net/http/pprof&lt;/em>&lt;/a>&lt;/p>
&lt;p>[24]&lt;/p>
&lt;p>runtime.MemProfile(): &lt;a href="https://pkg.go.dev/runtime#MemProfile">&lt;em>https://pkg.go.dev/runtime#MemProfile&lt;/em>&lt;/a>&lt;/p>
&lt;p>[25]&lt;/p>
&lt;p>CPU Profiler Limitations: &lt;em>#cpu-profiler-limitations&lt;/em>&lt;/p>
&lt;p>[26]&lt;/p>
&lt;p>2013 年: &lt;a href="https://github.com/golang/go/issues/6104">&lt;em>https://github.com/golang/go/issues/6104&lt;/em>&lt;/a>&lt;/p>
&lt;p>[27]&lt;/p>
&lt;p>felixge: &lt;a href="https://github.com/felixge">&lt;em>https://github.com/felixge&lt;/em>&lt;/a>&lt;/p>
&lt;p>[28]&lt;/p>
&lt;p>Datadog: &lt;a href="https://www.datadoghq.com/">&lt;em>https://www.datadoghq.com/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[29]&lt;/p>
&lt;p>Continuous Profiling: &lt;a href="https://www.datadoghq.com/product/code-profiling/">&lt;em>https://www.datadoghq.com/product/code-profiling/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[30]&lt;/p>
&lt;p>招人: &lt;a href="https://www.datadoghq.com/jobs-engineering/#all&amp;amp;all_locations">&lt;em>https://www.datadoghq.com/jobs-engineering/#all&amp;amp;all_locations&lt;/em>&lt;/a>&lt;/p>
&lt;p>[31]&lt;/p>
&lt;p>此指南: &lt;a href="https://github.com/DataDog/go-profiler-notes/blob/main/guide/README.md">&lt;em>https://github.com/DataDog/go-profiler-notes/blob/main/guide/README.md&lt;/em>&lt;/a>&lt;/p></description></item><item><title>Docs: Go 标准库</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/go-%E6%A0%87%E5%87%86%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E6%A0%87%E5%87%86%E5%BA%93/go-%E6%A0%87%E5%87%86%E5%BA%93/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/DesistDaydream/go-learning">GitHub,DesistDaydream/go-learning&lt;/a>(学习代码)&lt;/li>
&lt;li>&lt;a href="https://pkg.go.dev/std">Go 包，标准库&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://studygolang.com/pkgdoc">中文文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://go.dev/tour/list">go.dev,Tour(Go 语言之旅，通过在线解析器体验 Go 语言的各种特性)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Go Standard Library(Go 标准库)&lt;/strong> 也可以称为 &lt;strong>Package(包)&lt;/strong>，每个 package 都可以实现一类功能。&lt;/p>
&lt;p>&lt;a href="https://pkg.go.dev/std">Standard Library(标准库)&lt;/a> 就是 Go 语言 中的 package。每个 package 里有他们对应的常量、变量、函数、方法等。每个库就是一类功能，比如 bufio 库，这里面就是关于实现读写功能的各种内容；而 fmt 库则是关于实现格式化输入输出等功能。在&lt;a href="https://pkg.go.dev/std?tab=packages">这里&lt;/a>可以看到 go 语言 原生支持的所有标准库。&lt;/p>
&lt;p>与 标准库 相对应的就是 &lt;a href="https://www.teambition.com/project/5f90e312755d8a00446050eb/app/5eba5fba6a92214d420a3219/workspaces/5f90e312c800160016ea22fb/folders/5f9d3b0f4cc5830001c21a7c">第三方库&lt;/a> ，第三方库一般属于由个人开发，实现更多丰富功能的库。在 &lt;a href="https://pkg.go.dev/">Go.dev &lt;/a>可以搜索自己想要使用的所有库。&lt;/p>
&lt;p>&lt;a href="https://pkg.go.dev/">Go.dev&lt;/a> 是 golang.org 的配套网站。 Golang.org 是开源项目和发行版的所在地，而 go.dev 是 Go 用户的中心，可从整个 Go 生态系统中提供集中和精选的资源。&lt;/p>
&lt;p>Go.dev 提供：&lt;/p>
&lt;ul>
&lt;li>在 index.golang.org 上发布的 Go 软件包和模块的集中信息。&lt;/li>
&lt;li>基本学习资源&lt;/li>
&lt;li>关键用例和案例研究&lt;/li>
&lt;/ul>
&lt;p>Go.dev 当前处于 MVP 状态。我们为自己的建设感到自豪，并很高兴与社区分享。我们希望您能在使用 go.dev 的过程中找到价值和乐趣。 Go.dev 只有一小部分我们打算构建的功能，我们正在积极寻求反馈。如果您有任何想法，建议或问题，请告诉我们.&lt;/p></description></item><item><title>Docs: Go 常见问题</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</guid><description>
&lt;h1 id="goroutines-与-oschdir">goroutines 与 os.Chdir&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/golang/go/issues/27658">GitHub 项目,golang/go-issue-27658&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>In short, the bug report is that if two different goroutines call os.Chdir concurrently, it is unpredictable which will take effect.
简而言之，错误报告是，如果两种不同的 Goroutines 同时调用 OS.Chdir，则这将生效是不可预测的。
That is true. os.Chdir is a process-wide attribute, not a per-goroutine or per-thread attribute. Even if we could figure out a way to change that&amp;ndash;nothing comes to mind&amp;ndash;we could not change it now because it would break existing Go programs that call os.Chdir in one goroutine and expect it to affect another goroutine.
那是真实的。 OS.Chdir 是一个流程范围的属性，而不是每个 goroutine 或 per-thread 属性。即使我们能够弄清楚改变的方式 - 没有什么意思 - 没有什么想到的 - 我们现在无法改变它，因为它会破坏一个大峡谷中调用 OS.Chdir 的现有 Go 程序，并期望它会影响另一个大花序。
Closing as unfortunate.
关闭不幸。&lt;/p></description></item><item><title>Docs: Go 单元测试</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;h2 id="1-如何写好单元测试">1 如何写好单元测试&lt;/h2>
&lt;p>单元测试(Unit Tests, UT) 是一个优秀项目不可或缺的一部分，特别是在一些频繁变动和多人合作开发的项目中尤为重要。你或多或少都会有因为自己的提交，导致应用挂掉或服务宕机的经历。如果这个时候你的修改导致测试用例失败，你再重新审视自己的修改，发现之前的修改还有一些特殊场景没有包含，恭喜你减少了一次上库失误。也会有这样的情况，项目很大，启动环境很复杂，你优化了一个函数的性能，或是添加了某个新的特性，如果部署在正式环境上之后再进行测试，成本太高。对于这种场景，几个小小的测试用例或许就能够覆盖大部分的测试场景。而且在开发过程中，效率最高的莫过于所见即所得了，单元测试也能够帮助你做到这一点，试想一下，假如你一口气写完一千行代码，debug 的过程也不会轻松，如果在这个过程中，对于一些逻辑较为复杂的函数，同时添加一些测试用例，即时确保正确性，最后集成的时候，会是另外一番体验。&lt;/p>
&lt;p>如何写好单元测试呢？&lt;/p>
&lt;p>首先，学会写测试用例。比如如何测试单个函数/方法；比如如何做基准测试；比如如何写出简洁精炼的测试代码；再比如遇到数据库访问等的方法调用时，如何 &lt;code>mock&lt;/code>。&lt;/p>
&lt;p>然后，写可测试的代码。&lt;code>高内聚，低耦合&lt;/code>是软件工程的原则，同样，对测试而言，函数/方法写法不同，测试难度也是不一样的。职责单一，参数类型简单，与其他函数耦合度低的函数往往更容易测试。我们经常会说，“这种代码没法测试”，这种时候，就得思考函数的写法可不可以改得更好一些。为了代码可测试而重构是值得的。&lt;/p>
&lt;p>接下来将介绍如何使用 Go 语言的标准库 &lt;code>testing&lt;/code> 进行单元测试。&lt;/p>
&lt;h2 id="2-一个简单例子">2 一个简单例子&lt;/h2>
&lt;p>Go 语言推荐测试文件和源代码文件放在一块，测试文件以 &lt;code>_test.go&lt;/code> 结尾。比如，当前 package 有 &lt;code>calc.go&lt;/code> 一个文件，我们想测试 &lt;code>calc.go&lt;/code> 中的 &lt;code>Add&lt;/code> 和 &lt;code>Mul&lt;/code> 函数，那么应该新建 &lt;code>calc_test.go&lt;/code> 作为测试文件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>example/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |--calc.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |--calc_test.go
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>假如 &lt;code>calc.go&lt;/code> 的代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Mul&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么 &lt;code>calc_test.go&lt;/code> 中的测试用例可以这么写：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;testing&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestAdd&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">ans&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>); &lt;span style="color:#a6e22e">ans&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;1 + 2 expected be 3, but %d got&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">ans&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">ans&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">20&lt;/span>); &lt;span style="color:#a6e22e">ans&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">30&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;-10 + -20 expected be -30, but %d got&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">ans&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>测试用例名称一般命名为 &lt;code>Test&lt;/code> 加上待测试的方法名。&lt;/li>
&lt;li>测试用的参数有且只有一个，在这里是 &lt;code>t *testing.T&lt;/code>。&lt;/li>
&lt;li>基准测试(benchmark)的参数是 &lt;code>*testing.B&lt;/code>，TestMain 的参数是 &lt;code>*testing.M&lt;/code> 类型。&lt;/li>
&lt;/ul>
&lt;p>运行 &lt;code>go test&lt;/code>，该 package 下所有的测试用例都会被执行。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ go test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ok example 0.009s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或 &lt;code>go test -v&lt;/code>，&lt;code>-v&lt;/code> 参数会显示每个用例的测试结果，另外 &lt;code>-cover&lt;/code> 参数可以查看覆盖率。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ go test -v
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">===&lt;/span> RUN TestAdd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--- PASS: TestAdd &lt;span style="color:#f92672">(&lt;/span>0.00s&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">===&lt;/span> RUN TestMul
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--- PASS: TestMul &lt;span style="color:#f92672">(&lt;/span>0.00s&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PASS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ok example 0.007s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果只想运行其中的一个用例，例如 &lt;code>TestAdd&lt;/code>，可以用 &lt;code>-run&lt;/code> 参数指定，该参数支持通配符 &lt;code>*&lt;/code>，和部分正则表达式，例如 &lt;code>^&lt;/code>、&lt;code>$&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ go test -run TestAdd -v
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">===&lt;/span> RUN TestAdd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--- PASS: TestAdd &lt;span style="color:#f92672">(&lt;/span>0.00s&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PASS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ok example 0.007s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="3-子测试subtests">3 子测试(Subtests)&lt;/h2>
&lt;p>子测试是 Go 语言内置支持的，可以在某个测试用例中，根据测试场景使用 &lt;code>t.Run&lt;/code>创建不同的子测试用例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestMul&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Run&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;pos&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">Mul&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Fatal&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;fail&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Run&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;neg&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">Mul&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">6&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Fatal&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;fail&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>之前的例子测试失败时使用 &lt;code>t.Error/t.Errorf&lt;/code>，这个例子中使用 &lt;code>t.Fatal/t.Fatalf&lt;/code>，区别在于前者遇错不停，还会继续执行其他的测试用例，后者遇错即停。&lt;/li>
&lt;/ul>
&lt;p>运行某个测试用例的子测试：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ go test -run TestMul/pos -v
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">===&lt;/span> RUN TestMul
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">===&lt;/span> RUN TestMul/pos
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--- PASS: TestMul &lt;span style="color:#f92672">(&lt;/span>0.00s&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --- PASS: TestMul/pos &lt;span style="color:#f92672">(&lt;/span>0.00s&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PASS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ok example 0.008s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于多个子测试的场景，更推荐如下的写法(table-driven tests)：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestMul&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">cases&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">A&lt;/span>, &lt;span style="color:#a6e22e">B&lt;/span>, &lt;span style="color:#a6e22e">Expected&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;pos&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;neg&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">6&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;zero&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">cases&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Run&lt;/span>(&lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>, &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">ans&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">Mul&lt;/span>(&lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">A&lt;/span>, &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">B&lt;/span>); &lt;span style="color:#a6e22e">ans&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">Expected&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Fatalf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%d * %d expected %d, but %d got&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">A&lt;/span>, &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">B&lt;/span>, &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">Expected&lt;/span>, &lt;span style="color:#a6e22e">ans&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所有用例的数据组织在切片 &lt;code>cases&lt;/code> 中，看起来就像一张表，借助循环创建子测试。这样写的好处有：&lt;/p>
&lt;ul>
&lt;li>新增用例非常简单，只需给 cases 新增一条测试数据即可。&lt;/li>
&lt;li>测试代码可读性好，直观地能够看到每个子测试的参数和期待的返回值。&lt;/li>
&lt;li>用例失败时，报错信息的格式比较统一，测试报告易于阅读。&lt;/li>
&lt;/ul>
&lt;p>如果数据量较大，或是一些二进制数据，推荐使用相对路径从文件中读取。&lt;/p>
&lt;h2 id="4-帮助函数helpers">4 帮助函数(helpers)&lt;/h2>
&lt;p>对一些重复的逻辑，抽取出来作为公共的帮助函数(helpers)，可以增加测试代码的可读性和可维护性。 借助帮助函数，可以让测试用例的主逻辑看起来更清晰。&lt;/p>
&lt;p>例如，我们可以将创建子测试的逻辑抽取出来：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;testing&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">calcCase&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{ &lt;span style="color:#a6e22e">A&lt;/span>, &lt;span style="color:#a6e22e">B&lt;/span>, &lt;span style="color:#a6e22e">Expected&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">createMulTestCase&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">calcCase&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">ans&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">Mul&lt;/span>(&lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">A&lt;/span>, &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">B&lt;/span>); &lt;span style="color:#a6e22e">ans&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">Expected&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Fatalf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%d * %d expected %d, but %d got&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">A&lt;/span>, &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">B&lt;/span>, &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">Expected&lt;/span>, &lt;span style="color:#a6e22e">ans&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestMul&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">createMulTestCase&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">calcCase&lt;/span>{&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">createMulTestCase&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">calcCase&lt;/span>{&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">6&lt;/span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">createMulTestCase&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">calcCase&lt;/span>{&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这里，我们故意创建了一个错误的测试用例，运行 &lt;code>go test&lt;/code>，用例失败，会报告错误发生的文件和行号信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ go test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--- FAIL: TestMul &lt;span style="color:#f92672">(&lt;/span>0.00s&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> calc_test.go:11: &lt;span style="color:#ae81ff">2&lt;/span> * &lt;span style="color:#ae81ff">0&lt;/span> expected 1, but &lt;span style="color:#ae81ff">0&lt;/span> got
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FAIL
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exit status &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FAIL example 0.007s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，错误发生在第 11 行，也就是帮助函数 &lt;code>createMulTestCase&lt;/code> 内部。18, 19, 20 行都调用了该方法，我们第一时间并不能够确定是哪一行发生了错误。有些帮助函数还可能在不同的函数中被调用，报错信息都在同一处，不方便问题定位。因此，Go 语言在 1.9 版本中引入了 &lt;code>t.Helper()&lt;/code>，用于标注该函数是帮助函数，报错时将输出帮助函数调用者的信息，而不是帮助函数的内部信息。&lt;/p>
&lt;p>修改 &lt;code>createMulTestCase&lt;/code>，调用 &lt;code>t.Helper()&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">createMulTestCase&lt;/span>(&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">calcCase&lt;/span>, &lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Helper&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Run&lt;/span>(&lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>, &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">ans&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">Mul&lt;/span>(&lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">A&lt;/span>, &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">B&lt;/span>); &lt;span style="color:#a6e22e">ans&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">Expected&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Fatalf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%d * %d expected %d, but %d got&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">A&lt;/span>, &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">B&lt;/span>, &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">Expected&lt;/span>, &lt;span style="color:#a6e22e">ans&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行 &lt;code>go test&lt;/code>，报错信息如下，可以非常清晰地知道，错误发生在第 20 行。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ go test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--- FAIL: TestMul &lt;span style="color:#f92672">(&lt;/span>0.00s&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> calc_test.go:20: &lt;span style="color:#ae81ff">2&lt;/span> * &lt;span style="color:#ae81ff">0&lt;/span> expected 1, but &lt;span style="color:#ae81ff">0&lt;/span> got
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FAIL
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exit status &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FAIL example 0.006s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>关于 &lt;code>helper&lt;/code> 函数的 2 个建议：&lt;/p>
&lt;ul>
&lt;li>不要返回错误， 帮助函数内部直接使用 &lt;code>t.Error&lt;/code> 或 &lt;code>t.Fatal&lt;/code> 即可，在用例主逻辑中不会因为太多的错误处理代码，影响可读性。&lt;/li>
&lt;li>调用 &lt;code>t.Helper()&lt;/code> 让报错信息更准确，有助于定位。&lt;/li>
&lt;/ul>
&lt;h2 id="5-setup-和-teardown">5 setup 和 teardown&lt;/h2>
&lt;p>如果在同一个测试文件中，每一个测试用例运行前后的逻辑是相同的，一般会写在 setup 和 teardown 函数中。例如执行前需要实例化待测试的对象，如果这个对象比较复杂，很适合将这一部分逻辑提取出来；执行后，可能会做一些资源回收类的工作，例如关闭网络连接，释放文件等。标准库 &lt;code>testing&lt;/code> 提供了这样的机制：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">setup&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Before all tests&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">teardown&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;After all tests&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Test1&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;I&amp;#39;m test1&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Test2&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;I&amp;#39;m test2&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestMain&lt;/span>(&lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">M&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">setup&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">code&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">Run&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">teardown&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Exit&lt;/span>(&lt;span style="color:#a6e22e">code&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>在这个测试文件中，包含有 2 个测试用例，&lt;code>Test1&lt;/code> 和 &lt;code>Test2&lt;/code>。&lt;/li>
&lt;li>如果测试文件中包含函数 &lt;code>TestMain&lt;/code>，那么生成的测试将调用 TestMain(m)，而不是直接运行测试。&lt;/li>
&lt;li>调用 &lt;code>m.Run()&lt;/code> 触发所有测试用例的执行，并使用 &lt;code>os.Exit()&lt;/code> 处理返回的状态码，如果不为 0，说明有用例失败。&lt;/li>
&lt;li>因此可以在调用 &lt;code>m.Run()&lt;/code> 前后做一些额外的准备(setup)和回收(teardown)工作。&lt;/li>
&lt;/ul>
&lt;p>执行 &lt;code>go test&lt;/code>，将会输出&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ go test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Before all tests
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>I&lt;span style="color:#e6db74">&amp;#39;m test1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">I&amp;#39;&lt;/span>m test2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PASS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>After all tests
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ok example 0.006s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="6-网络测试network">6 网络测试(Network)&lt;/h2>
&lt;h3 id="61-tcphttp">6.1 TCP/HTTP&lt;/h3>
&lt;p>假设需要测试某个 API 接口的 handler 能够正常工作，例如 helloHandler&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">helloHandler&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">ResponseWriter&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Request&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">w&lt;/span>.&lt;span style="color:#a6e22e">Write&lt;/span>([]byte(&lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那我们可以创建真实的网络连接进行测试：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;io/ioutil&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;net&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;net/http&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;testing&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">handleError&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Helper&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Fatal&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;failed&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestConn&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ln&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">net&lt;/span>.&lt;span style="color:#a6e22e">Listen&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;tcp&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;127.0.0.1:0&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">handleError&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">ln&lt;/span>.&lt;span style="color:#a6e22e">Close&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">HandleFunc&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/hello&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">helloHandler&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Serve&lt;/span>(&lt;span style="color:#a6e22e">ln&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">resp&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;http://&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">ln&lt;/span>.&lt;span style="color:#a6e22e">Addr&lt;/span>().&lt;span style="color:#a6e22e">String&lt;/span>() &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/hello&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">handleError&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">resp&lt;/span>.&lt;span style="color:#a6e22e">Body&lt;/span>.&lt;span style="color:#a6e22e">Close&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">body&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ioutil&lt;/span>.&lt;span style="color:#a6e22e">ReadAll&lt;/span>(&lt;span style="color:#a6e22e">resp&lt;/span>.&lt;span style="color:#a6e22e">Body&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">handleError&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> string(&lt;span style="color:#a6e22e">body&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Fatal&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;expected hello world, but got&amp;#34;&lt;/span>, string(&lt;span style="color:#a6e22e">body&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:0&amp;quot;)&lt;/code>：监听一个未被占用的端口，并返回 Listener。&lt;/li>
&lt;li>调用 &lt;code>http.Serve(ln, nil)&lt;/code> 启动 http 服务。&lt;/li>
&lt;li>使用 &lt;code>http.Get&lt;/code> 发起一个 Get 请求，检查返回值是否正确。&lt;/li>
&lt;li>尽量不对 &lt;code>http&lt;/code> 和 &lt;code>net&lt;/code> 库使用 mock，这样可以覆盖较为真实的场景。&lt;/li>
&lt;/ul>
&lt;h3 id="62-httptest">6.2 httptest&lt;/h3>
&lt;p>针对 http 开发的场景，使用标准库 &lt;code>net/http/httptest&lt;/code> 进行测试更为高效。&lt;/p>
&lt;p>上述的测试用例改写如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;io/ioutil&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;net/http&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;net/http/httptest&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;testing&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestConn&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">req&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">httptest&lt;/span>.&lt;span style="color:#a6e22e">NewRequest&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;GET&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;http://example.com/foo&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">w&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">httptest&lt;/span>.&lt;span style="color:#a6e22e">NewRecorder&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">helloHandler&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span>, &lt;span style="color:#a6e22e">req&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">bytes&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ioutil&lt;/span>.&lt;span style="color:#a6e22e">ReadAll&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span>.&lt;span style="color:#a6e22e">Result&lt;/span>().&lt;span style="color:#a6e22e">Body&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> string(&lt;span style="color:#a6e22e">bytes&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Fatal&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;expected hello world, but got&amp;#34;&lt;/span>, string(&lt;span style="color:#a6e22e">bytes&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 httptest 模拟请求对象(req)和响应对象(w)，达到了相同的目的。&lt;/p>
&lt;h2 id="7-benchmark-基准测试">7 Benchmark 基准测试&lt;/h2>
&lt;p>基准测试用例的定义如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">BenchmarkName&lt;/span>(&lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">B&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>函数名必须以 &lt;code>Benchmark&lt;/code> 开头，后面一般跟待测试的函数名&lt;/li>
&lt;li>参数为 &lt;code>b *testing.B&lt;/code>。&lt;/li>
&lt;li>执行基准测试时，需要添加 &lt;code>-bench&lt;/code> 参数。&lt;/li>
&lt;/ul>
&lt;p>例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">BenchmarkHello&lt;/span>(&lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">B&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">b&lt;/span>.&lt;span style="color:#a6e22e">N&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Sprintf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ go test -benchmem -bench .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BenchmarkHello-16 &lt;span style="color:#ae81ff">15991854&lt;/span> 71.6 ns/op &lt;span style="color:#ae81ff">5&lt;/span> B/op &lt;span style="color:#ae81ff">1&lt;/span> allocs/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>基准测试报告每一列值对应的含义如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">BenchmarkResult&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">N&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Duration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Bytes&lt;/span> &lt;span style="color:#66d9ef">int64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">MemAllocs&lt;/span> &lt;span style="color:#66d9ef">uint64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">MemBytes&lt;/span> &lt;span style="color:#66d9ef">uint64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果在运行前基准测试需要一些耗时的配置，则可以使用 &lt;code>b.ResetTimer()&lt;/code> 先重置定时器，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">BenchmarkHello&lt;/span>(&lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">B&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">b&lt;/span>.&lt;span style="color:#a6e22e">ResetTimer&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">b&lt;/span>.&lt;span style="color:#a6e22e">N&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Sprintf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 &lt;code>RunParallel&lt;/code> 测试并发性能&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">BenchmarkParallel&lt;/span>(&lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">B&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">templ&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">template&lt;/span>.&lt;span style="color:#a6e22e">Must&lt;/span>(&lt;span style="color:#a6e22e">template&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;test&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">Parse&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello, {{.}}!&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">b&lt;/span>.&lt;span style="color:#a6e22e">RunParallel&lt;/span>(&lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">pb&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">PB&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">buf&lt;/span> &lt;span style="color:#a6e22e">bytes&lt;/span>.&lt;span style="color:#a6e22e">Buffer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">buf&lt;/span>.&lt;span style="color:#a6e22e">Reset&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">templ&lt;/span>.&lt;span style="color:#a6e22e">Execute&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">buf&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;World&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ go test -benchmem -bench .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BenchmarkParallel-16 &lt;span style="color:#ae81ff">3325430&lt;/span> &lt;span style="color:#ae81ff">375&lt;/span> ns/op &lt;span style="color:#ae81ff">272&lt;/span> B/op &lt;span style="color:#ae81ff">8&lt;/span> allocs/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="附-参考">附 参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://geektutu.com/post/quick-gomock.html">Go Mock (gomock) 简明教程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://golang.org/pkg/testing/">testing - golang.org&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://about.sourcegraph.com/go/advanced-testing-in-go">Advanced Testing in Go - sourcegraph.com&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="go-test-命令行工具">go test 命令行工具&lt;/h1>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>go test [build/test FLAGS] [PACKAGES] [build/test FLAGS &amp;amp; test binary FLAGS]&lt;/strong>&lt;/p>
&lt;h3 id="flags">FLAGS&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>-v&lt;/strong> # 打印完整的输出，要不只能看到一个运行是否成功的提示和消耗时间&lt;/li>
&lt;li>&lt;strong>-run&lt;/strong> # 指定要运行的测试函数&lt;/li>
&lt;/ul>
&lt;h2 id="example">Example&lt;/h2>
&lt;p>运行文件夹下 *.go 的所有测试函数&lt;/p>
&lt;ul>
&lt;li>&lt;code>go test -v pkg/4_arrays_and_slices/array/*.go&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>运行文件夹下 *.go 文件中名为 TestArrays 这个测试函数&lt;/p>
&lt;ul>
&lt;li>&lt;code>go test -run ^TestArrays$ -v pkg/4_arrays_and_slices/array/*.go&lt;/code>&lt;/li>
&lt;/ul></description></item><item><title>Docs: Go 第三方库</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/go-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;h1 id="日志">日志&lt;/h1>
&lt;h2 id="logrus">logrus&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/sirupsen/logrus">GitHub 项目，sirupsen/logrus&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pkg.go.dev/github.com/sirupsen/logrus">https://pkg.go.dev/github.com/sirupsen/logrus&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Logrus 是一种结构化得用于 Go 语言的日志处理器，完全与 Go 标准库中的 log 库。这名字来源于吉祥物 Walrus(海象)，所以在官方文档中，所有示例都与 Walrus 相关。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;github.com/sirupsen/logrus&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Logrus 共有七个日志级别，由高到底分别为：Trace、Debug、Info、Warning、Error、Fatal、Panic
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 默认情况下，只有 Info 及以下级别可以正常输出。如果想要输出高级别日志，通过 SetLevel() 函数设置日志级别即可
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// SetLevel() 函数的实参可以通过 ParseLevel() 函数将字符串解析为对应级别
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// logrus.SetLevel(logrus.InfoLevel)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 输出 Info 级别的日志内容
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">logrus&lt;/span>.&lt;span style="color:#a6e22e">Info&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello World&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 输出内容如下：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// time=&amp;#34;2021-09-20T11:58:36+08:00&amp;#34; level=info msg=&amp;#34;Hello World&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="文件处理">文件处理&lt;/h1>
&lt;h2 id="excel-文件处理">Excel 文件处理&lt;/h2>
&lt;h3 id="excelize">Excelize&lt;/h3>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/xuri/excelize">GitHub 项目，xuri/excelize&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://xuri.me/excelize/zh-hans/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item></channel></rss>