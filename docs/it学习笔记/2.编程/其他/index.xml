<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 其他</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E5%85%B6%E4%BB%96/</link><description>Recent content in 其他 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E5%85%B6%E4%BB%96/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Make 命令教程</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E5%85%B6%E4%BB%96/make-%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E5%85%B6%E4%BB%96/make-%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/make.1.html">Manual(手册)，make(1)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Make_(software)">Wiki,Make(software)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ruanyifeng.com/blog/2015/02/make.html">阮一峰博客，Make 命令教程&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="make-命令教程">Make 命令教程&lt;/h1>
&lt;p>代码变成可执行文件，叫做&lt;a href="https://www.ruanyifeng.com/blog/2014/11/compiler.html">编译&lt;/a>（compile）；先编译这个，还是先编译那个（即编译的安排），叫做&lt;a href="https://en.wikipedia.org/wiki/Software_build">构建&lt;/a>（build）。&lt;/p>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Make_%28software%29">Make&lt;/a>是最常用的构建工具，诞生于 1977 年，主要用于 C 语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用 Make 构建。&lt;/p>
&lt;p>本文介绍 Make 命令的用法，从简单的讲起，不需要任何基础，只要会使用命令行，就能看懂。我的参考资料主要是 Isaac Schlueter 的&lt;a href="https://gist.github.com/isaacs/62a2d1825d04437c6f08">《Makefile 文件教程》&lt;/a>和&lt;a href="https://www.gnu.org/software/make/manual/make.html">《GNU Make 手册》&lt;/a>。&lt;/p>
&lt;h2 id="一make-的概念">一、Make 的概念&lt;/h2>
&lt;p>Make 这个词，英语的意思是&amp;quot;制作&amp;quot;。Make 命令直接用了这个意思，就是要做出某个文件。比如，要做出文件 a.txt，就可以执行下面的命令。&lt;/p>
&lt;pre>&lt;code> $ make a.txt
&lt;/code>&lt;/pre>
&lt;p>但是，如果你真的输入这条命令，它并不会起作用。因为 Make 命令本身并不知道，如何做出 a.txt，需要有人告诉它，如何调用其他命令完成这个目标。&lt;/p>
&lt;p>比如，假设文件 a.txt 依赖于 b.txt 和 c.txt ，是后面两个文件连接（cat 命令）的产物。那么，make 需要知道下面的规则。&lt;/p>
&lt;pre>&lt;code> a.txt: b.txt c.txt
cat b.txt c.txt &amp;gt; a.txt
&lt;/code>&lt;/pre>
&lt;p>也就是说，make a.txt 这条命令的背后，实际上分成两步：第一步，确认 b.txt 和 c.txt 必须已经存在，第二步使用 cat 命令 将这个两个文件合并，输出为新文件。&lt;/p>
&lt;p>像这样的规则，都写在一个叫做 Makefile 的文件中，Make 命令依赖这个文件进行构建。Makefile 文件也可以写为 makefile， 或者用命令行参数指定为其他文件名。&lt;/p>
&lt;pre>&lt;code> $ make -f rules.txt
$ make --file=rules.txt
&lt;/code>&lt;/pre>
&lt;p>上面代码指定 make 命令依据 rules.txt 文件中的规则，进行构建。&lt;/p>
&lt;p>总之，make 只是一个根据指定的 Shell 命令进行构建的工具。它的规则很简单，你规定要构建哪个文件、它依赖哪些源文件，当那些文件有变动时，如何重新构建它。&lt;/p>
&lt;h2 id="二makefile-文件的格式">二、Makefile 文件的格式&lt;/h2>
&lt;p>构建规则都写在 Makefile 文件里面，要学会如何 Make 命令，就必须学会如何编写 Makefile 文件。&lt;/p>
&lt;h3 id="21-概述">2.1 概述&lt;/h3>
&lt;p>Makefile 文件由一系列规则（rules）构成。每条规则的形式如下。&lt;/p>
&lt;pre>&lt;code> &amp;lt;target&amp;gt; : &amp;lt;prerequisites&amp;gt;
[tab] &amp;lt;commands&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>上面第一行冒号前面的部分，叫做&amp;quot;目标&amp;quot;（target），冒号后面的部分叫做&amp;quot;前置条件&amp;quot;（prerequisites）；第二行必须由一个 tab 键起首，后面跟着&amp;quot;命令&amp;quot;（commands）。&lt;/p>
&lt;p>&amp;ldquo;目标&amp;quot;是必需的，不可省略；&amp;ldquo;前置条件&amp;quot;和&amp;quot;命令&amp;quot;都是可选的，但是两者之中必须至少存在一个。&lt;/p>
&lt;p>每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。&lt;/p>
&lt;h3 id="22-目标target">2.2 目标（target）&lt;/h3>
&lt;p>一个目标（target）就构成一条规则。目标通常是文件名，指明 Make 命令所要构建的对象，比如上文的 a.txt 。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。&lt;/p>
&lt;p>除了文件名，目标还可以是某个操作的名字，这称为&amp;quot;伪目标&amp;rdquo;（phony target）。&lt;/p>
&lt;pre>&lt;code> clean:
rm *.o
&lt;/code>&lt;/pre>
&lt;p>上面代码的目标是 clean，它不是文件名，而是一个操作的名字，属于&amp;quot;伪目标 &amp;ldquo;，作用是删除对象文件。&lt;/p>
&lt;pre>&lt;code> $ make clean
&lt;/code>&lt;/pre>
&lt;p>但是，如果当前目录中，正好有一个文件叫做 clean，那么这个命令不会执行。因为 Make 发现 clean 文件已经存在，就认为没有必要重新构建了，就不会执行指定的 rm 命令。&lt;/p>
&lt;p>为了避免这种情况，可以明确声明 clean 是&amp;quot;伪目标&amp;rdquo;，写法如下。&lt;/p>
&lt;pre>&lt;code> .PHONY: clean
clean:
rm *.o temp
&lt;/code>&lt;/pre>
&lt;p>声明 clean 是&amp;quot;伪目标&amp;quot;之后，make 就不会去检查是否存在一个叫做 clean 的文件，而是每次运行都执行对应的命令。像.PHONY 这样的内置目标名还有不少，可以查看&lt;a href="https://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets">手册&lt;/a>。&lt;/p>
&lt;p>如果 Make 命令运行时没有指定目标，默认会执行 Makefile 文件的第一个目标。&lt;/p>
&lt;pre>&lt;code> $ make
&lt;/code>&lt;/pre>
&lt;p>上面代码执行 Makefile 文件的第一个目标。&lt;/p>
&lt;h3 id="23-前置条件prerequisites">2.3 前置条件（prerequisites）&lt;/h3>
&lt;p>前置条件通常是一组文件名或其他 Target(目标)，之间用空格分隔。它指定了&amp;quot;目标&amp;quot;是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的 last-modification 时间戳比目标的时间戳新），&amp;ldquo;目标&amp;quot;就需要重新构建。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-makefile" data-lang="makefile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">result.txt&lt;/span>&lt;span style="color:#f92672">:&lt;/span> source.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cp source.txt result.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面代码中，构建 result.txt 的前置条件是 source.txt 。如果当前目录中，source.txt 已经存在，那么&lt;code>make result.txt&lt;/code>可以正常运行，否则必须再写一条规则，来生成 source.txt 。&lt;/p>
&lt;pre>&lt;code> source.txt:
echo &amp;quot;this is the source&amp;quot; &amp;gt; source.txt
&lt;/code>&lt;/pre>
&lt;p>上面代码中，source.txt 后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件还不存在，每次调用&lt;code>make source.txt&lt;/code>，它都会生成。&lt;/p>
&lt;pre>&lt;code>$ make result.txt
$ make result.txt
&lt;/code>&lt;/pre>
&lt;p>上面命令连续执行两次&lt;code>make result.txt&lt;/code>。第一次执行会先新建 source.txt，然后再新建 result.txt。第二次执行，Make 发现 source.txt 没有变动（时间戳晚于 result.txt），就不会执行任何操作，result.txt 也不会重新生成。&lt;/p>
&lt;p>如果需要生成多个文件，往往采用下面的写法。&lt;/p>
&lt;pre>&lt;code> source: file1 file2 file3
&lt;/code>&lt;/pre>
&lt;p>上面代码中，source 是一个伪目标，只有三个前置文件，没有任何对应的命令。&lt;/p>
&lt;pre>&lt;code> $ make source
&lt;/code>&lt;/pre>
&lt;p>执行&lt;code>make source&lt;/code>命令后，就会一次性生成 file1，file2，file3 三个文件。这比下面的写法要方便很多。&lt;/p>
&lt;pre>&lt;code>$ make file1
$ make file2
$ make file3
&lt;/code>&lt;/pre>
&lt;h3 id="24-命令commands">2.4 命令（commands）&lt;/h3>
&lt;p>命令（commands）表示如何更新目标文件，由一行或多行的 Shell 命令组成。它是构建&amp;quot;目标&amp;quot;的具体指令，它的运行结果通常就是生成目标文件。&lt;/p>
&lt;p>每行命令之前必须有一个 tab 键。如果想用其他键，可以用内置变量.RECIPEPREFIX 声明。&lt;/p>
&lt;pre>&lt;code> .RECIPEPREFIX = &amp;gt;
all:
&amp;gt; echo Hello, world
&lt;/code>&lt;/pre>
&lt;p>上面代码用.RECIPEPREFIX 指定，大于号（&amp;gt;）替代 tab 键。所以，每一行命令的起首变成了大于号，而不是 tab 键。&lt;/p>
&lt;p>需要注意的是，每行命令在一个单独的 shell 中执行。这些 Shell 之间没有继承关系。&lt;/p>
&lt;pre>&lt;code> var-lost:
export foo=bar
echo &amp;quot;foo=[$$foo]&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>上面代码执行后（&lt;code>make var-lost&lt;/code>），取不到 foo 的值。因为两行命令在两个不同的进程执行。一个解决办法是将两行命令写在一行，中间用分号分隔。&lt;/p>
&lt;pre>&lt;code> var-kept:
export foo=bar; echo &amp;quot;foo=[$$foo]&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>另一个解决办法是在换行符前加反斜杠转义。&lt;/p>
&lt;pre>&lt;code> var-kept:
export foo=bar; \
echo &amp;quot;foo=[$$foo]&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>最后一个方法是加上&lt;code>.ONESHELL:&lt;/code>命令。&lt;/p>
&lt;pre>&lt;code> .ONESHELL:
var-kept:
export foo=bar;
echo &amp;quot;foo=[$$foo]&amp;quot;
&lt;/code>&lt;/pre>
&lt;h2 id="三makefile-文件的语法">三、Makefile 文件的语法&lt;/h2>
&lt;h3 id="31-注释">3.1 注释&lt;/h3>
&lt;p>井号（#）在 Makefile 中表示注释。&lt;/p>
&lt;pre>&lt;code> result.txt: source.txt
cp source.txt result.txt
&lt;/code>&lt;/pre>
&lt;h3 id="32-回声echoing">3.2 回声（echoing）&lt;/h3>
&lt;p>正常情况下，make 会打印每条命令，然后再执行，这就叫做回声（echoing）。&lt;/p>
&lt;pre>&lt;code> test:
&lt;/code>&lt;/pre>
&lt;p>执行上面的规则，会得到下面的结果。&lt;/p>
&lt;pre>&lt;code> $ make test
&lt;/code>&lt;/pre>
&lt;p>在命令的前面加上@，就可以关闭回声。&lt;/p>
&lt;pre>&lt;code> test:
@
&lt;/code>&lt;/pre>
&lt;p>现在再执行&lt;code>make test&lt;/code>，就不会有任何输出。&lt;/p>
&lt;p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的 echo 命令前面加上@。&lt;/p>
&lt;pre>&lt;code> test:
@ @echo TODO
&lt;/code>&lt;/pre>
&lt;h3 id="33-通配符">3.3 通配符&lt;/h3>
&lt;p>通配符（wildcard）用来指定一组符合条件的文件名。Makefile 的通配符与 Bash 一致，主要有星号（_）、问号（？）和 [&amp;hellip;] 。比如， _.o 表示所有后缀名为 o 的文件。&lt;/p>
&lt;pre>&lt;code> clean:
rm -f *.o
&lt;/code>&lt;/pre>
&lt;h3 id="34-模式匹配">3.4 模式匹配&lt;/h3>
&lt;p>Make 命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。&lt;/p>
&lt;pre>&lt;code> %.o: %.c
&lt;/code>&lt;/pre>
&lt;p>等同于下面的写法。&lt;/p>
&lt;pre>&lt;code> f1.o: f1.c
f2.o: f2.c
&lt;/code>&lt;/pre>
&lt;p>使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。&lt;/p>
&lt;h3 id="35-变量和赋值符">3.5 变量和赋值符&lt;/h3>
&lt;p>Makefile 允许使用等号自定义变量。&lt;/p>
&lt;pre>&lt;code> txt = Hello World
test:
@echo $(txt)
&lt;/code>&lt;/pre>
&lt;p>上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中。&lt;/p>
&lt;p>调用 Shell 变量，需要在美元符号前，再加一个美元符号，这是因为 Make 命令会对美元符号转义。&lt;/p>
&lt;pre>&lt;code> test:
@echo $$HOME
&lt;/code>&lt;/pre>
&lt;p>有时，变量的值可能指向另一个变量。&lt;/p>
&lt;pre>&lt;code> v1 = $(v2)
&lt;/code>&lt;/pre>
&lt;p>上面代码中，变量 v1 的值是另一个变量 v2。这时会产生一个问题，v1 的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。&lt;/p>
&lt;p>为了解决类似问题，Makefile 一共提供了四个赋值运算符 （=、:=、？=、+=），它们的区别请看&lt;a href="https://stackoverflow.com/questions/448910/makefile-variable-assignment">StackOverflow&lt;/a>。&lt;/p>
&lt;pre>&lt;code> VARIABLE = value
VARIABLE := value
VARIABLE ?= value
VARIABLE += value
&lt;/code>&lt;/pre>
&lt;h3 id="36-内置变量implicit-variables">3.6 内置变量（Implicit Variables）&lt;/h3>
&lt;p>Make 命令提供一系列内置变量，比如，&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/e6ba0987-73ba-41d6-831e-246ad899c89b/latex" alt="">(MAKE) 指向当前使用的 Make 工具。这主要是为了跨平台的兼容性，详细的内置变量清单见&lt;a href="https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html">手册&lt;/a>。&lt;/p>
&lt;pre>&lt;code> output:
$(CC) -o output input.c
&lt;/code>&lt;/pre>
&lt;h3 id="37-自动变量automatic-variables">3.7 自动变量（Automatic Variables）&lt;/h3>
&lt;p>Make 命令还提供一些自动变量，它们的值与当前规则有关。主要有以下几个。&lt;/p>
&lt;p>&lt;strong>（1）$@&lt;/strong>&lt;/p>
&lt;p>$@指代当前目标，就是 Make 命令当前构建的那个目标。比如，&lt;code>make foo&lt;/code>的 $@ 就指代 foo。&lt;/p>
&lt;pre>&lt;code> a.txt b.txt:
touch $@
&lt;/code>&lt;/pre>
&lt;p>等同于下面的写法。&lt;/p>
&lt;pre>&lt;code> a.txt:
touch a.txt
b.txt:
touch b.txt
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>（2）$&amp;lt;&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/e6ba0987-73ba-41d6-831e-246ad899c89b/latex" alt="">&amp;lt; 就指代 p1。&lt;/p>
&lt;pre>&lt;code> a.txt: b.txt c.txt
cp $&amp;lt; $@
&lt;/code>&lt;/pre>
&lt;p>等同于下面的写法。&lt;/p>
&lt;pre>&lt;code> a.txt: b.txt c.txt
cp b.txt a.txt
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>（3）$?&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/e6ba0987-73ba-41d6-831e-246ad899c89b/latex" alt="">?就指代 p2。&lt;/p>
&lt;p>&lt;strong>（4）$^&lt;/strong>&lt;/p>
&lt;p>$^ 指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。&lt;/p>
&lt;p>&lt;strong>（5）$*&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/e6ba0987-73ba-41d6-831e-246ad899c89b/latex" alt="">* 就表示 f1。&lt;/p>
&lt;p>&lt;strong>（6）$(@D) 和 $(@F)&lt;/strong>&lt;/p>
&lt;p>$(@D) 和 $(@F) 分别指向 &lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/e6ba0987-73ba-41d6-831e-246ad899c89b/latex" alt="">(@F) 的值为 input.c。&lt;/p>
&lt;p>&lt;strong>（7）$(&amp;lt;D) 和 $(&amp;lt;F)&lt;/strong>&lt;/p>
&lt;p>$(&amp;lt;D) 和 $(&amp;lt;F) 分别指向 $&amp;lt; 的目录名和文件名。&lt;/p>
&lt;p>所有的自动变量清单，请看&lt;a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html">手册&lt;/a>。下面是自动变量的一个例子。&lt;/p>
&lt;pre>&lt;code> dest/%.txt: src/%.txt
@[ -d dest ] || mkdir dest
cp $&amp;lt; $@
&lt;/code>&lt;/pre>
&lt;p>上面代码将 src 目录下的 txt 文件，拷贝到 dest 目录下。首先判断 dest 目录是否存在，如果不存在就新建，然后，$&amp;lt; 指代前置文件（src/%.txt）， $@ 指代目标文件（dest/%.txt）。&lt;/p>
&lt;h3 id="38-判断和循环">3.8 判断和循环&lt;/h3>
&lt;p>Makefile 使用 Bash 语法，完成判断和循环。&lt;/p>
&lt;pre>&lt;code> ifeq ($(CC),gcc)
libs=$(libs_for_gcc)
else
libs=$(normal_libs)
endif
&lt;/code>&lt;/pre>
&lt;p>上面代码判断当前编译器是否 gcc ，然后指定不同的库文件。&lt;/p>
&lt;pre>&lt;code> LIST = one two three
all:
for i in $(LIST); do \
echo $$i; \
done
all:
for i in one two three; do \
echo $i; \
done
&lt;/code>&lt;/pre>
&lt;p>上面代码的运行结果。&lt;/p>
&lt;pre>&lt;code> one
two
three
&lt;/code>&lt;/pre>
&lt;h3 id="39-函数">3.9 函数&lt;/h3>
&lt;p>Makefile 还可以使用函数，格式如下。&lt;/p>
&lt;pre>&lt;code> $(function arguments)
${function arguments}
&lt;/code>&lt;/pre>
&lt;p>Makefile 提供了许多&lt;a href="https://www.gnu.org/software/make/manual/html_node/Functions.html">内置函数&lt;/a>，可供调用。下面是几个常用的内置函数。&lt;/p>
&lt;p>&lt;strong>（1）shell 函数&lt;/strong>&lt;/p>
&lt;p>shell 函数用来执行 shell 命令&lt;/p>
&lt;pre>&lt;code> srcfiles := $(shell echo src/{00..99}.txt)
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>（2）wildcard 函数&lt;/strong>&lt;/p>
&lt;p>wildcard 函数用来在 Makefile 中，替换 Bash 的通配符。&lt;/p>
&lt;pre>&lt;code> srcfiles := $(wildcard src/*.txt)
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>（3）subst 函数&lt;/strong>&lt;/p>
&lt;p>subst 函数用来文本替换，格式如下。&lt;/p>
&lt;pre>&lt;code> $(subst from,to,text)
&lt;/code>&lt;/pre>
&lt;p>下面的例子将字符串&amp;quot;feet on the street&amp;quot;替换成&amp;quot;fEEt on the strEEt&amp;rdquo;。&lt;/p>
&lt;pre>&lt;code> $(subst ee,EE,feet on the street)
&lt;/code>&lt;/pre>
&lt;p>下面是一个稍微复杂的例子。&lt;/p>
&lt;pre>&lt;code> comma:= ,
empty:=
space:= $(empty) $(empty)
foo:= a b c
bar:= $(subst $(space),$(comma),$(foo))
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>（4）patsubst 函数&lt;/strong>&lt;/p>
&lt;p>patsubst 函数用于模式匹配的替换，格式如下。&lt;/p>
&lt;pre>&lt;code> $(patsubst pattern,replacement,text)
&lt;/code>&lt;/pre>
&lt;p>下面的例子将文件名&amp;quot;x.c.c bar.c&amp;rdquo;，替换成&amp;quot;x.c.o bar.o&amp;quot;。&lt;/p>
&lt;pre>&lt;code> $(patsubst %.c,%.o,x.c.c bar.c)
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>（5）替换后缀名&lt;/strong>&lt;/p>
&lt;p>替换后缀名函数的写法是：变量名 + 冒号 + 后缀名替换规则。它实际上 patsubst 函数的一种简写形式。&lt;/p>
&lt;pre>&lt;code> min: $(OUTPUT:.js=.min.js)
&lt;/code>&lt;/pre>
&lt;p>上面代码的意思是，将变量 OUTPUT 中的后缀名 .js 全部替换成 .min.js 。&lt;/p>
&lt;h2 id="四makefile-的实例">四、Makefile 的实例&lt;/h2>
&lt;p>&lt;strong>（1）执行多个目标&lt;/strong>&lt;/p>
&lt;pre>&lt;code>.PHONY: cleanall cleanobj cleandiff
cleanall : cleanobj cleandiff
rm program
cleanobj :
rm *.o
cleandiff :
rm *.diff
&lt;/code>&lt;/pre>
&lt;p>上面代码可以调用不同目标，删除不同后缀名的文件，也可以调用一个目标（cleanall），删除所有指定类型的文件。&lt;/p>
&lt;p>&lt;strong>（2）编译 C 语言项目&lt;/strong>&lt;/p>
&lt;pre>&lt;code> edit : main.o kbd.o command.o display.o
cc -o edit main.o kbd.o command.o display.o
main.o : main.c defs.h
cc -c main.c
kbd.o : kbd.c defs.h command.h
cc -c kbd.c
command.o : command.c defs.h command.h
cc -c command.c
display.o : display.c defs.h
cc -c display.c
clean :
rm edit main.o kbd.o command.o display.o
.PHONY: edit clean
&lt;/code>&lt;/pre>
&lt;p>今天，Make 命令的介绍就到这里。下一篇文章我会介绍，&lt;a href="https://www.ruanyifeng.com/blog/2015/03/build-website-with-make.html">如何用 Make 来构建 Node.js 项目&lt;/a>。&lt;/p>
&lt;p>（完）&lt;/p></description></item><item><title>Docs: MIT 开源许可证</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E5%85%B6%E4%BB%96/mit-%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E5%85%B6%E4%BB%96/mit-%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81/</guid><description>
&lt;p>这一回终于把 MIT 协议讲明白了&lt;/p>
&lt;p>以下文章来源于微月人话 ，作者卫 sir&lt;/p>
&lt;p>微月人话&lt;/p>
&lt;p>简单而深入&lt;/p>
&lt;p>以前看到过李笑来讲的发生在他身上的故事，说他当年 ( 2001 年 ) 住在双榆树，经常去双安商场的地下超市买东西，有一次买了个什么东西觉得不好，要退，超市服务员说按规定，该类商品售出一概不能退，李笑来大怒，说你把书面规定拿出来，有的话我就不退了，如果没有，那我就一定要退，最后叫来了超市经理，经理一看这来者不善啊，也吵不过李笑来，就给退了。&lt;/p>
&lt;p>讲这个故事想说明什么呢，其实我们都明白，20 多年前的中国超市，很多管理规定都是口头上的，怎么会写成白纸黑字呢。&lt;/p>
&lt;p>从超市服务员的角度看，李笑来这行为就是捣乱，是胡搅蛮缠；李笑来则肯定觉得是在维护自己正当的消费者权益；最受震动的应该是超市管理层，如果是我，我会立刻要求起草一个关于退换货的规定，我可真不想再遇到下一个这样的人。&lt;/p>
&lt;p>这就是契约精神，说好的，都写下来，写下来的，我都认。&lt;/p>
&lt;p>现在说 MIT 协议。&lt;/p>
&lt;p>MIT 协议就是大名鼎鼎的开源软件许可协议 The MIT License，又称 MIT 许可证。&lt;/p>
&lt;p>有人在两年前专门做过分析 1，MIT 是 Github 上使用率最高的许可证，第二名到第五名是 Apache 2.0、GPL 2.0、GPL 3.0 和 bsd-3-clause。&lt;/p>
&lt;p>注：本文中，“MIT 协议”和“MIT 许可证”等同。&lt;/p>
&lt;p>什么是开源许可证？&lt;/p>
&lt;p>开源许可证是这样的，我把源码放网上了，如果还不错，就有很多人问我了，说你那个代码能不能让我用用？你那个代码我能不能放在我的产品里啊？你那个代码我用了，怎么那么多 Bug 啊？你那个代码我想当作教学案例使用，请问是不是可以啊？还有，你那个代码我用了，感觉不错，而且我还改了很多地方，我也把它放网上了，而且我还改了个名，你没有意见吧？你有意见我也准备改名了，因为现在这个软件中，我写的代码，比你写的多多了！&lt;/p>
&lt;p>（这都是比较有版权意识的，怕不问你就用以后惹上官司。）&lt;/p>
&lt;p>我可懒得回答这么多问题，我把这些可能问到的问题，都写成一段话，放在我的代码里，意思就是说：&lt;/p>
&lt;p>我允许你们 XXX，我许可你们 XXXX，你们可以 XXXX，但是，你们必须 XXXX，如果你们 XXXX 了，你们就必须 XXXX，对了，对于 XXXX 这些情况，我可不负责。&lt;/p>
&lt;p>你要同意，就用，不同意就别用。如果你用了，但违反了许可证的要求，我可能会告你啊！&lt;/p>
&lt;p>这就是许可证。&lt;/p>
&lt;p>你可以自己写一个许可证，但是如果你很懒的话 ( 一般人都很懒 ) ，你可以用别人写的比较好的许可证。&lt;/p>
&lt;p>写的比较好的开源许可证有很多种，比如 GPL、BSD、MIT、Apache 等等，MIT 只是其中的一个。&lt;/p>
&lt;p>你可以挑一个合你胃口的，这些许可证模版都是免费的，毕竟也没人指望这个卖钱。&lt;/p>
&lt;p>至于它们的区别，可以看看下面这张图接受一下科普。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tamq2d/1616161654522-76d7d7b6-c4cd-4bbc-87b4-835c7eb24fcb.jpeg" alt="">&lt;/p>
&lt;p>“新蜂商城”事件&lt;/p>
&lt;p>前段时间有一个叫做“新蜂商城”（简称“新蜂”）的开源项目有点新闻，它使用了 MIT 许可证，其作者被人告知说，哎，你的开源软件被人在网上卖哎，你不管管吗？&lt;/p>
&lt;p>作者一看，还真是，有 up 主在 b 站上卖，有人在闲鱼上卖，虽然卖的也不贵，有卖 300 的，有卖几十的，但一眼望过去，很显然卖的就是自己的“新蜂”嘛！&lt;/p>
&lt;p>具体可以戳这里 -&amp;gt; ……这是什么骚操作&lt;/p>
&lt;p>然后就有点热闹，有人说这是侵权，要声援作者，控诉有人如此无耻；有人说这不算侵权，MIT 是很宽松的协议，基本上你什么都可以干，只要保留作者版权即可。&lt;/p>
&lt;p>作者倒是没有想去怎么处理，作者只是觉得“我抽出下班时间，断断续续写了半年的项目，不是心血也算是我的小作品吧，开源出去就是给你这么玩的？佩服。”&lt;/p>
&lt;p>大概作者还是比较年轻，不懂人世间的险恶吧！&lt;/p>
&lt;p>其实这应该是预料中的事。&lt;/p>
&lt;p>不应该有任何心理波澜。&lt;/p>
&lt;p>更何况，MIT 许可证，允许别人卖你的源码！&lt;/p>
&lt;p>从契约精神讲，说好允许别人做，就让别人做吧。&lt;/p>
&lt;p>这里面有个新手不太能想明白的问题，为啥有许可证允许别人卖自己的开源软件？&lt;/p>
&lt;p>这要谈到开源的精神了，还没有一点概念的读者可以先看看这篇：开源的 7 大理念&lt;/p>
&lt;p>早期玩开源的人，开源自己的代码，大多不是为了卖软件，大多都有着开放、共享、自由、打破垄断等等比较理想化的情结，唯一可图的大概也就是个“名”，所以几乎所有许可证都要求保留作者名字。&lt;/p>
&lt;p>为了更好地传播自己的代码，开源作者通常允许别人卖自己的源码。初期会考虑这样的情况：如果有人把 Linux 源码刻录成光盘发放，是不是应该收点成本费呢，再或者服务费？&lt;/p>
&lt;p>那如果有人以此牟取暴利呢，岂不是很亏？通常不会。因为既然能在网上免费下载源码，明白人就不会再去花大价钱去买。&lt;/p>
&lt;p>而且，如果作者发现真有人能使用自己的源码牟取暴利，完全可以不授权让他从中牟利，改许可证就可以了。这种事也不是没有发生过，而且还不是个例。参见开源公司被云厂商“寄生”，咋整？&lt;/p>
&lt;p>比如开源云原生 SQL 数据库 CockroachDB 宣布修改开源协议，从原本的 Apache-2.0 协议修改为 BSL ( Business Source License ) ，该协议要求用户唯一不能做的是在没有取得授权的情况下以商业形式用 CockroachDB 提供数据库即服务 ( DBaaS ) 。&lt;/p>
&lt;p>BSL 由 MySQL 的开发者迈克尔·蒙蒂·维德纽斯 ( Michael &amp;ldquo;Monty&amp;rdquo; Widenius ) 在 2013 年设计。它有三个主要特点，一是非商业性使用没有限制，商业性使用有限制；二是许可证中可以附加使用者自己的要求；三是有一个 change date，自此时间开始，源码将会由 BSL 转变为作者指定的其他许可证，如 GPL 等开源许可证。&lt;/p>
&lt;p>依我看，闲鱼上把“新蜂”卖个几十块钱，还搭上售后服务，也算正常吧。&lt;/p>
&lt;p>MIT 到底说了什么 ( 学英语！)&lt;/p>
&lt;p>先看原文：&lt;/p>
&lt;p>Copyright ( C )&lt;/p>
&lt;p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files ( the &amp;ldquo;Software&amp;rdquo; ) , to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:&lt;/p>
&lt;p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.&lt;/p>
&lt;p>THE SOFTWARE IS PROVIDED &amp;ldquo;AS IS&amp;rdquo;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.&lt;/p>
&lt;p>英语不好的直接晕倒！&lt;/p>
&lt;p>英语就算还可以的，想弄明白，也得看好一阵！&lt;/p>
&lt;p>剖析其句子结构，其实就是下面这样的，注意放在括号里面的，都不是句子的主干成分：&lt;/p>
&lt;p>第一段：&lt;/p>
&lt;p>Permission is ( hereby ) granted ( , free of charge, ) to any person ( obtaining a copy of ( this software and associated documentation files ( the &amp;ldquo;Software” ) ) ) , to deal in the Software without restriction, ( including without limitation the rights ( to use, copy, modify, merge, publish, distribute, sublicense, ( and/or ) sell copies of the Software, and to permit persons ( to whom the Software is furnished ) to do so ) ) , subject to the following conditions:&lt;/p>
&lt;p>其大致意思就是：只要满足以下条件，许可被赋予任何 ( 获得本软件拷贝及相关文档的 ) 人 ，这些人可以免费地、没有限制地处理本软件 ( 包括随意地使用、拷贝、合并、发布、分发、再许可、卖拷贝，以及再授权其他人 ( 那些被装配了本软件的 ) 做上面说的这些事 ) 。&lt;/p>
&lt;p>注意，and to permit persons 这里的 to permit，是和 to use，to copy 并列的，后面那个 to do so，则是指代前面的的一系列权利，to whom the Software is furnished 是修饰 persons 的，指的是被装配、被配发本软件的人。&lt;/p>
&lt;p>再有一点比较有趣的是，这一长段被许可的选项中，后面出现了个 and/or。&lt;/p>
&lt;p>and/or 一般用于连接两个选项，比如 A and/or B，意思就是说 A or B or both。这段文字中，虽然 and/or 只连接最后两个选项，但其用意似乎却是连接所有。比如：A, B, C, D and/or E，想表达的是：A and/or B and/or C and/or D and/or E，意思就是 A、B、C、D、E 这些选项可以任意组合选用。这个写法貌似严谨，实则多余。因为没有它完全不影响对文本意思的理解，有了它反而还增加了疑惑。（在文学上或是法律用语上，对 and/or 用法的批评都比较多 2。）&lt;/p>
&lt;p>第二段：&lt;/p>
&lt;p>The above copyright notice and this permission notice shall be included ( in all ( copies or substantial portions ) of the Software ) .&lt;/p>
&lt;p>上面这句翻译过来就是：以上版权声明和许可声明都必须包含 ( 在所有的本软件的完整拷贝或者实质性成分中 ) 。所谓实质性成分，可以这样理解，比如你对这个软件做了修改，但只改了 5%，那么版权声明和许可证声明都必须包含，如果你改了 95%，那就未必需要了，具体多少需要，要看是不是实质上 ( substantially ) 仍然是人家的。&lt;/p>
&lt;p>第三段：&lt;/p>
&lt;p>THE SOFTWARE IS PROVIDED &amp;ldquo;AS IS”, ( WITHOUT WARRANTY OF ANY KIND ( , EXPRESS OR IMPLIED, ) ( INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ) ） IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE ( FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, ( WHETHER ( IN AN ACTION OF CONTRACT, TORT ) OR OTHERWISE ( , ARISING FROM, OUT OF OR IN CONNECTION WITH ( THE SOFTWARE OR ( ( THE USE OR OTHER DEALINGS ) IN THE SOFTWARE. ) ) ) ) )&lt;/p>
&lt;p>这段话，主要是说本软件是“AS IS”的，“AS IS”的意思就是“就这样的”，售出 ( 或免费提供 ) 后一概不负任何责任，“别再找我，就这样了”。有任何问题你就接受或者自己想办法处理吧，反正我这里不再管了，就是这个意思。有时候我在“闲鱼”上卖二手东西的时候，也真的想加一个标识“AS IS”，但是考虑到很多人不知道这个词，也就算了。&lt;/p>
&lt;p>上面这段全大写的英文很长，但还好，不算很难，基本上就是：本软件是 AS IS 的 ( 不提供任何保证， ( 不管是显式的还是隐式的，包括但不限于适销性保证、适用性保证、非侵权性保证 ) ) ，在任何情况下， ( 对于任何的权益追索、损失赔偿或者任何追责 ) ，作者或者版权所有人都不会负责。( 无论这些追责产生自合同、侵权，还是直接或间接来自于本软件以及与本软件使用或经营有关的情形 )&lt;/p>
&lt;p>适销性 ( MERCHANTABILITY ) 就是说商品一旦售出 ( 虽然可能是免费的 ) ，如果确有问题，就可以退换货，一般来说适销性是缺省的保证 ( 即便没有明示 ) ，法律会支持消费者对不合格产品的退换货权利 3。但对于 AS IS 这类商品而言，就是说你觉得不好使也别找我。你觉得根本没法用 ( FITNESS FOR A PARTICULAR PURPOSE ) 也别找我，而且我也不保证我这软件是不是侵权了。&lt;/p>
&lt;p>MIT 协议用了几乎一半的篇幅来说这个，足以见其重要性，这是西方人很强的商品经济意识和法律意识导致的。&lt;/p>
&lt;p>这是一种撇清关系的态度，就是说，出了什么事都别找我，更别去法院告我。我给你们贡献源码，可不是想给自己找麻烦的，我又不挣你们的钱。&lt;/p>
&lt;p>试想一下，如果在一个医疗设备的软件中，使用了“本软件”，结果由于 bug 导致医疗事故，结果追查下来，还要找我麻烦，那我怎么受得了！&lt;/p>
&lt;p>把这个 license 里所有的主干挑出来，其实就是：&lt;/p>
&lt;p>Permission is granted to any person to deal in the Software without restriction，subject to the following conditions:&lt;/p>
&lt;p>The above copyright notice and this permission notice shall be included.&lt;/p>
&lt;p>THE SOFTWARE IS PROVIDED &amp;ldquo;AS IS&amp;rdquo;, IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE.&lt;/p>
&lt;p>全文翻译过来，大约是这样，下面译版的版权归我哦：&lt;/p>
&lt;p>MIT 开源许可协议 ( 中文版翻译：卫 sir，遵循：CC-BY 协议 )&lt;/p>
&lt;p>版权 ( C ) &amp;lt;这里填年份&amp;gt; &amp;lt;这里填版权者姓名&amp;gt;&lt;/p>
&lt;p>特此向任何得到本软件拷贝及相关文档 ( 以下统称“本软件” ) 的人授权：被授权人有权使用、复制、修改、合并、发布、发行、再许可、售卖本软件拷贝、并有权向被供应人授予同等的权利，但必须满足以下条件：&lt;/p>
&lt;p>在本软件的所有副本或实质性使用中，都必须包含以上版权声明和本授权声明。&lt;/p>
&lt;p>本软件是“按原样“提供的，不附带任何明示或暗示的保证，包括没有任何有关适销性、适用性、非侵权性保证以及其他保证。在任何情况下，作者或版权持有人，对任何权益追索、损害赔偿以及其他追责，都不负任何责任。无论这些追责产生自合同、侵权，还是直接或间接来自于本软件以及与本软件使用或经营有关的情形。&lt;/p>
&lt;p>翻译成大白话缩略版，大约是下面这样的：&lt;/p>
&lt;p>版权是我 XXX 的，源自 XXXX 这一年！&lt;/p>
&lt;p>我授权任何人，可以干任何事，包括卖拷贝！&lt;/p>
&lt;p>但是，你必须：&lt;/p>
&lt;p>保留我的版权和许可！&lt;/p>
&lt;p>这软件就这样的！爱用不用，出了事别找我！&lt;/p>
&lt;p>我怎么用人家代码才算合规？&lt;/p>
&lt;p>使用一个用了 MIT 协议的源代码，你只需要保留人家的版权和许可证信息即可。&lt;/p>
&lt;p>也就是说要包含 LICENSE 文件，这个文件有完整的 MIT 许可证，其中也会有作者的版权信息。&lt;/p>
&lt;p>人家源码里面的版权和许可信息头，你也得保留。&lt;/p>
&lt;p>由于 MIT 协议并不要求使用者公开源码，如果你发行的仅仅是可执行软件（不带源码），那就要在软件的某个界面上说明。&lt;/p>
&lt;p>比如 Google Chrome 浏览器使用很多开源软件，在其界面中都予以了明示。&lt;/p>
&lt;p>在 Chrome 浏览器的“关于”中，有一句话：“Google Chrome 的诞生离不开 Chromium 开源项目以及其他开源软件。”&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tamq2d/1616161654514-af86080c-b38d-410b-87da-382264e29ef2.jpeg" alt="">&lt;/p>
&lt;p>点击“开源软件”，会打开一个页面，列出了一长串的开源软件、其 LICENSE 和主页（或代码托管地）。&lt;/p>
&lt;p>下面是部分截图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tamq2d/1616161654516-35908e7c-5b5c-4806-8bc9-0563ea70d0e9.jpeg" alt="">&lt;/p>
&lt;p>这就很规范了。&lt;/p>
&lt;p>我在里面随便找个一个使用 MIT 协议的软件：brotli&lt;/p>
&lt;p>进入其代码仓库后，可以看到其源码头部是这么写的。&lt;/p>
&lt;p>/* Copyright 2013 Google Inc. All Rights Reserved.&lt;/p>
&lt;p>Distributed under MIT license.&lt;/p>
&lt;p>See file LICENSE for detail or copy at &lt;a href="https://opensource.org/licenses/MIT">https://opensource.org/licenses/MIT&lt;/a>&lt;/p>
&lt;p>*/&lt;/p>
&lt;p>截图如下：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tamq2d/1616161654546-2a9951cc-1854-40fc-ab21-8a040710fcfa.jpeg" alt="">&lt;/p>
&lt;p>注意这个用法，第一行是写明了版权，下面则是对 MIT 许可证的一个引用。这样显得比较简洁。&lt;/p>
&lt;p>毕竟 MIT 许可证中唯一需要填写的就是版权。所以把第一句的信息放这里就可以了，MIT 许可证就不用动了。&lt;/p>
&lt;p>注意版权是指这个软件的著作权是谁的，许可证是指版权所有者允许别人怎么用这个软件。&lt;/p>
&lt;p>版权后面那句“All Rights Reserved”写不写都可以，这只是一个形式。真打到法院去，所有的权利都遵循著作权相关法律。&lt;/p>
&lt;p>顺便解释一下版权中的年份概念：&lt;/p>
&lt;p>软件在发布时都会声明版权，其中会包含年份，比如 Copyright 2012， Copyright 2008-2012 等。如果只包含一个年份，说明这是首次发布的年份。如果包含时间段，则第一个年份为第一次发布的年份，第二个是当前版本发布的年份。&lt;/p>
&lt;p>比如微软的 Windows XP 版权声明：Copyright© 1985-2001 Microsoft Corp。说明 Windows 第一个版本发布在 1985 年，Windows XP 版本发布年份为 2001 年。&lt;/p>
&lt;p>我是作者，我如何使用 MIT 协议&lt;/p>
&lt;p>如果我的开源软件要使用 MIT 协议，我应该怎么做？&lt;/p>
&lt;p>通常应该这么做：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在一级目录下，给出一个 LICENSE（或 COPYING）文件，里面就是这个许可证的全文。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在所有的源码头部，说明版权，说明许可。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>注：有的项目使用了多个许可证，会建一个 licenses 目录放这些许可证。（比如 cockroachdb）&lt;/p>
&lt;p>版权那一行，你还可以写上你软件的主页或者代码存放地，一般来说，使用者都不应该删除这行内容的。&lt;/p>
&lt;p>举个例子，“木兰许可证”是这样指导人们使用的：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tamq2d/1616161654557-38671027-cd5b-405c-8ac4-7daac1cc0b96.jpeg" alt="">&lt;/p>
&lt;p>那么，“新蜂”是怎么做的？&lt;/p>
&lt;p>我专门去“新蜂”的 github 仓库看了一眼，没错，作者在一级目录下放了 LICENSE 文件。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tamq2d/1616161654543-b5460bf5-e188-422f-ac69-9e867e9216bb.jpeg" alt="">&lt;/p>
&lt;p>打开 LICENSE 文件，可以看到：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tamq2d/1616161654557-3d9aa8cf-b207-4ac5-a2fd-fd8a04c0fd9c.jpeg" alt="">&lt;/p>
&lt;p>年份写成了 2019-2029，版权所有人写成了 newbee-mall。&lt;/p>
&lt;p>这是需要改进的，年份不应该写到 2029 去，应该写到当前版本发布的年份。&lt;/p>
&lt;p>版权所有人应该写作者“十三”（或“13”）而不是软件的名字。&lt;/p>
&lt;p>看看源码里面是怎么写的：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/tamq2d/1616161654547-b5472820-8f0a-431b-ac22-f5dec273610f.jpeg" alt="">&lt;/p>
&lt;p>翻了一遍，没有发现在任何源码的头部有版权和许可信息，这个做法也不规范。&lt;/p>
&lt;p>可见，作者十三对开源许可证并没有研究过。&lt;/p>
&lt;p>一些问题解答&lt;/p>
&lt;p>我能改许可证吗？ 当然可以。（MIT 允许你干任何事）&lt;/p>
&lt;p>所以说，MIT 协议和其他协议的兼容性很强（其实是单向兼容），比如，完全可以把一个 MIT 协议的软件改为 GPL 的，但一个 GPL 的可改不回 MIT 的。&lt;/p>
&lt;p>我能自己写一个许可证吗？ 当然可以。&lt;/p>
&lt;p>我能不写任何许可吗？ 当然可以，不写许可，就是“保留所有权利”。你可以让他们打电话问你，写邮件问你，发微信问你，你再告诉他们可以干什么。&lt;/p>
&lt;p>保留许可的意思基本上就是说，他们除了可以看你的源码 ( 因为你自己把它开源了 ) ，除了著作权法里面说的权利，基本上啥也不能干。&lt;/p>
&lt;p>如果我保留所有权利，那他有运行的权利吗？ 如果他是为了学习、研究或者欣赏，是可以运行的。&lt;/p>
&lt;p>他还可以评论您的软件。&lt;/p>
&lt;p>因为我国著作权法赋予了他这样的权利：&lt;/p>
&lt;p>现行的中华人民共和国著作权法 ( 2010 修正 ) 第二十二条中规定：&lt;/p>
&lt;p>在下列情况下使用作品，可以不经著作权人许可，不向其支付报酬，但应当指明作者姓名、作品名称，并且不得侵犯著作权人依照本法享有的其他权利：&lt;/p>
&lt;p>( 一 ) 为个人学习、研究或者欣赏，使用他人已经发表的作品；&lt;/p>
&lt;p>( 二 ) 为介绍、评论某一作品或者说明某一问题，在作品中适当引用他人已经发表的作品；&lt;/p>
&lt;p>……&lt;/p>
&lt;p>如果有人没有按照我的许可做，怎么办？ 你可以告他。&lt;/p>
&lt;p>不过，能不能打赢官司又是另一个话题了！&lt;/p>
&lt;hr>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://www.kaggle.com/mrisdal/safely-analyzing-github-projects-popular-licenses">https://www.kaggle.com/mrisdal/safely-analyzing-github-projects-popular-licenses&lt;/a> ↩&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/And/or">https://en.wikipedia.org/wiki/And/or&lt;/a> ↩&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://consumer.findlaw.com/consumer-transactions/what-is-the-warranty-of-merchantability.html">https://consumer.findlaw.com/consumer-transactions/what-is-the-warranty-of-merchantability.html&lt;/a> ↩&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>推荐阅读&lt;/p>
&lt;p>树莓派销量突然猛增&lt;/p>
&lt;p>80%的代码曾由一人提交，这项目何以从 ASF 毕业&lt;/p>
&lt;p>红帽借“订阅”模式成开源一哥，首创者升任总裁&lt;/p>
&lt;p>Git 15 周年：当年的分道扬镳，成就了今天的开源传奇&lt;/p>
&lt;p>Windows 中现在有独立的 Linux 文件夹系统&lt;/p></description></item><item><title>Docs: SCM</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E5%85%B6%E4%BB%96/scm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E5%85%B6%E4%BB%96/scm/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;h2 id="参考">参考：&lt;/h2>
&lt;/blockquote>
&lt;p>SCM(Software Configuration Management)，软件配置管理系统。&lt;/p>
&lt;p>SCM(Source Control Management)，源代码控制管理系统。&lt;/p>
&lt;p>git、Subversion(SVN)、CVS、Perforce、ClearCase 等都可以称为 SCM。&lt;/p>
&lt;p>可以称为 SCM 的在线网站：&lt;/p>
&lt;ul>
&lt;li>GitLab&lt;/li>
&lt;li>GitHub&lt;/li>
&lt;li>&lt;a href="https://sourceforge.net/">SourceForge&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://git.savannah.gnu.org/">GNU/git&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>SCM 可以算是源码管理相关工具的统称。&lt;/p></description></item><item><title>Docs: WebAssembly</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E5%85%B6%E4%BB%96/webassembly/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E5%85%B6%E4%BB%96/webassembly/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://webassembly.org/">官网&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="继-python-之后go-也顺利在浏览器上运行">继 Python 之后，Go 也顺利在浏览器上运行&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>公众号-OSC 开源社区，继 Python 之后，Go 也顺利在浏览器上运行&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Anaconda 开发商最近发布了 &lt;a href="http://mp.weixin.qq.com/s?__biz=MjM5NzM0MjcyMQ==&amp;amp;mid=2650144570&amp;amp;idx=1&amp;amp;sn=e0bce6b9f78f6b24418aba0b5cdd4c8f&amp;amp;chksm=beda245489adad42c2f53106e9c949f033ccddfdeeccabf9db9534a6774cbe338175c15d4505&amp;amp;scene=21#wechat_redirect">PyScript&lt;/a>，这是一个可以让开发者在 HTML 中混写 Python 代码的框架，有人将其称为 “Python 版 JSP”。事实上，PyScript 底层采用了 WebAssembly， 因为它基于 Pyodide 构建，Pyodide 由编译成 WebAssembly 的 CPython 3.8 解释器组成，允许在网页浏览器中运行 Python。&lt;/p>
&lt;p>无独有偶，开发者采用相同的思路让 Go 也顺利在浏览器上运行。&lt;a href="https://goscript.dev">https://goscript.dev&lt;/a>  网站支持在浏览器端直接运行 Go 代码，这是一个 Go playground，底层采用 Goscript，通过 WASM 实现。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/smwgcm/1652665930491-5aeffc9f-4d14-4512-a81d-338d42d8420b.png" alt="">&lt;/p>
&lt;p>Goscript 是 Go 语言规范的非官方实现，用于 Rust 项目的内嵌或封装，提供了更简单的方式封装和调用底层的 Rust 代码。就像 Lua 之于 Redis/WoW，或者 Python 之于 NumPy。&lt;/p>
&lt;p>Goscript 包含六个项目：&lt;/p>
&lt;ul>
&lt;li>&lt;code>parser&lt;/code>把源代码变成 AST，移植自 Go 官方代码。&lt;/li>
&lt;li>&lt;code>type checker&lt;/code>基于 AST 做类型推倒和类型检查，也移植自 Go 官方代码。&lt;/li>
&lt;li>&lt;code>codegen&lt;/code>基于 AST 和类型信息生成字节码。&lt;/li>
&lt;li>&lt;code>vm&lt;/code>运行字节码。&lt;/li>
&lt;li>&lt;code>std&lt;/code>官方库，移植自 Go 官方库。&lt;/li>
&lt;li>&lt;code>engine&lt;/code>包含官方库的 native 部分，再加上简单封装。&lt;/li>
&lt;/ul>
&lt;p>Goscript 实现了 Go 的几乎所有特性（pre 1.18，因此不包括泛型），并移植了部分官方库，已通过的相关测试用例查看 &lt;a href="https://github.com/oxfeeefeee/goscript/tree/master/engine/tests">https://github.com/oxfeeefeee/goscript/tree/master/engine/tests&lt;/a>。&lt;/p>
&lt;p>Goscript 项目代码：&lt;a href="https://github.com/oxfeeefeee/goscript">https://github.com/oxfeeefeee/goscript&lt;/a>&lt;/p></description></item><item><title>Docs: 按键精灵</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E5%85%B6%E4%BB%96/%E6%8C%89%E9%94%AE%E7%B2%BE%E7%81%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E5%85%B6%E4%BB%96/%E6%8C%89%E9%94%AE%E7%B2%BE%E7%81%B5/</guid><description/></item><item><title>Docs: 编程工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E5%85%B6%E4%BB%96/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E5%85%B6%E4%BB%96/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;h1 id="辅助">辅助&lt;/h1>
&lt;h2 id="lint">Lint&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Lint_(software)">Wiki,Lint&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Lint 或 Linter 是一种静态代码分析工具，用于标记 编程错误、Bug、风格错误、可疑结构 等。该术语源自一个检查 C 语言代码的 Unix 程序。
现在泛指所有可以实现这种功能的程序，通常，每种编程语言都会开发出一个对应的 Linter，比如 Go 语言的 &lt;a href="https://www.yuque.com/desistdaydream/learning/cu85tu#eSHeK">Staticcheck &lt;/a>就是 gopls。&lt;/p>
&lt;h1 id="ai-代码补全">AI 代码补全&lt;/h1>
&lt;h2 id="copilot">Copilot&lt;/h2>
&lt;h2 id="tabnine">Tabnine&lt;/h2>
&lt;h1 id="反编译器">反编译器&lt;/h1>
&lt;h2 id="ilspy">ILSpy&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/icsharpcode/ILSpy">GitHub 项目，icsharpcode/ILSpy&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>ILSpy 是开源的 .NET 程序集浏览器和反编译器&lt;/p></description></item></channel></rss>