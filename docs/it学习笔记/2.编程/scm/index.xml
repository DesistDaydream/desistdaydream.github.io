<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – SCM</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/</link><description>Recent content in SCM on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Git</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/git/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/git/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://git-scm.com/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/YBRdyyxkv3lpNDyqrBiLCA">公众号,Git 各指令的本质&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Git 是一个免费的开源分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有内容。&lt;/p>
&lt;p>Git 易于学习，占地面积小，具有闪电般的快速性能。它具有廉价的本地分支，方便的暂存区域和多个工作流等功能，其性能优于 Subversion，CVS，Perforce 和 ClearCase 等 SCM 工具。&lt;/p>
&lt;h2 id="git-优势">Git 优势&lt;/h2>
&lt;p>Git 是一个分布式代码管理工具，在讨论分布式之前避免不了提及一下什么是中央式代码管理仓库：&lt;/p>
&lt;ul>
&lt;li>中央式：所有的代码保存在中央服务器，所以提交必须依赖网络，并且每次提交都会带入到中央仓库，如果是协同开发可能频繁触发代码合并，进而增加提交的成本和代价。最典型的就是 SVN。&lt;/li>
&lt;li>分布式：可以在本地提交，不需要依赖网络，并且会将每次提交自动备份到本地。每个开发者都可以把远程仓库 clone 一份到本地，并会把提交历史一并拿过来。代表就是 Git。&lt;/li>
&lt;/ul>
&lt;p>那 Git 相比于 SVN 有什么优势呢？打个比方：“巴拉巴拉写了一大堆代码，突然发现写的有问题，我想回到一个小时之前”，对于这种情况 Git 的优势就很明显了，因为 commit 的成本比较小并且本地会保存所有的提交记录，随时随刻可以进行回退。在这并不是说 SVN 的不能完成这种操作，只是 Git 的回退会显得更加的优雅。Git 相比于中央式工具还有很多优点，就不一一列举了&lt;/p>
&lt;h2 id="git-文件状态">Git 文件状态&lt;/h2>
&lt;p>在 Git 中文件大概分为三种状态：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>modified(修改)&lt;/strong> # Git 可以感知到工作目录中哪些文件被修改了，然后把修改的文件加入到 modified 区域&lt;/li>
&lt;li>&lt;strong>staged(暂存)&lt;/strong> # 通过 add 命令将工作目录中修改的文件提交到暂存区，等候被 commit&lt;/li>
&lt;li>&lt;strong>committed(提交)&lt;/strong> # 将暂存区文件 commit 至 Git 目录中永久保存&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>commit 节点&lt;/strong>
为了便于表述，本篇文章我会通过节点代称 commit 提交。
在 Git 中每次提交都会生成一个节点，而每个节点都会有一个哈希值作为唯一标示，多次提交会形成一个线性节点链（不考虑 merge 的情况），如图 1。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sq07re/1622380398088-7ac43710-9863-46af-b3f4-6b30c76a3558.webp" alt="">图 1
节点上方是通过 SHA1 计算的哈希值。
C2 节点包含 C1 提交内容,同样 C3 节点包含 C1、C2 提交内容。
&lt;strong>HEAD&lt;/strong>
HEAD 是 Git 中非常重要的一个概念，你可以称它为指针或者引用，它可以指向任意一个节点，并且指向的节点始终为当前工作目录，换句话说就是当前工作目录(也就是你所看到的代码)就是 HEAD 指向的节点。
还以图 1 举例，如果 HEAD 指向 C2 那工作目录对应的就是 C2 节点。具体如何移动 HEAD 指向后面会讲到，此处不要纠结。
同时 HEAD 也可以指向一个分支，间接指向分支所指向的节点。
&lt;strong>远程仓库&lt;/strong>
虽然 Git 会把代码以及历史保存在本地，但最终还是要提交到服务器上的远程仓库。通过 clone 命令可以把远程仓库的代码下载到本地，同时也会将提交历史、分支、HEAD 等状态一并同步到本地，但这些状态并不会实时更新，需要手动从远程仓库去拉取，至于何时拉、怎么拉后面章节会讲到。
通过远程仓库为中介，你可以和你的同事进行协同开发，开发完新功能后可以申请提交至远程仓库，同时也可以从远程仓库拉取你同事的代码。
注意点：因为你和你的同事都会以远程仓库的代码为基准，所以要时刻保证远程仓库的代码质量，切记不要将未经检验测试的代码提交至远程仓库。&lt;/p>
&lt;h2 id="分支">分支&lt;/h2>
&lt;p>&lt;strong>什么是分支？&lt;/strong>
分支也是 Git 中相当重要的一个概念，当一个分支指向一个节点时，当前节点的内容即是该分支的内容，它的概念和 HEAD 非常接近同样也可以视为指针或引用，不同的是分支可以存在多个，而 HEAD 只有一个。通常会根据功能或版本建立不同的分支。
&lt;strong>那分支有什么用呢？&lt;/strong>
举个例子：你们的 App 经历了千辛万苦终于发布了 v1.0 版本，由于需求紧急 v1.0 上线之后便马不停蹄的开始 v1.1，正当你开发的兴起时，QA 同学说用户反馈了一些 bug，需要修复然后重新发版，修复 v1.0 肯定要基于 v1.0 的代码，可是你已经开发了一部分 v1.1 了，此时怎么搞？
面对上面的问题通过引入分支概念便可优雅的解决，如图 2：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sq07re/1622380397995-e668f4eb-8196-48d8-827e-38b63bb28ad1.webp" alt="">
图 2&lt;/p>
&lt;ul>
&lt;li>先看左边示意图，假设 C2 节点既是 v1.0 版本代码，上线后在 C2 的基础上新建一个分支 ft-1.0&lt;/li>
&lt;li>再看右边示意图，在 v1.0 上线后可在 master 分支开发 v1.1 内容，收到 QA 同学反馈后提交 v1.1 代码生成节点 C3，随后切换到 ft-1.0 分支做 bug 修复，修复完成后提交代码生成节点 C4，然后再切换到 master 分支并合并 ft-1.0 分支，到此我们就解决了上面提出的问题&lt;/li>
&lt;/ul>
&lt;p>除此之外利用分支还可以做很多事情，比如现在有一个需求不确定要不要上线，但是得先做，此时可以单独创建一个分支开发该功能，等到啥时候需要上线直接合并到主分支即可。分支适用的场景很多就不一一列举了。
注意点：当在某个节点创建一个分支后，并不会把该节点对应的代码复制一份出来，只是将新分支指向该节点，因此可以很大程度减少空间上的开销。一定要记着不管是 HEAD 还是分支它们都只是引用而已，量级非常轻。&lt;/p>
&lt;h1 id="git-安装">Git 安装&lt;/h1>
&lt;p>windows 版 git 安装完成后，git config &amp;ndash;global core.autocrlf input 执行该命令让，git 在 pull 时不转换换行符为 CRLF，而在 push 时，所有 CRLF 转换为 LF。&lt;/p>
&lt;p>也可通过配置文件进行修改 ，配置文件在 C:\Users\用户名.gitconfig，修改其中的 autocrlf = input 即可。&lt;/p>
&lt;p>&lt;a href="https://github.com/cssmagic/blog/issues/22">https://github.com/cssmagic/blog/issues/22&lt;/a>&lt;/p>
&lt;p>配置换行符官方文档：&lt;a href="https://docs.github.com/cn/github/using-git/configuring-git-to-handle-line-endings">https://docs.github.com/cn/github/using-git/configuring-git-to-handle-line-endings&lt;/a>&lt;/p>
&lt;h1 id="git-关联文件">Git 关联文件&lt;/h1>
&lt;p>&lt;strong>~/.gitconfig&lt;/strong> # git 通用配置文件
&lt;strong>~/.git-credentials&lt;/strong> # 登录后凭据的保存路径&lt;/p>
&lt;p>gitconfig 配置内容与 git config &amp;ndash;global 命令一一对应&lt;/p>
&lt;p>比如：&lt;/p>
&lt;pre>&lt;code># 执行如下命令
git config --global user.name &amp;quot;DesistDaydream&amp;quot;
# gitconfig 文件中生成如下内容
[user]
name = DesistDaydream
&lt;/code>&lt;/pre>
&lt;p>其中 user 配置环境标识，name 为该配置环境中的关键字。&lt;/p></description></item><item><title>Docs: Git 命令行工具</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/git-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/git-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>git 工具通过多个子命令来使用&lt;/p>
&lt;p>COMMAND:
add Add file contents to the index
bisect Find by binary search the change that introduced a bug
branch List, create, or delete branches
checkout Checkout a branch or paths to the working tree&lt;/p>
&lt;h2 id="clone--将一个存储库克隆到一个新的目录">clone # 将一个存储库克隆到一个新的目录&lt;/h2>
&lt;p>OPTIONS&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;branch,-b&lt;/strong> # 指定名为 NAME 的分支&lt;/li>
&lt;/ul>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>git clone -b v1.0 XXXX # 克隆 v1.0 分支的代码&lt;/li>
&lt;/ul>
&lt;p>commit Record changes to the repository&lt;/p>
&lt;h2 id="config--配置-git">config # 配置 git&lt;/h2>
&lt;p>此命令分别设置要与提交一起使用的作者姓名和电子邮件地址。&lt;/p>
&lt;p>diff Show changes between commits, commit and working tree, etc&lt;/p>
&lt;p>fetch Download objects and refs from another repository&lt;/p>
&lt;p>grep Print lines matching a pattern&lt;/p>
&lt;p>init #创建一个空的 Git 存储库或重新初始化现有的存储库&lt;/p>
&lt;h2 id="log-展示所有-commit-的记录默认展示当前分支">log #展示所有 commit 的记录。默认展示当前分支。&lt;/h2>
&lt;p>git log [] [] [[&amp;ndash;] &amp;hellip;]&lt;/p>
&lt;p>EXAMPLE&lt;/p>
&lt;ul>
&lt;li>git log -p -2 prometheus-rules.yaml #查看 prometheus-rules.yaml 文件最近两次的修改记录&lt;/li>
&lt;/ul>
&lt;p>merge Join two or more development histories together&lt;/p>
&lt;p>mv Move or rename a file, a directory, or a symlink&lt;/p>
&lt;p>pull Fetch from and merge with another repository or a local branch&lt;/p>
&lt;p>push Update remote refs along with associated objects&lt;/p>
&lt;p>rebase Forward-port local commits to the updated upstream head&lt;/p>
&lt;p>reset Reset current HEAD to the specified state&lt;/p>
&lt;p>rm Remove files from the working tree and from the index&lt;/p>
&lt;p>show Show various types of objects&lt;/p>
&lt;p>status Show the working tree status&lt;/p>
&lt;p>tag Create, list, delete or verify a tag object signed with GPG&lt;/p>
&lt;h1 id="git-命令的应用实例">git 命令的应用实例&lt;/h1>
&lt;p>git 放弃本地修改，强制拉取更新&lt;/p>
&lt;ul>
&lt;li>git fetch &amp;ndash;all #指令是下载远程仓库最新内容，不做合并&lt;/li>
&lt;li>git reset &amp;ndash;hard origin/master #指令把 HEAD 指向 master 最新版本&lt;/li>
&lt;li>git pull #可以省略&lt;/li>
&lt;/ul>
&lt;p>本地所有修改，没有提交的文件，都返回到原来的状态&lt;/p>
&lt;ul>
&lt;li>git checkout . #&lt;/li>
&lt;/ul>
&lt;p>提交修改并上传代码&lt;/p>
&lt;ul>
&lt;li>git add . #&lt;/li>
&lt;li>git commit -a -m &amp;lsquo;XXXX 修改&amp;rsquo; #&lt;/li>
&lt;li>git push #&lt;/li>
&lt;/ul>
&lt;p>git 回滚到之前某一 commit&lt;/p>
&lt;ul>
&lt;li>git log # 查看所有 commit 记录，记录其中的 commit 号，比如 commit 号为：d07466766d46710e54a627f913eea5661382331a&lt;/li>
&lt;li>git reset &amp;ndash;hard d07466766d46710e54a627f913eea5661382331a # 恢复到这次 commit 的状态&lt;/li>
&lt;/ul>
&lt;h2 id="修改-git-commit-信息">修改 git commit 信息&lt;/h2>
&lt;p>对自己的提交进行修改&lt;/p>
&lt;ul>
&lt;li>git commit &amp;ndash;amend&lt;/li>
&lt;/ul>
&lt;p>将修改强制提交，覆盖原先的提交内容&lt;/p>
&lt;ul>
&lt;li>git push -f&lt;/li>
&lt;/ul>
&lt;h2 id="撤销已-push-的-commit">撤销已 push 的 commit&lt;/h2>
&lt;p>查看所有 commit 记录&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># git log&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>commit 3c15aad50ed125938bbedbedffed05a7b9d600da &lt;span style="color:#f92672">(&lt;/span>HEAD -&amp;gt; main, origin/main&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Author: DesistDaydream &amp;lt;373406000@qq.com&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Date: Tue May &lt;span style="color:#ae81ff">17&lt;/span> 14:52:27 &lt;span style="color:#ae81ff">2022&lt;/span> +0800
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Update e37-exporter-workflows.yml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>commit 8251ddbbbffe59e5ddb25bb70874425012aa035e
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Author: DesistDaydream &amp;lt;373406000@qq.com&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Date: Mon May &lt;span style="color:#ae81ff">16&lt;/span> 17:15:07 &lt;span style="color:#ae81ff">2022&lt;/span> +0800
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>回退到指定的版本&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># git reset --hard 8251ddbbbffe59e5ddb25bb70874425012aa035e&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HEAD is now at 8251ddb Update e37-exporter-workflows.yml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>强制推送，覆盖远端的版本信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># git push origin main --force&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Total &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>delta 0&lt;span style="color:#f92672">)&lt;/span>, reused &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>delta 0&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>To https://github.com/DesistDaydream/e37-exporter.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> + 3c15aad...8251ddb main -&amp;gt; main &lt;span style="color:#f92672">(&lt;/span>forced update&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="命令详解">命令详解&lt;/h1>
&lt;p>&lt;strong>提交相关&lt;/strong>
前面我们提到过，想要对代码进行提交必须得先加入到暂存区，Git 中是通过命令 add 实现。
添加某个文件到暂存区：
git add  文件路径
添加所有文件到暂存区：
git add .
同时 Git 也提供了撤销工作区和暂存区命令。
撤销工作区改动：
git checkout &amp;ndash;  文件名
清空暂存区：
git reset HEAD  文件名
提交：
将改动文件加入到暂存区后就可以进行提交了，提交后会生成一个新的提交节点，具体命令如下：
git commit -m &amp;ldquo;该节点的描述信息&amp;rdquo;&lt;/p>
&lt;p>&lt;strong>分支相关&lt;/strong>
创建分支：
创建一个分支后该分支会与 HEAD 指向同一节点，说通俗点就是 HEAD 指向哪创建的新分支就指向哪，命令如下：
git branch  分支名
切换分支：
当切换分支后，默认情况下 HEAD 会指向当前分支，即 HEAD 间接指向当前分支指向的节点。
git checkout  分支名
同时也可以创建一个分支后立即切换，命令如下：
git checkout -b  分支名
删除分支：
为了保证仓库分支的简洁，当某个分支完成了它的使命后应该被删除。比如前面所说的单独开一个分支完成某个功能，当这个功能被合并到主分支后应该将这个分支及时删除。
删除命令如下：
git branch -d  分支名&lt;/p>
&lt;p>&lt;strong>合并相关&lt;/strong>
关于合并的命令是最难掌握同时也是最重要的。我们常用的合并命令大概有三个 merge、rebase、cherry-pick。
merge：
merge 是最常用的合并命令，它可以将某个分支或者某个节点的代码合并至当前分支。具体命令如下：
git merge  分支名/节点哈希值
如果需要合并的分支完全领先于当前分支，如图 3 所示：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/yc1he6/1622380437243-d5cc7b99-b228-4972-a253-f048e1378e68.webp" alt="">
图 3
由于分支 ft-1 完全领先分支 ft-2 即 ft-1 完全包含 ft-2，所以 ft-2 执行了“git merge ft-1”后会触发 fast forward(快速合并)，此时两个分支指向同一节点，这是最理想的状态。但是实际开发中我们往往碰到的是下面这种情况：如图 4（左）。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/yc1he6/1622380437303-d391e621-2e78-48d4-8500-77e2a09964b3.webp" alt="">
图 4
这种情况就不能直接合了，当 ft-2 执行了“git merge ft-1”后 Git 会将节点 C3、C4 合并随后生成一个新节点 C5，最后将 ft-2 指向 C5 如图 4（右）。
注意点：如果 C3、C4 同时修改了同一个文件中的同一句代码，这个时候合并会出错，因为 Git 不知道该以哪个节点为标准，所以这个时候需要我们自己手动合并代码。
rebase：
rebase 也是一种合并指令，命令行如下：
git rebase  分支名/节点哈希值
与 merge 不同的是 rebase 合并看起来不会产生新的节点（实际上是会产生的，只是做了一次复制），而是将需要合并的节点直接累加，如图 5。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/yc1he6/1622380437264-b4959853-9005-408b-b49b-10745896aca3.webp" alt="">
图 5
当左边示意图的 ft-1.0 执行了 git rebase master 后会将 C4 节点复制一份到 C3 后面，也就是 C4&amp;rsquo;，C4 与 C4&amp;rsquo;相对应，但是哈希值却不一样。
rebase 相比于 merge 提交历史更加线性、干净，使并行的开发流程看起来像串行，更符合我们的直觉。既然 rebase 这么好用是不是可以抛弃 merge 了？其实也不是了，下面我罗列一些 merge 和 rebase 的优缺点：
merge 优缺点：&lt;/p>
&lt;ul>
&lt;li>优点：每个节点都是严格按照时间排列。当合并发生冲突时，只需要解决两个分支所指向的节点的冲突即可&lt;/li>
&lt;li>缺点：合并两个分支时大概率会生成新的节点并分叉，久而久之提交历史会变成一团乱麻&lt;/li>
&lt;/ul>
&lt;p>rebase 优缺点：&lt;/p>
&lt;ul>
&lt;li>优点：会使提交历史看起来更加线性、干净&lt;/li>
&lt;li>缺点：虽然提交看起来像是线性的，但并不是真正的按时间排序，比如图 3-3 中，不管 C4 早于或者晚于 C3 提交它最终都会放在 C3 后面。并且当合并发生冲突时，理论上来讲有几个节点 rebase 到目标分支就可能处理几次冲突&lt;/li>
&lt;/ul>
&lt;p>对于网络上一些只用 rebase 的观点，作者表示不太认同，如果不同分支的合并使用 rebase 可能需要重复解决冲突，这样就得不偿失了。但如果是本地推到远程并对应的是同一条分支可以优先考虑 rebase。所以我的观点是 根据不同场景合理搭配使用 merge 和 rebase，如果觉得都行那优先使用 rebase。
cherry-pick：
cherry-pick 的合并不同于 merge 和 rebase，它可以选择某几个节点进行合并，如图 6。
命令行：
git cherry-pick  节点哈希值&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/yc1he6/1622380437213-1e90e77b-8877-4449-a6b7-1dfe7d760ddb.webp" alt="">
图 6
假设当前分支是 master，执行了 git cherry-pick C3(哈希值)，C4(哈希值)命令后会直接将 C3、C4 节点抓过来放在后面，对应 C3&amp;rsquo;和 C4&amp;rsquo;。
&lt;strong>回退相关&lt;/strong>
分离 HEAD：
在默认情况下 HEAD 是指向分支的，但也可以将 HEAD 从分支上取下来直接指向某个节点，此过程就是分离 HEAD，具体命令如下：
git checkout  节点哈希值
//也可以直接脱离分支指向当前节点
git checkout &amp;ndash;detach
由于哈希值是一串很长很长的乱码，在实际操作中使用哈希值分离 HEAD 很麻烦，所以 Git 也提供了 HEAD 基于某一特殊位置（分支/HEAD）直接指向前一个或前 N 个节点的命令，也即相对引用，如下：
//HEAD 分离并指向前一个节点
git checkout  分支名/HEAD^
//HEAD 分离并指向前 N 个节点
git checkout  分支名～ N
将 HEAD 分离出来指向节点有什么用呢？举个例子：如果开发过程发现之前的提交有问题，此时可以将 HEAD 指向对应的节点，修改完毕后再提交，此时你肯定不希望再生成一个新的节点，而你只需在提交时加上&amp;ndash;amend 即可，具体命令如下：
git commit &amp;ndash;amend
回退：
回退场景在平时开发中还是比较常见的，比如你巴拉巴拉写了一大堆代码然后提交，后面发现写的有问题，于是你想将代码回到前一个提交，这种场景可以通过 reset 解决，具体命令如下：
//回退 N 个提交
git reset HEAD~N
reset 和相对引用很像，区别是 reset 会使分支和 HEAD 一并回退。
&lt;strong>远程相关&lt;/strong>
当我们接触一个新项目时，第一件事情肯定是要把它的代码拿下来，在 Git 中可以通过 clone 从远程仓库复制一份代码到本地，具体命令如下：
git clone 仓库地址
前面的章节我也有提到过，clone 不仅仅是复制代码，它还会把远程仓库的引用（分支/HEAD）一并取下保存在本地，如图 7 所示：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/yc1he6/1622380437328-fac36536-b8d8-4ee2-b0cc-9e52d5828b2f.webp" alt="">
图 7
其中 origin/master 和 origin/ft-1 为远程仓库的分支，而远程的这些引用状态是不会实时更新到本地的，比如远程仓库 origin/master 分支增加了一次提交，此时本地是感知不到的，所以本地的 origin/master 分支依旧指向 C4 节点。我们可以通过 fetch 命令来手动更新远程仓库状态。
小提示：并不是存在服务器上的才能称作是远程仓库，你也可以 clone 本地仓库作为远程，当然实际开发中我们不可能把本地仓库当作公有仓库，说这个只是单纯的帮助你更清晰的理解分布式。
fetch：
说的通俗一点，fetch 命令就是一次下载操作，它会将远程新增加的节点以及引用(分支/HEAD)的状态下载到本地，具体命令如下：
git fetch  远程仓库地址/分支名
pull：
pull 命令可以从远程仓库的某个引用拉取代码，具体命令如下：
git pull  远程分支名
其实 pull 的本质就是 fetch+merge，首先更新远程仓库所有状态到本地，随后再进行合并。合并完成后本地分支会指向最新节点。
另外 pull 命令也可以通过 rebase 进行合并，具体命令如下：
git pull &amp;ndash;rebase  远程分支名
push：
push 命令可以将本地提交推送至远程，具体命令如下：
git push  远程分支名
如果直接 push 可能会失败，因为可能存在冲突，所以在 push 之前往往会先 pull 一下，如果存在冲突本地解决。push 成功后本地的远程分支引用会更新，与本地分支指向同一节点。&lt;/p>
&lt;p>综上所述
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/yc1he6/1622380437220-cc136a5f-1d56-4767-85a1-0e16753a3cd0.webp" alt="">&lt;/p>
&lt;ul>
&lt;li>不管是 HEAD 还是分支，它们都只是引用而已，引用+节点是 Git 构成分布式的关键&lt;/li>
&lt;li>merge 相比于 rebase 有更明确的时间历史，而 rebase 会使提交更加线性应当优先使用&lt;/li>
&lt;li>通过移动 HEAD 可以查看每个提交对应的代码&lt;/li>
&lt;li>clone 或 fetch 都会将远程仓库的所有提交、引用保存在本地一份&lt;/li>
&lt;li>pull 的本质其实就是 fetch+merge，也可以加入&amp;ndash;rebase 通过 rebase 方式合并&lt;/li>
&lt;/ul></description></item><item><title>Docs: Git 配置详解</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/git-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/git-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;h1 id="gitconfig-文件配置详解">~./gitconfig 文件配置详解&lt;/h1>
&lt;p>该配置文件可以手动修改，也可以通过 git config &amp;ndash;global XXX 命令修改。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>filter &lt;span style="color:#e6db74">&amp;#34;lfs&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> required &lt;span style="color:#f92672">=&lt;/span> true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clean &lt;span style="color:#f92672">=&lt;/span> git-lfs clean -- %f
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> smudge &lt;span style="color:#f92672">=&lt;/span> git-lfs smudge -- %f
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> process &lt;span style="color:#f92672">=&lt;/span> git-lfs filter-process
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>user&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name &lt;span style="color:#f92672">=&lt;/span> DesistDaydream
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> email &lt;span style="color:#f92672">=&lt;/span> 373406000@qq.com
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>core&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> autocrlf &lt;span style="color:#f92672">=&lt;/span> input
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>credential&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> helper &lt;span style="color:#f92672">=&lt;/span> store
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>git config &amp;ndash;global credential.helper store&lt;/strong>&lt;/p></description></item><item><title>Docs: GitHub</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/github/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/github/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官方文档：&lt;a href="https://docs.github.com/cn">https://docs.github.com/cn&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在代码仓库中，点击 &lt;code>.&lt;/code> 即可进入 Web 版的 VS Code，在线编辑当前仓库的代码。&lt;/p></description></item><item><title>Docs: GitHub</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/github/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/github/</guid><description/></item><item><title>Docs: GitLab</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/gitlab/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/gitlab/</guid><description>
&lt;h1 id="gitlab-介绍">GitLab 介绍&lt;/h1>
&lt;p>&lt;a href="https://www.qikqiak.com/post/gitlab-install-on-k8s/">https://www.qikqiak.com/post/gitlab-install-on-k8s/&lt;/a>&lt;/p>
&lt;p>官方文档：&lt;a href="https://docs.gitlab.com/">https://docs.gitlab.com/&lt;/a>&lt;/p>
&lt;h1 id="gitlab-部署">GitLab 部署&lt;/h1>
&lt;p>官方文档：&lt;a href="https://docs.gitlab.com/ee/install/README.html">https://docs.gitlab.com/ee/install/README.html&lt;/a>&lt;/p>
&lt;h2 id="通过官方的-linux-软件包安装">通过官方的 linux 软件包安装&lt;/h2>
&lt;p>&lt;a href="https://about.gitlab.com/install/">https://about.gitlab.com/install/&lt;/a> 根据该页面选择想要运行 GitLab 的 Linux 发行版，可以通过 yum、apt 等方式直接安装 GitLab 及其所需的依赖。&lt;/p>
&lt;h2 id="使用-docker-运行-gitlab">使用 Docker 运行 GitLab&lt;/h2>
&lt;p>官方文档：&lt;a href="https://docs.gitlab.com/omnibus/docker/">https://docs.gitlab.com/omnibus/docker/&lt;/a>&lt;/p>
&lt;pre>&lt;code>docker run --detach \
--hostname 10.10.100.151 \
--publish 443:443 --publish 80:80 --publish 9022:22 \
--name gitlab \
--restart always \
--volume /root/gitlab/config:/etc/gitlab \
--volume /root/gitlab/logs:/var/log/gitlab \
--volume /root/gitlab/data:/var/opt/gitlab \
gitlab/gitlab-ce:latest
&lt;/code>&lt;/pre>
&lt;p>部署完成后，使用 root 和 第一次打开 web 页面时设置的密码，即可登录管理员账户。&lt;/p></description></item><item><title>Docs: 代码提交规范</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="">GitHub 项目，conventional-commits/conventionalcommits.org&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://www.conventionalcommits.org/zh-hans/v1.0.0/">https://www.conventionalcommits.org/zh-hans/v1.0.0/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>约定式提交规范是一种基于提交信息的轻量级约定。 它提供了一组简单规则来创建清晰的提交历史； 这更有利于编写自动化工具。 通过在提交信息中描述功能、修复和破坏性变更， 使这种惯例与 &lt;a href="http://semver.org/">SemVer&lt;/a> 相互对应。&lt;/p></description></item><item><title>Docs: 关于git提示“warning LF will be replaced by CRLF”终极解答</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/%E5%85%B3%E4%BA%8Egit%E6%8F%90%E7%A4%BAwarning-lf-will-be-replaced-by-crlf%E7%BB%88%E6%9E%81%E8%A7%A3%E7%AD%94/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/%E5%85%B3%E4%BA%8Egit%E6%8F%90%E7%A4%BAwarning-lf-will-be-replaced-by-crlf%E7%BB%88%E6%9E%81%E8%A7%A3%E7%AD%94/</guid><description>
&lt;h1 id="heading">&lt;/h1>
&lt;p>关于 git 提示“warning: LF will be replaced by CRLF”终极解答&lt;/p>
&lt;p>一、发现问题&lt;/p>
&lt;p>windows 平台下使用 git add，git deploy 文件时经常出现“warning: LF will be replaced by CRLF” 的提示。&lt;/p>
&lt;p>网上很多解决办法提到：&lt;/p>
&lt;p>设置 core.autocrlf=false，windows 也用 LF 换行。&lt;/p>
&lt;p>除了记事本，其他编辑器都可以正常编辑。&lt;/p>
&lt;p>而没有给出具体原因和分析，现在加以补充。&lt;/p>
&lt;p>二、分析问题&lt;/p>
&lt;p>格式化与多余的空白字符，特别是在跨平台情况下，有时候是一个令人发指的问题。由于编辑器的不同或者文件行尾的换行符在 Windows 下被替换了，一些细微的空格变化会不经意地混入提交，造成麻烦。虽然这是小问题，但它会极大地扰乱跨平台协作。&lt;/p>
&lt;p>其实，这是因为在文本处理中，CR（CarriageReturn），LF（LineFeed），CR/LF 是不同操作系统上使用的换行符，具体如下：&lt;/p>
&lt;p>换行符‘\n’和回车符‘\r’&lt;/p>
&lt;ul>
&lt;li>
&lt;p>回车符就是回到一行的开头，用符号 r 表示，十进制 ASCII 代码是 13，十六进制代码为 0x0D，回车（return）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>换行符就是另起一行，用 n 符号表示，ASCII 代码是 10，十六制为 0x0A， 换行（newline）。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>所以我们平时编写文件的回车符应该确切来说叫做回车换行符。&lt;/p>
&lt;p>应用情况&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Dos 和 Windows 平台： 使用回车（CR）和换行（LF）两个字符来结束一行，回车+换行(CR+LF)，即“\r\n”；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Mac 和 Linux 平台：只使用换行（LF）一个字符来结束一行，即“\n”；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最早 Mac 每行结尾是回车 CR 即&amp;rsquo;\r&amp;rsquo;，后 mac os x 也投奔了 unix。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>许多 Windows 上的编辑器会悄悄把行尾的换行（LF）字符转换成回车（CR）和换行（LF），或在用户按下 Enter 键时，插入回车（CR）和换行（LF）两个字符。&lt;/p>
&lt;p>影响：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一个直接后果是，Unix/Mac 系统下的文件在 Windows 里打开的话，所有文字会变成一行；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>而 Windows 里的文件在 Unix/Mac 下打开的话，在每行的结尾可能会多出一个^M 符号。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Linux 保存的文件在 windows 上用记事本看的话会出现黑点。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这些问题都可以通过一定方式进行转换统一，例如，在 linux 下，命令 unix2dos 是把 linux 文件格式转换成 windows 文件格式，命令 dos2unix 是把 windows 格式转换成 linux 文件格式。&lt;/p>
&lt;p>三、解决问题：&lt;/p>
&lt;p>Git 默认行为会在提交时自动地把 CRLF(回车换行) 转换成 LF(换行)，而在检出代码时把 LF(换行) 转换成 CRLF(回车换行) .&lt;/p>
&lt;p>情况一：&lt;/p>
&lt;p>你可以用 git config &amp;ndash;global core.autocrlf true 来打开此项功能。 如果是在 Windows 系统上，把它设置成 true，这样在检出代码时，换行会被转换成回车和换行：&lt;/p>
&lt;pre>&lt;code>#提交时转换为LF，检出时转换为CRLF
$ git config --global core.autocrlf true
&lt;/code>&lt;/pre>
&lt;p>情况二：&lt;/p>
&lt;p>如果使用以换行（LF）作为行结束符的 Linux 或 Mac，你不需要 Git 在检出文件时进行自动的转换。然而当一个以回车（CR）和换行（LF）作为行结束符的文件不小心被引入时，你肯定想让 Git 修正。 所以，你可以把 core.autocrlf 设置成 input 来告诉 Git 在提交时把回车和换行转换成换行，检出时不转换：（这样在 Windows 上的检出文件中会保留回车和换行，而在 Mac 和 Linux 上，以及版本库中会保留换行。）&lt;/p>
&lt;pre>&lt;code>#提交时转换为LF，检出时不转换
$ git config --global core.autocrlf input
&lt;/code>&lt;/pre>
&lt;p>情况三：&lt;/p>
&lt;p>如果你是 Windows 程序员，且正在开发仅运行在 Windows 上的项目，可以设置 false 取消此功能，把回车保留在版本库中：&lt;/p>
&lt;pre>&lt;code>#提交检出均不转换
$ git config --global core.autocrlf false
&lt;/code>&lt;/pre>
&lt;p>你也可以在文件提交时进行 safecrlf 检查&lt;/p>
&lt;pre>&lt;code>#拒绝提交包含混合换行符的文件
git config --global core.safecrlf true
#允许提交包含混合换行符的文件
git config --global core.safecrlf false
#提交包含混合换行符的文件时给出警告
git config --global core.safecrlf warn
&lt;/code>&lt;/pre>
&lt;p>通俗解释&lt;/p>
&lt;ul>
&lt;li>
&lt;p>git 的 Windows 客户端基本都会默认设置 core.autocrlf=true，设置 core.autocrlf=true, 只要保持工作区都是纯 CRLF 文件，编辑器用 CRLF 换行，就不会出现警告了；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Linux 最好不要设置 core.autocrlf，因为这个配置算是为 Windows 平台定制；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Windows 上设置 core.autocrlf=false，仓库里也没有配置 .gitattributes，很容易引入 CRLF 或者混合换行符（Mixed Line Endings，一个文件里既有 LF 又有 CRLF）到版本库，这样就可能产生各种奇怪的问题。&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: 如何参与开源项目 - 细说 GitHub 上的 PR 全过程</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/%E5%A6%82%E4%BD%95%E5%8F%82%E4%B8%8E%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-%E7%BB%86%E8%AF%B4-github-%E4%B8%8A%E7%9A%84-pr-%E5%85%A8%E8%BF%87%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/scm/%E5%A6%82%E4%BD%95%E5%8F%82%E4%B8%8E%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-%E7%BB%86%E8%AF%B4-github-%E4%B8%8A%E7%9A%84-pr-%E5%85%A8%E8%BF%87%E7%A8%8B/</guid><description>
&lt;h2 id="一概述">一、概述&lt;/h2>
&lt;blockquote>
&lt;p>原文链接：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/8tKpPqFeZOEE4ldEWptMZg">https://mp.weixin.qq.com/s/8tKpPqFeZOEE4ldEWptMZg&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>今天我准备和你详细介绍如何开始参与开源项目，帮助你在 GitHub 上完成第一个 PR 的合入&lt;/strong>。&lt;/p>
&lt;p>当然，除了正常的 PR 合入流程之外，我还准备详细介绍一下如果一个 PR 提交后遇到了冲突、需要追加 commits、需要合并 commits 等等相对复杂问题该如何解决。&lt;/p>
&lt;p>总的来说，本文计划分为 4 个部分：&lt;/p>
&lt;ol>
&lt;li>谈谈为什么要参与开源项目以及我为什么要介绍如何 PR&lt;/li>
&lt;li>谈谈怎么开始参与开源项目，也就是如何寻找合适的开源项目、如何寻找贡献点&lt;/li>
&lt;li>介绍怎么上手 PR 流程，即从 fork 到 push 全流程&lt;/li>
&lt;li>介绍提交了 PR 之后遇到各种常见问题如何解决&lt;/li>
&lt;/ol>
&lt;p>Ok, let&amp;rsquo;s get started!&lt;/p>
&lt;h2 id="二为什么要参与开源项目">二、为什么要参与开源项目&lt;/h2>
&lt;p>本文我不打算长篇大论 “为什么要参与开源”，详细介绍参与开源项目的收获，我想仅从“提升编码能力” 角度谈一谈“为什么要参与开源项目”。&lt;/p>
&lt;p>在面试的时候我有个习惯，如果候选人在自己的简历里说到自己熟悉某一门语言，我就会习惯性问他一个问题：&lt;/p>
&lt;p>&lt;strong>你有没有阅读过某个开源项目的源码？或者更进一步，有没有参与过某个开源社区，或者说给开源项目提过 PR&lt;/strong>？&lt;/p>
&lt;p>如果答案是肯定的，比如候选人说自己读过部分 Kubernetes 模块的源码，再进一步我确认他真的读过并且读懂了或者说真的提交过 bugfix/feature 类型的 PR，那我就不再问编程语言层面的问题了，因为我相信能看懂一个成熟的开源项目部分模块源码或者能够提交 bugfix/feature 类型的 PR 已经说明了一切。&lt;/p>
&lt;p>我自己在学习 Golang 的时候，大致分为两个阶段：&lt;/p>
&lt;ol>
&lt;li>学习基础语法，开始写项目，直到能够熟练完成各种业务功能的开发；&lt;/li>
&lt;li>看了一些开源项目的源码，深感受益颇多，编码水平再上一个台阶。&lt;/li>
&lt;/ol>
&lt;p>差不多也就是在看 Kubernetes 项目源码的时候，我深刻认识到一般的企业内部项目和汇集全世界最优秀的程序员智慧结晶的开源项目之间的巨大差距，也意识到学习优秀开源项目源码对于一个程序员编码水平提升的重要性（当然，你可以说 Google 内部也存在非开源的非常优秀的代码，这毫无疑问，但是我想今天我们没有必要讨论特例）。&lt;/p>
&lt;p>认真阅读开源项目源码，你总会发现一些小瑕疵，这时候提一个 PR(Pull Request)，让你的代码合入开源项目，运行在 “世界每一个角落”，那是多么有趣的事情！而成功合入第一个 PR 往往就像打开潘多拉魔盒一样，你会进入到另外一个世界，开始接触到开源社区，感受开源的魅力！&lt;/p>
&lt;h2 id="三为什么我想介绍如何-pr">三、为什么我想介绍如何 PR&lt;/h2>
&lt;p>我司开源了 2 个项目，分别是：&lt;/p>
&lt;ol>
&lt;li>CNCF Project DevStream[1]&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>CNCF Project DevStream&lt;/p>
&lt;ol start="2">
&lt;li>Apache DevLake[2]&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/li>
&lt;/ol>
&lt;p>DevStream 项目和 DevLake 项目隔三差五就会有新贡献者提交 PR 过来，但是多数贡献者在提交第一个 PR 时往往会遇到一个或多个问题，比如产生冲突、commits 记录过多或者混乱、commit 没有签名、commit message 不规范、各种 ci 流程检查报错等等。&lt;/p>
&lt;p>在看到新贡献者提交 PR 时，我们自然是非常开心且热情地对他表示欢迎并且告知如何修复各种问题，但是随着贡献者的增多，我们的开源社区几乎每天都需要回答一个问题：“&lt;strong>如何正确地提交一个 PR&lt;/strong>”。可能此时你会开始怀疑我们是不是没有提供相应的文档？其实不然，我们有详细的文档，但是人总是有惰性的，多数的新贡献者并没有足够的意愿去仔细看翻看文档然后再提交 PR，甚至很多新贡献者由于刚开始接触开源项目，对于项目结构和文档组织结构比较陌生，甚至不会想到有这些文档的存在，总之各种各样的理由让多数的新贡献者会选择 “&lt;strong>先提了 PR 再说&lt;/strong>”。&lt;/p>
&lt;p>那么今天我想尝试彻底讲明白 “如何正确地提交一个 PR”，尝试细说 GitHub 上的 PR 全过程，以及这里面可能会遇到的各种困难和解决办法。&lt;strong>一方面希望对第一次参与开源项目的新人有所帮助，另一方面希望能够进一步降低 DevStream 社区和 DevLake 社区的参与门槛&lt;/strong>。&lt;/p>
&lt;h2 id="四我想参与开源项目怎么开始">四、我想参与开源项目，怎么开始？&lt;/h2>
&lt;p>不管你为什么决定开始参与开源项目，不管出发点是出于学习、兴趣、成就感等等，还是为了让某个自己需要的特性合入某个开源项目，总之今天你下定决心，要给某个开源项目提交一个 PR 了，好，我们开始吧！&lt;/p>
&lt;h3 id="41寻找一个合适的开源项目">4.1、寻找一个合适的开源项目&lt;/h3>
&lt;p>如果你已经决定参与某个开源社区了，那么请直接跳过本小节。&lt;/p>
&lt;p>如果你就只是想开始参与开源，暂时还不知道该参与哪个社区，那么我有几个小建议：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>不要从特别成熟的项目开始&lt;/strong>。比如现在去参与 Kubernetes 社区，一方面由于贡献者太多，很难抢到一个入门级的 issue 来开始第一个 PR；另外一方面也由于贡献者太多，你的声音会被淹没，社区维护者并不在意多你一个或者少你一个（当然可能没有人会承认，但是你不得不信），如果你提个 PR 都遇到了各种问题还不能自己独立解决，那么很可能你的 PR 会直接超时关闭，没有人在意你是不是有一个好的参与体验；&lt;/li>
&lt;li>&lt;strong>不要从特别小的项目开始&lt;/strong>。这就不需要我解释了吧？很早期的开源项目可能面临着非常多的问题，比如代码不规范、协作流程不规范、重构频繁且不是 issue 驱动的，让外部参与者无所适从……&lt;/li>
&lt;li>&lt;strong>选择知名开源软件基金会的孵化项目&lt;/strong>，这类项目一方面不是特别成熟，所以对新贡献者友好；另一方面也不会特别不成熟，不至于给人很差的参与体验，比如 &lt;strong>Apache 基金会、Linux 基金会、CNCF 等&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;p>比如可以从这些地方寻找自己感兴趣的开源项目：&lt;/p>
&lt;ul>
&lt;li>CNCF 沙箱项目[3]&lt;/li>
&lt;li>CNCF 孵化项目 (列表包括毕业项目)[4]&lt;/li>
&lt;li>Apache 项目 (孵化期项目名字中带 Incubating)[5]&lt;/li>
&lt;/ul>
&lt;p>当然，你也可以直接选择从 CNCF 沙箱项目 DevStream[6] 或者 Apache 孵化项目 Apache DevLake[7]，以此敲开开源世界的大门。&lt;/p>
&lt;h3 id="42寻找贡献点">4.2、寻找贡献点&lt;/h3>
&lt;p>开源项目的参与方式很多，最典型的方式是提交一个特性开发或者 bug 修复相关的 PR，但是其实文档完善、测试用例完善、bug 反馈等等也都是非常有价值的贡献。不过本文还是从需要提 PR 的贡献点开始上手，以 DevStream 项目为例（其他项目也一样），在项目 GitHub 代码库首页都会有一个 Issues 入口[8]，这里会记录项目目前已知的 bug、proposal(可以理解成新需求)、计划补充的文档、亟需完善的 UT 等等，如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>DevStream Issues&lt;/p>
&lt;p>在 Issues 里我们一般可以找到一个 “good first issue” 标签标记的 issues，点击这个标签可以进一步直接筛选出所有的 good first issues，这是社区专门留给新贡献者的相对简单的入门级 issues：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>DevStream Good First Issues&lt;/p>
&lt;p>没错，从这里开始，浏览一下这些 good first issues，看下有没有你感兴趣的而且还没被分配的 issue，然后在下面留言，等待项目管理员分配任务后就可以开始编码了，就像这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>Claim an Issue in DevStream&lt;/p>
&lt;p>如图所示，如果一个 issue 还没有被认领，这时候你上去留个言，等待管理员会将这个任务分配给你，接着你就可以开始开发了。&lt;/p>
&lt;h2 id="五我要提交-pr怎么上手">五、我要提交 PR，怎么上手？&lt;/h2>
&lt;p>一般开源项目代码库根目录都会有一个 CONTRIBUTING.md 或者其他类似名字的文档来介绍如何开始贡献，像这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>DevStream Contributing&lt;/p>
&lt;p>在 DevStream 的 Contributing[9] 文档里我们放了一个 Development Workflow[10]，其实就是 PR 工作流的介绍，不过今天，我要更详细地聊聊 PR 工作流。&lt;/p>
&lt;h3 id="51第一步fork-项目仓库">5.1、第一步：Fork 项目仓库&lt;/h3>
&lt;p>GitHub 上的项目都有一个 Fork 按钮，我们需要先将开源项目 fork 到自己的账号下，以 DevStream 为例：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>Fork DevStream&lt;/p>
&lt;p>点一下 Fork 按钮，然后回到自己账号下，可以找到 fork 到的项目了：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>DevStream Fork&lt;/p>
&lt;p>这个项目在你自己的账号下，也就意味着你有任意修改的权限了。我们后面要做的事情，就是将代码变更提到自己 fork 出来的代码库里，然后再通过 Pull Request 的方式将 commits 合入上游项目。&lt;/p>
&lt;h3 id="52第二步克隆项目仓库到本地">5.2、第二步：克隆项目仓库到本地&lt;/h3>
&lt;p>对于任意一个开源项目，流程几乎都是一样的。我直接写了一些命令，大家可以复制粘贴直接执行。当然，命令里的一些变量还是需要根据你自己的实际需求修改，比如对于 DevStream 项目，我们可以先这样配置几个环境变量：&lt;/p>
&lt;ul>
&lt;li>环境变量&lt;/li>
&lt;/ul>
&lt;p>&lt;code>export WORKING_PATH=&amp;quot;~/gocode&amp;quot; export USER=&amp;quot;daniel-hutao&amp;quot; export PROJECT=&amp;quot;devstream&amp;quot; export ORG=&amp;quot;devstream-io&amp;quot;&lt;/code>&lt;/p>
&lt;p>同理对于 DevLake，这里的命令就变成了这样：&lt;/p>
&lt;p>&lt;code>export WORKING_PATH=&amp;quot;~/gocode&amp;quot; export USER=&amp;quot;daniel-hutao&amp;quot; export PROJECT=&amp;quot;incubator-devlake&amp;quot; export ORG=&amp;quot;apache&amp;quot;&lt;/code>&lt;/p>
&lt;p>记得 USER 改成你的 GitHub 用户名，WORKING_PATH 当然也可以灵活配置，你想把代码放到哪里，就写对应路径。&lt;/p>
&lt;p>接着就是几行通用的命令来完成 clone 等操作了：&lt;/p>
&lt;ul>
&lt;li>clone 等&lt;/li>
&lt;/ul>
&lt;p>`mkdir -p ${WORKING_PATH}
cd ${WORKING_PATH}&lt;/p>
&lt;h1 id="you-can-also-use-the-url-gitgithubcomhttpsnotes-learningoss-cn-beijingaliyuncscoma781caab-57c4-4243-85ca-0fc5495b12delatexprojectgit">You can also use the url: &lt;a href="mailto:git@github.com">git@github.com&lt;/a>:&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/latex" alt="">{PROJECT}.git&lt;/h1>
&lt;h1 id="if-your-ssh-configuration-is-proper">if your ssh configuration is proper&lt;/h1>
&lt;p>git clone &lt;a href="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/latex">https://github.com/{PROJECT}.git&lt;/a>
cd ${PROJECT}&lt;/p>
&lt;p>git remote add upstream &lt;a href="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/latex">https://github.com/{PROJECT}.git&lt;/a>&lt;/p>
&lt;h1 id="never-push-to-upstream-locally">Never push to upstream locally&lt;/h1>
&lt;p>git remote set-url &amp;ndash;push upstream no_push&lt;/p>
&lt;p>`&lt;/p>
&lt;p>如果你配置好了 ssh 方式来 clone 代码，当然，git clone 命令用的 url 可以改成&lt;code>git@github.com:${USER}/${PROJECT}.git&lt;/code>。&lt;/p>
&lt;p>完成这一步后，我们在本地看到的 remote 信息应该是这样的：&lt;/p>
&lt;ul>
&lt;li>&lt;code>git remote -v&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;code>origin git@github.com:daniel-hutao/devstream.git (fetch) origin git@github.com:daniel-hutao/devstream.git (push) upstream https://github.com/devstream-io/devstream (fetch) upstream no_push (push)&lt;/code>&lt;/p>
&lt;p>记住啰，你本地的代码变更永远只提交到 origin，然后通过 origin 提交 Pull Request 到 upstream。&lt;/p>
&lt;h3 id="53第三步更新本地分支代码">5.3、第三步：更新本地分支代码&lt;/h3>
&lt;p>如果你刚刚完成 fork 和 clone 操作，那么你本地的代码肯定是新的。但是 “刚刚” 只存在一次，接着每一次准备开始写代码之前，你都需要确认本地分支的代码是新的，因为基于老代码开发你会陷入无限的冲突困境之中。&lt;/p>
&lt;ul>
&lt;li>更新本地 main 分支代码：&lt;/li>
&lt;/ul>
&lt;p>&lt;code>git fetch upstream git checkout main git rebase upstream/main&lt;/code>&lt;/p>
&lt;p>当然，我不建议你直接在 main 分支写代码，虽然你的第一个 PR 从 main 提交完全没有问题，但是如果你需要同时提交 2 个 PR 呢？总之鼓励新增一个 feat-xxx 或者 fix-xxx 等更可读的分支来完成开发工作。&lt;/p>
&lt;ul>
&lt;li>创建分支&lt;/li>
&lt;/ul>
&lt;p>&lt;code>git checkout -b feat-xxx&lt;/code>&lt;/p>
&lt;p>这样，我们就得到了一个和上游 main 分支代码一样的特性分支 feat-xxx 了，接着可以开始愉快地写代码啦！&lt;/p>
&lt;h3 id="54第四步写代码">5.4、第四步：写代码&lt;/h3>
&lt;p>没啥好说的，写就是了，写！&lt;/p>
&lt;h3 id="55第五步commit-和-push">5.5、第五步：Commit 和 Push&lt;/h3>
&lt;ul>
&lt;li>通用的流程：&lt;/li>
&lt;/ul>
&lt;p>&lt;code>git add &amp;lt;file&amp;gt; git commit -s -m &amp;quot;some description here&amp;quot; git push origin feat-xxx&lt;/code>&lt;/p>
&lt;p>当然，这里大家需要理解这几个命令和参数的含义，灵活调整。比如你也可以用&lt;code>git add --all&lt;/code>完成 add 步骤，在 push 的时候也可以加&lt;code>-f&lt;/code>参数，用来强制覆盖远程分支（假如已经存在，但是 commits 记录不合你意）。但是请记得&lt;code>git commit&lt;/code>的&lt;code>-s&lt;/code>参数一定要加哦！&lt;/p>
&lt;p>如果你习惯用 IDE 来 commit，当然也没有任何问题，像这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>DevStream Commit with Goland&lt;/p>
&lt;p>这里要注意 commit message 的规范，可能每个开源项目的要求不尽相同，比如 DevStream 的规范[11]是类似这样的格式：&lt;/p>
&lt;p>`[optional scope]:&lt;/p>
&lt;p>[optional body]&lt;/p>
&lt;p>[optional footer(s)]&lt;/p>
&lt;p>`&lt;/p>
&lt;p>举几个例子：&lt;/p>
&lt;ul>
&lt;li>&lt;code>feat: some description here&lt;/code>&lt;/li>
&lt;li>&lt;code>docs: some description here&lt;/code>&lt;/li>
&lt;li>&lt;code>fix: some description here&lt;/code>&lt;/li>
&lt;li>&lt;code>fix(core): some description here&lt;/code>&lt;/li>
&lt;li>&lt;code>chore: some description here&lt;/code>&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>commit 和 push 两个步骤可以在 IDE 里一步到位，也可以分开，我习惯分开操作，给自己多一些余地。另外，我更习惯命令行操作：&lt;/p>
&lt;ul>
&lt;li>&lt;code>git push origin feat-1&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>`Counting objects: 80, done.
Delta compression using up to 10 threads.
Compressing objects: 100% (74/74), done.
Writing objects: 100% (80/80), 13.78 KiB | 4.59 MiB/s, done.
Total 80 (delta 55), reused 0 (delta 0)
remote: Resolving deltas: 100% (55/55), completed with 31 local objects.
remote:
remote: Create a pull request for &amp;lsquo;feat-1&amp;rsquo; on GitHub by visiting:
remote:      &lt;a href="https://github.com/daniel-hutao/devstream/pull/new/feat-1">https://github.com/daniel-hutao/devstream/pull/new/feat-1&lt;/a>
remote:
To github.com:daniel-hutao/devstream.git&lt;/p>
&lt;ul>
&lt;li>[new branch]      feat-1 -&amp;gt; feat-1
`&lt;/li>
&lt;/ul>
&lt;p>到这里，本地 commits 就推送到远程了。&lt;/p>
&lt;h3 id="56第六步开一个-pr">5.6、第六步：开一个 PR&lt;/h3>
&lt;p>在完成 push 操作后，我们打开 GitHub，可以看到一个黄色的提示框，告诉我们可以开一个 Pull Request 了：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>Compare &amp;amp; pull request&lt;/p>
&lt;p>如果你没有看到这个框，也可以直接切换到 feat-1 分支，然后点击下方的 “Contribute” 按钮来开启一个 PR，或者直接点 Issues 边上的 Pull requests 进入对应页面。&lt;/p>
&lt;ul>
&lt;li>Pull Request 格式默认是这样的：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>DevStream Pull Request&lt;/p>
&lt;p>这里我们需要填写一个合适的标题（默认和 commit message 一样），然后按照模板填写 PR 描述。PR 模板其实在每个开源项目里都不太一样，我们需要仔细阅读上面的内容，避免犯低级错误。&lt;/p>
&lt;p>比如 DevStream 的模板里目前分为 4 个部分：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Pre-Checklist&lt;/strong>：这里列了 3 个前置检查项，提醒 PR 提交者要先阅读 Contributing 文档，然后代码要有完善的注释或者文档，尽可能添加测试用例等；&lt;/li>
&lt;li>&lt;strong>Description&lt;/strong>：这里填写的是 PR 的描述信息，也就是介绍你的 PR 内容的，你可以在这里描述这个 PR 解决了什么问题等；&lt;/li>
&lt;li>&lt;strong>Related Issues&lt;/strong>：记得吗？我们在开始写代码之前其实是需要认领 issue 的，这里要填写的也就是对应 issue 的 id，假如你领的 issue 链接是 &lt;a href="https://github.com/devstream-io/devstream/issues/796%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%BF%99%E4%B8%AA">https://github.com/devstream-io/devstream/issues/796，并且这个&lt;/a> issue 通过你这个 PR 的修改后就完成了，可以关闭了，这时候可以在 Related Issues 下面写 “&lt;strong>close #796&lt;/strong>”；&lt;/li>
&lt;li>&lt;strong>New Behavior&lt;/strong>：代码修改后绝大多数情况下是需要进行测试的，这时候我们可以在这里粘贴测试结果截图，这样 reviewers 就能够知道你的代码已经通过测试，功能符合预期，这样可以减少 review 工作量，快速合入。&lt;/li>
&lt;/ol>
&lt;p>这个模板并不复杂，我们直接对着填写就行。&lt;/p>
&lt;ul>
&lt;li>比如：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>DevStream Pull Request Template&lt;/p>
&lt;p>然后点击右下角 “Create pull request” 就完成了一个 PR 的创建了。不过我这里不能去点这个按钮，我用来演示的修改内容没有意义，不能合入上游代码库。不过我还是想给你看下 PR 创建出来后的效果，我们以 pr655[12] 为例吧：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>DevStream Pull Request 655&lt;/p>
&lt;p>这是上个月我提的一个 PR，基本和模板格式一致。除了模板的内容，可能你已经注意到这里多了一个 Test 小节，没错，模板不是死的，模板只是为了降低沟通成本，你完全可以适当调整，只要结果是 “往更清晰的方向走” 的。我这里通过 Test 部分添加了本地详细测试结果记录，告诉 reviewers 我已经在本地充分测试了，请放心合入。&lt;/p>
&lt;p>提交了 PR 之后，我们就可以在 PR 列表里找到自己的 PR 了，这时候还需要注意 ci 检查是不是全部能够通过，假如失败了，需要及时修复。以 DevStream 为例，ci 检查项大致如下：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>DevStream CI Checks&lt;/p>
&lt;h3 id="57第七步pr-合入">5.7、第七步：PR 合入&lt;/h3>
&lt;p>如果你的 PR 很完美，毫无争议，那么过不了太长时间，项目管理员会直接合入你的 PR，那么你这个 PR 的生命周期也就到此结束了。&lt;/p>
&lt;p>但是，没错，这里有个 “但是”，但是往往第一次 PR 不会那么顺利，我们接下来就详细介绍一下可能经常遇到的一些问题和对应的解决办法。&lt;/p>
&lt;h2 id="六我提交了一个-pr然后遇到了问题-abcdefg">六、我提交了一个 PR，然后遇到了问题 A,B,C,D,E,F,G,&amp;hellip;😭&lt;/h2>
&lt;p>多数情况下，提交一个 PR 后是不会被马上合入的，reviewers 可能会提出各种修改意见，或者我们的 PR 本身存在一些规范性问题，或者 ci 检查就直接报错了，怎么解决呢？继续往下看吧。&lt;/p>
&lt;h3 id="61reviewers-提了一些修改意见我如何更新-pr">6.1、Reviewers 提了一些修改意见，我如何更新 PR？&lt;/h3>
&lt;p>很多时候，我们提交了一个 PR 后，还需要继续追加 commit，比如提交后发现代码还有点问题，想再改改，或者 reviewers 提了一些修改意见，我们需要更新代码。&lt;/p>
&lt;p>一般我们遵守一个约定：在 review 开始之前，更新代码尽量不引入新的 commits 记录，也就是能合并就合并，保证 commits 记录清晰且有意义；在 review 开始之后，针对 reviewers 的修改意见所产生的新 commit，可以不向前合并，这样能够让二次 review 工作更有针对性。&lt;/p>
&lt;p>不过不同社区要求不一样，可能有的开源项目会要求一个 PR 里只能包含一个 commit，大家根据实际场景灵活判断即可。&lt;/p>
&lt;p>说回如何更新 PR，我们只需要在本地继续修改代码，然后通过和第一个 commit 一样的步骤，执行这几个命令：&lt;/p>
&lt;p>&lt;code>git add &amp;lt;file&amp;gt; git commit -s -m &amp;quot;some description here&amp;quot; git push origin feat-xxx&lt;/code>&lt;/p>
&lt;p>这时候别看 push 的是 origin 的 feat-xxx 分支，其实 GitHub 会帮你把新增的 commits 全部追加到一个未合入 PR 里去。没错，你只管不断 push，PR 会自动更新。&lt;/p>
&lt;p>至于如何合并 commits，我们下一小节具体介绍。&lt;/p>
&lt;h3 id="62commits-太多或者记录混乱如何合并-commits">6.2、Commits 太多或者记录混乱，如何合并 Commits？&lt;/h3>
&lt;p>很多情况下我们需要去合并 commits，比如你的第一个 commit 里改了 100 行代码，然后发现少改了 1 行，这时候又提交了一个 commit，那么第二个 commit 就太 “没意思” 了，我们需要合并一下。&lt;/p>
&lt;h4 id="621git-命令行方式合并-commits">6.2.1、Git 命令行方式合并 Commits&lt;/h4>
&lt;p>比如我这里有 2 个同名的 commits，第二个 commit 其实只改了一个标点：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>Commits to be Merged&lt;/p>
&lt;p>这时候我们可以通过 rebase 命令来完成 2 个 commits 的合并：&lt;/p>
&lt;p>&lt;code>git rebase -i HEAD~2&lt;/code>&lt;/p>
&lt;p>执行这个命令会进入一个编辑页面，默认是 vim 编辑模式，内容大致如下：&lt;/p>
&lt;p>`pick 3114c0f docs: just for test
pick 9b7d63b docs: just for test&lt;/p>
&lt;h1 id="rebase-d6409319b7d63b-onto-d640931-2-commands">Rebase d640931..9b7d63b onto d640931 (2 commands)&lt;/h1>
&lt;h1 id="heading">&lt;/h1>
&lt;h1 id="commands">Commands:&lt;/h1>
&lt;h1 id="p-pick--use-commit">p, pick = use commit&lt;/h1>
&lt;h1 id="r-reword--use-commit-but-edit-the-commit-message">r, reword = use commit, but edit the commit message&lt;/h1>
&lt;h1 id="e-edit--use-commit-but-stop-for-amending">e, edit = use commit, but stop for amending&lt;/h1>
&lt;h1 id="s-squash--use-commit-but-meld-into-previous-commit">s, squash = use commit, but meld into previous commit&lt;/h1>
&lt;h1 id="f-fixup--like-squash-but-discard-this-commits-log-message">f, fixup = like &amp;ldquo;squash&amp;rdquo;, but discard this commit&amp;rsquo;s log message&lt;/h1>
&lt;h1 id="x-exec--run-command-the-rest-of-the-line-using-shell">x, exec = run command (the rest of the line) using shell&lt;/h1>
&lt;h1 id="d-drop--remove-commit">d, drop = remove commit&lt;/h1>
&lt;h1 id="heading-1">&lt;/h1>
&lt;h1 id="these-lines-can-be-re-ordered-they-are-executed-from-top-to-bottom">These lines can be re-ordered; they are executed from top to bottom.&lt;/h1>
&lt;h1 id="heading-2">&lt;/h1>
&lt;h1 id="if-you-remove-a-line-here-that-commit-will-be-lost">If you remove a line here THAT COMMIT WILL BE LOST.&lt;/h1>
&lt;h1 id="heading-3">&lt;/h1>
&lt;h1 id="however-if-you-remove-everything-the-rebase-will-be-aborted">However, if you remove everything, the rebase will be aborted.&lt;/h1>
&lt;p>`&lt;/p>
&lt;p>我们需要把第二个 pick 改成 s，然后保存退出 (vim 的 wq 命令)：&lt;/p>
&lt;p>&lt;code>pick 3114c0f docs: just for test s 9b7d63b docs: just for test&lt;/code>&lt;/p>
&lt;p>接着会进入第二个编辑页面：&lt;/p>
&lt;p>`# This is a combination of 2 commits.&lt;/p>
&lt;h1 id="this-is-the-1st-commit-message">This is the 1st commit message:&lt;/h1>
&lt;p>docs: just for test&lt;/p>
&lt;p>Signed-off-by: Daniel Hu &lt;a href="mailto:tao.hu@merico.dev">tao.hu@merico.dev&lt;/a>&lt;/p>
&lt;h1 id="this-is-the-commit-message-2">This is the commit message #2:&lt;/h1>
&lt;p>docs: just for test&lt;/p>
&lt;p>Signed-off-by: Daniel Hu &lt;a href="mailto:tao.hu@merico.dev">tao.hu@merico.dev&lt;/a>&lt;/p>
&lt;h1 id="please-enter-the-commit-message-for-your-changes-lines-starting">Please enter the commit message for your changes. Lines starting&lt;/h1>
&lt;h1 id="with--will-be-ignored-and-an-empty-message-aborts-the-commit">with &amp;lsquo;#&amp;rsquo; will be ignored, and an empty message aborts the commit.&lt;/h1>
&lt;h1 id="heading-4">&amp;hellip;&lt;/h1>
&lt;p>`&lt;/p>
&lt;p>这里是用来编辑合并后的 commit message 的，我们直接删掉多余部分，只保留这样几行：&lt;/p>
&lt;p>`docs: just for test&lt;/p>
&lt;p>Signed-off-by: Daniel Hu &lt;a href="mailto:tao.hu@merico.dev">tao.hu@merico.dev&lt;/a>&lt;/p>
&lt;p>`&lt;/p>
&lt;p>接着同样是 vim 的保存退出操作，这时候可以看到日志：&lt;/p>
&lt;p>&lt;code>[detached HEAD 80f5e57] docs: just for test Date: Wed Jul 6 10:28:37 2022 +0800 1 file changed, 2 insertions(+) Successfully rebased and updated refs/heads/feat-1.&lt;/code>&lt;/p>
&lt;p>这时候可以通过&lt;code>git log&lt;/code>命令查看下 commits 记录是不是符合预期：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>Rebased&lt;/p>
&lt;p>好，我们在本地确认 commits 已经完成合并，这时候就可以继续推送到远程，让 PR 也更新掉：&lt;/p>
&lt;p>&lt;code>git push -f origin feat-xxx&lt;/code>&lt;/p>
&lt;p>这里需要有一个&lt;code>-f&lt;/code>参数来强制更新，合并了 commits 本质也是一种冲突，需要冲掉远程旧的 commits 记录。&lt;/p>
&lt;h4 id="622-ide-里合并-commits">6.2.2 IDE 里合并 Commits&lt;/h4>
&lt;p>图形化方式当然也可以实现 Commits 的合并。&lt;/p>
&lt;ul>
&lt;li>截图走起&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>点击右下角的 Git&lt;/li>
&lt;li>选择想要合并的 commits&lt;/li>
&lt;li>右键，然后点击 Squash Commits，记得嘴里默念一句：走你！&lt;/li>
&lt;/ol>
&lt;p>接着就可以看到这个页面了：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>Squash with Goland&lt;/p>
&lt;p>这是图形化方式修改 commit message 的页面，行吧，改成你喜欢的样子，然后点击右下角的 OK 按钮，事情就算结束了。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>Squash with Goland&lt;/p>
&lt;p>看，2 个 commits，它们 “融合” 了，变成了一个 “改头换面” 的新 commit 了。&lt;/p>
&lt;h3 id="63pr-产生了冲突如何解决">6.3、PR 产生了冲突，如何解决？&lt;/h3>
&lt;p>冲突可以在线解决，也可能本地解决，我们逐个来看。&lt;/p>
&lt;h4 id="631在线解决冲突">6.3.1、在线解决冲突&lt;/h4>
&lt;p>我们要尽可能避免冲突，养成每次写代码前更新本地代码的习惯。不过，冲突不可能完全避免，有时候你的 PR 被阻塞了几天，可能别人改了同一行代码，还抢先被合入了，这时候你的 PR 就出现冲突了，类似这样（同样，此刻我不能真的去上游项目构造冲突，所以下面用于演示的冲突在我在自己的 repo 里）：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>Conflict Happened&lt;/p>
&lt;p>每次看到这个页面都会让人觉得心头一紧。我们点击 “Resolve conflicts” 按钮，就可以看到具体冲突的内容了：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>Conflict File&lt;/p>
&lt;p>可以看到具体冲突的行了，接下来要做的就是解决冲突。我们需要删掉所有的 &lt;code>&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code>、&lt;code>&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code> 和 &lt;code>=======&lt;/code> 标记，只保留最终想要的内容，如下：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>Conflict Resolved&lt;/p>
&lt;p>接着点击右上角的 “Mark as Resolved”：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>Mark as resolved&lt;/p>
&lt;p>最后点击 “Commit merge”：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>这样就完成冲突解决了，可以看到产生了一个新的 commit：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>Conflict Resolved&lt;/p>
&lt;p>到这里，冲突就解决掉了。&lt;/p>
&lt;h4 id="632本地解决冲突">6.3.2、本地解决冲突&lt;/h4>
&lt;p>更多时候，我们需要在本地解决冲突，尤其是冲突太多，太复杂的时候。&lt;/p>
&lt;p>同样，我们构造一个冲突，这次尝试在本地解决冲突。&lt;/p>
&lt;ul>
&lt;li>先在线看一下冲突的内容：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>Conflict Happened&lt;/p>
&lt;ul>
&lt;li>接着我们在本地执行：&lt;/li>
&lt;/ul>
&lt;p>`# 先切回到 main 分支
git checkout main&lt;/p>
&lt;h1 id="拉取上游代码实际场景肯定是和上游冲突我们这里的演示环境其实是-origin">拉取上游代码（实际场景肯定是和上游冲突，我们这里的演示环境其实是 origin）&lt;/h1>
&lt;p>git fetch upstream&lt;/p>
&lt;h1 id="更新本地-main这里也可以用-rebase但是-reset-不管有没有冲突总是会成功">更新本地 main（这里也可以用 rebase，但是 reset 不管有没有冲突总是会成功）&lt;/h1>
&lt;p>git reset &amp;ndash;hard upstream/main
`&lt;/p>
&lt;p>到这里，本地 main 分支就和远程 (或者上游) main 分支代码完全一致了，然后我们要做的是将 main 分支的代码合入自己的特性分支，同时解决冲突。&lt;/p>
&lt;p>&lt;code>git checkout feat-1 git rebase main&lt;/code>&lt;/p>
&lt;ul>
&lt;li>这时候会看到这样的日志：&lt;/li>
&lt;/ul>
&lt;p>`First, rewinding head to replay your work on top of it&amp;hellip;
Applying: docs: conflict test 1
Using index info to reconstruct a base tree&amp;hellip;
M       README.md
Falling back to patching base and 3-way merge&amp;hellip;
Auto-merging README.md
CONFLICT (content): Merge conflict in README.md
error: Failed to merge in the changes.
Patch failed at 0001 docs: conflict test 1
The copy of the patch that failed is found in: .git/rebase-apply/patch&lt;/p>
&lt;p>Resolve all conflicts manually, mark them as resolved with
&amp;ldquo;git add/rm &amp;lt;conflicted_files&amp;gt;&amp;rdquo;, then run &amp;ldquo;git rebase &amp;ndash;continue&amp;rdquo;.
You can instead skip this commit: run &amp;ldquo;git rebase &amp;ndash;skip&amp;rdquo;.
To abort and get back to the state before &amp;ldquo;git rebase&amp;rdquo;, run &amp;ldquo;git rebase &amp;ndash;abort&amp;rdquo;.&lt;/p>
&lt;p>`&lt;/p>
&lt;p>我们需要解决冲突，直接打开 README.md，找到冲突的地方，直接修改。这里的改法和上一小节介绍的在线解决冲突没有任何区别，我就不赘述了。&lt;/p>
&lt;p>代码里同样只保留最终内容，然后继续 git 命令走起来：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>Conflict Resolved&lt;/p>
&lt;p>可能此时你并不放心，那就通过&lt;code>git log&lt;/code>命令看一下 commits 历史记录吧：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>Commits History&lt;/p>
&lt;p>这里的 “conflict test 2” 是我提交到 main 分支的记录，可以看到这个时间比 “conflict test 1” 还要晚了一些，但是它先合入了。我们在 rebase 操作后，这个记录在前，我们特性分支的 “conflict test 1” 在后，看起来很和谐，我们继续将这个变更推送到远程，这个命令已经出现很多次了：&lt;/p>
&lt;p>&lt;code>git push -f origin feat-xxx&lt;/code>&lt;/p>
&lt;p>这时候我们再回到 GitHub 看 PR 的话，可以发现冲突已经解决了，并且没有产生多余的 commit 记录，也就是说这个 PR 的 commit 记录非常干净，好似冲突从来没有出现过：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>至于什么时候可以在线解决冲突，什么时候适合本地解决冲突，就看大家如何看待 “&lt;strong>需不需要保留解决冲突的记录&lt;/strong>” 了，不同社区的理解不一样，可能特别成熟的开源社区会希望使用本地解决冲突方式，因为在线解决冲突产生的这条 merge 记录其实 “没营养”。至于 DevStream 社区和 DevLake 社区，我们推荐使用后一种，但是不做强制要求。&lt;/p>
&lt;h3 id="64ci-检查不过commit-message-相关问题如何修复">6.4、CI 检查不过：commit message 相关问题如何修复？&lt;/h3>
&lt;p>前面我们提到过 commit message 的规范，但是第一次提交 PR 的时候还是很容易出错，比如&lt;code>feat: xxx&lt;/code>其实能通过 ci 检查，但是&lt;code>feat: Xxx&lt;/code>就不行了。假设现在我们不小心提交了一个 PR，但是里面 commit 的 message 不规范，这时候怎么修改呢？&lt;/p>
&lt;ul>
&lt;li>太简单了，直接执行：&lt;/li>
&lt;/ul>
&lt;p>&lt;code>git commit --amend&lt;/code>&lt;/p>
&lt;p>这条命令执行后就能进入编辑页面，随意更新 commit message 了。改完之后，继续 push：&lt;/p>
&lt;p>&lt;code>git push -f origin feat-xxx&lt;/code>&lt;/p>
&lt;p>这样就能更新 PR 里的 commit message 了。&lt;/p>
&lt;h3 id="65ci-检查不过dcosign-问题如何修复">6.5、CI 检查不过：DCO(sign) 问题如何修复？&lt;/h3>
&lt;p>相当多的开源项目会要求所有合入的 commits 都包含一行类似这样的记录：&lt;/p>
&lt;p>&lt;code>Daniel Hu &amp;lt;tao.hu@merico.dev&amp;gt;&lt;/code>&lt;/p>
&lt;p>所以 commit message 看起来会像这样：&lt;/p>
&lt;p>`feat: some description here&lt;/p>
&lt;pre>&lt;code>Signed-off-by: Daniel Hu &amp;lt;tao.hu@merico.dev&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>`&lt;/p>
&lt;p>这行信息相当于是对应 commit 的作者签名。要添加这样一行签名当然很简单，我们直接在&lt;code>git commit&lt;/code>命令后面加一个&lt;code>-s&lt;/code>参数就可以了，比如&lt;code>git commit -s -m &amp;quot;some description here&amp;quot;&lt;/code>提交的 commit 就会带上你的签名。&lt;/p>
&lt;p>但是如果如果你第一次提交的 PR 里忘记了在 commits 中添加 Signed-off-by 呢？这时候，如果对应开源项目配置了 DCO 检查[13]，那么你的 PR 就会在 ci 检查中被 “揪出来” 没有正确签名。&lt;/p>
&lt;p>同样先构造一个没有加签名的 commit：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>请添加图片描述&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>Commit Without Sign&lt;/p>
&lt;p>我不能直接推到 DevStream 项目代码库里演示如何让 DCO 报错，但是如果提 PR，看到的效果是这样的：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/a781caab-57c4-4243-85ca-0fc5495b12de/640" alt="">&lt;/p>
&lt;p>Commit With DCO Error&lt;/p>
&lt;p>我们看下如何解决：&lt;/p>
&lt;ul>
&lt;li>&lt;code>git commit --amend -s&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>这样一个简单的命令，就能直接在最近一个 commit 里加上 Signed-off-by 信息。执行这行命令后会直接进入 commit message 编辑页面，默认如下图：&lt;/p>
&lt;p>`docs: dco test&lt;/p>
&lt;p>Signed-off-by: Daniel Hu &lt;a href="mailto:tao.hu@merico.dev">tao.hu@merico.dev&lt;/a>&lt;/p>
&lt;p>`&lt;/p>
&lt;p>这时候我们可以同时修改 commit message，如果不需要，那就直接保存退出好了，签名信息是会自动加上的。&lt;/p>
&lt;p>完成签名后呢？当然是来一个强制 push 了：&lt;/p>
&lt;p>&lt;code>git push -f origin feat-xxx&lt;/code>&lt;/p>
&lt;p>这样，你 PR 中的 DCO 报错就自然修复了。&lt;/p>
&lt;h2 id="七最后">七、最后&lt;/h2>
&lt;p>一个不小心这篇文章写的有点长了。行，打完收工！&lt;/p>
&lt;ul>
&lt;li>欢迎到我的个人网站[14]或者微信公众号 “&lt;strong>胡说云原生&lt;/strong>” 浏览更多我的文章；&lt;/li>
&lt;li>欢迎关注 DevStream 社区[15]，和我一起玩开源；&lt;/li>
&lt;li>欢迎到 DevStream 官方博客[16]浏览更多 DevStream 团队发布的文章。&lt;/li>
&lt;/ul>
&lt;p>本文外链&lt;/p>
&lt;p>[1]&lt;/p>
&lt;p>CNCF Project DevStream: &lt;a href="https://github.com/devstream-io/devstream">&lt;em>https://github.com/devstream-io/devstream&lt;/em>&lt;/a>&lt;/p>
&lt;p>[2]&lt;/p>
&lt;p>Apache DevLake: &lt;a href="https://github.com/apache/incubator-devlake">&lt;em>https://github.com/apache/incubator-devlake&lt;/em>&lt;/a>&lt;/p>
&lt;p>[3]&lt;/p>
&lt;p>CNCF 沙箱项目: &lt;a href="https://www.cncf.io/sandbox-projects/">&lt;em>https://www.cncf.io/sandbox-projects/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[4]&lt;/p>
&lt;p>CNCF 孵化项目 (列表包括毕业项目): &lt;a href="https://www.cncf.io/projects/">&lt;em>https://www.cncf.io/projects/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[5]&lt;/p>
&lt;p>Apache 项目 (孵化期项目名字中带 Incubating): &lt;a href="https://projects.apache.org/projects.html">&lt;em>https://projects.apache.org/projects.html&lt;/em>&lt;/a>&lt;/p>
&lt;p>[6]&lt;/p>
&lt;p>DevStream: &lt;a href="https://www.cncf.io/projects/devstream/">&lt;em>https://www.cncf.io/projects/devstream/&lt;/em>&lt;/a>&lt;/p>
&lt;p>[7]&lt;/p>
&lt;p>Apache DevLake: &lt;a href="https://projects.apache.org/project.html?incubator-devlake">&lt;em>https://projects.apache.org/project.html?incubator-devlake&lt;/em>&lt;/a>&lt;/p>
&lt;p>[8]&lt;/p>
&lt;p>Issues 入口: &lt;a href="https://github.com/devstream-io/devstream/issues">&lt;em>https://github.com/devstream-io/devstream/issues&lt;/em>&lt;/a>&lt;/p>
&lt;p>[9]&lt;/p>
&lt;p>DevStream 的 Contributing: &lt;a href="https://github.com/devstream-io/devstream/blob/main/CONTRIBUTING.md">&lt;em>https://github.com/devstream-io/devstream/blob/main/CONTRIBUTING.md&lt;/em>&lt;/a>&lt;/p>
&lt;p>[10]&lt;/p>
&lt;p>Development Workflow: &lt;a href="https://github.com/devstream-io/devstream/blob/main/docs/development/development-workflow.md">&lt;em>https://github.com/devstream-io/devstream/blob/main/docs/development/development-workflow.md&lt;/em>&lt;/a>&lt;/p>
&lt;p>[11]&lt;/p>
&lt;p>规范: &lt;a href="https://github.com/devstream-io/devstream/blob/main/docs/development/commit-messages.md">&lt;em>https://github.com/devstream-io/devstream/blob/main/docs/development/commit-messages.md&lt;/em>&lt;/a>&lt;/p>
&lt;p>[12]&lt;/p>
&lt;p>pr655: &lt;a href="https://github.com/devstream-io/devstream/pull/655">&lt;em>https://github.com/devstream-io/devstream/pull/655&lt;/em>&lt;/a>&lt;/p>
&lt;p>[13]&lt;/p>
&lt;p>DCO 检查: &lt;a href="https://wiki.linuxfoundation.org/dco">&lt;em>https://wiki.linuxfoundation.org/dco&lt;/em>&lt;/a>&lt;/p>
&lt;p>[14]&lt;/p>
&lt;p>我的个人网站: &lt;a href="https://www.danielhu.cn">&lt;em>https://www.danielhu.cn&lt;/em>&lt;/a>&lt;/p>
&lt;p>[15]&lt;/p>
&lt;p>DevStream 社区: &lt;a href="https://github.com/devstream-io">&lt;em>https://github.com/devstream-io&lt;/em>&lt;/a>&lt;/p>
&lt;p>[16]&lt;/p>
&lt;p>DevStream 官方博客: &lt;a href="https://blog.devstream.io">&lt;em>https://blog.devstream.io&lt;/em>&lt;/a>
&lt;a href="https://mp.weixin.qq.com/s/8tKpPqFeZOEE4ldEWptMZg">https://mp.weixin.qq.com/s/8tKpPqFeZOEE4ldEWptMZg&lt;/a>&lt;/p></description></item></channel></rss>