<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 无法分类的语言</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/</link><description>Recent content in 无法分类的语言 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: XML</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/xml/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/xml/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/XML">wiki，XML&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.w3.org/TR/xml/">W3C 官网，XML 标准&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Extensible Markup Language(可扩展标记语言，简称 XML)&lt;/strong> 是一种用于存储、传输和重建任意数据的标记语言和文件格式，常用来作为配置文件使用。它定义了一组规则，用于以人类可读和机器可读的格式对文档进行编码。万维网联盟 1998 年的 XML 1.0 规范和其他几个相关规范——它们都是免费的开放标准——定义了 XML。&lt;/p>
&lt;h1 id="xml-标准">XML 标准&lt;/h1>
&lt;p>XML 使用了与 HTML 相似的术语&lt;/p>
&lt;ul>
&lt;li>Element(元素)&lt;/li>
&lt;li>Tag(标签)&lt;/li>
&lt;li>Attribute(属性)&lt;/li>
&lt;/ul>
&lt;p>整个 XML 是由一个元素的集合体，由根元素开头。通过缩进控制层级，每个层级都表示是上层元素的子元素。&lt;/p></description></item><item><title>Docs: ASN.1</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/asn.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/asn.1/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.itu.int/en/ITU-T/asn1/Pages/asn1_project.aspx">ITU 官网,ITU-T-ASN.1 项目&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/ASN.1">Wiki,ASN.1&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/X.690#DER_encoding">Wiki,X.690-DER_encoding&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.txrzx.com/i4477.html">http://www.txrzx.com/i4477.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://threelambda.com/2020/11/08/asn-1/">http://threelambda.com/2020/11/08/asn-1/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://lapo.it/asn1js">https://lapo.it/asn1js&lt;/a>&lt;/li>
&lt;li>《抽象语法记法 asn.1 原理与应用》&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>**Abstract Syntax Notation One(抽象语法表示法，简称 ASN.1) **是一个形式化的标准，用于定义抽象数据类型的规范。它广泛用于计算机网络中，用于描述 telecommunications protocols(电信协议) 传输数据时所使用的 &lt;strong>formal notation(正式表示法)&lt;/strong>。&lt;/p>
&lt;p>通信设备需要相互传输数据，但是设备可能是由不同厂家生产的，其硬件体系结构、程序语言的语法定义和程序功能实现一般是不相同的。例如，在一台设备中，整形数据类型是 16 位表示，而在另一台则可能用 32 位表示。这些差异导致了同一数据对象在不同的设备上被表示为不同的符号串。为了解决以上问题，ISO 组织推出了抽象语法表符号 1（ASN.1，Abstract Syntax Notation One）。ASN.1 通过定义若干简单类型和复合类型，使得各个设备对其间交换消息的数据类型有了一致的认识。系统的消息发送方采用编码规则（BER、PER）将 ASN.1 描述的消息编码成二进制字节流；消息接受方对收到的字节流进行解码，再转化为符合其自身语法的消息格式。这样，经过 ASN.1 处理的消息独立于应用环境，就不会因为系统终端的区别而产生歧义。基于 H.323 协议的视频会议系统的信令消息就是采用 ASN.1 来表示的。&lt;/p>
&lt;p>80 年代初，当时的国际电报电话咨询委员会（CCITT）将应用于 E-mail MHS 协议的基本记法和解码格式进行了标准化，形成了 X.409 方案，这是 ASN.1 的前身。该标准后来被 ISO 组织采用并将其分为抽象语法记法和传输语法，形成了 ISO/IEC 8824 和 ISO/IEC 8825 两个系列标准，且版本在不断更新之中（目前是 2015 年版本）。CCITT 于 1989 年相应地发布了 X.208（ASN.1）和 X.209（BER）取代了 X.409。但后来由国际电信联盟（ITU）在 1994 年颁布的数据结构基本描述 X.680（Specification of basic notation）、信息对象描述 X.681（Information object specification）、约束描述 X.682（Constraint specification）和规范的参数化 X.683（Parameters of ASN.1 specification）等系列标准代替了 X.208；X.209 也被 ITU 在 1994 年的 X.690~ X.696 所代替。X.680 系列和 X.690 系列又分别于 1997 年、2002 年和 2015 年更新了版本。ITU-T 的 X.680 系列和 X.690 系列分别与 ISO 的 8824 系列和 8825 系列相对应；我国从 1996 年开始也陆续颁布了相应的国家标准。欲进一步了解我国关于 ASN.1 的相关标准索引的&lt;a href="http://www.txrzx.com/i4748.html">请进入&lt;/a>。&lt;/p>
&lt;p>ASN.1 这种表示法提供了一定数量的预定义的基本类型，比如：&lt;/p>
&lt;ul>
&lt;li>INTEGER(整数)&lt;/li>
&lt;li>BOOLEAN(布尔)&lt;/li>
&lt;li>IA5String(字符串)&lt;/li>
&lt;li>BIT STRING(比特字符串)&lt;/li>
&lt;li>等等&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>并且还可以定义构造类型，比如：&lt;/p>
&lt;ul>
&lt;li>SEQUENCE(序列) # 其实就是 map&lt;/li>
&lt;li>SEQUENCE OF(顺序) # 其实就是列表
&lt;ul>
&lt;li>这就好比 yaml 中使用 &lt;code>-&lt;/code> 符号表示列表，ASN.1 用一串字母表示。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CHOICE(选择)&lt;/li>
&lt;li>等等&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>ASN.1 是 ITU-T 第 17 研究组和 ISO/IEC 中国际电信联盟电信标准化部门（ITU-T）的联合标准，最初于 1984 年定义为 CCITT X.409：1984 的一部分。1988 年，由于广泛适用，ASN.1 移至其自己的标准 &lt;em>X.208&lt;/em>。_X.680 _系列涵盖了经过实质性修订的 1995 年版本。X.680 系列建议的最新版本是 2015 年发布的 5.0 版。&lt;/p>
&lt;p>ASN.1 已经融入了人们生活的方方面面，当我们使用手机、从 ATM 取款、管理网络、在线购物、接受包裹、发送邮件、通过互联网打电话看电影听音乐，都在使用 ASN.1。每天，从 RFID、VoIP、生物识别和许多其他新兴领域，ASN.1 被选为基础技术。&lt;/p>
&lt;h1 id="encodings-rules编码规则">Encodings Rules(编码规则)&lt;/h1>
&lt;p>从计算机的角度看 ASN.1 是 abstract(抽象的)，计算机无法理解字符串，所以需要一种 Encodings Rules(编码规则)，将 ASN.1 格式的内容表示为 bits 和 bytes。这些编码规则规范了如何将 ASN.1 数据结构表示为 Bytes。&lt;strong>ASN.1 与 Encoding Rules 的关系有点像 unicode 与 utf-8 的关系&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>备注：ASN.1 与 PEM 是完全没有关系的。但是 ASN.1 编码后是二进制的数据，这不利于复制黏贴，所以，通常都需要将二进制数据再转换为便于复制黏贴的字符串，所以通常使用 DER 编码的 ASN.1 数据还会再通过 PEM 标准进行编码。
为什么要套娃？很奇怪，莫名其妙~~~~从 文本——二进制——文本，不累么。。。。。o(╯□╰)o&lt;/p>
&lt;/blockquote>
&lt;h2 id="itu-x690-标准">ITU X.690 标准&lt;/h2>
&lt;p>ITU-T X.690 标准，指定了几种 ASN.1 编码格式：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/X.690#BER_encoding">Basic Encoding Rules&lt;/a>(基本编码规则，简称 BER)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/X.690#CER_encoding">Canonical Encoding Rules&lt;/a>(规范编码规则，简称 CER)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/X.690#DER_encoding">Distinguished Encoding Rules&lt;/a>(杰出编码规则，简称 DER)&lt;/li>
&lt;/ul>
&lt;h3 id="der-编码规则">DER 编码规则&lt;/h3>
&lt;p>&lt;strong>Distinguished Encoding Rules(专用编码规则，简称 DER)&lt;/strong> 是 BER 的一种受限制变体，用于为 ASN.1 所描述的数据结构生成明确的传输语法。像 CER 一样，DER 编码是有效的 BER 编码。 DER 与 BER 相同，只是删除了一个发送者的所有选项。&lt;/p>
&lt;p>用白话说： DER 是一种以二进制形式编码 ASN.1 语法的方法&lt;/p>
&lt;p>&lt;strong>DER，是对 &lt;strong>&lt;a href="https://www.yuque.com/go/doc/33220231">&lt;strong>ASN.1&lt;/strong>&lt;/a>&lt;/strong> 这种语言进行编码的一种规则&lt;/strong>，也是最常用的一种。所谓对某种语言编码，就是类似编译器的效果。所以也可以称为 &lt;strong>ASN.1 的 DER 规则&lt;/strong>。&lt;/p>
&lt;h2 id="编码示例">编码示例&lt;/h2>
&lt;p>这是定义虚构&lt;a href="https://en.wikipedia.org/wiki/Foo">Foo&lt;/a>协议的消息（数据结构）的示例 ASN.1 模块：&lt;/p>
&lt;pre>&lt;code>FooProtocol 定义 ::= BEGIN
FooQuestion ::= SEQUENCE {
trackingNumber INTEGER,
question IA5String
}
FooAnswer ::= SEQUENCE {
questionNumber INTEGER,
answer BOOLEAN
}
END
&lt;/code>&lt;/pre>
&lt;p>这可能是 Foo 协议的创建者发布的规范。ASN.1 中没有定义会话流、交易交换和状态，而是留给协议的其他符号和文本描述。
假设一条消息符合 Foo 协议并且将被发送到接收方，这个特定的消息（&lt;a href="https://en.wikipedia.org/wiki/Protocol_data_unit">协议数据单元&lt;/a>（PDU））是：&lt;/p>
&lt;pre>&lt;code>myQuestion FooQuestion ::= {
trackingNumber 5,
question “有人在吗？”
}
&lt;/code>&lt;/pre>
&lt;p>ASN.1 支持对值和大小以及可扩展性的约束。上述规格可改为&lt;/p>
&lt;pre>&lt;code>FooProtocol DEFINITIONS ::= BEGIN
FooQuestion ::= SEQUENCE {
trackingNumber INTEGER(0..199),
question IA5String
}
FooAnswer ::= SEQUENCE {
questionNumber INTEGER(10..20),
answer BOOLEAN
}
FooHistory ::= SEQUENCE {
questions SEQUENCE (SIZE(0..10)) OF FooQuestion,
回答 SEQUENCE(SIZE(1..10)) OF FooAnswer,
anArray SEQUENCE(SIZE(100)) OF INTEGER(0..1000),
...
}
END
&lt;/code>&lt;/pre>
&lt;p>此更改将 trackingNumbers 限制为介于 0 和 199 之间的值，并将 questionNumbers 限制为介于 10 和 20 之间的值。问题数组的大小可以在 0 到 10 个元素之间，答案数组的大小可以在 1 到 10 个元素之间。anArray 字段是一个固定长度的 100 个元素的整数数组，必须在 0 到 1000 的范围内。“&amp;hellip;”扩展性标记意味着 FooHistory 消息规范在规范的未来版本中可能会有其他字段；兼容一个版本的系统应该能够接收和传输来自更高版本的事务，但只能处理早期版本中指定的字段。好的 ASN.1 编译器将生成（在 C、C++、Java 等中）源代码，这些代码将自动检查事务是否在这些约束范围内。不应从应用程序接受或向应用程序提交违反约束的事务。这一层的约束管理显着简化了协议规范，因为应用程序将免受约束违反，降低风险和成本。
为了通过网络发送 myQuestion 消息，使用其中一个&lt;a href="https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One#Encodings">编码规则&lt;/a>将消息序列化（编码）为一系列&lt;a href="https://en.wikipedia.org/wiki/Byte">字节&lt;/a>。Foo 协议规范应该明确命名要使用的一组编码规则，以便 Foo 协议的用户知道他们应该使用和期望使用哪一个。&lt;/p>
&lt;h3 id="在-der-中编码的示例编辑httpsenwikipediaorgwindexphptitleasn1actioneditsection7">在 DER 中编码的示例[&lt;a href="https://en.wikipedia.org/w/index.php?title=ASN.1&amp;amp;action=edit&amp;amp;section=7">编辑&lt;/a>]&lt;/h3>
&lt;p>下面是上面显示的 FooQuestion 以&lt;a href="https://en.wikipedia.org/wiki/X.690#DER_encoding">DER 格式&lt;/a>编码的数据结构（所有数字均为十六进制）：
30 13 02 01 05 16 0e 41 6e 79 62 6f 64 79 20 74 68 65 72 65 3f
DER 是&lt;a href="https://en.wikipedia.org/wiki/Type%E2%80%93length%E2%80%93value">类型-长度-值&lt;/a>编码，所以上面的序列可以解释，参考标准的 SEQUENCE、INTEGER 和 IA5String 类型，如下：
30 — 指示 SEQUENCE 的类型标记 13 — 以八位字节为单位的值的长度 02 — 指示整数的类型标记 01 — 以八位字节为单位的跟随值的长度 05 — 值 (5) 16 — 指示&lt;a href="https://en.wikipedia.org/wiki/IA5String">IA5String 的&lt;/a> 类型标记 （IA5 表示完整的 7 位 ISO 646 集，包括变体， 但通常是 US-ASCII） 0e — 41 6e 79 62 6f 64 79 20 74 68 65 72 65 3f — 值（“有人吗？”）&lt;/p>
&lt;h3 id="以-xer-编码的示例编辑httpsenwikipediaorgwindexphptitleasn1actioneditsection8">以 XER 编码的示例[&lt;a href="https://en.wikipedia.org/w/index.php?title=ASN.1&amp;amp;action=edit&amp;amp;section=8">编辑&lt;/a>]&lt;/h3>
&lt;p>或者，可以使用&lt;a href="https://en.wikipedia.org/wiki/XML_Encoding_Rules">XML 编码规则&lt;/a>(XER) 对相同的 ASN.1 数据结构进行&lt;a href="https://en.wikipedia.org/wiki/XML_Encoding_Rules">编码，&lt;/a>以实现更高的“在线”可读性。然后它将显示为以下 108 个八位字节，（空格数包括用于缩进的空格）：
**&lt;!-- raw HTML omitted --> ** &lt;strong>&lt;!-- raw HTML omitted -->&lt;/strong> 5 **&lt;!-- raw HTML omitted --> ** **&lt;!-- raw HTML omitted -->&lt;strong>有人在吗？&lt;/strong>&lt;!-- raw HTML omitted --> ** &lt;strong>&lt;!-- raw HTML omitted -->&lt;/strong>&lt;/p>
&lt;h3 id="以-per-编码的示例未对齐编辑httpsenwikipediaorgwindexphptitleasn1actioneditsection9">以 PER 编码的示例（未对齐）[&lt;a href="https://en.wikipedia.org/w/index.php?title=ASN.1&amp;amp;action=edit&amp;amp;section=9">编辑&lt;/a>]&lt;/h3>
&lt;p>或者，如果采用&lt;a href="https://en.wikipedia.org/wiki/Packed_Encoding_Rules">打包编码规则&lt;/a>，将产生以下 122 位（16 个八位字节等于 128 位，但这里只有 122 位携带信息，最后 6 位只是填充）：
01 05 0e 83 bb ce 2d f9 3c a0 e9 a3 2f 2c af c0
在这种格式中，所需元素的类型标记未编码，因此在不知道用于编码的预期模式的情况下无法对其进行解析。此外，IA5String 值的字节使用 7 位单元而不是 8 位单元进行打包，因为编码器知道编码 IA5String 字节值只需要 7 位。然而，长度字节仍然在此处编码，即使对于第一个整数标记 01（但 PER 打包器也可以省略它，如果它知道允许的值范围适合 8 位，它甚至可以用更少的值压缩单个值字节 05 比 8 位，如果它知道允许的值只能适合更小的范围）。
编码的 PER 中的最后 6 位在最后一个字节 c0 的 6 个最低有效位中用空位填充：如果此序列作为较长未对齐的一部分插入，则这些额外位可能不会被传输或用于编码其他内容 PER 序列。
这意味着未对齐的 PER 数据本质上是一个有序的位流，而不是像对齐的 PER 那样的有序字节流，并且在普通处理器上通过软件解码会更复杂一些，因为它需要额外的上下文位 -移位和掩码，而不是直接字节寻址（但对于现代处理器和最小可寻址单元大于 1 个八位字节的内存/存储单元，同样的评论也是正确的）。然而，现代处理器和信号处理器包括对比特流的快速内部解码的硬件支持，自动处理跨越可寻址存储单元边界的计算单元（这是在数据编解码器中进行有效处理以进行压缩/解压缩或某些加密/解密算法）。
如果需要在八位字节边界上对齐，对齐的 PER 编码器将产生：
01 05 0e 41 6e 79 62 6f 64 79 20 74 68 65 72 65 3f
（在这种情况下，每个八位字节在其未使用的最高有效位上单独填充空位）。&lt;/p>
&lt;h2 id="以一个证书分析-asn1-语法">以一个证书分析 ASN.1 语法&lt;/h2>
&lt;p>以下是一个&lt;code>PEM&lt;/code>格式的证书。&lt;/p>
&lt;pre>&lt;code>-----BEGIN CERTIFICATE-----
MIIFwTCCA6mgAwIBAgIUNQk34EiXUjqgxnfhOZtv6zxIiekwDQYJKoZIhvcNAQEN
BQAwcDELMAkGA1UEBhMCQ04xEDAOBgNVBAgMB0JlaWppbmcxEDAOBgNVBAcMB0Jl
aWppbmcxEDAOBgNVBAoMB2V4YW1wbGUxETAPBgNVBAsMCFBlcnNvbmFsMRgwFgYD
VQQDDA9yZXBvLmVubmlvdC5uZXQwHhcNMjAwODExMDMwMzE0WhcNMzAwODA5MDMw
MzE0WjBwMQswCQYDVQQGEwJDTjEQMA4GA1UECAwHQmVpamluZzEQMA4GA1UEBwwH
QmVpamluZzEQMA4GA1UECgwHZXhhbXBsZTERMA8GA1UECwwIUGVyc29uYWwxGDAW
BgNVBAMMD3JlcG8uZW5uaW90Lm5ldDCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCC
AgoCggIBAN6xDFkixeboRBjaVLi1/IjCfHvGS2xGihWrx2dN9jXIZWQqU2Lw8rLy
yzrnzSEJDRcUFGaXpRagHTYJPhcr31Sa4OkCsoorwElagcOOPQXAc1A87vBk1+r/
3eQu+IPGjr+3DU/yqNNuaq0CZgDDww9ttbyTb8JxZweXdAMjK0D7LiNCkpvwM1l6
ylVl9o5+ACA34qb81IyVAsGFSHP/ukcFIaC79Zf/7p3Tjm4uRkAdtQYJGwA0Oafk
HbPaPLOHPJdi+3+a/OmmBJamxyWXF9pJ/BRrxFrqtssnAhIyPsNqKsPDCknJOzwS
6vdTVsuMkLMUbc0OK1dSIulXxZaea+jXcZMYWUA4ZDNdo1SrMg3Vvj/CrLWgm7b0
T1Wb8tXsr2NUNoacMzDgN41Kz7Ht57LQURaFf9rzjqACHVYfj/Ad8/PmgA6V3Dc3
gvMvqOoyp2iic1xQ2GcIItHvqD4YwBSdtyxJc1N5llNBF7A6+JWVc0kJpOQCDKVb
U+0Py6ugnbb/pQ89/4zXXWyuTQO0BGULoHCo0++eF+pLcW6LstQNSUYxYRr4tmLr
sbUJFPoFcHXdQ9F8I2rBXdKCePHDBPQ2HexhANUWnRQdjtnYG9UQRQaDVKiCXUMj
9f6ixjN9DAz+SqndPksE0Ux0cgfkTEfi9N+5c7rCxzZYgH8UlFiDAgMBAAGjUzBR
MB0GA1UdDgQWBBRaOW9HUg7eACHGDuPMcc/k7nPmbjAfBgNVHSMEGDAWgBRaOW9H
Ug7eACHGDuPMcc/k7nPmbjAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBDQUA
A4ICAQCu1kx2rnRp9oiPw3Y2WuJ2hnzkMTUGPv4rpX0hgVSLNAEiDEvujz/pnHaJ
83+JZuMHebAQnWHXVaUdmzn7Yw9WsZoXu15st0WMOAC8cUZ4uD0t1osPJTSuc3hA
F0ZG3tHzuJBpX4T6pVrZ3jJvuY5vGJGCMwRdS4V7e6wQmLjzqf3oq05y9JlvKBYX
JdU69BynZ1vEtUuC91WJTTvlqLtbAS6LTSmnSYWscNpP4KOTXNfdf8HlKFRKGR2e
cVyAXu9bA89HeEeG8ztceyD2GO+S7xBNuZRV11Oi2xO59rJJAzzrIO1W8oda5lac
JVRI+n8w+hLG+bbq+24s9tVB0MBZj3/honpYRLOYMAT507YlOvDPjreudYHWJSLG
cTjRH0dtIgqbi8uTH3iJ2yWTq92OfGSSERofVdSOPrlzH5GpkpeIoRcYlP1KLnIy
wxlI4E7W50PX5rMKMIp4/p6ALgA7psuC7ZTzk3f7R/tmHBSNb5JiSbp7MjI+iVRE
zZX73VW1nLf4YaSS+MYNudAQl0ZoUvK3f0QEj4NwzRjDkdsUKI+X7Q2p03foBMCU
4ijSDMvjyn3JEvT878Fxh7KB4IbZKh3kj9RetGaGEljjgv/Pg3h2gu+GNPgk30xJ
TfK5QkRaYenm9aWKpHHf4hpUQlMKawxdS1k+3gVGwWu8YM/a0A==
-----END CERTIFICATE-----
&lt;/code>&lt;/pre>
&lt;p>对这个证书进行解析的方法是用一个在线的工具 &lt;a href="http://lapo.it/asn1js/">http://lapo.it/asn1js/&lt;/a>。&lt;/p>
&lt;p>可以把上面 base64 编码的证书复制到网站解码之后，可以看到类似如下的结果。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ylqsbb/1639220174069-639f8b9d-ae40-485a-bece-8e3ae158f746.png" alt="image.png">
ASN.1 的编码基本上遵循的是&lt;code>type+length+value&lt;/code>的方式。&lt;/p>
&lt;p>ASN.1 的数据 tag 大概有以下几种，&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>type&lt;/th>
&lt;th>tagNumber&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Boolean&lt;/td>
&lt;td>0x01&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Integer&lt;/td>
&lt;td>0x02&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>BitString&lt;/td>
&lt;td>0x03&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OctetString&lt;/td>
&lt;td>0x04&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Null&lt;/td>
&lt;td>0x05&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ObjectIdentifier&lt;/td>
&lt;td>0x06&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Enumerated&lt;/td>
&lt;td>0x0a&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UTF8String&lt;/td>
&lt;td>0x0c&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Sequence&lt;/td>
&lt;td>0x10&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Set&lt;/td>
&lt;td>0x11&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PrintableString&lt;/td>
&lt;td>0x13&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IA5String&lt;/td>
&lt;td>0x16&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UTCTime&lt;/td>
&lt;td>0x17&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UnicodeString&lt;/td>
&lt;td>0x1e&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>那么具体看一下以上 ca 证书的前四个字节是什么含义。&lt;/p>
&lt;pre>&lt;code>30 82 05 C1
&lt;/code>&lt;/pre>
&lt;ol>
&lt;li>首先看是什么 type。第一个字节&lt;code>0x30&lt;/code>描述了 type 信息。tagClass = 0x30 &amp;raquo; 6 = 0 ，表示&lt;code>universal isConstructed = 0x30 &amp;amp; 0x20 = True&lt;/code>，对于&lt;code>sequence&lt;/code>基本都是 true, &lt;code>tagNumber = 0x30 &amp;amp; 0x1F = 0x10&lt;/code> ，因此对应的&lt;code>Sequence&lt;/code>&lt;/li>
&lt;li>接下来计算长度。 第二个字节为&lt;code>0x82&lt;/code>, 分两种情况，判断表达式，&lt;code>byte &amp;amp; 0x7F == byte&lt;/code> 如果为 true 就是小于 127。否则就是大于 127。&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>长度是小于 127(short form) 那么该该字节就是 length，之后就是 value 的内容。&lt;/li>
&lt;li>长度大于 127(long form)， byte &amp;amp; 0x7F 表示 length 的编码长度。&lt;/li>
&lt;/ul>
&lt;p>对于以上的例子，&lt;code>0x82&lt;/code>是 long form 因为&lt;/p>
&lt;pre>&lt;code>( 0x82 == (0x82 &amp;amp; 0x7F) = False
&lt;/code>&lt;/pre>
&lt;p>那么表示长度的字节数量是&lt;/p>
&lt;pre>&lt;code>0x82 &amp;amp; 0x7F = 0x2
&lt;/code>&lt;/pre>
&lt;p>因此’0x82’之后的两个字节’0x05’和’0xC1’组成长度。&lt;/p>
&lt;pre>&lt;code>0x05C1 = 1473
&lt;/code>&lt;/pre>
&lt;p>两个字节表示 value 的长度 1473。&lt;/p>
&lt;p>因此，&lt;/p>
&lt;pre>&lt;code>30 82 05 C1
&lt;/code>&lt;/pre>
&lt;p>这个头四个字节的含义是，这个是&lt;code>Sequence&lt;/code>类型， 长度是 1473，这四节之后的 1473 个字节就是&lt;code>Sequence&lt;/code>类型的值。&lt;/p></description></item><item><title>Docs: EBNF</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/ebnf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/ebnf/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">Wiki,EBNF&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Metasyntax">Wiki,Metasyntax&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Extended Backus-Naur Form(扩展的 Backus-Naur 格式，简称 EBNF)&lt;/strong> 是一组 &lt;a href="https://en.wikipedia.org/wiki/Metasyntax">Metasyntax(元语法)&lt;/a> 表示法。EBNF 用于对计算机&lt;a href="https://en.wikipedia.org/wiki/Programming_language">编程语言&lt;/a>等&lt;a href="https://en.wikipedia.org/wiki/Formal_language">形式语言&lt;/a>进行形式化描述。EBNF 是基于 BNF 的扩展。&lt;/p>
&lt;p>EBNF 是一种表达形式语言语法的代码。EBNF 由两部分组成&lt;/p>
&lt;ul>
&lt;li>Terminal Symbols(终结符号)&lt;/li>
&lt;li>non-terminal production rules(非终结表达式规则) # 其实就相当于一个表达式&lt;/li>
&lt;/ul>
&lt;p>这两部分组合起来，其实就是一句话，最后跟一个句号~~~一行内容就是一个 EBNF 表示法，比如：&lt;/p>
&lt;pre>&lt;code>digit excluding zero = &amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | &amp;quot;3&amp;quot; | &amp;quot;4&amp;quot; | &amp;quot;5&amp;quot; | &amp;quot;6&amp;quot; | &amp;quot;7&amp;quot; | &amp;quot;8&amp;quot; | &amp;quot;9&amp;quot; ;
digit = &amp;quot;0&amp;quot; | digit excluding zero ;
&lt;/code>&lt;/pre>
&lt;h1 id="symbols符号">Symbols(符号)&lt;/h1>
&lt;p>下面定义的符号意义中，&lt;code>...&lt;/code> 仅仅用来表示符号中可以是任意内容，不属于被定义的符号的一部分。
&lt;code>=&lt;/code> # Definition(定义)
&lt;code>,&lt;/code> # Concatenation(串接)
&lt;code>;&lt;/code> # Termination(终止)
&lt;code>|&lt;/code> # Alternation(交替)，就是“或者”的意思。
&lt;code>[...]&lt;/code> # Optional(可选)
&lt;code>{}&lt;/code> # Repetition(重复)
&lt;code>(...)&lt;/code> # Grouping(分组)
&lt;code>'...'&lt;/code> # Terminal String(终端字符串)
&lt;code>&amp;quot;...&amp;quot;&lt;/code> # Terminal String(终端字符串)
&lt;code>(*...*)&lt;/code> # Comment(注释)
&lt;code>?...?&lt;/code> # Special Sequence(特殊序列)&lt;/p></description></item><item><title>Docs: INI</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/ini/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/ini/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/INI_file">Wiki,INI&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="ini-格式规范">INI 格式规范&lt;/h2>
&lt;ul>
&lt;li>&lt;code>;&lt;/code> 分号表示注释&lt;/li>
&lt;/ul>
&lt;h1 id="ini-原语">INI 原语&lt;/h1>
&lt;h2 id="keyvalue-pair键值对">Key/Value pair(键/值对)&lt;/h2>
&lt;p>INI 格式的文件主要结构是 &lt;strong>Key/Value pair(键/值对)&lt;/strong> 格式。Key 与 Value 以 &lt;code>=&lt;/code> 符号分割。有的地方也称为 &lt;strong>Properties(属性)&lt;/strong>。&lt;/p>
&lt;h2 id="sections部分">Sections(部分)&lt;/h2>
&lt;p>&lt;strong>Selections(部分)&lt;/strong> 是 &lt;code>键值对&lt;/code> 的集合，也称为 Hash Tables(哈希表) 或 Dictionaries(字典)，以 &lt;code>[]&lt;/code> 符号表示。从 Table 的 &lt;code>[]&lt;/code> 符号开始到下一个 &lt;code>[]&lt;/code> 符号为止，所有键值对都属于该 Sections。&lt;/p>
&lt;p>人们日常生活中描述的 第一部分、第二部分、我这部分 等等，这就是 部分的意思，表示一个整体的其中一部分。一个 INI 有很多部分，比如可以说：有 main 部分、logging 部分 等等。&lt;/p>
&lt;p>Sections 也有章节的意思，但是不如 Chapter 这个词用来表示章节更合适。&lt;/p></description></item><item><title>Docs: JSON</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/json/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/json/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官方文档：&lt;a href="https://www.json.org/json-zh.html">https://www.json.org/json-zh.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/JSON">Wiki,JSON&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc8259">RFC 8259&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>JavaScript Object Notation(JS 对象表示法，简称 JSON)&lt;/strong> 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。 它基于 JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999 的一个子集。 JSON 采用完全独立于语言的文本格式，但是也使用了类似于 C 语言家族的习惯（包括 C, C++, C#, Java, JavaScript, Perl, Python 等）。 这些特性使 JSON 成为理想的数据交换语言。&lt;/p>
&lt;p>JSON 建构于两种结构：&lt;/p>
&lt;ul>
&lt;li>“名称/值”对的集合（A collection of name/value pairs） # 不同的语言中，它被理解为对象（object），映射（mapping），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。&lt;/li>
&lt;li>值的有序列表（An ordered list of values） # 在大部分语言中，它被理解为数组（array）。&lt;/li>
&lt;/ul>
&lt;p>JSON 具有以下这些形式：&lt;/p>
&lt;ol>
&lt;li>映射是一个无序的“‘名称/值’对”集合。一个对象以 &lt;code>{&lt;/code>左大括号 开始， &lt;code>}&lt;/code>右大括号 结束。每个“名称”后跟一个 :冒号 ；“‘名称/值’ 对”之间使用 ,逗号 分隔。&lt;/li>
&lt;li>数组是值（value）的有序集合。一个数组以&lt;code>[&lt;/code>左中括号 开始，&lt;code>]&lt;/code>右中括号 结束。值之间使用 ,逗号 分隔。&lt;/li>
&lt;/ol>
&lt;p>映射格式样例&lt;/p>
&lt;pre>&lt;code> {
&amp;quot;name&amp;quot;: &amp;quot;lichenhao&amp;quot;,
&amp;quot;age&amp;quot;: 30
}
&lt;/code>&lt;/pre>
&lt;p>数组格式样例&lt;/p>
&lt;pre>&lt;code> [
&amp;quot;lichenhao&amp;quot;,
&amp;quot;zhangna&amp;quot;
]
&lt;/code>&lt;/pre>
&lt;p>混合格式样例：&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;family&amp;quot;: [
{
&amp;quot;name&amp;quot;: &amp;quot;lichenhao&amp;quot;,
&amp;quot;age&amp;quot;: 30
},
{
&amp;quot;name&amp;quot;: &amp;quot;zhangna&amp;quot;,
&amp;quot;age&amp;quot;: 30
}
]
}
&lt;/code>&lt;/pre></description></item><item><title>Docs: Protobuf</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/protobuf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/protobuf/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/kfyTcs6xuDvlCX3U04Edng">公众号-码农的荒岛求生，神奇的 Google 二进制编解码技术：Protobuf&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Protocol_Buffers">Wiki,Protocol Buffers&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>计算机网络编程中一个非常基本的问题：该怎样表示 client 与 server 之间交互的数据，在往下看之前先想一想这个问题。&lt;/p>
&lt;h1 id="共识与协议">共识与协议&lt;/h1>
&lt;p>这个问题可不像看上去的那样简单，因为 client 进程和 server 进程运行在不同的机器上，这些机器可能运行在不同的处理器平台、可能运行在不同的操作系统、可能是由不同的编程语言编写的，server 要怎样才能识别出 client 发送的是什么数据呢？就像这样：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/0f716e20-2641-4626-b2ff-1c0675946e8d/640" alt="">
client 给 server 发送了一段数据：&lt;/p>
&lt;pre>&lt;code>0101000100100001
&lt;/code>&lt;/pre>
&lt;p>server 怎么能知道该怎样“解读”这段数据呢？&lt;/p>
&lt;p>显然，client 和 server 在发送数据之前必须首先达成某种关于怎样解读数据的共识，这就是所谓的&lt;strong>协议&lt;/strong>。&lt;/p>
&lt;p>这里的协议可以是这样的：“将每 8 个比特为一个单位解释为无符号数字”，如果协议是这样的，那么 server 接收到这串二进制后就会将其解析为 81(01010001)与 33(00100001)。&lt;/p>
&lt;p>当然，这里的协议也可以是这样的：“将每 8 个比特为一个单位解释为 ASCII 字符”，那么 server 接收到这串二进制后就将其解析为“Q!”。&lt;/p>
&lt;p>可见，同样一串二进制在不同的“上下文/协议”下有完全不一样的解读，&lt;strong>这也是为什么计算机明明只认知 0 和 1 但是却能处理非常复杂任务的根本原因，因为一切都可以编码为 0 和 1，同样的我们也可以从 0 和 1 中解析出我们想要的信息，这就是所谓的编解码技术。&lt;/strong>&lt;/p>
&lt;p>实际上不止 0 和 1，我们也可以将信息编码为摩斯密码(Morse code)等，只不过计算机擅长处理 0 和 1 而已。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/0f716e20-2641-4626-b2ff-1c0675946e8d/640" alt="">&lt;/p>
&lt;p>扯远了，回到本文的主题。&lt;/p>
&lt;h5 id="heading">&lt;/h5>
&lt;h1 id="远程过程调用rpc">远程过程调用：RPC&lt;/h1>
&lt;p>作为程序员我们知道，client 以及 server 之间不会简单传递一串数字以及字符这样简单，尤其在互联网大厂后端服务这种场景下。&lt;/p>
&lt;p>当我们在电商 App 搜索商品、打车 App 呼叫出租车以及刷短视频时，每一次请求的背后在后端都涉及大量服务之间的交互，就像这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/0f716e20-2641-4626-b2ff-1c0675946e8d/640" alt="">&lt;/p>
&lt;p>完成一次客户端请求 gateway 这个服务要调用 N 多个下游服务，所谓调用是说 A 服务向 B 服务发送一段数据（请求），B 服务接收到这段数据后执行相应的函数，并将结果返回给 A 服务。&lt;/p>
&lt;p>只不过对于服务 A 来说并不想关心网络传输这样的底层细节，如果能像调用本地函数一样调用远程服务就好了，这就是所谓的 RPC，经典的实现方式是这样的：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/0f716e20-2641-4626-b2ff-1c0675946e8d/640" alt="">&lt;/p>
&lt;p>RPC 对上层提供和普通函数一样的接口，只不过在实现上封装了底层复杂的网络通信，RPC 框架是当前互联网后端的基石之一，很多所谓互联网后端的职位无非就是在此基础之上堆业务逻辑。&lt;/p>
&lt;p>本文我们不关心其中的细节，这里我们只关心在网络层 client 是怎样对请求参数进行编码、server 怎样对请求参数进行解码的，也就是本文开头提出的问题。&lt;/p>
&lt;h5 id="heading-1">&lt;/h5>
&lt;h1 id="信息的编解码">信息的编解码&lt;/h1>
&lt;p>在思考怎样进行编解码之前我们必须意识到：&lt;/p>
&lt;ul>
&lt;li>client 和 server 可能是用不同语言编写的，你的编解码方案必须通用且不能和语言绑定&lt;/li>
&lt;li>编解码方法的性能问题，尤其是对时间要求苛刻的服务&lt;/li>
&lt;/ul>
&lt;p>首先，我们最应该能想到的就是以纯文本的形式来表示。&lt;/p>
&lt;p>纯文本从来都是一种非常有友好的信息载体，为什么？很简单，因为人类(我们)可以直接看懂，就像这段：&lt;/p>
&lt;pre>&lt;code>{ &amp;quot;widget&amp;quot;: {  &amp;quot;window&amp;quot;: {   &amp;quot;title&amp;quot;: &amp;quot;Sample Konfabulator Widget&amp;quot;,   &amp;quot;name&amp;quot;: &amp;quot;main_window&amp;quot;,   &amp;quot;width&amp;quot;: 500,   &amp;quot;height&amp;quot;: 500  },  &amp;quot;image&amp;quot;: {    &amp;quot;src&amp;quot;: &amp;quot;Images/Sun.png&amp;quot;,   &amp;quot;name&amp;quot;: &amp;quot;sun1&amp;quot;,   &amp;quot;hOffset&amp;quot;: 250,   &amp;quot;vOffset&amp;quot;: 250,  }, }}
&lt;/code>&lt;/pre>
&lt;p>是不是很清晰，一目了然，只要我们实现约定好文本的结构(也就是语法)，那么 client 和 server 就能利用这种文本进行信息的编码以及解码，不管 client 和 server 是运行在 x86 还是 Arm、是 32 位的还是 64 位的、运行在 Linux 上还是 windows 上、是大端还是小端，都可以无障碍交流。&lt;/p>
&lt;p>因此在这里，文本的语法就是一种协议。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/0f716e20-2641-4626-b2ff-1c0675946e8d/640" alt="">
顺便说一句，&lt;strong>你都规定好了文本的语法，实际上就相当于发明了一种语言&lt;/strong>。&lt;/p>
&lt;p>这里用来举例用的语言就是所谓的 Json，只不过 json 这种语言不是用来表示逻辑(代码)而是用来存储数据的。&lt;/p>
&lt;p>Json 就是这个老头提出来的：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/0f716e20-2641-4626-b2ff-1c0675946e8d/640" alt="">&lt;/p>
&lt;p>除了 Json，另一种利用文本存储数据的表示方法是 XML，来一段感受下：&lt;/p>
&lt;pre>&lt;code>&amp;lt;note&amp;gt;&amp;lt;to&amp;gt;Tove&amp;lt;/to&amp;gt;&amp;lt;from&amp;gt;Jani&amp;lt;/from&amp;gt;&amp;lt;heading&amp;gt;Reminder&amp;lt;/heading&amp;gt;&amp;lt;body&amp;gt;Don't forget me this weekend!&amp;lt;/body&amp;gt;&amp;lt;/note&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>相对 Json 来说是不是就没那么容易看懂了，Json 出现后在 web 领域逐渐取代了 XML。&lt;/p>
&lt;p>当两段数据量很少的时候——就像浏览器和服务端的交互，Json 可以工作的非常好，这个场景就是这里：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/0f716e20-2641-4626-b2ff-1c0675946e8d/640" alt="">
在这里是 json 的天下。&lt;/p>
&lt;p>但对于后端服务之间的交互来说就不一样了，后端服务之间的 RPC 调用可能会传输大量数据，如果全部用纯文本的形式来表示数据那么不管是网络带宽还是性能可能都会差强人意。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/0f716e20-2641-4626-b2ff-1c0675946e8d/640" alt="">&lt;/p>
&lt;p>在这种场景下，Json 并不是最好的选项，主要原因之一就在于性能以及数据的体积。&lt;/p>
&lt;p>我们知道，文本表示对人类是最友好的，对机器来说则不是这样，对机器来说最好的还是 01 二进制。&lt;/p>
&lt;p>那么有没有二进制的编码方法吗？答案是肯定的，这就是当前互联网后端中流行的 protobuf，Google 公司开源项目。&lt;/p>
&lt;p>那么 protobuf 有什么神奇之处吗？&lt;/p>
&lt;p>假设 client 端想给 server 端传输这样一段信息：“我有一个 id，其值为 43”，那么在 XML 下是这样表示的：&lt;/p>
&lt;pre>&lt;code>&amp;lt;id&amp;gt;43&amp;lt;/id&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>数一数这这段数据占据了多少字节，很显然是 11 字节；&lt;/p>
&lt;p>而如果用 json 来表示呢？&lt;/p>
&lt;pre>&lt;code>{&amp;quot;id&amp;quot;:43}
&lt;/code>&lt;/pre>
&lt;p>数一数这段数据占据了多少字节，显然是 9 字节；&lt;/p>
&lt;p>而如果用 protobuf 来表示呢? 是这样的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 消息定义
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">Msg&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">optional&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span> id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e">// 实例化
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>Msg msg;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>msg.set_id(&lt;span style="color:#ae81ff">43&lt;/span>);&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 Msg 的定义看上去比 Json 和 XML 更加复杂了，但这些只是给人看的，这些还会被 protbuf 进一步处理，最终被编码为：&lt;/p>
&lt;pre>&lt;code>082b
&lt;/code>&lt;/pre>
&lt;p>也就是 0x08 与 0x2b，这占据了多少字节呢？答案是 2 字节。&lt;/p>
&lt;p>从 json 的 9 字节到 protobuf 的 2 字节，数据大小减少了 4 倍多，数据量的减少意味着：&lt;/p>
&lt;ul>
&lt;li>更少的网络带宽&lt;/li>
&lt;li>更快的解析速度&lt;/li>
&lt;/ul>
&lt;p>那么 protobuf 是怎样做到这一点的呢？&lt;/p>
&lt;h5 id="heading-2">&lt;/h5>
&lt;h1 id="protobuf-是怎样实现的">protobuf 是怎样实现的？&lt;/h1>
&lt;p>首先，我们来思考最简单的情况，该怎样表示数字。&lt;/p>
&lt;p>你可能会想这还不简单，统一用固定长度，比如用 64 个比特(8 字节)，这种方法可行，但问题是不论一个数字有多小，比方 2，那么用这种方法表示 2 也需要占据 64 个比特(8 字节)：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/0f716e20-2641-4626-b2ff-1c0675946e8d/640" alt="">&lt;/p>
&lt;p>明明只要一个字节就能表示而我们却用了 8 个，前面的全都是 0，这也太奢侈太浪费了吧。&lt;/p>
&lt;p>显然，&lt;strong>在这里我们不能使用固定长度来表示数字，而需要使用变长方法来表示。&lt;/strong>&lt;/p>
&lt;p>什么叫变长？意思是说如果数字本身比较大，那么其使用的比特位可以较多，但如果数字很小那么就应该使用较少的比特位来表示，这就叫变长，随机应变，不死板。&lt;/p>
&lt;p>那怎样变长呢？&lt;/p>
&lt;p>我们规定：对于每一个字节来说，&lt;strong>第一个比特位如果是 1 那么表示接下来的一个比特依然要用来解释为一个数字，如果第一个比特为 0，那么说明接下来的一个字节不是用来表示该数字的。&lt;/strong>&lt;/p>
&lt;p>也就是说对于每个 8 个比特(1 字节)来说，它的有效载荷是 7 个比特，第一个比特仅仅用来标记是否还应该把接下来的一个字节解析为数字。&lt;/p>
&lt;p>根据这个规定假设来了这样一串 01 二进制：&lt;/p>
&lt;pre>&lt;code>1010110000000010
&lt;/code>&lt;/pre>
&lt;p>根据规定，我们首先取出第一个字节，也就是：&lt;/p>
&lt;pre>&lt;code>10101100
&lt;/code>&lt;/pre>
&lt;p>此时我们发现第一个比特位是 1，因此我们知道接下来的一个字节也属于该数字，将当前字节的 1 去掉就是：&lt;/p>
&lt;pre>&lt;code>0101100
&lt;/code>&lt;/pre>
&lt;p>然后我们看下一个字节：&lt;/p>
&lt;pre>&lt;code>00000010
&lt;/code>&lt;/pre>
&lt;p>我们发现第一个 bit 为 0，因此我们知道下一个字节不属于该数字了。&lt;/p>
&lt;p>接下来我们将解析到的 0101100(第一个字节去掉第一个比特位)以及第二个字节 0000010(第二个字节去掉第一个比特位)翻转之后拼接到一起，这里之所以翻转是因为我们规定数字的高位在后。&lt;/p>
&lt;p>这个过程就是：&lt;/p>
&lt;pre>&lt;code> 1010110000000010
-&amp;gt; 10101100 | 00000010 // 解析得到两个字节
_ _
-&amp;gt; 0101100 | 0000010 // 各自去掉最高位
-&amp;gt; 0000010 | 0101100 // 两个字节翻转顺序
0000010 + 0101100
-&amp;gt; 100101100 // 拼接
&lt;/code>&lt;/pre>
&lt;p>最后我们得到了 100101100，这一串二进制表示数字 300。&lt;/p>
&lt;p>这种数字的变长表示方法在 protobuf 中被称之为 varint。&lt;/p>
&lt;p>因此在这种表示方法下，如果数字较大，那么使用的比特就多，如果数字较小那么使用比特就少，聪明吧。&lt;/p>
&lt;p>有的同学看到这里可能会问题，刚才讲解的方法只能表示无符号数字，那么有符号数字该怎么表示呢？比如-2 该怎么表示？&lt;/p>
&lt;h5 id="heading-3">&lt;/h5>
&lt;h1 id="有符号数的表示">有符号数的表示&lt;/h1>
&lt;p>按照刚才变长编码的思想，-2147483646 使用的比特位应该比-2 要少。&lt;/p>
&lt;p>然而我们知道在计算机世界中负数使用补码表示的，也就是说最高位(最左侧的比特位)一定是 1，假设我们使用 64 位来表示数字，那么如果我们依然用补码来表示数字的话那么无论这个负数有多大还是多小都需要占据 10 个字节的空间。&lt;/p>
&lt;p>为什么是 10 个字节呢？&lt;/p>
&lt;p>不要忘了 varint 每个字节的有效负荷是 7 个比特，那么对于需要 64 位表示的数字来说就需要 64/7 向上取整也就是 10 个字节来表示。&lt;/p>
&lt;p>这显然不能满足我们对数字变长存储的要求。&lt;/p>
&lt;p>该怎么解决这个问题呢？&lt;/p>
&lt;p>&lt;strong>既然无符号数字可以方便的进行变长编码，那么我们将有符号数字映射称为无符号数字不就可以了&lt;/strong>，这就是所谓的 ZigZag 编码，是不是很聪明，就像这样：&lt;/p>
&lt;pre>&lt;code>原始信息 编码后
0 0
-1 1
1 2
-2 3
2 4
-3 5
3 6
... ...
2147483647 4294967294
-2147483648 4294967295
&lt;/code>&lt;/pre>
&lt;p>这样我们就可以将有符号数字转为无符号数字，接收方接收到该数据后再恢复出有符号数字。&lt;/p>
&lt;p>现在数字的问题彻底解决了，但这仅仅是万里长征第一步。&lt;/p>
&lt;h1 id="字段名称与字段类型">字段名称与字段类型&lt;/h1>
&lt;p>对于任何一个有用的信息都包含这样几部分：&lt;/p>
&lt;ul>
&lt;li>字段名称&lt;/li>
&lt;li>字段类型&lt;/li>
&lt;li>字段值&lt;/li>
&lt;/ul>
&lt;p>就像 C/C++中定义变量时：&lt;/p>
&lt;pre>&lt;code>int i = 100;
&lt;/code>&lt;/pre>
&lt;p>在这里，字段名称就是 i，字段类型是 int，字段值是 100。&lt;/p>
&lt;p>刚才我们用 varint 以及 ZigZag 编码解决了字段值表示的问题，那么该怎样表示字段名称和字段类型呢？&lt;/p>
&lt;p>首先，对于字段类型还比较简单，因为字段类型就那么多，protobuf 中定义了 6 种字段类型：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/0f716e20-2641-4626-b2ff-1c0675946e8d/640" alt="">&lt;/p>
&lt;p>对于 6 种字段类型我们使用 3 个比特位来表示就足够了。&lt;/p>
&lt;p>接下来比较有趣的是字段名称该怎么表示呢？假设我们需要传递这样一个字段：&lt;/p>
&lt;pre>&lt;code>int long_long_name = 100;
&lt;/code>&lt;/pre>
&lt;p>那么我们真的需要把“long_long_name”这么多字符通过网络传递给对端吗？&lt;/p>
&lt;p>既然通信双方需要协议，那么“long_long_name”这字段其实是 client 和 server 都知道的，它们唯一不知道的就是“&lt;strong>哪些值属于哪些字段&lt;/strong>”。&lt;/p>
&lt;p>为解决这个问题，&lt;strong>我们给每个字段都进行编号&lt;/strong>，比如通信双方都知道“long_long_name”这个字段的编号是 2，那么对于：&lt;/p>
&lt;pre>&lt;code>int long_long_name = 100;
&lt;/code>&lt;/pre>
&lt;p>这个信息我们只需要传递：&lt;/p>
&lt;ul>
&lt;li>字段名称：2 (2 对应字段“long_long_name”)&lt;/li>
&lt;li>字段类型：0 (0 表示 varint 类型，参见上图)&lt;/li>
&lt;li>字段值：100&lt;/li>
&lt;/ul>
&lt;p>所以我们可以看到，**无论你用多么复杂的字段名称也不会影响编码后占据的空间，字段名称根本就不会出现在编码后的信息中，**so clever。&lt;/p>
&lt;h5 id="heading-4">&lt;/h5>
&lt;h1 id="从宏观上看">从宏观上看&lt;/h1>
&lt;p>我们已经在 protobuf 中看到了数字以及字段名称以及字段类型是怎么表示了，现在是时候从宏观角度来看看多个字段该怎么编码了。&lt;/p>
&lt;p>从本质上讲，protobuf 被编码后形成一系列的 key-value，每个 key-value 对应一个 proto 中的字段。&lt;/p>
&lt;p>也就是键值对：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/0f716e20-2641-4626-b2ff-1c0675946e8d/640" alt="">&lt;/p>
&lt;p>其中 value 比较简单，也就是字段值；而字段名称和字段类型会被拼接成 key，protobuf 中共有 6 种类型，因此只需要 3 个比特位即可；字段名称只需要存储对应的编号，这样可以就可以这样编码：&lt;/p>
&lt;pre>&lt;code>(字段编号 &amp;lt;&amp;lt; 3) | 字段类型
&lt;/code>&lt;/pre>
&lt;p>假设 server 接收到了一个 key 为 0x08，其二进制的表示为：&lt;/p>
&lt;pre>&lt;code>0000 1000
&lt;/code>&lt;/pre>
&lt;p>由于 key 也是利用 varint 编码的，因此需要将第一个比特位去掉，这样我的得到：&lt;/p>
&lt;pre>&lt;code>000 1000
&lt;/code>&lt;/pre>
&lt;p>根据 key 的编码方式，其后三个比特位表示字段类型，即：&lt;/p>
&lt;pre>&lt;code>000
&lt;/code>&lt;/pre>
&lt;p>也就是 0，这样我们知道该 key 的类型是 Varint(第 0 号类型)，而字段编号为抹掉后 3 个比特位的值，即：&lt;/p>
&lt;pre>&lt;code>0001
&lt;/code>&lt;/pre>
&lt;p>这样，我们就知道了该 key 对应的字段编号为 1，得到编号我们就能根据编号找到对应的编号名称。&lt;/p>
&lt;h5 id="heading-5">&lt;/h5>
&lt;h1 id="嵌套数据">嵌套数据&lt;/h1>
&lt;p>与 Json 和 XML 类似，protobuf 中也支持嵌套消息，就像这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">SubMsg&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">optional&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span> id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">Msg&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">optional&lt;/span> SubMsg msg &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其实现也比较简单，这依然遵循被编码后形成一系列的 key-value，只不过对于嵌套类型的 key 来说，其 value 是由子消息的 key-value 组成。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/0f716e20-2641-4626-b2ff-1c0675946e8d/640" alt="">&lt;/p>
&lt;h5 id="heading-6">&lt;/h5>
&lt;h1 id="protobuf-与编译语言">protobuf 与编译语言&lt;/h1>
&lt;p>与 Json 一样，protobuf 也是一门语言，兼具了文本的可读性以及二进制的高效。&lt;/p>
&lt;p>protobuf 之所以能做到这一点就好比 C 语言与机器指令。&lt;/p>
&lt;p>C 语言是给程序员看的，可读性好，而机器指令是给硬件使用的，性能好，编译器会将 C 语言程序转为机器可执行的机器指令。&lt;/p>
&lt;p>&lt;strong>而 protobuf 也一样，protobuf 也是一门语言，会将可读性较好的消息编码为二进制从而可以在网络中进行传播，而对端也可以将其解码回来。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>在这里 protobuf 中定义的消息就好比 C 语言，编码后的二进制消息就好比机器指令。&lt;/strong>&lt;/p>
&lt;p>而 protobuf 作为事实上语言必然有自己的语法，其语法就是这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/0f716e20-2641-4626-b2ff-1c0675946e8d/640" alt="">&lt;/p>
&lt;p>怎么样，还觉得编译原理没什么用吗？&lt;/p>
&lt;p>不理解编译原理是不可能发明 protobuf 这种技术的。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>我在写这篇文章时不断感叹，Google 的这项技术节省了多少程序员的时间，同时我们也能看到这种基石般的技术依赖的底层原理却非常古老：&lt;/p>
&lt;ul>
&lt;li>信息的编解码&lt;/li>
&lt;li>编译原理&lt;/li>
&lt;/ul>
&lt;p>怎么样，这些是不是远远没有 IT 界各种流行的技术听上去时髦有趣，而正是这种朴素的技术支撑起了工业界，现在你也应该能明白底层技术的重要性了吧。&lt;/p></description></item><item><title>Docs: TOML</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/toml/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/toml/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/toml-lang/toml">GitHub 项目&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://toml.io/en/latest">官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/TOML">Wiki,TOML&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/50412485">知乎&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cnblogs.com/sunsky303/p/9208848.html">格式对比&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Tom&amp;rsquo;s Obvious, Minimal Language(简称 TOML)&lt;/strong> 是一种配置语言，旨在称为一种最小的配置文件结构，并且易于阅读、具有显而易见的语义。&lt;/p>
&lt;h2 id="toml-规范">TOML 规范&lt;/h2>
&lt;ul>
&lt;li>TOML 大小写敏感&lt;/li>
&lt;li>TOML 必须是有效的 UTF-8 编码的 Unicode 文档&lt;/li>
&lt;li>空白表示 Tab(0x09) 或 空格(0x20)&lt;/li>
&lt;li>换行表示 LF(0x0a) 或 CRLF(0x0D 0x0A)&lt;/li>
&lt;/ul>
&lt;h2 id="toml-特点">TOML 特点&lt;/h2>
&lt;p>TOML 的原子单位也是 &lt;strong>Key/Value pair(键值对)&lt;/strong>。多个 Key/Value pair 组成一个 Table(表)。&lt;/p>
&lt;p>所以，一个 TOML 格式的配置文件，本质上是 &lt;strong>Table(表)&lt;/strong> 的集合。&lt;/p>
&lt;p>TOML 放弃了括号或缩进的底层原理，而是以 &lt;code>.&lt;/code> 符号来表示层级关系(实现类似缩进的效果)&lt;/p>
&lt;h2 id="toml-基本示例">TOML 基本示例&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># This is a TOML document.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">title = &amp;#34;TOML Example&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">owner]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">name = &amp;#34;Tom Preston-Werner&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">dob = 1979-05-27T07:32:00-08:00&lt;/span> &lt;span style="color:#75715e"># First class dates&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">database]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">server = &amp;#34;192.168.1.1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">ports = [ 8000, 8001, 8002 ]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">connection_max = 5000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">enabled = true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">servers]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 可以使用缩进让结构更清晰，但是并不是必须要缩进的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">servers.alpha]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">ip = &amp;#34;10.0.0.1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">dc = &amp;#34;eqdc10&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">servers.beta]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">ip = &amp;#34;10.0.0.2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">dc = &amp;#34;eqdc10&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">clients]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">data = [ [&amp;#34;gamma&amp;#34;, &amp;#34;delta&amp;#34;], [1, 2] ]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 在数组内部，是可以使用换行符的，主要是为了方便人类阅读&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">hosts = [&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;alpha&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;omega&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="转换成-json-后是这样的">转换成 JSON 后是这样的&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;title&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;TOML Example&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;owner&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Tom Preston-Werner&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;dob&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;date&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1979-05-27 07:32:00&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;timezone_type&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;timezone&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;-08:00&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;database&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;server&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;192.168.1.1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;ports&amp;#34;&lt;/span>: [&lt;span style="color:#ae81ff">8000&lt;/span>, &lt;span style="color:#ae81ff">8001&lt;/span>, &lt;span style="color:#ae81ff">8002&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;connection_max&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">5000&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;enabled&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;servers&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;alpha&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;ip&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;10.0.0.1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;dc&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;eqdc10&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;beta&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;ip&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;10.0.0.2&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;dc&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;eqdc10&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;clients&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;data&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#e6db74">&amp;#34;gamma&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;delta&amp;#34;&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;hosts&amp;#34;&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;alpha&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;omega&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="toml-与-inijsonyaml-的对比">TOML 与 INI、JSON、YAML 的对比&lt;/h2>
&lt;p>配置文件是一种非常基础的文件格式，但远没有数据文件格式（如 &lt;code>SQLite&lt;/code>）、文档文件格式（如 &lt;code>Markdown&lt;/code>）、编程语言（如 &lt;code>JavaScript&lt;/code>）、甚至二进制文件格式（如 &lt;code>PNG&lt;/code>）需求那么复杂。
　　只要严谨但不严苛、支持必要的数据类型和嵌套，又易于人类手工直接阅读和编辑就可以了。
　　但就是这样一种广泛需要而又简单的应用场景，却反而长期以来一直没有一种足够好的文件格式。&lt;/p>
&lt;hr>
&lt;p>INI（&lt;code>.ini&lt;/code>）文件是一种非常原始的基础形式，但各家有各家的用法，而且它最多只能解决一层嵌套。只适合非常非常简单的配置文件，一旦需要两层嵌套，或需要数组，就力不从心了。&lt;/p>
&lt;pre>&lt;code>; 最简单的结构
a = a;
b = b; 这些等号后面的值是字符串（句末分号不是必须的；它后面的都是注释）
; 稍微复杂一点的单层嵌套结构
[c]
x = c.x
y = c.y
[d]
x = d.x
y = d.y
&lt;/code>&lt;/pre>
&lt;hr>
&lt;p>JSON（&lt;code>.json&lt;/code>）是一种非常好的数据存放和传输的格式，但阅读和编辑它实在不方便。即便 &lt;code>JSON5&lt;/code>（&lt;code>.json5&lt;/code> - &lt;code>ECMAScript 5.1 JSON&lt;/code>）这种扩展格式允许了你像写 &lt;code>JavaScript&lt;/code> 对象那样书写裸键名、允许尾逗号，并且可以有注释，写多行字符串依然麻烦。即便它将来加上了多行字符串语法，依然不行，因为它虽然是基于括号嵌套语法的层级关系，在不缩进的情况下，却根本没法阅读。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;a&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;b&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;b&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;c&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;x&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;c.x&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;y&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;c.y&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;d&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;x&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;d.x&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;y&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;d.y&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;e&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { &lt;span style="color:#f92672">&amp;#34;x&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;e[0].x&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;y&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;e[0].y&amp;#34;&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { &lt;span style="color:#f92672">&amp;#34;x&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;e[1].x&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;y&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;e[1].y&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;p>YAML（&lt;code>.yaml&lt;/code> 或 &lt;code>.yml&lt;/code>）干脆将 &lt;code>JSON&lt;/code> 中有了不够、没有不行的括号结构去掉了，只保留缩进。但编辑和阅读它总令人非常慌张，生怕数错了层次（实际上，对于阅读，语法关键字并不是越小越好）。而且在不支持统一缩进、反缩进、自动在换行时缩进的编辑环境下，这非常麻烦——这本来对编程语言来说不是什么事，但配置文件最常用的使用场景却恰恰是这样。
　　另外，&lt;code>YAML&lt;/code> 的语法实在太多了，而且不是循序渐进的，即便你不需要复杂的功能，为了保证自己的简单功能不出错，也要对那些复杂的语法有所了解并加以避免（比如究竟什么键名可以不加引号，什么字符串可以不加引号；你总不能为了避免歧义全都加上引号，那和 &lt;code>JSON&lt;/code> 也就差球不多了）。更糟的是，纵使如此复杂，想要配置一段精确的多行字符串（精确控制首尾空行数）时，却显得力不从心。再加上缩进问题，编辑多行文本实在烦不胜烦。如果你还需要转义字符……&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">a1&lt;/span>: &lt;span style="color:#ae81ff">abc&lt;/span> &lt;span style="color:#75715e"># string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">a2&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span> &lt;span style="color:#75715e"># boolean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">b1&lt;/span>: &lt;span style="color:#ae81ff">nil&lt;/span> &lt;span style="color:#75715e"># string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">b2&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#75715e"># null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">b3&lt;/span>: &lt;span style="color:#ae81ff">NULL&lt;/span> &lt;span style="color:#75715e"># null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">b4&lt;/span>: &lt;span style="color:#ae81ff">NuLL&lt;/span> &lt;span style="color:#75715e"># string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">b5&lt;/span>: &lt;span style="color:#ae81ff">Null&lt;/span> &lt;span style="color:#75715e"># null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">c&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">x&lt;/span>: &lt;span style="color:#ae81ff">c.x&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">y&lt;/span>: &lt;span style="color:#ae81ff">c.y&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">d&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">x&lt;/span>: &lt;span style="color:#ae81ff">d.x&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">y&lt;/span>: &lt;span style="color:#ae81ff">d.y&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">e&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">x&lt;/span>: &lt;span style="color:#ae81ff">e[0].x&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">y&lt;/span>: &lt;span style="color:#ae81ff">e[0].y&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">x&lt;/span>: &lt;span style="color:#ae81ff">e[1].x&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">y&lt;/span>: &lt;span style="color:#ae81ff">e[1].y&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;p>终于，TOML（&lt;code>.toml&lt;/code>）横空出世。它彻底放弃了括号或缩进的底层原理，而是采取了显式键名链的方式。
　　为了方便（同时看起来更清楚——这种读和写的契合非常关键！），你可以指定小节名。妙的是，小节名也是可以链式声明的。
　　另外，某些数据可能使用内联数组或表更合适以避免臃肿，这也是支持的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">a = &amp;#34;a&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">b = &amp;#34;b&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">c.x = &amp;#34;c.x&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">c.y = &amp;#34;c.y&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">d]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">x = &amp;#34;d.x&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">y&lt;/span> &lt;span style="color:#ae81ff">= &amp;#34;d.y&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[[&lt;span style="color:#ae81ff">e]]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">x = &amp;#34;e[0].x&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">y&lt;/span> &lt;span style="color:#ae81ff">= &amp;#34;e[0].y&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[[&lt;span style="color:#ae81ff">e]]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">x = &amp;#34;e[1].x&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">y&lt;/span> &lt;span style="color:#ae81ff">= &amp;#34;e[1].y&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">f.A]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">x.y = &amp;#34;f.A.x.y&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">f.B]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">x.y = &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">f.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">B.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">x.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">y&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">f.C]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">points = [&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{ &lt;span style="color:#ae81ff">x=1, y=1, z=0 },&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{ &lt;span style="color:#ae81ff">x=2, y=4, z=0 },&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{ &lt;span style="color:#ae81ff">x=3, y=9, z=0 },&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="toml-原语">TOML 原语&lt;/h1>
&lt;h2 id="keyvalue-pair键值对">Key/Value pair(键/值对)&lt;/h2>
&lt;p>TOML 文档的主要结构也是 &lt;code>Key/Value pair(键/值对)&lt;/code> 格式。key 与 value 以 &lt;code>=&lt;/code> 符号分割&lt;/p>
&lt;h3 id="array数组">Array(数组)&lt;/h3>
&lt;h2 id="table表">Table(表)&lt;/h2>
&lt;blockquote>
&lt;p>类似于 INI 中的 Sections(部分)&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Table(表)&lt;/strong> 是 &lt;code>键值对&lt;/code> 的集合，也称为 Hash Tables(哈希表) 或 Dictionaries(字典)，以 &lt;code>[]&lt;/code> 符号表示。从 Table 的 &lt;code>[]&lt;/code> 符号开始到下一个 &lt;code>[]&lt;/code> 符号为止，所有键值对都属于该 Table。&lt;/p>
&lt;p>Table 的名称则用 &lt;code>[]&lt;/code> 符号内的字符串表示。Table 的命名规则与 Key 的命名规则相同，同样是可以使用 &lt;code>.&lt;/code> 符号来表示 Table 与 Table 之间的层级关系。&lt;/p>
&lt;p>配置文件的开头没有任何 &lt;code>[]&lt;/code> 表示的部分，也称为 &lt;strong>root Table(根表)&lt;/strong>。根表不用 [] 符号，也就没有名称，所有&lt;strong>属于根表的 Key/Value pair 都只能写在文件开头&lt;/strong>。&lt;/p>
&lt;h3 id="示例">示例&lt;/h3>
&lt;pre>&lt;code>[table-1]
key1 = &amp;quot;some string&amp;quot;
key2 = 123
[table-2]
key1 = &amp;quot;another string&amp;quot;
key2 = 456
&lt;/code>&lt;/pre>
&lt;p>转为 JSON：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;table-1&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;key1&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;some string&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;key2&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">123&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;table-2&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;key1&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;another string&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;key2&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">456&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>[dog.&amp;quot;tater.man&amp;quot;]
type.name = &amp;quot;pug&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>转为 JSON：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{ &lt;span style="color:#f92672">&amp;#34;dog&amp;#34;&lt;/span>: { &lt;span style="color:#f92672">&amp;#34;tater.man&amp;#34;&lt;/span>: { &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: { &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;pug&amp;#34;&lt;/span> } } } }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="inline-tables内联表">Inline Tables(内联表)&lt;/h3>
&lt;p>比如：&lt;/p>
&lt;pre>&lt;code>name = { first = &amp;quot;Tom&amp;quot;, last = &amp;quot;Preston-Werner&amp;quot; }
point = { x = 1, y = 2 }
animal = { type.name = &amp;quot;pug&amp;quot; }
&lt;/code>&lt;/pre>
&lt;p>表示：&lt;/p>
&lt;pre>&lt;code>[name]
first = &amp;quot;Tom&amp;quot;
last = &amp;quot;Preston-Werner&amp;quot;
[point]
x = 1
y = 2
[animal]
type.name = &amp;quot;pug&amp;quot;
&lt;/code>&lt;/pre>
&lt;h3 id="array-of-tables表的数组">Array of Tables(表的数组)&lt;/h3>
&lt;p>Table 的数组使用 &lt;code>[[]]&lt;/code> 符号表示。
比如，下面的配置：&lt;/p>
&lt;pre>&lt;code>[[products]]
name = &amp;quot;Hammer&amp;quot;
sku = 738594937
[[products]] # empty table within the array
[[products]]
name = &amp;quot;Nail&amp;quot;
sku = 284758393
color = &amp;quot;gray&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>转换为 JSON 为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;products&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Hammer&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;sku&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">738594937&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Nail&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;#34;sku&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">284758393&lt;/span>, &lt;span style="color:#f92672">&amp;#34;color&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;gray&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="总结">总结&lt;/h1>
&lt;p>从某种成都上来说，TOML 也可以使用类似系统中的路径格式来表示，不管是 Table 还是 &lt;code>.&lt;/code> 符号，这些原语组合成一个 Key 并确定唯一一个值，非常像 Kubernetes 在 Etcd 中存储的数据格式。
比如前文的&lt;a href="https://desistdaydream.github.io/docs/IT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/TOML.md">基本示例&lt;/a>中的所有 Key，可以看成下面这个样子：&lt;/p>
&lt;pre>&lt;code>/title
/owner/name
/owner/dob
/database/server
/database/ports
/database/connection_max
/database/enabled
/servers/alpha/ip
/servers/alpha/dc
/servers/beta/ip
/servers/beta/dc
/clients/data
/clients/hosts
&lt;/code>&lt;/pre></description></item><item><title>Docs: YAML</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/yaml/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/yaml/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://yaml.org/spec/1.2.2/">官方文档，规范 v1.2.2&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/YAML">Wiki,YAML&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>编程免不了要写配置文件，怎么写配置也是一门学问。&lt;/p>
&lt;p>YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便&lt;/p>
&lt;p>&lt;strong>YAML Ain&amp;rsquo;t Markup Language(简称 YAML)&lt;/strong> 是一种数据序列化语言。设计目标就是方便人类读写，并且可以在日常工作中与现代编程语言很好的配合。它实质上是一种通用的数据串行化格式。&lt;/p>
&lt;h2 id="yaml-与-json-的关系">YAML 与 JSON 的关系&lt;/h2>
&lt;p>JSON 和 YAML 都旨在成为人类可读的数据交换格式。但是，JSON 和 YAML 具有不同的优先级。 JSON 的首要设计目标是简单性和通用性。因此，JSON 的生成和解析非常简单，但代价是人类可读性降低。它还使用最低公分母信息模型，以确保所有现代编程环境都可以轻松处理任何 JSON 数据。&lt;/p>
&lt;p>相反，YAML 的首要设计目标是人类可读性并支持序列化任意本机数据结构。因此，YAML 允许可读性极强的文件，但生成和解析起来更复杂。此外，YAML 的业务范围超越了最低公分母数据类型，因此在不同的编程环境之间进行转换时，需要进行更复杂的处理。&lt;/p>
&lt;p>因此，YAML 可以看作是 JSON 的自然超集，可以提高人类可读性和更完整的信息模型。实际上也是这种情况；每个 JSON 文件也是一个有效的 YAML 文件，JSON 与 YAML 格式可以轻松得互相转换&lt;/p>
&lt;p>并且，YAML 格式也可以转换为别的格式&lt;/p>
&lt;h1 id="yaml-基本语法规则">YAML 基本语法规则&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>大小写敏感&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用缩进表示层级关系&lt;/p>
&lt;ul>
&lt;li>缩进时不允许使用 Tab 键，只允许使用空格。&lt;/li>
&lt;li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h1 id="表示注释从这个字符一直到行尾都会被解析器忽略">表示注释，从这个字符一直到行尾，都会被解析器忽略&lt;/h1>
&lt;/li>
&lt;/ul>
&lt;h1 id="data-structures数据结构">Data Structures(数据结构)&lt;/h1>
&lt;p>YAML 由多个 &lt;strong>Node(节点)&lt;/strong> 组成，每个 Node 都可以是三种 &lt;strong>Native Data Structures(原生数据结构)&lt;/strong> 其中之一：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>scalars(标量)&lt;/strong># 单个的、不可再分的值，又称为 Strings(字符串)、Numbers(数字)&lt;/li>
&lt;li>&lt;strong>mappings(映射)&lt;/strong> # 键值对的集合，又称为哈希(hashes)、字典(dictionarys)。转为 json 后使用&lt;code>{ }&lt;/code>符号包围。
&lt;ul>
&lt;li>使用冒号和空格&lt;code>:&lt;/code>分隔每个键值对&lt;/li>
&lt;li>映射使用键值的方式表示一个数据(比如“名字: 李辰昊”，“名字”是一个数据名，“李辰昊”是该数据的值)&lt;/li>
&lt;li>映射的一组键值对使用冒号结构表示，并且冒号后面需要跟一个空格，否则该行代码无效&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>sequences(序列)&lt;/strong> # 一组按次序排列的值，又称为数组(arrays)、列表(lists)。转为 json 后使用&lt;code>[ ]&lt;/code>符号包围。对于序列，人们更多得使用数组来称呼这种原语
&lt;ul>
&lt;li>使用 &lt;code>-&lt;/code>(波折号和空格) 来表示数组中的每个元素。&lt;/li>
&lt;li>如果一个对象要定义多个，那么该对象的子对象的第一个前面要加-，比如：如果要定义多个 container 字段，这个 container 包括 name，image，ports 等子字段，那么就需要在 container 对象下一行添加一个-，这样，每个-至下一个-中间的内容表示一个 container 的各种规格，第二个-至第三个-中间表示第二个 container 的各种规则&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>上述三种类型的 Node 又可以互相组合并形成复合结构：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Object(对象)&lt;/strong>。# 由 mappings 组合成的一种复杂结构，官方文档描述为 &lt;strong>Mapping of Mappings&lt;/strong>(意味在一个 mapping 中有多个 Maapings)。
&lt;ul>
&lt;li>在某些说明文档中，会看到 &lt;code>[]Object&lt;/code> 符号，这表示，这个字段下的子字段，是序列和映射的组合体，不是单一的数据结构。[]Object 分开看，就是 [] 与 Object，而 Object 是用 {} 表示。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>这些概念，与各种编程语言中的数组、映射概念相同。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/actt7h/1670853760782-b2b178b4-bfcf-42bb-b7df-e6827a16233a.svg" alt="">&lt;/p>
&lt;h2 id="node">Node&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://yaml.org/spec/1.2.2/#3211-nodes">官方规范，Nodes&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>其实本人更喜欢将 Node 称为 Field(字段)&lt;del>&lt;del>囧&lt;/del>&lt;/del>~&lt;/strong>&lt;/p>
&lt;h3 id="scalar标量">Scalar(标量)&lt;/h3>
&lt;p>YAML 中标量通常不能独自存在，一般都会在 Mapping 或 Sequence 中作为其中的一部分。&lt;/p>
&lt;h3 id="mapping映射">Mapping(映射)&lt;/h3>
&lt;p>&lt;strong>map[STRING]STRING&lt;/strong> # Mapping(映射) 标识符。表示多个键/值对。键 和 值 的数据类型都是 STRING。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">key1&lt;/span>: &lt;span style="color:#ae81ff">value1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">key2&lt;/span>: &lt;span style="color:#ae81ff">value2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="sequence序列">Sequence(序列)&lt;/h3>
&lt;p>&lt;strong>[]TYPE&lt;/strong> # Sequences(序列) 标识符。表示该字段由数组组成，数组元素类型为 TYPE，比如 &lt;code>[]STRING&lt;/code> 格式应该就是下面这样&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#ae81ff">deletecr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- --&lt;span style="color:#ae81ff">ns&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- --&lt;span style="color:#ae81ff">name&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>TYPE 也可以是有多种类型，比如 sequence of scalars and mappings(序列中包含标量和映射)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#e6db74">&amp;#34;10.0.0.15/24&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">lifetime&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">label&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;maas&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="复合-node">复合 Node&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>OBJECT&lt;/strong># Object(对象) 标识符。表示复合结构的 map。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">resources&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">limits&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">cpu&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">memory&lt;/span>: &lt;span style="color:#ae81ff">2Gi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">requests&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">cpu&lt;/span>: &lt;span style="color:#ae81ff">500m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">memory&lt;/span>: &lt;span style="color:#ae81ff">400Mi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>[]OBJECT&lt;/strong># 表示该字段由数组组成，并且数组中的元素都是一个 OBJECT，比如格式应该像下面这样&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">containers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">args&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">AAA&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">BBB&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">XXX&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">XXX&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">YYY&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">YYY&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="yaml-示例">YAML 示例&lt;/h1>
&lt;p>这是一个关于发票信息的配置信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">invoice&lt;/span>: &lt;span style="color:#ae81ff">34843&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">date&lt;/span>: &lt;span style="color:#e6db74">2001-01-23&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">bill-to&lt;/span>: &lt;span style="color:#75715e">&amp;amp;id001&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">given&lt;/span>: &lt;span style="color:#ae81ff">Chris&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">family&lt;/span>: &lt;span style="color:#ae81ff">Dumars&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">address&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">lines&lt;/span>: |&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> 458 Walkman Dr.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> Suite #292&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">city&lt;/span>: &lt;span style="color:#ae81ff">Royal Oak&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">state&lt;/span>: &lt;span style="color:#ae81ff">MI&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">postal&lt;/span>: &lt;span style="color:#ae81ff">48046&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">ship-to&lt;/span>: &lt;span style="color:#75715e">*id001&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">product&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">sku&lt;/span>: &lt;span style="color:#ae81ff">BL394D&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">quantity&lt;/span>: &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#ae81ff">Basketball&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">price&lt;/span>: &lt;span style="color:#ae81ff">450.00&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">sku&lt;/span>: &lt;span style="color:#ae81ff">BL4438H&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">quantity&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#ae81ff">Super Hoop&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">price&lt;/span>: &lt;span style="color:#ae81ff">2392.00&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">tax&lt;/span>: &lt;span style="color:#ae81ff">251.42&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">total&lt;/span>: &lt;span style="color:#ae81ff">4443.52&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">comments&lt;/span>: &lt;span style="color:#ae81ff">Late afternoon is best.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">Backup contact is Nancy&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">Billsmer @ 338-4338.&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是一个日志信息的基本示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">Time&lt;/span>: &lt;span style="color:#e6db74">2001-11-23 15:01:42 -5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">User&lt;/span>: &lt;span style="color:#ae81ff">ed&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">Warning&lt;/span>: &lt;span style="color:#ae81ff">This is an error message&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">for the log file&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">Time&lt;/span>: &lt;span style="color:#e6db74">2001-11-23 15:02:31 -5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">User&lt;/span>: &lt;span style="color:#ae81ff">ed&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">Warning&lt;/span>: &lt;span style="color:#ae81ff">A slightly different error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">message.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">Date&lt;/span>: &lt;span style="color:#e6db74">2001-11-23 15:03:17 -5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">User&lt;/span>: &lt;span style="color:#ae81ff">ed&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">Fatal&lt;/span>: &lt;span style="color:#ae81ff">Unknown variable &amp;#34;bar&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">Stack&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">file&lt;/span>: &lt;span style="color:#ae81ff">TopClass.py&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">line&lt;/span>: &lt;span style="color:#ae81ff">23&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">code&lt;/span>: |&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> x = MoreObject(&amp;#34;345\n&amp;#34;)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">file&lt;/span>: &lt;span style="color:#ae81ff">MoreClass.py&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">line&lt;/span>: &lt;span style="color:#ae81ff">58&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">code&lt;/span>: |-&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> foo = bar&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="yaml-与-json-数据格式对比">YAML 与 JSON 数据格式对比&lt;/h1>
&lt;p>yaml 有两种格式&lt;/p>
&lt;ul>
&lt;li>Document 格式 yaml 数据。也称为 格式化之后的数据、人类可读类数据 等等
&lt;ul>
&lt;li>一般作为书面人类可读的格式使用，通过缩进、- 符号来规范格式。一般有多行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>非 Document 格式 yaml 数据。也称为 格式化之前的数据、人类不可读数据 等等。这种格式与 JSON 格式基本一致
&lt;ul>
&lt;li>一般用于在代码中传值使用，使用 {} 和 [] 之类的符号来规范格式。一般只有一行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="映射">映射&lt;/h2>
&lt;p>映射的一组键值对，使用冒号结构表示&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">key&lt;/span>: &lt;span style="color:#ae81ff">value&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>转为 JSON 如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{ &lt;span style="color:#f92672">&amp;#34;key&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;value&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="对象映射的复合结构">对象(映射的复合结构)&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">object&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Steve&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">foo&lt;/span>: &lt;span style="color:#ae81ff">bar&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>转为 JSON 如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#f92672">&amp;#34;object&amp;#34;&lt;/span>:{&lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;Steve&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;#34;foo&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;bar&amp;#34;&lt;/span>}}{&lt;span style="color:#960050;background-color:#1e0010">object:&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">{&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">name:&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;#39;Steve&amp;#39;,&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">foo:&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;#39;bar&amp;#39;&lt;/span> } &lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="注意">注意&lt;/h3>
&lt;p>映射下不可以有子字段，比如下面这种结构是错误的写法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">key&lt;/span>: &lt;span style="color:#ae81ff">value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">keyerror&lt;/span>: &lt;span style="color:#ae81ff">valueerror&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="数组">数组&lt;/h2>
&lt;p>一组连词线开头的行，构成一个数组。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#ae81ff">A&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#ae81ff">B&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#ae81ff">C&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>转为 JSON 如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- - &lt;span style="color:#ae81ff">A&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">B&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">C&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>转为 JSON 如下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>[[&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>]]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>数组也可以采用行内表示法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">A&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">B&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">C&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>转为 JSON 如下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{ &lt;span style="color:#f92672">&amp;#34;A&amp;#34;&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>] }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="映射与数组得复合结构">映射与数组得复合结构&lt;/h3>
&lt;p>映射和数组可以结合使用，形成复合结构。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">languages&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">Ruby&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#ae81ff">unknown&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">XXX&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">Perl&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">Python&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#ae81ff">Scripts Programming&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">scripts&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">websites&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">YAML&lt;/span>: &lt;span style="color:#ae81ff">yaml.org&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">Ruby&lt;/span>: &lt;span style="color:#ae81ff">ruby-lang.org&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">Python&lt;/span>: &lt;span style="color:#ae81ff">python.org&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">Perl&lt;/span>: &lt;span style="color:#ae81ff">use.perl.org&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>转为 JSON 如下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;languages&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;Ruby&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;description&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;unknown&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;XXX&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Perl&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;Python&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;description&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Scripts Programming&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;scripts&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;websites&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;YAML&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;yaml.org&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;Ruby&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;ruby-lang.org&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;Python&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;python.org&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;Perl&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;use.perl.org&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="纯量">纯量&lt;/h2>
&lt;p>纯量是最基本的、不可再分的值。以下数据类型都属于 YAML 的纯量。&lt;/p>
&lt;ul>
&lt;li>字符串&lt;/li>
&lt;li>布尔值&lt;/li>
&lt;li>整数&lt;/li>
&lt;li>浮点数&lt;/li>
&lt;li>Null&lt;/li>
&lt;li>时间&lt;/li>
&lt;li>日期&lt;/li>
&lt;/ul>
&lt;p>数值直接以字面量的形式表示。
number: 12.30&lt;/p>
&lt;p>转为 JSON 如下。
{ number: 12.30 }&lt;/p>
&lt;p>布尔值用 true 和 false 表示。
isSet: true&lt;/p>
&lt;p>转为 JSON 如下。
{ isSet: true }&lt;/p>
&lt;p>null 用~表示。
parent: ~&lt;/p>
&lt;p>转为 JavaScript 如下。
{ parent: null }&lt;/p>
&lt;p>时间采用 ISO8601 格式。
iso8601: 2001-12-14t21:59:43.10-05:00&lt;/p>
&lt;p>转为 JSON 如下。
{&amp;ldquo;iso8601&amp;rdquo;: &amp;ldquo;2001-12-15T02:59:43.100Z&amp;rdquo;}&lt;/p>
&lt;p>日期采用复合 iso8601 格式的年、月、日表示。
date: 1976-07-31&lt;/p>
&lt;p>转为 JavaScript 如下。
{ date: new Date(&amp;lsquo;1976-07-31&amp;rsquo;) }&lt;/p>
&lt;p>YAML 允许使用两个感叹号，强制转换数据类型。
e: !!str 123f: !!str true&lt;/p>
&lt;p>转为 JavaScript 如下
{ e: &amp;lsquo;123&amp;rsquo;, f: &amp;rsquo;true&amp;rsquo; }&lt;/p>
&lt;p>六、字符串&lt;/p>
&lt;p>字符串是最常见，也是最复杂的一种数据类型。&lt;/p>
&lt;p>字符串默认不使用引号表示。&lt;/p>
&lt;p>str: 这是一行字符串&lt;/p>
&lt;p>转为 JavaScript 如下。&lt;/p>
&lt;p>{ str: &amp;lsquo;这是一行字符串&amp;rsquo; }&lt;/p>
&lt;p>如果字符串之中包含空格或特殊字符，需要放在引号之中。&lt;/p>
&lt;p>str: &amp;lsquo;内容： 字符串&amp;rsquo;&lt;/p>
&lt;p>转为 JavaScript 如下。&lt;/p>
&lt;p>{ str: &amp;lsquo;内容: 字符串&amp;rsquo; }&lt;/p>
&lt;p>单引号和双引号都可以使用，双引号不会对特殊字符转义。&lt;/p>
&lt;p>s1: &amp;lsquo;内容\n 字符串&amp;rsquo;s2: &amp;ldquo;内容\n 字符串&amp;rdquo;&lt;/p>
&lt;p>转为 JavaScript 如下。&lt;/p>
&lt;p>{ s1: &amp;lsquo;内容\n 字符串&amp;rsquo;, s2: &amp;lsquo;内容\n 字符串&amp;rsquo; }&lt;/p>
&lt;p>单引号之中如果还有单引号，必须连续使用两个单引号转义。&lt;/p>
&lt;p>str: &amp;rsquo;labor&amp;rsquo;&amp;rsquo;s day&amp;rsquo;&lt;/p>
&lt;p>转为 JavaScript 如下。&lt;/p>
&lt;p>{ str: &amp;rsquo;labor&amp;rsquo;s day&amp;rsquo; }&lt;/p>
&lt;p>字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格。&lt;/p>
&lt;p>str: 这是一段 多行 字符串&lt;/p>
&lt;p>转为 JavaScript 如下。&lt;/p>
&lt;p>{ str: &amp;lsquo;这是一段 多行 字符串&amp;rsquo; }&lt;/p>
&lt;p>多行字符串可以使用|保留换行符，也可以使用&amp;gt;折叠换行。&lt;/p>
&lt;p>this: | Foo Barthat: &amp;gt; Foo Bar&lt;/p>
&lt;p>转为 JavaScript 代码如下。&lt;/p>
&lt;p>{ this: &amp;lsquo;Foo\nBar\n&amp;rsquo;, that: &amp;lsquo;Foo Bar\n&amp;rsquo; }&lt;/p>
&lt;p>+表示保留文字块末尾的换行，-表示删除字符串末尾的换行。&lt;/p>
&lt;p>s1: | Foos2: |+ Foos3: |- Foo&lt;/p>
&lt;p>转为 JavaScript 代码如下。&lt;/p>
&lt;p>{ s1: &amp;lsquo;Foo\n&amp;rsquo;, s2: &amp;lsquo;Foo\n\n\n&amp;rsquo;, s3: &amp;lsquo;Foo&amp;rsquo; }&lt;/p>
&lt;p>字符串之中可以插入 HTML 标记。&lt;/p>
&lt;p>message: |&lt;/p>
&lt;pre>&lt;code>段落
&lt;/code>&lt;/pre>
&lt;p>转为 JavaScript 如下。&lt;/p>
&lt;p>{ message: &amp;lsquo;\n&lt;/p>
&lt;p>\n 段落\n&lt;/p>
&lt;p>\n&amp;rsquo; }&lt;/p>
&lt;p>七、引用&lt;/p>
&lt;p>锚点&amp;amp;和别名*，可以用来引用。&lt;/p>
&lt;p>defaults: &amp;amp;defaults adapter: postgres host: localhostdevelopment: database: myapp_development &amp;laquo;: *defaultstest: database: myapp_test &amp;laquo;:*defaults&lt;/p>
&lt;p>等同于下面的代码。&lt;/p>
&lt;p>defaults: adapter: postgres host: localhostdevelopment: database: myapp_development adapter: postgres host: localhosttest: database: myapp_test adapter: postgres host: localhost&lt;/p>
&lt;p>&amp;amp;用来建立锚点（defaults），&amp;laquo;表示合并到当前数据，*用来引用锚点。&lt;/p>
&lt;p>下面是另一个例子。&lt;/p>
&lt;ul>
&lt;li>&amp;amp;showell Steve - Clark - Brian - Oren - *showell&lt;/li>
&lt;/ul>
&lt;p>转为 JavaScript 代码如下。&lt;/p>
&lt;p>[ &amp;lsquo;Steve&amp;rsquo;, &amp;lsquo;Clark&amp;rsquo;, &amp;lsquo;Brian&amp;rsquo;, &amp;lsquo;Oren&amp;rsquo;, &amp;lsquo;Steve&amp;rsquo; ]&lt;/p>
&lt;h3 id="block-literal文字块">block literal（文字块）&lt;/h3>
&lt;p>这是 YAML 的亮点，特别是与 XML 相比，它的 CDATA 显得相当简陋，block literal 可以将大块文本细致地插入文件中，常用来在传递配置文件时使用(比如通过 k8s 的 configmap 来传递某个程序的配置文件)&lt;/p>
&lt;p>可以使用竖线 | 指令在你的文本中保留新行，如：&lt;/p>
&lt;pre>&lt;code> text: | This is a really long text that spans multiple lines (but preserves new lines). It does not need to be escaped with special brackets, CDATA tags, or anything like that
&lt;/code>&lt;/pre>
&lt;p>YAML 编译器将会从第一行的第一个文本字符开始编译（并丢掉所有的缩进空格），但是会在你的文本中保留新行。&lt;/p>
&lt;p>另外，你还可以使用大于符号（&amp;gt;）告诉 YAML 编译器给所有新行加上条纹，并将输入的文本作为一个长行处理：&lt;/p>
&lt;pre>&lt;code> text: &amp;gt; This is a really long text that spans multiple lines (but preserves new lines). It does not need to be escaped with special brackets, CDATA tags, or anything like that
&lt;/code>&lt;/pre>
&lt;p>除了这两个指令之外，你还可以使用竖线和加号 |+ ，它给位于前面的空格加上条纹，保留新行和末尾的空格。还可以使用大于号和减号 &amp;gt;- ，它给所有的空格加上条纹。|- 用于删除字符串末尾的换行&lt;/p></description></item><item><title>Docs: 按键精灵</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/%E6%8C%89%E9%94%AE%E7%B2%BE%E7%81%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/%E6%8C%89%E9%94%AE%E7%B2%BE%E7%81%B5/</guid><description/></item></channel></rss>