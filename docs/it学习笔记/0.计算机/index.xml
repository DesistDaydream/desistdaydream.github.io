<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 0.计算机</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/</link><description>Recent content in 0.计算机 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: CPU</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/cpu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/cpu/</guid><description>
&lt;h1 id="中央处理器cpu-介绍">&lt;strong>中央处理器(CPU) 介绍&lt;/strong>&lt;/h1>
&lt;p>&lt;strong>Central Processing Unit(中央处理器，简称 CPU)&lt;/strong>。
如同华硕主板示意图上半部的中央部分，那就是 CPU 插槽。由于 CPU 负责大量运算，因此 CPU 通常是具有相当高发热量的元件。所以如果你曾经拆开过主板，应该就会看到 CPU 上头通常会安插一颗风扇来主动散热的。&lt;/p>
&lt;p>x86 个人电脑的 CPU 主要供应商为 Intel 与 AMD，目前（2015）主流的 CPU 都是双核以上的架构了！原本的单核心 CPU 仅有一个运算单元，所谓的多核心则是在一颗 CPU 封装当中嵌入了两个以上的运算核心， 简单的说，就是一个实体的 CPU 外壳中，含有两个以上的 CPU 单元就是了。&lt;/p>
&lt;p>不同的 CPU 型号大多具有不同的脚位（CPU 上面的插脚），能够搭配的主板芯片组也不同， 所以当你想要将你的主机升级时，不能只考虑 CPU，你还得要留意你的主板上面所支持的 CPU 型号喔！不然买了最新的 CPU 也不能够安插在你的旧主板上头的！目前主流的 CPU 有 Intel 的 i3/i5/i7 系列产品中，甚至先后期出厂的类似型号的脚位也不同， 例如 i7-2600 使用 LGA1155 脚位而 i7-4790 则使用 FCLGA1150 脚位，挑选时必须要很小心喔！&lt;/p>
&lt;p>我们前面谈到 CPU 内部含有微指令集，不同的微指令集会导致 CPU 工作效率的优劣。除了这点之外， CPU 性能的比较还有什么呢？那就是 CPU 的频率了！什么是频率呢？简单的说， 频率就是 CPU 每秒钟可以进行的工作次数。所以频率越高表示这颗 CPU 单位时间内可以作更多的事情。举例来说，Intel 的 i7-4790 CPU 频率为 3.6GHz， 表示这颗 CPU 在一秒内可以进行 3.6x109 次工作，每次工作都可以进行少数的指令运行之意。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lgtxxk/1616168680795-7c145400-1473-4cdc-b525-3a106f810f80.gif" alt="">&lt;/p>
&lt;p>&lt;strong>Tips&lt;/strong>注意，不同的 CPU 之间不能单纯的以频率来判断运算性能喔！这是因为每颗 CPU 的微指令集不相同，架构也不见得一样，可使用的第二层高速缓存及其计算机制可能也不同，加上每次频率能够进行的工作指令数也不同！所以，频率目前仅能用来比较同款 CPU 的速度！&lt;/p>
&lt;p>CPU 的工作频率：外频与倍频&lt;/p>
&lt;p>早期的 CPU 架构主要通过北桥来链接系统最重要的 CPU、内存与显卡设备。因为所有的设备都得通过北桥来链接，因此每个设备的工作频率应该要相同。于是就有所谓的前端总线（FSB） 这个东西的产生。但因为 CPU 的运算速度比其他的设备都要来的快，又为了要满足 FSB 的频率，因此厂商就在 CPU 内部再进行加速， 于是就有所谓的外频与倍频了。&lt;/p>
&lt;p>总结来说，在早期的 CPU 设计中，所谓的外频指的是 CPU 与外部元件进行数据传输时的速度，倍频则是 CPU 内部用来加速工作性能的一个倍数， 两者相乘才是 CPU 的频率速度。例如 Intel Core 2 E8400 的内频为 3.0GHz，而外频是 333MHz，因此倍频就是 9 倍啰！（3.0G=333Mx9, 其中 1G=1000M）&lt;/p>
&lt;h3 id="超频">&lt;strong>超频&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>Tips&lt;/strong>很多计算机硬件玩家很喜欢玩“超频”，所谓的超频指的是：将 CPU 的倍频或者是外频通过主板的设置功能更改成较高频率的一种方式。但因为 CPU 的倍频通常在出厂时已经被锁定而无法修改，因此较常被超频的为外频。举例来说，像上述 3.0GHz 的 CPU 如果想要超频，可以将他的外频 333MHz 调整成为 400MHz，但如此一来整个主板的各个元件的运行频率可能都会被增加成原本的 1.333 倍(4/ 3)，虽然 CPU 可能可以到达 3.6GHz，但却因为频率并非正常速度，故可能会造成死机等问题。&lt;/p>
&lt;p>但如此一来所有的数据都被北桥卡死了，北桥又不可能比 CPU 更快，因此这家伙常常是系统性能的瓶颈。为了解决这个问题，新的 CPU 设计中， 已经将内存控制器整合到 CPU 内部，而链接 CPU 与内存、显卡的控制器的设计，在 Intel 部份使用 QPI （Quick Path Interconnect） 与 DMI 技术，而 AMD 部份则使用 Hyper Transport 了，这些技术都可以让 CPU 直接与内存、显卡等设备分别进行沟通，而不需要通过外部的链接芯片了。&lt;/p>
&lt;p>因为现在没有所谓的北桥了（整合到 CPU 内），因此，CPU 的频率设计就无须考虑得要同步的外频，只需要考虑整体的频率即可。所以，如果你经常有查阅自己 CPU 频率的习惯，当使用 cpu-z [9]这个软件时，应该会很惊讶的发现到，怎么外频变成 100MHz 而倍频可以到达 30 以上！相当有趣呢！&lt;/p>
&lt;p>**Tips **现在 Intel 的 CPU 会主动帮你超频喔！例如 i7-4790 这颗 CPU 的规格[10]中，基本频率为 3.6GHz，但是最高可自动超频到 4GHz 喔！通过的是 Intel 的 turbo 技术。同时，如果你没有大量的运算需求，该 CPU 频率会降到 1.xGHz 而已，借此达到节能省电的目的！所以，各位好朋友，不需要自己手动超频了！Intel 已经自动帮你进行超频了&amp;hellip;所以，如果你用 cpu-z 观察 CPU 频率，发现该频率会一直自动变动，很正常！你的系统没坏掉！&lt;/p>
&lt;p>32 位与 64 位的 CPU 与总线“宽度”&lt;/p>
&lt;p>从前面的简易说明中，我们知道 CPU 的各项数据通通得要来自于内存。因此，如果内存能提供给 CPU 的数据量越大的话，当然整体系统的性能应该也会比较快！那如何知道内存能提供的数据量呢？此时还是得要借由 CPU 内的内存控制芯片与内存间的传输速度“前端总线速度（Front Side Bus, FSB） 来说明。&lt;/p>
&lt;p>与 CPU 的频率类似的，内存也是有其工作的频率，这个频率限制还是来自于 CPU 内的内存控制器所决定的。以图 0.2.1 为例， CPU 内置的内存控制芯片对内存的工作频率最高可达到 1600MHz。这只是工作频率（每秒几次）。一般来说，每次频率能够传输的数据量，大多为 64 位，这个 64 位就是所谓的“宽度”了！因此，在图 0.2.1 这个系统中，CPU 可以从内存中取得的最快带宽就是 1600MHz &lt;em>64bit = 1600MHz&lt;/em> 8 Bytes = 12.8GByte/s。&lt;/p>
&lt;p>与总线宽度相似的，CPU 每次能够处理的数据量称为字组大小（word size）， 字组大小依据 CPU 的设计而有 32 位与 64 位。我们现在所称的电脑是 32 或 64 位主要是依据这个 CPU 解析的字组大小而来的！早期的 32 位 CPU 中，因为 CPU 每次能够解析的数据量有限， 因此由内存传来的数据量就有所限制了。这也导致 32 位的 CPU 最多只能支持最大到 4GBytes 的内存。&lt;/p>
&lt;p>**Tips **得利于北桥整合到 CPU 内部的设计，CPU 得以“个别”跟各个元件进行沟通！因此，每种元件与 CPU 的沟通具有很多不同的方式！例如内存使用系统总线带宽来与 CPU 沟通。而显卡则通过 PCI-E 的序列信道设计来与 CPU 沟通喔！详细说明我们在本章稍后的主板部份再来谈谈。&lt;/p>
&lt;p>CPU 等级&lt;/p>
&lt;p>由于 x86 架构的 CPU 在 Intel 的 Pentium 系列（1993 年）后就有不统一的脚位与设计，为了将不同种类的 CPU 规范等级， 所以就有 i386,i586,i686 等名词出现了。基本上，在 Intel Pentium MMX 与 AMD K6 年代的 CPU 称为 i586 等级， 而 Intel Celeron 与 AMD Athlon（K7）年代之后的 32 位 CPU 就称为 i686 等级。至于目前的 64 位 CPU 则统称为 x86_64 等级。&lt;/p>
&lt;p>目前很多的程序都有对 CPU 做最优化的设计，万一哪天你发现一些程序是注明给 x86_64 的 CPU 使用时， 就不要将他安装在 686 以下等级的电脑中，否则可是会无法执行该软件的！不过，在 x86_64 的硬件下倒是可以安装 386 的软件喔！也就是说，这些东西具有向下相容的能力啦！&lt;/p>
&lt;h3 id="超线程hyper-threading-ht">&lt;strong>超线程（Hyper-Threading, HT）&lt;/strong>&lt;/h3>
&lt;p>我们知道现在的 CPU 至少都是两个核心以上的多核心 CPU 了，但是 Intel 还有个很怪的东西，叫做 CPU 的超线程（Hyper-Threading） 功能！那个是啥鬼东西？我们知道现在的 CPU 运算速度都太快了，因此运算核心经常处于闲置状态下。而我们也知道现在的系统大多都是多任务的系统， 同时间有很多的程序会让 CPU 来执行。因此，若 CPU 可以假象的同时执行两个程序，不就可以让系统性能增加了吗？反正 CPU 的运算能力还是没有用完啊！&lt;/p>
&lt;p>那是怎么达成的啊这个 HT 功能？强者鸟哥的同事蔡董大大用个简单的说明来解释。在每一个 CPU 内部将重要的寄存器（register） 分成两群， 而让程序分别使用这两群寄存器。也就是说，可以有两个程序“同时竞争 CPU 的运算单元”，而非通过操作系统的多任务切换！这一过程就会让 CPU 好像“同时有两个核心”的模样！因此，虽然大部分 i7 等级的 CPU 其实只有四个实体核心，但通过 HT 的机制， 则操作系统可以抓到八个核心！并且让每个核心逻辑上分离，就可以同时运行八个程序了。&lt;/p>
&lt;p>虽然很多研究与测试中，大多发现 HT 虽然可以提升性能，不过，有些情况下却可能导致性能降低喔！因为，实际上明明就仅有一个运算单元嘛！不过在鸟哥使用数值模式的情况下，因为鸟哥操作的数值模式主要为平行运算功能，且运算通常无法达到 100% 的 CPU 使用率，通常仅有大约 60%运算量而已。因此在鸟哥的实作过程中，这个 HT 确实提升相当多的性能！至少应该可以节省鸟哥大约 30%~50%的等待时间喔！不过网络上大家的研究中， 大多说这个是 case by case，而且使用的软件影响很大！所以，在鸟哥的例子是启用 HT 帮助很大！您的案例就得要自行研究啰！&lt;/p></description></item><item><title>Docs: Memory</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/memory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/memory/</guid><description>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://en.wikipedia.org/wiki/Computer_memory">Wiki,Computer memory&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Random Access Memory(随机存取存储器，简称 RAM，也叫主存)，平时大家都叫 Memory(内存)&lt;/strong>。&lt;/p>
&lt;p>RAM 是一种形式的计算机存储器可被读取和以任何顺序发生变化，通常用于存储工作数据和机器代码。[1] [2]甲随机存取存储器设备允许数据项被读出或写入在几乎相同的时间量，而不管存储器内数据的物理位置的。相反，对于其他直接访问数据存储介质，例如硬盘，CD-RW，DVD-RW和较旧的磁带和磁鼓存储器一样，由于机械限制（例如介质旋转速度和机械臂移动），读写数据项所需的时间根据其在记录介质上的物理位置而有很大不同。&lt;/p>
&lt;p>RAM包含多路复用和多路分解电路，用于将数据线连接到寻址的存储器，以读取或写入条目。通常，同一地址访问的存储空间不止一位，而RAM设备通常具有多条数据线，并且被称为“ 8位”或“ 16位”等设备。&lt;/p>
&lt;p>在当今的技术中，随机存取存储器采用具有MOS（金属氧化物半导体）存储单元的集成电路（IC）芯片的形式。RAM通常与易失性类型的内存（例如动态随机存取存储器（DRAM）模块）相关联，尽管已经开发了非易失性RAM，但如果断电，则会丢失存储的信息。[3]存在其他类型的非易失性存储器，它们允许对读操作进行随机访问，但要么不允许写操作，要么对其具有其他种类的限制。其中包括大多数类型的ROM和一种闪存称为_NOR-Flash_。&lt;/p>
&lt;p>易失性随机存取半导体存储器的两种主要类型是静态随机存取存储器（SRAM）和动态随机存取存储器（DRAM）。半导体RAM的商业用途可以追溯到1965年，当时IBM为他们的System / 360 Model 95计算机引入了SP95 SRAM芯片，而东芝则为其Toscal BC-1411电子计算器使用了DRAM存储单元，两者均基于双极晶体管。基于MOS晶体管的商用MOS存储器是在1960年代后期开发的，此后一直是所有商用半导体存储器的基础。1970年10月推出了第一款商用DRAM IC芯片Intel 1103。同步动态随机存取存储器（SDRAM）随后于1992年与三星KM48SL2000芯片一起首次亮相。&lt;/p></description></item><item><title>Docs: Disk</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/disk/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/disk/</guid><description>
&lt;p>对很多 PC 的使用者来说，UEFI 就像是一颗深水炸弹，表面风平浪静，暗地里却早已引发了巨大的震动。多亏了 Microsoft 的强横，预装 WIN8 的电脑指定需要 GPT 分区这一举措，让人们不禁发出感慨：哦天哪，我的电脑里还有这东西？一些好学的人对 GPT 进行了解以后，进一步发现了我们的幕后功臣：UEFI。本期文章我们就来说说，硬盘和硬盘分区这点事。&lt;/p>
&lt;p>简单地说，硬盘分区是就使用分区编辑器（partition editor）将一个硬盘上划分几个独立的逻辑部分，盘片一旦划分成数个分区，不同类的目录与文件可以存储进不同的分区。越多分区，也就有更多不同的地方，可以将文件的性质区分得更细，按照更为细分的性质，存储在不同的地方以管理文件；但太多分区就成了麻烦。&lt;/p>
&lt;p>硬盘分区就像给一间空荡的房子划分出卧室，厨房，客厅等相互隔离的空间一样。主要是为了方面用户的使用。另一方面，通过合理的硬盘分区，有效保护系统盘空间，确实能够提高系统运行速度，再者，硬盘分区也可以有效地对数据进行保护。你当然可以不分区，只不过，当你面对越来越多的子目录，或者是越来越慢的 Windows，不得不费功夫去管理你的文件，或者重装 Windows 的时候，恐怕会悔不当初。 “不要把所有的鸡蛋放在同一个篮子里”这句至理名言在经济学以外的其他领域也同样是句警世恒言。&lt;/p>
&lt;p>在讲解 MBR 之前，有必要讲讲机械硬盘的一些相关概念，毕竟 MBR 作为 20 世纪最棒的磁盘管理方式，与机械硬盘可是联系紧密的&lt;/p>
&lt;p>（这样可以更好地理解后面的内容）。&lt;/p>
&lt;h1 id="机械硬盘原理">机械硬盘原理&lt;/h1>
&lt;p>机械硬盘由坚硬金属材料制成的涂以磁性介质的盘片，盘片两面称为盘面或扇面，都可以记录信息，由磁头对盘面进行操作（如果你有坏的硬盘，可以动手拆开看。嗯？为什么用坏的？用好的可能费钱……）一般用磁头号区分。结构特性决定了机械硬盘如果受到剧烈冲击（摔在地上或是勤奋的你想拆开学习），磁头与盘面可能产生的哪怕是轻微撞击都有可能报废。&lt;/p>
&lt;p>继续讲原理：假设磁头不动，硬盘旋转，那么磁头就会在磁盘表面画出一个圆形轨迹并将之磁化，数据就保存在这些磁化区中，称之为磁道，将每个磁道分段，一个弧段就是一个扇区。一个硬盘可以包含多个扇面，扇面同轴重叠放置，每个盘面磁道数相同，具有相同周长的磁道所形成的圆柱称之为柱面，柱面数与磁道数相等。如下图
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kwiih4/1623075065699-cc31c470-bed5-45ba-95b5-1c56eafbfb57.png" alt="image.png">&lt;/p>
&lt;p>了解了这些，我们就可以对最初的硬盘地址管理方式作一个原理层面的了解：&lt;/p>
&lt;p>最初的寻址方式称为 CHS，在 LBA（Logical Block Address）概念诞生之前，由他负责管理磁盘地址。所谓 CHS 即柱面（cylinder），磁头（header），扇区（sector），通过这三个变量描述磁盘地址，需要明白的是，这里表示的已不是物理地址而是逻辑地址了。这种方法也称作是 LARGE 寻址方式。该方法下：&lt;/p>
&lt;ul>
&lt;li>硬盘容量=磁头数 × 柱面数 × 扇区数 × 扇区大小（一般为 512byte）。&lt;/li>
&lt;/ul>
&lt;p>后来，人们通过为每个扇区分配逻辑地址，以扇区为单位进行寻址，也就有了 LBA 寻址方式。但是为了保持与 CHS 模式的兼容，通过逻辑变换算法，可以转换为磁头/柱面/扇区三种参数来表示，和 LARGE 寻址模式一样，这里的地址也是逻辑地址了。（固态硬盘的存储原理虽然与机械硬盘不同，采用的是 flash 存储，但仍然使用 LBA 进行管理，此处不再详述。）&lt;/p>
&lt;p>科普到这里，我们可以试图去理解 MBR 分区了。现在我们来看看 MBR 分区的技术原理。&lt;/p>
&lt;h1 id="mbr-原理">MBR 原理&lt;/h1>
&lt;p>MBR：Master Boot Record，主分区引导记录。最早在 1983 年在 IBM PC DOS 2.0 中提出。前面说过，每个扇区/区块都被分配了一个逻辑块地址，即 LBA，而引导扇区则是每个分区的第一扇区，而主引导扇区则是整个硬盘的第一扇区（主分区的第一个扇区）。MBR 就保存在主引导扇区中。另外，这个扇区里还包含了硬盘分区表 DPT（Disk Partition Table），和结束标志字（Magic number）。扇区总计 512 字节，MBR 占 446 字节（0000H - 01BDH），DPT 占据 64 个字节（01BEH - 01FDH），最后的 magic number 占 2 字节（01FEH – 01FFH）。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kwiih4/1623075104446-267bee24-522c-4faa-9103-51ff02b02d91.png" alt="image.png">
现在，我们来看一个 MBR 记录的实例：&lt;/p>
&lt;p>&lt;strong>80 01 01 00, 0B FE BF FC, 3F 00 00 00, 7E 86 BB 00&lt;/strong>&lt;/p>
&lt;p>其中， “80”是一个分区的激活标志，表示系统可引导；“01 01 00”表示分区开始的磁头号为 01，开始的扇区号为 01，开始的柱面号为 00；“0B”表示该分区的系统类型是 FAT32，其他比较常用的有 04(FAT16)、07(NTFS)；“FE BF FC”表示分区结束的磁头号为 254，分区结束的扇区号为 63、分区结束的柱面号为 764；“3F 00 00 00”表示首扇区的相对扇区号为 63；“7E 86 BB 00”表示总扇区数为 12289622。&lt;/p>
&lt;p>可以看到，在只分配 64 字节给 DPT 的情况下，每个分区项分别占用 16 个字节，因此只能记录四个分区信息，尽管后来为了支持更多的分区，引入了扩展分区及逻辑分区的概念。但每个分区项仍然用 16 个字节存储。能表示的最大扇区数为 FF FF,FF FFH，因此可管理的最大空间=总扇区数*扇区大小（512byte），也就是 2TB（由于硬盘制造商采用 1:1000 进行单位换算，因此也有 2.2TB 一说，别怪他们，他们不是程序员）。超过 2TB 以后的空间，不能分配地址，自然也就无法管理了。&lt;/p>
&lt;p>MBR 的诸多缺点使其应用大大受限。硬盘技术日新月异，硬盘容量突飞猛进（希捷将于今年开卖 60TB 固态硬盘），多出来的硬盘空间总不能晾着吧，于是，在刚诞生的 UEFI 规范下一起研发了新技术&lt;/p>
&lt;h1 id="gpt-原理">GPT 原理&lt;/h1>
&lt;p>GPT 分区：全称为 Globally Unique Identifier Partition Table，也叫做 GUID 分区表，它是 UEFI 规范的一部分。由于硬盘容量的急速增长，MBR 的 2.2T 容量难以满足要求，而 UEFI BIOS 的推广也为 GPT 的实现打下了坚实的技术基础，GPT 应运而生，&lt;/p>
&lt;p>我们来看看 GPT 的结构图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kwiih4/1623075115463-8dca0892-772a-42b0-a682-6ce0fc9efc22.png" alt="image.png">
等等，MBR 是不是走错片场了？答案当然是没有。这里的 P 意为 protective，PMBR 存在的意义就是，当不支持 GPT 的分区工具试图对硬盘进行操作时（例如 MS-DOS 和 Linux 的 fdisk 程序），它可以根据这份 PMBR 以传统方式启动，过程和 MBR+BIOS 完全一致，极大地提高了兼容性。而支持 GPT 的系统在检测 PMBR 后会直接跳到 GPT 表头读取分区表。和 MBR 类似，分区表中存储了某个分区的起始和结束位置及其文件系统属性信息，而分区才是实际存在的物理磁盘的一部分。&lt;/p>
&lt;p>GPT HDR：GPT 表头，如下图，主要定义了分区表中项目数及每项大小，还包含硬盘的容量信息。在 64 位的 Windows Server 2003 的机器上，最多可以创建 128 个分区，即分区表中保留了 128 个项，其中每个都是 128 字节。（也是 EFI 标准中的最低要求：分区表最小要有 16,384 字节）分区表头还记录了这块硬盘的 GUID，分区表头位置（总是 LBA1）和大小，也包含了备份分区表头和分区表的位置和大小信息（LBA-1~LBA-34）。同时还储存着它本身和分区表的 CRC32 校验。固件、引导程序和操作系统在启动时可以根据这个校验值来判断分区表是否出错，如果出错，可以使用软件从硬盘最后的备份 GPT 中恢复整个分区表，如果备份 GPT 也校验错误，硬盘将不可使用。具体内容如下表：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kwiih4/1623075153084-e4d0873a-dbcf-4878-a1b4-522235fe8f3b.png" alt="image.png">
Partition Table：分区表，包含分区的类型 GUID（如：EFI 系统分区的 GUID 类型是{C12A7328-F81F-11D2-BA4B-00A0C93EC93B}），名称，起始终止位置，该分区的 GUID 以及分区属性。其内容如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kwiih4/1623075157132-b6dd078b-59ca-429a-b6f2-a93d16d9b553.png" alt="image.png">
Microsoft 对分区属性做了更详细的区分，目前有：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kwiih4/1623075161478-4a21cc5d-b761-474a-a545-aff2fb7d0f22.png" alt="image.png">
相较于 MBR，GPT 具有以下优点：
（1）得益于 LBA 提升至 64 位，以及分区表中每项 128 位设定，GPT 可管理的空间近乎无限大，假设一个扇区大小仍为 512 字节，可表示扇区数为，算下来，可管理的硬盘容量=18EB(1EB=1024PB=1,048,576TB)，2T 在它面前完全不在话下。按目前的硬盘技术来看，确实近乎无限，不过，以后的事谁知道呢。
（2）分区数量几乎没有限制，由于可在表头中设置分区数量的大小，如果愿意，设置个分区也可以（有人愿意管理这么多分区吗），不过，目前 windows 仅支持最大 128 个分区。
（3）自带保险，由于在磁盘的首尾部分各带一个 GPT 表头，任何一个受到破坏后都可以通过另一份恢复，极大地提高了磁盘的抗性（两个一起坏的请出门买彩票）。
（4）循环冗余检验值针对关键数据结构而计算，提高了数据崩溃的检测几率。
（5）尽管目前分区类型不超过百数（十数也没有吧。），GPT 仍提供了 16 字节的 GUID 来标识分区类型，使其更不容易产生冲突。
（6）每个分区都可以拥有一个特别的名字，最长 72 字节，足够写一首七律了。满足你的各种奇葩起名需求。&lt;/p>
&lt;p>完美支持 UEFI，毕竟它就是 UEFI 规范的衍生品。在将来全行业 UEFI 的情境下，GPT 必将更快淘汰 MBR。&lt;/p>
&lt;h1 id="其他">其他&lt;/h1>
&lt;p>接下来进入加料时间，更详细的讲述硬盘知识。&lt;/p>
&lt;p>前面说到过，磁化的弧段称作一个扇区，一个扇区大小 512B，但硬盘在进行文件操作时并非以扇区为单位，而是——簇，“簇”是系统进行分配的最小单位，一个簇可以包含多个扇区，假设目前一个簇包含 4 个扇区，簇大小为 2KB，一个文件大小恰为 2KB，则占用了簇的所有可用空间，即便你有一个 1B 大小的文件需要保存，那么你占用的空间也是一个簇，簇内其他空间不可读写。&lt;/p>
&lt;p>而对簇的大小进行管理的就是文件系统：&lt;/p>
&lt;p>FAT16/FAT32: 早期的 MS-DOS 和 WIN95 操作系统中最常见的硬盘分区格式。一个簇最小为 512 个字节，其大小可以成倍增长，最大为 32K，系统为每个簇分配唯一的索引号——一个 16 位二进制数来标识。因为 16 位二进制数最大为 65536，所以 FAT 分区所拥有的簇的数量不可能超过 65536 个。这正是 FAT 分区大小不能超过 2GB 的原因。FAT16 的继任者——FAT32 与其原理基本相同，相比前任优势仅在于分区可以大于 2GB，但不能存储大于 4GB 的单个文件，看看现在一部 BD 的电影都要 3,4 个 G，显然不能满足时代的需求，被淘汰的很快。&lt;/p>
&lt;p>更多 FAT 文件系统知识：FAT 文件系统与 UEFI - 知乎专栏&lt;/p>
&lt;p>NTFS 文件系统相比 FAT，最大优点在于支持文件加密，通过采用日志式文件系统，详细记录磁盘的所有读写操作，提高了数据和系统的安全性，另一点则是突破了 4GB 大小限制。也是目前机械硬盘上的分区主流。不过对于目前越来越亲民的的 flash 存储，过多的操作记录对存储介质造成了较大的负担，同样的存取操作，NTFS 下的读写次数就会比 FAT32 下来得多，造成了寿命较短的缺陷。因此针对移动存储设备和固态硬盘，推出了 exFAT 文件系统。&lt;/p>
&lt;p>exFAT：分区大小和单文件大小最大可达 16EB（16×1024×1024TB）；簇大小非 常灵活，最小 512B，最高达 32MB；采用了剩余空间分配表，空间利用率更高；同一目录下最大文件数可达 65536 个。其特性未必强于 NTFS，主要是针对 flash 存储设备进行了优化（SSD，U 盘），传统硬盘不能格式化为该格式。&lt;/p>
&lt;p>要是到现在你对扇区，簇，文件系统，分区几个名词有点混淆，不妨看看下图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/kwiih4/1623075174204-ac88087e-ef89-4716-878b-7383f3a1db7f.png" alt="image.png">
有人会问，图中的怎么突然出现了 4k 扇区，而且为什么下面又包含的是 8 个 512b 的扇区呢？边上的伪装是啥意思？恭喜你，你已经抓住了近年来的硬盘发展潮流。&lt;/p>
&lt;p>扇区的大小虽然约定俗成，但其实是可以更改的，开始于 2009 年晚期，硬盘制造商正在从传统的 512 字节扇区迁移到更大、更高效的 4096 字节扇区，国际硬盘设备与材料协会（International Disk Drive Equipment and&lt;/p>
&lt;p>Materials Association，IDEMA）将之称为高级格式化，也就是现在常说的“4K 扇区”。&lt;/p>
&lt;p>多年来，硬盘行业一直采用 512 字节扇区。然而，随着硬盘容量的不断增长，扇区大小日渐成为提高硬盘容量和纠错效率方面的制约。扇区分辨率（扇区大小和总存储大小的百分比）越来越低，尽管在管理小型离散数据时，分辨率越低越好。但现代的计算系统中多的是大型数据块，一般远比传统 512 字节扇区大小要大得多。另外，随着区域密度的增加，小型 512 字节扇区在硬盘表面上占用的空间也将越来越小。硬盘扇区中的数据占据的空间越小，错误纠正就会变得越困难，因为同样大小的介质缺陷对总体数据负载损害的百分比更高，所以就需要更大的纠错强度。现在，硬盘开始通过先进的区域密度来提高错误纠正的上限。因此，为了改善错误纠正和实现格式化效率，提高扇区大小是硬盘行业内的普遍诉求。&lt;/p>
&lt;p>不过，由于计算机系统的缓慢发展，多数仍将扇区假定为 512 字节，因此就产生了 4K 对齐问题。即使物理硬盘分区与计算机使用的逻辑分区对齐，保证硬盘读写效率。&lt;/p>
&lt;p>有 4k 对齐当然就有 4k 对不齐。这个锅，或许应该甩给操作系统。硬盘厂商为了保证与操作系统的兼容性，将新标准的&amp;quot;4K 扇区&amp;quot;的硬盘模拟成扇区为 512B 的硬盘，问题出现在此时：当在一些特殊情况下格式化的系统（比如用 ghost11.5 以下版本），会默认定义为 4096 字节大小为一个簇，这没毛病，但是，由于其引导区只占用了不多不少 63 个扇区，真正的文件系统在 63 号扇区之后，&lt;/p>
&lt;p>我们可以算出前 63 个扇区大小为：63*512B = 32256B。&lt;/p>
&lt;p>63 个扇区占用簇个数：32256B/4096B=7.875 簇。&lt;/p>
&lt;p>从第 64 个扇区开始，每个簇都会跨越两个物理单元，占据前一个单元的一小部分和后一个单元的一大部分，前面说过，系统文件操作以簇为单位，如果每个簇都要用到两个扇区，势必拖累读写速度。也就产生了“4k 对不齐”的概念，“4K 对齐”要做的事就是将硬盘的模拟扇区(512B)对齐到的 8 整数倍个“实际”4K 扇区，即 8*4096 = 32768B，使其正好跨过 63 扇区的特性，从第 64 个扇区对齐。&lt;/p>
&lt;p>其实不仅是操作系统，一些广泛使用的软件程序也可能引发 4k 对不齐现象。因此，对齐技术的存在确有其必要性。尽管 4k 必然取代 512b，但冰冻三尺非一日之寒，全行业仍需要一个时间来进行技术的全面推广。&lt;/p>
&lt;p>后记
一些经常被问到的关于 GPT 的问题：
1. Q：怎么知道我的硬盘是 MBR 的还是 GPT 的？
A： windows 自带个非常好用的工具-diskpart，简单几条命令即可，如图：&lt;/p>
&lt;ol start="2">
&lt;li>Q：如何将 GPT 转换为 MBR？
A: 还是 diskpart,(警告：请先备份内容），通过 convert mbr 指令&lt;/li>
&lt;/ol>
&lt;p>不过我还是建议你不要这样做，毕竟 MBR 是个被淘汰的技术。在转换之前要删除所有分区或者直接用 clean。如果不想丢失内容，推荐使用 AOMEI Partition Assistant Standard，它是个免费软件。非常好用。为谨慎起见还是建议提前备份内容。&lt;/p>
&lt;ol start="3">
&lt;li>Q：GPT 真好，我想立刻使用，可是如何将 MBR 转换为 GPT？
A：这是个好主意，答案还是 Diskpart&lt;/li>
&lt;/ol>
&lt;p>在转换之前要删除所有分区或者直接用 clean。如果不想丢失内容，我推荐使用 AOMEI Partition Assistant Standard，它是个免费软件。非常好用。为谨慎起见还是建议提前备份内容。&lt;/p></description></item><item><title>Docs: 计算机底层逻辑 与 晶体管</title><link>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91-%E4%B8%8E-%E6%99%B6%E4%BD%93%E7%AE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/it%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91-%E4%B8%8E-%E6%99%B6%E4%BD%93%E7%AE%A1/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>原文链接：&lt;a href="https://mp.weixin.qq.com/s/1pYxnWwmUA33eV2B5A2TjA">公众号,码农的荒岛求生&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV12d4y1272j">B 站-幼麟实验室，迷你计算机(小白入门)：计算机工作的原理&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>每次回家开灯时你有没有想过，用你按的简单开关实际上能打造出复杂的 CPU 来，只不过需要的数量会比较多，也就&lt;strong>几十亿&lt;/strong>个吧。&lt;/p>
&lt;h1 id="伟大的发明-晶体管">伟大的发明-晶体管&lt;/h1>
&lt;p>过去 200 年人类最重要的发明是什么？蒸汽机？电灯？火箭？这些可能都不是，最重要的也许是这个小东西：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d234bf8c-9b05-42cf-91a7-c31bbd32b8c3/640" alt="">&lt;/p>
&lt;p>这个小东西就叫&lt;strong>晶体管&lt;/strong>，你可能会问，晶体管有什么用呢？&lt;/p>
&lt;p>实际上晶体管的功能简单到不能再简单，给一端通上电，那么电流可以从另外两端通过，否则不能通过，其本质就是一个开关。&lt;/p>
&lt;p>就是这个小东西的发明让三个人获得了诺贝尔物理学奖，可见其举足轻重的地位。&lt;/p>
&lt;p>&lt;strong>无论程序员编写的程序多么复杂，软件承载的功能最终都是通过这个小东西简单的开闭完成的&lt;/strong>，除了神奇二字，我想不出其它词来。&lt;/p>
&lt;h2 id="andornot">AND、OR、NOT&lt;/h2>
&lt;p>现在有了晶体管，也就是开关，在此基础之上就可以搭积木了，你随手搭建出来这样三种组合：&lt;/p>
&lt;ul>
&lt;li>两个开关只有同时打开电流才会通过，灯才会亮&lt;/li>
&lt;li>两个开关中只要有一个打开电流就能通过，灯就会亮&lt;/li>
&lt;li>当开关关闭时电流通过灯会亮，打开开关灯反而电流不能通过灯会灭&lt;/li>
&lt;/ul>
&lt;p>天赋异禀的你搭建的上述组合分别就是：与门，AND Gate、或门，OR gate、非门，NOT gate，用符号表示就是这样：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d234bf8c-9b05-42cf-91a7-c31bbd32b8c3/640" alt="">&lt;/p>
&lt;p>&lt;strong>道生一、一生二、二生三、三生万物&lt;/strong>&lt;/p>
&lt;p>最神奇的是，你随手搭建的三种电路竟然有一种很 amazing 的特性，那就是：任何一个逻辑函数最终都可以通过 AND、OR 以及 NOT 表达出来，这就是所谓的&lt;strong>逻辑完备性&lt;/strong>，就是这么神奇。&lt;/p>
&lt;p>也就是说**给定足够的 AND、OR 以及 NOT 门，就可以实现任何一个逻辑函数，除此之外我们不需要任何其它类型的逻辑门电路，**这时我们认为 AND、OR、NOT 门就是逻辑完备的。&lt;/p>
&lt;p>这一结论的得出吹响了计算机革命的号角，这个结论告诉我们计算机最终可以通过简单的 AND、OR、NOT 门构造出来，这些简单的逻辑门电路就好比基因。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d234bf8c-9b05-42cf-91a7-c31bbd32b8c3/640" alt="">
老子有云：&lt;strong>道生一、一生二、二生三、三生万物，实乃异曲同工之妙&lt;/strong>。&lt;/p>
&lt;p>虽然，我们可以用 AND、OR、NOT 来实现所有的逻辑运算，但我们真的需要把所有的逻辑运算都用 AND、OR、NOT 门实现出来吗？显然不是，而且这也不太可行。&lt;/p>
&lt;h2 id="逻辑门">逻辑门&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d234bf8c-9b05-42cf-91a7-c31bbd32b8c3/1660727560561-e35f4da3-81bf-405e-8f93-57d6174848fd.png" alt="image.png">&lt;/p>
&lt;h1 id="计算能力是怎么来的">计算能力是怎么来的&lt;/h1>
&lt;p>现在能生成万物的基础元素与或非门出现了，接下来我们着手设计 CPU 最重要的能力：计算，以加法为例。&lt;/p>
&lt;p>由于 CPU 只认知 0 和 1，也就是二进制，那么二进制的加法有哪些组合呢：&lt;/p>
&lt;ul>
&lt;li>0 + 0，结果为 0，进位为 0&lt;/li>
&lt;li>0 + 1，结果为 1，进位为 0&lt;/li>
&lt;li>1 + 0，结果为 1，进位为 0&lt;/li>
&lt;li>1 + 1，结果为 0，进位为 1，二进制嘛！&lt;/li>
&lt;/ul>
&lt;p>注意进位一列，只有当两路输入的值都是 1 时，进位才是 1 ，看一下你设计的三种组合电路，这就是与门啊，有没有！&lt;/p>
&lt;p>再看下结果一列，当两路输入的值不同时结果为 1，输入结果相同时结果为 0，这就是异或啊，有没有！我们说过与或非门是逻辑完备可以生万物，异或逻辑当然不在话下，用一个与门和一个异或门就可以实现二进制加法：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d234bf8c-9b05-42cf-91a7-c31bbd32b8c3/640" alt="">&lt;/p>
&lt;p>上述电路就是一个简单的加法器，就问你神奇不神奇，加法可以用与或非门实现，其它的也一样能实现，逻辑完备嘛。&lt;/p>
&lt;p>除了加法，我们也可以根据需要将不同的算数运算设计出来，负责计算的电路有一个统称，这就是所谓的 arithmetic/logic unit，ALU，CPU 中专门负责运算的模块，本质上和上面的简单电路没什么区别，就是更加复杂而已。&lt;/p>
&lt;p>现在，通过与或非门的组合我们获得了计算能力，计算能力就是这么来的。&lt;/p>
&lt;p>但，只有计算能力是不够的，电路需要能&lt;strong>记得住&lt;/strong>信息。&lt;/p>
&lt;h1 id="神奇的记忆能力">神奇的记忆能力&lt;/h1>
&lt;p>到目前为止，你设计的组合电路比如加法器天生是没有办法存储信息的，它们只是简单的根据输入得出输出，但输入输出总的有个地方能够保存起来，这就是需要电路能保存信息。&lt;/p>
&lt;p>电路怎么能保存信息呢？你不知道该怎么设计，这个问题解决不了你寝食难安，吃饭时在思考、走路时在思考，蹲坑时在思考，直到有一天你在梦中遇一位英国物理学家，他给了你这样一个简单但极其神奇的电路：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d234bf8c-9b05-42cf-91a7-c31bbd32b8c3/640" alt="">&lt;/p>
&lt;p>这是两个 NAND 门的组合，不要紧张，NAND 也是有你设计的与或非门组合而成的，所谓 NAND 门就是与非门，先与然后取非，比如给定输入 1 和 0，那么与运算后为 0，非运算后为 1，这就是与非门，这些不重要。&lt;/p>
&lt;p>比较独特的是该电路的组合方式，&lt;strong>一个 NAND 门的输出是两一个 NAND 门的输入&lt;/strong>，该电路的组合方式会自带一种很有趣的特性，&lt;strong>只要给 S 和 R 段输入 1，那么这个电路只会有两种状态&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>要么 a 端为 1，此时 B=0、A=1、b=0；&lt;/li>
&lt;li>要么 a 端为 0，此时 B=1、A=0、b=1;&lt;/li>
&lt;/ul>
&lt;p>不会再有其他可能了，&lt;strong>我们把 a 端的值作为电路的输出&lt;/strong>。&lt;/p>
&lt;p>此后，你把 S 端置为 0 的话 (R 保持为 1)，那么电路的输出也就是 a 端永远为 1，这时就可以说我们把 1 存到电路中了；而如果你把 R 段置为 0 的话 (S 保持为 1)，那么此时电路的输出也就是 a 端永远为 0，此时我们可以说把 0 存到电路中了。&lt;/p>
&lt;p>就问你神奇不神奇，&lt;strong>电路竟然具备存储信息的能力了&lt;/strong>。&lt;/p>
&lt;p>现在为保存信息你需要同时设置 S 端和 R 端，但你的输入是有一个 (存储一个 bit 位嘛)，为此你对电路进行了简单的改造：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d234bf8c-9b05-42cf-91a7-c31bbd32b8c3/640" alt="">&lt;/p>
&lt;p>这样，当 D 为 0 时，整个电路保存的就是 0，否则就是 1。&lt;/p>
&lt;h1 id="寄存器与内存的诞生">寄存器与内存的诞生&lt;/h1>
&lt;p>现在你的电路能存储一个比特位了，想存储多个比特位还不简单，复制粘贴就可以了：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d234bf8c-9b05-42cf-91a7-c31bbd32b8c3/640" alt="">&lt;/p>
&lt;p>我们管这个组合电路就叫&lt;strong>寄存器&lt;/strong>，你没有看错，我们常说的寄存器就是这个东西。&lt;/p>
&lt;p>你不满足，还要继续搭建更加复杂的电路以存储更多信息，同时提供寻址功能，就这样&lt;strong>内存&lt;/strong>也诞生了。&lt;/p>
&lt;p>寄存器及内存都离不开上一节那个简单电路，只要通电，这个电路中就保存信息，但是断电后很显然保存的信息就丢掉了，&lt;strong>现在你应该明白为什么内存在断电后就不能保存数据了吧&lt;/strong>。&lt;/p>
&lt;h1 id="硬件还是软件">硬件还是软件？&lt;/h1>
&lt;p>现在我们的电路可以计算数据、也可以存储信息，但现在还有一个问题，那就是尽管我们可以用 AND、OR、NOT 表达出所有的逻辑函数，但我们真的有必要把所有的逻辑运算都用与或非门实现出来吗？这显然是不现实的。&lt;/p>
&lt;p>这就好比厨师，你没有听说只专做一道菜的厨师然后酒店要把各个菜系厨师雇全才能做出一桌菜来吧！&lt;/p>
&lt;p>中国菜系博大精深，千差万别，但制作每道菜品的方式大同小异，其中包括刀工、颠勺技术等，这些是基本功，制作每道菜品都要经过这些步骤，变化的也无非就是食材、火候、调料等，这些放到菜谱中即可，这样给厨师一个菜谱他就能制作出任意的菜来，在这里厨师就好比硬件，菜谱就好比软件。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d234bf8c-9b05-42cf-91a7-c31bbd32b8c3/640" alt="">&lt;/p>
&lt;p>同样的道理，&lt;strong>我们没有必要为所有的计算逻辑实现出对应的硬件&lt;/strong>，硬件只需要提供最基本的功能，最终所有的计算逻辑都通过这些最基本的功能用软件表达出来就好，这就是所谓的软件一词的来源，&lt;strong>硬件不可变，但软件可变&lt;/strong>，&lt;strong>不变的是硬件但提供不同的软件就能让硬件实现全新的功能&lt;/strong>，&lt;strong>无比天才的思想&lt;/strong>，人类真的是太聪明了。&lt;/p>
&lt;p>同样一台计算机硬件，安装上 word 你就能编辑文档，安装上微信你就能读到码农的荒岛求生公众号、安装上游戏你就能玩王者农药，硬件还是那套硬件，提供不同的软件就是实现不同的功能，&lt;strong>每次打开电脑使用各种 App 时没有在内心高呼一声牛逼你都对不起计算机这么伟大的发明创造&lt;/strong>，这就是为什么计算机被称为&lt;strong>通用&lt;/strong>计算设备的原因，这一思想是计算机科学祖师爷图灵提出的。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d234bf8c-9b05-42cf-91a7-c31bbd32b8c3/640" alt="">&lt;/p>
&lt;p>扯远了，接下来我们看下硬件是怎么提供所谓的基本功能的。&lt;/p>
&lt;h1 id="硬件的基本功">硬件的基本功&lt;/h1>
&lt;p>让我们来思考一个问题，CPU 怎么能知道自己要去对两个数进行加法计算，以及哪两个数进行加法计算呢？&lt;/p>
&lt;p>很显然，你得告诉 CPU，该怎么告诉呢？还记得上一节中给厨师的菜谱吗？没错，CPU 也需要一张菜谱告诉自己该接下来该干啥，在这里菜谱就是机器指令，指令通过我们上述实现的组合电路来执行。&lt;/p>
&lt;p>接下来我们面临另一个问题，那就是这样的指令应该会很多吧，废话，还是以加法指令为例，你可以让 CPU 计算 1+1，也可以计算 1+2 等等，实际上单单加法指令就可以有无数种组合，显然 CPU 不可能去实现所有的指令。&lt;/p>
&lt;p>实际上 CPU 只需要提供&lt;strong>加法操作&lt;/strong>，你提供&lt;strong>操作数&lt;/strong>就可以了，CPU 说：“我可以打人”，你告诉 CPU 该打谁、CPU 说：“我可以唱歌”，你告诉 CPU 唱什么，CPU 说我可以做饭，你告诉 CPU 该做什么饭，CPU 说：“我可以炒股”，你告诉 CPU 快滚一边去吧韭菜。&lt;/p>
&lt;p>因此我们可以看到 CPU 只提供&lt;strong>机制&lt;/strong>或者说功能 (打人、唱歌、炒菜，加法、减法、跳转)，我们提供&lt;strong>策略&lt;/strong>(打谁、歌名、菜名，操作数，跳转地址)。&lt;/p>
&lt;p>CPU 表达机制就通过指令集来实现的。&lt;/p>
&lt;h2 id="指令集">指令集&lt;/h2>
&lt;p>指令集告诉我们 CPU 可以执行什么指令，每种指令需要提供什么样的操作数。不同类型的 CPU 会有不同的指令集。&lt;/p>
&lt;p>指令集中的指令其实都非常简单，画风大体上是这样的：&lt;/p>
&lt;ul>
&lt;li>从内存中读一个数，地址是 abc&lt;/li>
&lt;li>对两个数加和&lt;/li>
&lt;li>检查一个数是不是大于 6&lt;/li>
&lt;li>把这数存储到内存，地址是 abc&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;p>看上去很像碎碎念有没有，这就是机器指令，我们用高级语言编写的程序，比如对一个数组进行排序，&lt;strong>最终都会等价转换为上面的碎碎念指令，然后 CPU 一条一条的去执行，很神奇有没有&lt;/strong>。&lt;/p>
&lt;p>接下来我们看一条可能的机器指令：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d234bf8c-9b05-42cf-91a7-c31bbd32b8c3/640" alt="">&lt;/p>
&lt;p>这条指令占据 16 比特，其中前四个比特告诉 CPU 这是加法指令，这意味着该 CPU 的指令集中可以包含 2^4 也就是 16 个机器指令，这四个比特位告诉 CPU 该做什么，剩下的 bit 告诉 CPU 该怎么做，也就是把寄存器 R6 和寄存器 R2 中的值相加然后写到寄存器 R6 中。&lt;/p>
&lt;p>可以看到，机器指令是非常繁琐的，现代程序员都使用高级语言来编写程序，关于高级程序语言以及机器指令的话题请参见&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247485439&amp;amp;idx=1&amp;amp;sn=5045e795fe3a881ec719ffd0ea41302a&amp;amp;chksm=fcb980a1cbce09b7cb79cac0964d082bda3f8b94701012ab5fbd911d630bd5fef6017feb6dd9&amp;amp;scene=21#wechat_redirect">《你管这破玩意叫编程语言？&lt;/a>》。&lt;/p>
&lt;h3 id="指挥家让我们演奏一曲">指挥家：让我们演奏一曲&lt;/h3>
&lt;p>现在我们的电路有了计算功能、存储功能，还可以通过指令告诉该电路执行什么操作，还有一个问题没有解决。&lt;/p>
&lt;p>我们的电路有很多部分，用来计算的、用来存储的，以最简单的加法为例，假设我们要计算 1+1，这两个数分别来自寄存器 R1 和 R2，要知道寄存器中可以保存任意值，&lt;strong>我们怎么能确保加法器开始工作时 R1 和 R2 中在这一时刻保存的都是 1 而不是其它数&lt;/strong>？&lt;/p>
&lt;p>即，我们靠什么来协调或者说靠什么来同步电路各个部分让它们协同工作呢？就像一场成功的交响乐演离不开指挥家一样，我们的计算组合电路也需要这样一个指挥家。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d234bf8c-9b05-42cf-91a7-c31bbd32b8c3/640" alt="">&lt;/p>
&lt;p>负责指挥角色的就是时钟信号。&lt;/p>
&lt;p>时钟信号就像指挥家手里拿的指挥棒，&lt;strong>指挥棒挥动一下整个乐队会整齐划一的有个相应动作&lt;/strong>，同样的，时钟信号每一次电压改变，整个电路中的各个寄存器 (也就是整个电路的状态) 会更新一下，这样我们就能确保整个电路协同工作不会这里提到的问题。&lt;/p>
&lt;p>现在你应该知道 CPU 的主频是什么意思了吧，主频是说一秒钟指挥棒挥动了多少次，显然主频越高 CPU 在一秒内完成的操作也就越多。&lt;/p>
&lt;h2 id="大功告成">大功告成&lt;/h2>
&lt;p>现在我们有了可以完成各种计算的 ALU、可以存储信息的寄存器以及控制它们协同工作的时钟信号，这些统称 &lt;strong>Central Processing Unit&lt;/strong>，简称就是 &lt;strong>CPU&lt;/strong>。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>一个小小的开关竟然能构造出功能强大的 CPU ，这背后理论和制造工艺的突破是人类史上的里程碑时刻，说 CPU 是智慧的结晶简直再正确不过。&lt;/p>
&lt;p>本文从一枚开关开始讲解了 CPU 构造的基本原理，希望这篇对大家理解 CPU 有所帮助。&lt;/p>
&lt;h5 id="_参考资料_">&lt;strong>&lt;em>参考资料:&lt;/em>&lt;/strong>&lt;/h5>
&lt;ol>
&lt;li>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247483850&amp;amp;idx=1&amp;amp;sn=b90a78604fa174f0e7314227a3002bdc&amp;amp;chksm=fcb98694cbce0f82024467c835c6e3b4984773b1a2f6c1625d573066c36b14420d996819bed7&amp;amp;scene=21#wechat_redirect">&lt;strong>程序员应如何理解 CPU&lt;/strong>&lt;/a>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247483736&amp;amp;idx=1&amp;amp;sn=4da1eec64e42567a0fdf4ae6d4e9344e&amp;amp;chksm=fcb98606cbce0f10090d950ec468b0a1e28087cd158a850bc7dc4c262fd2612a319851987220&amp;amp;scene=21#wechat_redirect">&lt;strong>？&lt;/strong>&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247485379&amp;amp;idx=1&amp;amp;sn=77ccd2258f0280dfb536ad3d389cd43a&amp;amp;chksm=fcb9809dcbce098b6f89dc59e71cf7fb6af6e5152e40f2f84f7c33ba9ea62e5bc8390ffd0553&amp;amp;scene=21#wechat_redirect">&lt;strong>CPU 空闲时在干嘛？&lt;/strong>&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247484768&amp;amp;idx=1&amp;amp;sn=049db350af9e5eea5cf3523ceb83f447&amp;amp;chksm=fcb9823ecbce0b28ca28d021e68c78138cde4a1b86ea7209c0c667d3d544d223d8b2aecbccec&amp;amp;scene=21#wechat_redirect">&lt;strong>CPU 与进程、线程、操作系统&lt;/strong>&lt;/a>&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/d234bf8c-9b05-42cf-91a7-c31bbd32b8c3/1635558486480-ff327f4a-083d-4ca9-b59f-75bc494e67bf.png" alt="image.png">&lt;/p>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/1pYxnWwmUA33eV2B5A2TjA">
&lt;/a>&lt;/p></description></item></channel></rss>