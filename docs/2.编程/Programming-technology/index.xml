<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Programming technology on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-technology/</link><description>Recent content in Programming technology on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-technology/index.xml" rel="self" type="application/rss+xml"/><item><title>Programming Technology</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-technology/Programming-Technology/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-technology/Programming-Technology/</guid><description>概述 参考：
Programming Technology(编程技术) 包含 XX、YY、etc.
CRUD(增删改查) 参考：
Wiki, CRUD 在计算机编程中，Create、Read、Update、Delete(创建、读取、更新、删除，简称 增删改查(CRUD)) 是持久性存储的四个基本操作。CRUD 有时也用于描述用户界面约定，这些约定便于使用基于计算机的表单和报告查看、搜索和更改信息。这个词很可能是詹姆斯·马丁 (James Martin) 在他的 1983 著作《管理数据库环境》中首次推广的。
Projects(项目) 项目一般就是指开发一个程序。
从写代码的角度看，一个项目就是一个文件夹，该文件夹中包含该项目所需要依赖的第三方库，项目主体的代码，可执行文件等。
前端与后端 后端：一般是用来处理客户端发送的请求，并将前端写的 页面代码 文件，发送给客户端；或者从数据库获取数据，并填充到前端页面中；等等
前端：一般用来展示的，客户端收到的页面文件(比如输入用户名和密码的框，下拉框等等)，都是由前端工程师来写的，一般是 html 等。
前后端交互 前端与后端之间的交互取决于是前后端分离还不分离
前后端不分离时，通常由后端代码渲染 html 等静态资源文件，此时客户端访问的是由后端代码监听的端口 前后端分离时，又分多种情况 将 html 等静态资源放在 Nginx 等可以提供 HTTP 服务的程序中，然后通过后端提供的 API 进行交互，此时客户端访问的是由提供 HTTP 服务程序监听的端口 将 html 等静态资源与后端代码放在一起，这种行为通常称为“XX 语言嵌入静态资源”，此时客户端访问的是由后端程序监听的端口 比如 Go 语言在 1.16 版本中推出的 embed 库即可实现该效果 前后端数据交互 通常来说，HTML 展示出的页面内容中的数据通常分为两大类
静态 动态 在早期互联网不发达的时候，页面内容是不变的，数据也是静态的，但是随着互联网的发展，信息增多，一个页面的数据需要在用户操作时可以变化，此时就需要用到 AJAX 以动态的方式进行数据展示。
现在静态数据的网站已经很少见了，比如 DTCG 卡牌列表（截至 2023.12.19），这种就属于静态数据。静态数据有个弊端，就是哪怕不展示，也是全量加载，比如这个 卡牌列表 网站，虽然也分成了 4 页，但是在访问的时候，实际上是加载了所有页中的所有数据到前端，然后前端通过分页隐藏了其他页的数据。这种做法无形中增加了每次访问的流量，一共 4 页数据全加载了，但是真实情况却并不需要看到。</description></item><item><title>编程范式</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-technology/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-technology/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</guid><description>概述 参考：
Wiki 分类，Programming paradigms(编程范式) 下面这种你属于什么分类？
Scripting language(脚本语言) https://en.wikipedia.org/wiki/Scripting_language Compiled language(编译语言) https://en.wikipedia.org/wiki/Compiled_language 常见编程的非国际定义的标准 为什么那么多公司做前后端分离项目后端响应的 HTTP 状态一律 200？
用于区分内网错误还是外网错误 400、500 被运营商劫持跳转到其他链接 etc. 编程规范 参考：
无法忍受不做单元测试和内卷，我离开了这家在美中国企业 Method Stub 参考：
Wiki, Method stub 在软件开发中，Method stub(方法存根) 是一段代码，用于代替某些其他编程功能</description></item><item><title>Library</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-technology/Library/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-technology/Library/</guid><description>概述 参考：
Wiki, Library(computing) 公众号 - 码农的荒岛求生，动态库和静态库有什么区别？ B 站，动态库和静态库到底有什么区别？ 公众号 - 码农的荒岛求生，动态链接库的实现原理是什么？ B 站，动态链接库的实现原理是什么？ Library(库) 是一个只读资源的集合(collection)，用来实现计算机程序。这个 collection 中通常是很多已经写好的可复用的代码，类似于代码中的 Function。相对代码文件中的 Function、Library 则更像是存在于代码文件外部的 Function，表现一种可执行代码的 Binary(二进制) 文件、纯文本代码文件，甚至随着发展，还可能包括图像。
e.g. 程序可以使用 Library 来间接进行 System Call，而不是直接在程序中编写系统调用的相关代码。
一个 Library 可以被多个独立的使用者（程序、其他 Library）使用以，modular(模块化) 的方式 code reuse(重用代码)。
Static lib 与 Dynamic lib Library 通常分为两大类
Static lib(静态库) # 编译程序时，将 Library 打包进最终的可执行文件 通常可以通过代码中使用 import、etc. 关键字在文件开头导入，各种语言和环境的 Library 形态不太一样。有的语言直接把代码源码放到本地，编译时引用；有的语言会把代码编译成 .a、.lib 文件，在编译时引用；etc. Dynamic lib(动态库) # 程序运行时，将 Library 加载到内存中 通常以文件的形式。Linux 中文件后缀为 .so，Windows 中文件后缀为 .dll。 Linker 参考:</description></item><item><title>排序</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-technology/%E6%8E%92%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-technology/%E6%8E%92%E5%BA%8F/</guid><description>概述 参考：
各种排序方法演示： https://www.bilibili.com/video/BV1Tk4y1v7SJ Selection Sort(选择排序)
Insertion Sort(插入排序)
Quick Sort(LR prts)(快速排序)
Merge Sort(归并排序)
Heap Sort(堆排序)
Radlx Sort(MSD 基数排序)
std::sort()
std::stable_sort()
Shell Sort(希尔排序)
Bubble Sort(冒泡排序)
Gnome Sort()
Bitnoic Sort
Bogo Sort</description></item><item><title>设计模式</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-technology/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-technology/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description>概述 参考：
Wiki, Design pattern 菜鸟教程，设计模式 mohuishou，Go 设计模式24-总结 掘金，设计模式 Design pattern(设计模式) 代表了最佳的实践。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。
1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）一书，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）匿名著称。
有关软件设计模式的定义很多，有些从模式的特点来说明，有些从模式的作用来说明。本教程给出的定义是大多数学者公认的，从以下两个方面来说明。
1. 软件设计模式的概念 软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。
2. 学习设计模式的意义 设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。正确使用设计模式具有以下优点：
可以提高程序员的思维能力、编程能力和设计能力。 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。 当然，软件设计模式只是一个引导。在具体的软件开发中，必须根据设计的应用系统的特点和要求来恰当选择。对于简单的程序开发，可能写一个简单的算法要比引入某种设计模式更加容易。但对大项目的开发或者框架设计，用设计模式来组织代码显然更好。
装饰模式 Decorator(装饰器)
策略模式 用来解决过多 if else 逻辑的模式
// 假如现在有如下条件 if FirstCondition { // 条件一 } else if SecondCondition { // 条件二 } 策略指：当满足 XX 条件，执行 YY 行为。
也就是说，可以将上面的 if else 中的 Condition(条件) 转为 Strategy(策略，i.</description></item><item><title>ORM</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-technology/ORM/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-technology/ORM/</guid><description>概述 参考：
Wiki, Object–relational mapping C 语言中文网，ORM 是什么 B 站-哔哩哔哩技术，如何用 go 实现一个 ORM（为什么需要 ORM） Object Relational Mapping(对象关系映射，简称 ORM) 是一种用于在关系数据库和面向对象变成语言之间转换数据的编程技术。解决了代码和关系型数据库之间的数据交互问题。这实际上创建了一个可以在编程语言中使用的虚拟对象数据库。
为什么需要 ORM 直接使用 database/sql 的痛点：
首先看看用 database/sql 如何查询数据库。
我们用 user 表来做例子，一般的工作流程是先做技术方案，其中排在比较前面的是数据库表的设计，大部分公司应该有严格的数据库权限控制，不会给线上程序使用比较危险的操作权限，比如创建删除数据库，表，删除数据等。
表结构如下：
CREATE TABLE `user` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &amp;#39;id&amp;#39;, `name` varchar(100) NOT NULL COMMENT &amp;#39;名称&amp;#39;, `age` int(11) NOT NULL DEFAULT &amp;#39;0&amp;#39; COMMENT &amp;#39;年龄&amp;#39;, `ctime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &amp;#39;创建时间&amp;#39;, `mtime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &amp;#39;更新时间&amp;#39;, PRIMARY KEY (`id`), ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 首先我们要写出和表结构对应的结构体 User，如果你足够勤奋和努力，相应的 json tag 和注释都可以写上，这个过程无聊且重复，因为在设计表结构的时候你已经写过一遍了。</description></item><item><title>SDK 开发</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-technology/SDK-%E5%BC%80%E5%8F%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-technology/SDK-%E5%BC%80%E5%8F%91/</guid><description>概述 参考：
经典的 SDK 设计方式 https://github.com/huaweicloud/huaweicloud-sdk-go-v3 https://github.com/wujiyu115/yuqueg 目录结构示例
pkg/my_sdk/ ├── README.md ├── core │ ├── v1 │ │ └── client.go │ └── v2 │ ├── client.go │ └── log.go ├── index.go ├── services │ ├── v1 │ │ ├── book.go │ │ └── models │ │ ├── model_request.go │ │ └── model_response.go │ └── v2 │ ├── doc.go │ ├── group.go │ ├── models │ │ ├── model_request.go │ │ └── model_response.</description></item><item><title>代码提交规范</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-technology/%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-technology/%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/</guid><description>概述 参考：
GitHub 项目，conventional-commits/conventionalcommits.org https://www.conventionalcommits.org/zh-hans/v1.0.0/ 约定式提交规范是一种基于提交信息的轻量级约定。 它提供了一组简单规则来创建清晰的提交历史； 这更有利于编写自动化工具。 通过在提交信息中描述功能、修复和破坏性变更， 使这种惯例与 SemVer 相互对应。</description></item></channel></rss>