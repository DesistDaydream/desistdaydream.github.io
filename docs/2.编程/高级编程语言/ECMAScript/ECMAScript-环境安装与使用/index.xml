<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – ECMAScript 环境安装与使用</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><description>Recent content in ECMAScript 环境安装与使用 on 断念梦</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: ECMAScript 环境安装与使用</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>有两种运行时环境可以运行 ECMAScript 代码(Javascript、Typescript)&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Browser&lt;/strong># 浏览器就是 ECMAScript 的运行时环境。&lt;/li>
&lt;li>&lt;strong>Node.js&lt;/strong> # 在服务器或 PC 上安装 Node.js 环境以运行 ECMAScript 代码
&lt;ul>
&lt;li>&lt;strong>Deno&lt;/strong> # &lt;a href="https://github.com/denoland/deno">GtiHub 项目，denoland/deno&lt;/a>。据说要替代 Node.js，很尴尬的是。。。早期 18 年的 issue 中被各种国人无意义灌水&lt;/li>
&lt;li>&lt;strong>Bun&lt;/strong> # &lt;a href="https://github.com/oven-sh/bun">GtiHub 项目，oven-sh/bun&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>但是这两者可以提供的 API 能力各不相同&lt;/p>
&lt;ul>
&lt;li>Browser 可以提供的 dockument、window 和其他关于 DOM 或其他 Web 平台 API 的对象。&lt;/li>
&lt;li>Node.js 则可以提供很多操作系统相关的 API，比如文件的读写、进程管理、网络通信等等。&lt;/li>
&lt;/ul>
&lt;p>Node.js 与 Browser 都是基于 Chrome V8 引擎的 ECMAScript 运行时环境&lt;/p>
&lt;p>你也许会想，直接在我的硬盘上创建好 HTML 和 JavaScript 文件，然后用浏览器打开，不就可以看到效果了吗？&lt;/p>
&lt;p>这种方式运行部分 JavaScript 代码没有问题，但由于浏览器的安全限制，以 file:// 开头的地址无法执行如联网等 JavaScript 代码，最终，你还是需要架设一个 Web 服务器，然后以 http:// 开头的地址来正常执行所有 JavaScript 代码。&lt;/p>
&lt;p>所以，想要运行 JavaScript 编写的静态文件，通常都需要一个可以提供 HTTP 服务的程序，以便响应客户端的请求返回这些静态文件。通常在生产环境中，我们都会将静态资源文件放到 Nginx 的目录中，由 Nginx 为客户端提供 HTTP 服务。&lt;/p>
&lt;p>而本地测试时，我们通过 npm 工具即可安装一个简易的 HTTP 服务，这个 HTTP 服务都是由 JS 代码写的，必须要保证本地有 Node.js 环境，即可启动一个 HTTP 服务&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Npm 安装 http-server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># npm install http-server&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>http-server 来源于 &lt;a href="https://github.com/http-party/http-server">GitHub 项目，http-party/http-server&lt;/a>&lt;/p>
&lt;p>通过 &lt;code>npm exec serve&lt;/code> 命令将会安装另一个名为 serve 的库以运行 HTTP 服务，默认在 3000 端口上启动 HTTP 服务，通过浏览器访问 localhost:3000 即可获取到所有自己编写的静态文件，便于让开发人员在本地调试。&lt;/p>
&lt;h2 id="重点运行具有-module模块-功能的静态资源">(重点)运行具有 Module(模块) 功能的静态资源&lt;/h2>
&lt;p>从 &lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript%20%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85.md">ECMAScript 模块与包&lt;/a> 章节可以看到，当我们使用 &lt;code>import name from './one.js'&lt;/code> 导入的模块是一个文件时，那么这个文件将会被响应给浏览器，如果使用 &lt;code>import name from 'one'&lt;/code> 导入的模块是一组文件时，此时浏览器无法直接识别，将会产生报错。因为浏览器想要执行这一组文件需要发起很多次的请求将所有文件都加载到本地，这其中的路由路径将是不可答的。&lt;/p>
&lt;p>所以，此时我们则需要想办法将这&lt;strong>一组文件变为一个文件&lt;/strong>响应给浏览器以便加载代码。这个转换的操作，我们可以使用打包工具(i.e.Webpack、&lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript%20%E5%B7%A5%E5%85%B7/Vite.md">Vite&lt;/a> 等等) 将源代码&lt;strong>打包编译&lt;/strong>成新的静态文件即可。&lt;/p>
&lt;p>后面的逻辑，与基本运行 ECMAScript 代码的行为就是一样的了。&lt;/p>
&lt;h2 id="使用-vite-运行-ecmascript-代码">使用 Vite 运行 ECMAScript 代码&lt;/h2>
&lt;p>npm、yarn 的打包后运行代码的速度非常缓慢，才是推荐使用 Vite 工具启动 HTTP 服务并运行 JS/TS 代码，详见：&lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript%20%E5%B7%A5%E5%85%B7/Vite.md">《Vite》&lt;/a> 章节&lt;/p>
&lt;h2 id="运行-typesript">运行 TypeSript&lt;/h2>
&lt;p>Node.js 和 浏览器都无法直接运行 TypeScript 代码，这是因为 TS 的代码需要先转换为 JS 代码才可以运行。此时就需要一种工具，先转换再运行，或者直接转换运行一体。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>tsc&lt;/strong> # 将 TS 代码转换为 JS 代码。&lt;code>npm install -g typescript&lt;/code>&lt;/li>
&lt;li>&lt;strong>ts-node&lt;/strong> # 可以直接转换并运行 TS 代码，&lt;code>npm install -g ts-node&lt;/code> 安装即可&lt;/li>
&lt;li>&lt;strong>ts-node-esm&lt;/strong> # ts-node 执行 TS 代码有时候会报错 &lt;code>TypeError [ERR_UNKNOWN_FILE_EXTENSION]: Unknown file extension &amp;quot;.ts&amp;quot;&lt;/code>，此时就需要 ts-node-esm 工具。&lt;/li>
&lt;/ul>
&lt;h1 id="nodejs">Node.js&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://nodejs.org/en/">org 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://nodejs.dev/">dev 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://nodejs.cn/">dev 官网中文翻译&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Node.js">Wiki，Node.js&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Node.js 是基于 Chrome V8 引擎的 ECMAScript 运行时环境，由 RyanDahl 于 2009 年 5 月 27 日发布。转年(i.e.2010 年 1 月)，为 Node.js 环境引入了一个名为 npm 的包管理器。包管理器使程序员更容易发布和共享 Node.js 的源代码，旨在简化包的安装、更新、卸载。&lt;/p>
&lt;p>Browser 和 Node.js 都是 ECMAScript 的运行时环境，但是这两者可以提供的 API 能力各不相同&lt;/p>
&lt;ul>
&lt;li>Browser 可以提供的 dockument、window 和其他关于 DOM 或其他 Web 平台 API 的对象。&lt;/li>
&lt;li>Node.js 则可以提供很多操作系统相关的 API，比如文件的读写、进程管理、网络通信等等。&lt;/li>
&lt;/ul>
&lt;p>通过 Node.js，可以让我们使用一种语言编写前端与后端。我们甚至可以通过 npm 与 yarn 安装第三方库后，使用 Node.js 在本地监听端口并响应给客户端静态资源文件。&lt;/p>
&lt;h2 id="安装-nodejs">安装 Node.js&lt;/h2>
&lt;h3 id="linux">Linux&lt;/h3>
&lt;p>从&lt;a href="https://nodejs.org/zh-cn/download/">官网&lt;/a>下载 Linux 版的 &lt;code>.tar.xg&lt;/code> 包，并解压&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export NodejsVersion&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;v18.15.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://nodejs.org/dist/&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>/node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64.tar.xz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo tar -xvf node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64.tar.xz -C /usr/local/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo mv /usr/local/node-&lt;span style="color:#e6db74">${&lt;/span>NodejsVersion&lt;span style="color:#e6db74">}&lt;/span>-linux-x64 /usr/local/nodejs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置环境变量&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo tee /etc/profile.d/nodejs.sh &amp;gt; /dev/null &amp;lt;&amp;lt;-&lt;span style="color:#e6db74">&amp;#34;EOF&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>$PATH:/usr/local/nodejs/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>EOF
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>source /etc/profile.d/nodejs.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="windows">Windows&lt;/h3>
&lt;p>警告！！！由于 msi 安装包会修改 &lt;code>$PREFIX&lt;/code> 为 &lt;code>%APPDATA%\npm&lt;/code> ，并将该目录到 $PATH。我个人推荐下载 zip，并自己解压到想要的位置后，手动配置环境变量。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>$NodejsVersion = &lt;span style="color:#e6db74">&amp;#34;20.11.1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$NodejsUrl = &lt;span style="color:#e6db74">&amp;#34;https://nodejs.org/dist/v&lt;/span>$NodejsVersion&lt;span style="color:#e6db74">/node-v&lt;/span>$NodejsVersion&lt;span style="color:#e6db74">-win-x64.zip&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$TempZipFile = &lt;span style="color:#e6db74">&amp;#34;D:\tmp\nodejs.zip&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ExtractPath = &lt;span style="color:#e6db74">&amp;#34;D:\Tools&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Download the zip file to a temporary location&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Invoke-WebRequest -Uri $NodejsUrl -OutFile $TempZipFile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Extract the contents of the zip file to the installation directory and rename the top-level directory to &amp;#34;nodejs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Expand-Archive -Path $TempZipFile -DestinationPath $ExtractPath
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Rename-Item -Path &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$ExtractPath&lt;span style="color:#e6db74">\node-v&lt;/span>$NodejsVersion&lt;span style="color:#e6db74">-win-x64&amp;#34;&lt;/span> -NewName &lt;span style="color:#e6db74">&amp;#34;nodejs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将 nodejs/ 目录添加到用户的 PATH 环境变量中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>$path = [&lt;span style="color:#66d9ef">Environment&lt;/span>]::GetEnvironmentVariable(&lt;span style="color:#e6db74">&amp;#34;Path&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;User&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$newPath = &lt;span style="color:#e6db74">&amp;#34;D:\Tools\nodejs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#66d9ef">Environment&lt;/span>]::SetEnvironmentVariable(&lt;span style="color:#e6db74">&amp;#34;Path&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$path&lt;span style="color:#e6db74">;&lt;/span>$newPath&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;User&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="目录结构">目录结构&lt;/h3>
&lt;p>Linux 目录结构，node_modules/ 目录在 lib/ 目录下，这点与 Windows 不同。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># tree -L 2 -F&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── bin/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── corepack -&amp;gt; ../lib/node_modules/corepack/dist/corepack.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── node*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── npm -&amp;gt; ../lib/node_modules/npm/bin/npm-cli.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── npx -&amp;gt; ../lib/node_modules/npm/bin/npx-cli.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── pnpm -&amp;gt; ../lib/node_modules/corepack/dist/pnpm.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── pnpx -&amp;gt; ../lib/node_modules/corepack/dist/pnpx.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── yarn -&amp;gt; ../lib/node_modules/corepack/dist/yarn.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── yarnpkg -&amp;gt; ../lib/node_modules/corepack/dist/yarnpkg.js*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── CHANGELOG.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── include/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── node/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── lib/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── node_modules/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── LICENSE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── README.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── share/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── doc/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── man/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── systemtap/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Windows 目录结构&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ tree -L &lt;span style="color:#ae81ff">2&lt;/span> -F
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── CHANGELOG.md*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── LICENSE*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── README.md*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── corepack*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── corepack.cmd*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── install_tools.bat*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── node.exe*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── node_etw_provider.man*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── node_modules/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── corepack/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── npm/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── nodevars.bat*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── npm*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── npm.cmd*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── npx*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── npx.cmd*
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="nvm">NVM&lt;/h3>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/nvm-sh/nvm">GitHub 项目，nvm-sh/nvm&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Node Version Manager(Node.js 版本管理器，简称 NVM)&lt;/strong>&lt;/p>
&lt;h2 id="nodejs-关联文件与配置">Node.js 关联文件与配置&lt;/h2>
&lt;p>详见：&lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript%20%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86.md#npm%20%E5%85%B3%E8%81%94%E6%96%87%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE">npm 关联文件与配置&lt;/a>&lt;/p>
&lt;h2 id="常见问题">常见问题&lt;/h2>
&lt;p>记录于 2024.1.15: 下面这些问题，最好都不要去解决了，使用 Deno 去吧！！！&lt;/p>
&lt;h3 id="nodejs-无法使用-es6-语法问题">Node.js 无法使用 ES6 语法问题&lt;/h3>
&lt;p>在使用 import 语法导入包的代码中，使用 node 命令运行，报错: &lt;code>SyntaxError: Cannot use import statement outside a module&lt;/code>。&lt;/p>
&lt;p>本质上上 Node.js 默认无法使用 import 关键字导入模块。参考 &lt;a href="https://nodejs.org/docs/latest-v16.x/api/esm.html#enabling">https://nodejs.org/docs/latest-v16.x/api/esm.html#enabling&lt;/a>，在 package.json 文件中设置 &lt;code>&amp;quot;type&amp;quot;: &amp;quot;module&amp;quot;&lt;/code> 或者使用 &lt;code>--input-type=module&lt;/code> 命令行参数以告诉 Node.js 使用 ECMAScript 模块加载器。默认情况下，Node.js 使用 CommonJS 模块加载器。&lt;/p>
&lt;h3 id="ts-node-无法执行-ts-脚本">ts-node 无法执行 .ts 脚本&lt;/h3>
&lt;p>报错: &lt;code>TypeError [ERR_UNKNOWN_FILE_EXTENSION]: Unknown file extension &amp;quot;.ts&amp;quot;&lt;/code>&lt;/p>
&lt;p>&lt;a href="https://stackoverflow.com/questions/62096269/cant-run-my-node-js-typescript-project-typeerror-err-unknown-file-extension">https://stackoverflow.com/questions/62096269/cant-run-my-node-js-typescript-project-typeerror-err-unknown-file-extension&lt;/a>&lt;/p>
&lt;p>在这里有讨论&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/TypeStrong/ts-node/issues/935">https://github.com/TypeStrong/ts-node/issues/935&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/TypeStrong/ts-node/issues/1007#issuecomment-1163471306">https://github.com/TypeStrong/ts-node/issues/1007#issuecomment-1163471306&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>这是因为我们在 package.json 中使用了 &lt;code>&amp;quot;type&amp;quot;: &amp;quot;module&amp;quot;&lt;/code> 配置，所以需要删除该配置。若是不想删除该配置，则可以在 &lt;code>tsconfig.json&lt;/code> 文件中添加如下配置&lt;/p>
&lt;pre tabindex="0">&lt;code> &amp;#34;compilerOptions&amp;#34;: {
&amp;#34;esModuleInterop&amp;#34;: true,
}
&lt;/code>&lt;/pre>&lt;p>然后使用 &lt;code>ts-node-esm&lt;/code> 命令而不是 ts-node 命令执行 .ts 脚本。&lt;/p>
&lt;h3 id="nodejs-运行-es6-语法的-ts-代码">Node.js 运行 ES6 语法的 TS 代码&lt;/h3>
&lt;p>综合上面两个问题，保证 package.json 和 tsconfig.json 的最低配置。同时使用 &lt;code>ts-node-esm&lt;/code> 命令运行 .ts 文件。&lt;/p>
&lt;p>package.json&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;module&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>tsconfig.json&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;compilerOptions&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// &amp;#34;target&amp;#34;: &amp;#34;es2016&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">&amp;#34;module&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;ES6&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;esModuleInterop&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Notes: 有的时候 TS 依赖库还依赖原始的 JS 库，所以也要同时安装 JS 库。crypto-js 就是这个情况，要想使用 &lt;code>ts-node-esm&lt;/code> 正常运行代码， package.json 至少需要如下内容：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;module&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;dependencies&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;@types/crypto-js&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;^4.2.1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;crypto-js&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;^4.2.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="deno">Deno&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/denoland/deno">GitHub 项目，denoland/deno&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/denolib/awesome-deno">GitHub 项目，denolib/awesome-deno&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ruanyifeng.com/blog/2020/01/deno-intro.html">阮一峰，Deno 运行时入门教程：Node.js 的替代品&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.deno.com/runtime/manual/references/vscode_deno/">https://docs.deno.com/runtime/manual/references/vscode_deno/&lt;/a> VSCode 中使用 Deno 的方式&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Deno 也是一个服务器运行时，但是支持多种语言，可以直接运行 JavaScript、TypeScript 和 WebAssembly 程序。&lt;/p>
&lt;p>它内置了 V8 引擎，用来解释 JavaScript。同时，也内置了 tsc 引擎，解释 TypeScript。它使用 Rust 语言开发，由于 Rust 原生支持 WebAssembly，所以它也能直接运行 WebAssembly。它的异步操作不使用 libuv 这个库，而是使用 Rust 语言的 &lt;a href="https://github.com/tokio-rs/tokio">Tokio&lt;/a> 库，来实现事件循环（event loop）。&lt;/p>
&lt;blockquote>
&lt;p>内置了 V8 引擎意味着可以随时随地运行那些依赖浏览器环境的库，再也不用在 js 代码中补浏览器环境了！内置了 tsc 引擎意味着再也不用面临 Node.js 那些让人头痛的无法运行 .ts 的问题。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Deno 运行代码时，并不依赖 tsconfig.json 文件或 package.json 文件。不用面临 CommonJS 和 ES6 语法的冲突配置问题。&lt;/p>
&lt;/blockquote>
&lt;p>Deno 甚至可以通过命令行工具的 &lt;code>deno compile&lt;/code> 命令将程序编译成可执行的二进制文件（比如 windows 下就是 .exe 文件），然后直接执行！！就像 Go 的二进制文件一样。如果是编译了一个使用浏览器操作的文件，那么就会在 Shell 中显示像浏览器似的控制，浏览器弹窗就是 Shell 中的等待输入，诸如此类的效果。&lt;/p>
&lt;h2 id="安装-deno">安装 Deno&lt;/h2>
&lt;p>从 &lt;a href="https://github.com/denoland/deno/releases">Release&lt;/a> 处下载 Deno 二进制文件后即可直接使用。非常简单，&lt;a href="https://github.com/denoland/deno/releases/download/v1.39.4/deno-x86_64-pc-windows-msvc.zip">deno-x86_64-pc-windows-msvc.zip&lt;/a> 就是一个非常简单直接的二进制文件，放到 $PATH 中即可直接使用。&lt;/p>
&lt;h2 id="deno-关联文件与配置">Deno 关联文件与配置&lt;/h2>
&lt;p>&lt;strong>deno.json&lt;/strong> # 适用于每个项目的配置文件&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.deno.com/runtime/manual/getting_started/configuration_file">https://docs.deno.com/runtime/manual/getting_started/configuration_file&lt;/a> 这是关于 deno.json 文件的官方文档&lt;/li>
&lt;li>&lt;a href="https://github.com/denoland/fresh/blob/main/deno.json">https://github.com/denoland/fresh/blob/main/deno.json&lt;/a> 典型使用示例。其中有 import map 的用法。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>${DENO_DIR}&lt;/strong> # Deno 的缓存目录。类似于 GOPATH。可以通过 &lt;code>deno info&lt;/code> 命令查看当前具体目录。&lt;code>Windows 默认值: %LocalAppData%/deno/&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./deps/&lt;/strong> # Deno 直接管理的远程模块缓存数据保存路径。通常根据协议分为 https 和 http 等目录。有点类似 go 中的 &lt;code>${GOPATH}/pkg/&lt;/code> 目录
&lt;ul>
&lt;li>&lt;strong>./https/${DOMAIN}/&lt;/strong> # 依赖包保存在其所在域名的同名目录下。有点类似 go 中的 &lt;code>${GOPATH}/pkg/mod/${DOMAIN}&lt;/code> 目录&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>./npm/&lt;/strong> # Deno 适配 package.json 文件后，npm 模块缓存数据保存路径。TODO: 待确认？&lt;/li>
&lt;li>&lt;strong>./gen/&lt;/strong> # Emitted 模块缓存数据保存路径。TODO: 这是啥？是构建或运行时生成的数据吗？&lt;/li>
&lt;li>&lt;strong>./registries/&lt;/strong> # Language server registries cache 这是啥？&lt;/li>
&lt;li>&lt;strong>./location_data/&lt;/strong> # Origin storage 这是啥？&lt;/li>
&lt;/ul>
&lt;h2 id="模块与包">模块与包&lt;/h2>
&lt;p>&lt;a href="https://deno.land/x">https://deno.land/x&lt;/a> 是 Deno 第三方模块的托管仓库，就像 &lt;a href="https://pkg.go.dev/">https://pkg.go.dev/&lt;/a> 。Deno 可以从网络上的任何位置导入模块，例如 GitHub，个人网络服务器或 ESM.SH，SKYPACK，JSPM.IO 或 JSDELIVR 等 CDN。为了使消费第三方模块更容易，Deno 提供了一些内置的工具，例如 Deno Info 和 Deno Doc。&lt;/p>
&lt;p>&lt;a href="https://deno.land/std">https://deno.land/std&lt;/a> 是 Deno 的标准库&lt;/p>
&lt;p>Deno 有一个类似 go 一样的命令行工具 deno，内置了开发者需要的各种功能，不再需要外部工具。打包、格式清理、测试、安装、文档生成、linting、脚本编译成可执行文件等，都有专门命令。&lt;/p>
&lt;p>直接运行 deno 命令，也可直接进入 REPL &lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83.md">编程环境&lt;/a>。&lt;/p>
&lt;h3 id="兼容-node-和-npm-模块">兼容 Node 和 npm 模块&lt;/h3>
&lt;p>&lt;a href="https://docs.deno.com/runtime/manual/node">https://docs.deno.com/runtime/manual/node&lt;/a> 这里可以找到 Deno 兼容 Node 和 npm 模块的方式。当前有三种方式&lt;/p>
&lt;ul>
&lt;li>在 import 关键字语法中，使用 npm 和 node 修饰符，比如 &lt;code>import CryptoJS from &amp;quot;npm:crypto-js&amp;quot;&lt;/code>
&lt;ul>
&lt;li>从 1.28 版本开始，Deno 可以直接使用 Nodejs 语法的 import 以导入想要使用的包（e.g. &lt;code>import CryptoJS from &amp;quot;npm:crypto-js&amp;quot;&lt;/code>）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>读取 &lt;a href="https://docs.deno.com/runtime/manual/node/package_json">package.json 文件&lt;/a>，import 关键字中的语法不用变化。但是要让 package.json 文件中包含依赖包信息&lt;/li>
&lt;li>通过 &lt;a href="https://docs.deno.com/runtime/manual/node/cdns">CDN&lt;/a> 使用 npm 包。&lt;/li>
&lt;/ul>
&lt;p>通过上面前两种方法使用 Deno 运行代码时，会自动创建 node_moduels/ 目录，并将 npm 依赖保存其中&lt;/p>
&lt;p>TODO: Deno 从哪里下载 npm 模块？从 &lt;a href="https://registry.npmjs.org/">https://registry.npmjs.org/&lt;/a>？ 比如 crypto-js，从 &lt;a href="https://registry.npmjs.org/crypto-js">https://registry.npmjs.org/crypto-js&lt;/a> 下载？&lt;/p>
&lt;h1 id="初始化项目">初始化项目&lt;/h1>
&lt;h2 id="javascript-项目初始化">JavaScript 项目初始化&lt;/h2>
&lt;p>&lt;code>pnpm init&lt;/code> 会生成 package.json 文件。&lt;/p>
&lt;h2 id="typescript-项目初始化">TypeScript 项目初始化&lt;/h2>
&lt;p>使用 &lt;code>npm install -g typescript&lt;/code> 安装 tsc 命令。&lt;/p>
&lt;p>使用 &lt;code>tsc init&lt;/code> 命令将会生成 &lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/TSConfig.md">TSConfig&lt;/a> 文件。&lt;/p>
&lt;h2 id="框架初始化">框架初始化&lt;/h2>
&lt;p>npm 等包管理工具下载完框架后，会自动生成项目目录，这些目录是已经初始化完成的项目，包含了很多必要的文件，比如 package.json 等。&lt;/p>
&lt;p>随着学习深入，会逐步总结一个前端项目如果不使用框架从头构建的话会需要什么。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>public/&lt;/strong> 目录存放公共资源&lt;/li>
&lt;li>&lt;strong>src/&lt;/strong> # 所有代码都在 src/ 目录下&lt;/li>
&lt;li>&lt;strong>.eslintrc.cjs&lt;/strong> # ESLint 程序配置&lt;/li>
&lt;li>&lt;strong>.prettierc.json&lt;/strong> # Prettier 插件的配置&lt;/li>
&lt;li>&lt;strong>env.d.ts&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>index.html&lt;/strong> # 程序入口&lt;/li>
&lt;li>&lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/package.json.md">&lt;strong>package.json&lt;/strong>&lt;/a> # 包管理器配置文件，比如 npm、pnpm 等&lt;/li>
&lt;li>&lt;strong>vite.config.ts&lt;/strong> # Vite 程序给项目打包时使用的配置&lt;/li>
&lt;li>&lt;strong>tsconfig.json&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>tsconfig.config.json&lt;/strong> # &lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/TSConfig.md">TSConfig&lt;/a> 文件&lt;/li>
&lt;/ul>
&lt;h1 id="编译与打包">编译与打包&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/webpack/webpack">GitHub 项目，webpack/webpack&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/rollup/rollup">GitHub 项目，rollup/rollup&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>前端代码通常是直接在某个运行环境中执行代码，并不需要 Compile(编译) 代码，而是通过一种称为 &lt;strong>Bundle(打包)&lt;/strong> 的行为，将多个 JS、HTMl、CSS 等文件组合成一个文件，实现这个行为的称为 &lt;strong>Bundler(打包器)&lt;/strong>&lt;/p>
&lt;p>为什么需要打包呢？在 &lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript%20%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85.md">ECMAScript 模块与包&lt;/a> 中的 “浏览器中使用 ESM 的常见问题” 可以看到，浏览器自身是没法自动导入某个依赖库的，所以想要在浏览器中运行 JS 代码，就需要吧依赖库与本身的 JS 文件打包起来，形成一个或一组 JS 文件，这时，浏览器再执行 import 时，就从这些已打包的文件中查找，就可以找到相关依赖了。&lt;/p>
&lt;p>打包工具有很多：&lt;/p>
&lt;ul>
&lt;li>Webpack&lt;/li>
&lt;li>Rollup&lt;/li>
&lt;li>&lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript%20%E5%B7%A5%E5%85%B7/Vite.md">Vite&lt;/a>&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;等等&lt;/li>
&lt;/ul>
&lt;h2 id="webpack">Webpack&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/webpack/webpack">GitHub 项目，webpack/webpack&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: ECMAScript 模块与包</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript-%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript-%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">MDN-参考，JavaScript-JavaScript 指南-JavaScript 模块&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wangdoc.com/es6/module.html">网道，ES6 教程-Module 的语法&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhangxinxu.com/wordpress/2018/08/browser-native-es6-export-import-module/">https://www.zhangxinxu.com/wordpress/2018/08/browser-native-es6-export-import-module/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>历史上，JavaScript 一直没有 &lt;strong>Module(模块)&lt;/strong> 体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的 require、Python 的 import，甚至就连 CSS 都有 @import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。&lt;/p>
&lt;p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 2009 年 1 月发起的 CommonJS 和 AMD 两种，前者用于服务器，后者用于浏览器。&lt;/p>
&lt;blockquote>
&lt;p>2013 年 5 月，npm 的作者宣布 Node.js 已经废弃 CommonJS，详见 &lt;a href="https://github.com/nodejs/node-v0.x-archive/issues/5132#issuecomment-15432598">GitHub issue-5132，nodejs/node-v0.x-archive&lt;/a> &amp;gt; &lt;a href="https://en.wikipedia.org/wiki/Asynchronous_module_definition">Wiki，Asynchronous_module_definition&lt;/a>(异步模块定义，简称 AMD)&lt;/p>
&lt;/blockquote>
&lt;p>比如，CommonJS 模块就是对象，输入时必须查找对象属性。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// CommonJS 标准
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> { &lt;span style="color:#a6e22e">stat&lt;/span>, &lt;span style="color:#a6e22e">exists&lt;/span>, &lt;span style="color:#a6e22e">readfile&lt;/span> } &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">require&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;fs&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 等同于 js 代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">_fs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">require&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;fs&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">stat&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">_fs&lt;/span>.&lt;span style="color:#a6e22e">stat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">exists&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">_fs&lt;/span>.&lt;span style="color:#a6e22e">exists&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">readfile&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">_fs&lt;/span>.&lt;span style="color:#a6e22e">readfile&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面代码的实质是整体加载 fs 模块（即加载 fs 的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。&lt;/p>
&lt;h2 id="es6-module">ES6 Module&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://beginor.github.io/2021/08/16/using-es-modules-in-borwser-with-importmaps.html">https://beginor.github.io/2021/08/16/using-es-modules-in-borwser-with-importmaps.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>ES6 Module(ES6 模块，简称 ESM)&lt;/strong>，ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。这种模块功能与 ES6 一起发布于 2015 年&lt;/p>
&lt;p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。&lt;/p>
&lt;p>通常来说，&lt;strong>一个模块指的一组文件的合集&lt;/strong>，只不过在通过编译工具编译后，将合并成一个文件。&lt;/p>
&lt;p>ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ES6 模块
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">import&lt;/span> { &lt;span style="color:#a6e22e">stat&lt;/span>, &lt;span style="color:#a6e22e">exists&lt;/span>, &lt;span style="color:#a6e22e">readFile&lt;/span> } &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面代码的实质是从 fs 模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。&lt;/p>
&lt;blockquote>
&lt;p>只支持相对路径或者绝对路径下的 ES 模块 (./, ../, /, http://, https://) ， 同时也受服务器跨域请求策略、 HTTPS 策略的约束。&lt;/p>
&lt;/blockquote>
&lt;p>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。&lt;/p>
&lt;p>除了静态加载带来的各种好处，ES6 模块还有以下好处。&lt;/p>
&lt;ul>
&lt;li>不再需要 UMD 模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。&lt;/li>
&lt;li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者 navigator 对象的属性。&lt;/li>
&lt;li>不再需要对象作为命名空间（比如 Math 对象），未来这些功能可以通过模块提供。&lt;/li>
&lt;/ul>
&lt;h2 id="import">import&lt;/h2>
&lt;p>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&lt;/a>&lt;/p>
&lt;h2 id="import-maps">Import maps&lt;/h2>
&lt;p>&lt;a href="https://beginor.github.io/2021/08/16/using-es-modules-in-borwser-with-importmaps.html">https://beginor.github.io/2021/08/16/using-es-modules-in-borwser-with-importmaps.html&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">script&lt;/span> &lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;importmap&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;imports&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;vue&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;https://unpkg.com/vue@3/dist/vue.esm-browser.js&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">script&lt;/span> &lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;module&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">import&lt;/span> { &lt;span style="color:#a6e22e">createApp&lt;/span> } &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;vue&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="node_modules">node_modules&lt;/h1>
&lt;p>&lt;a href="https://juejin.cn/post/6914508615969669127">稀土掘金，node_modules 困境&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://cloud.tencent.com/developer/article/2212864">Deno不只是个Javascript运行时&lt;/a> 提到了 node_modules 困境&lt;/li>
&lt;/ul>
&lt;p>有了 Deno 后，应该就不用再用恶心人 node_modules 了。&lt;/p>
&lt;h1 id="模块的加载方式">模块的加载方式&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://stackoverflow.com/questions/47403478/es6-modules-in-local-files-the-server-responded-with-a-non-javascript-mime-typ">https://stackoverflow.com/questions/47403478/es6-modules-in-local-files-the-server-responded-with-a-non-javascript-mime-typ&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://localcoder.org/es6-modules-in-local-files-the-server-responded-with-a-non-javascript-mime-typ">https://localcoder.org/es6-modules-in-local-files-the-server-responded-with-a-non-javascript-mime-typ&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://axellarsson.com/blog/expected-javascript-module-script-server-response-mimetype-text-html/">https://axellarsson.com/blog/expected-javascript-module-script-server-response-mimetype-text-html/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 Node.js 环境和 Browser 环境中加载 ESM 的方式不太一样&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Node.js&lt;/strong> # 可以使用模块名称。从根目录下的 node_modules/ 中查找模块&lt;/li>
&lt;li>&lt;strong>Browser&lt;/strong> # 不可以使用模块名称。必须通过编译工具将模块编译成单一文件，并修改 import 指向单一文件，以便可以发起请求获取这个静态资源&lt;/li>
&lt;/ul>
&lt;h2 id="浏览器中使用-esm-的常见问题">浏览器中使用 ESM 的常见问题&lt;/h2>
&lt;p>使用 &lt;code>import * as Vue from 'vue'&lt;/code> 将会产生如下报错：&lt;/p>
&lt;p>&lt;code>Failed to resolve module specifier &amp;quot;vue&amp;quot;. Relative references must start with either &amp;quot;/&amp;quot;, &amp;quot;./&amp;quot;, or &amp;quot;../&amp;quot;.&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mm0ymr/1651724399014-d2052b6f-cd7c-4ec0-b6fc-b748bd5a11ed.png" alt="image.png">
接着修改为 &lt;code>import * as Vue from '../node_modules/vue'&lt;/code> 将会产生如下报错：
&lt;code>Failed to load module script: The server responded with a non-JavaScript MIME type of &amp;quot;text/html&amp;quot;. Strict MIME type checking is enforced for module scripts per HTML spec.&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mm0ymr/1651724430503-b62b86bd-4cc7-48b8-ac73-69fa62564ed5.png" alt="image.png" title="firefox">&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/mm0ymr/1651724407422-526db251-775f-40d5-a25e-402791aa38cc.png" alt="image.png" title="chrome">&lt;/p>
&lt;p>问题原因：&lt;/p>
&lt;p>这个情况的原因是浏览器在处理 import 逻辑时导致的。浏览器在发现 import 语句时，将会请求 from 后面的静态文件，当 from 指定的是模块名称而不是模块文件的路径时时，浏览器无法发起请求，因为浏览器不知道如何获取到模块文件。&lt;/p>
&lt;p>解决方式：&lt;/p>
&lt;ul>
&lt;li>使用配置文件告诉 JavaScript 引擎如何从名为 XX 的模块中获取模块文件&lt;/li>
&lt;li>打包代码，js 代码被打包后，导入的模块的一组文件将会被制作为一个或多个文件；并且 from 后面的模块名将被修改为模块文件的路径，即可在浏览器中运行&lt;/li>
&lt;/ul>
&lt;p>这几种解决方式通常都是通过编译工具实现的，比如 Webpack、Vite 等工具。&lt;/p>
&lt;h1 id="ecmascript-模块的使用与管理">ECMAScript 模块的使用与管理&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.npmjs.com/cli/v8/configuring-npm/folders">官方文档，cli-配置 npm-文件夹&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>ECMAScript 的模块与包相关概念与工具是相当混乱的，最早期是由 Node.js 安装时自带的 NPM 工具集进行管理，并且 NPM 工具集中的工具除了模块与包的管理，还可以提供运行时环境等功能。&lt;/p>
&lt;p>在后期，出现了 yarn、pnpm 等新型的管理工具，可以通过 Node.js 自带的 &lt;code>corepack enable&lt;/code> 命令启用这些新的包管理工具。&lt;/p>
&lt;p>ECMAScript 的包管理器安装各种包、依赖时，早期都是分开的，可以安装在项目当前目录，或某一个统一目录。但是如果项目想要正常启动，一般都只能安装在项目的当前目录（历史原因已不可考，反正很恶心）。&lt;/p>
&lt;p>后来出现的 pnpm 工具，可以让我们将各种不同的项目的依赖放在同一个路径下进行统一管理。&lt;/p>
&lt;h2 id="安装-typescript-第三方模块">安装 TypeScript 第三方模块&lt;/h2>
&lt;p>如果使用 &lt;code>pnpm install crypto-js&lt;/code> 这种命令安装的模块是 JS 代码，有些第三方库并没有提供 TypeScript 类型声明文件，这会导致 TypeScript 在编译时无法识别该库的类型信息。可以通过安装类型声明文件解决该问题。类型声明文件通常以 &lt;code>.d.ts&lt;/code> 结尾，存放在 &lt;code>@types&lt;/code> 组织中。&lt;/p>
&lt;p>所以，为了解决这个问题，我们安装第三方库是，一般库名前都要加一个 &lt;code>@types&lt;/code>，以标识该库要从 @types 中拉取，比如上面的 crypto-js 库，应该使用如下命令拉取 TS 版本的&lt;/p>
&lt;pre tabindex="0">&lt;code>pnpm install @types/crypto-js
&lt;/code>&lt;/pre>&lt;p>Notes: 有的时候这种 TS 依赖库还依赖原始的 JS 库，也要同时安装 JS 库。这个 crypto-js 就是这个情况，要想使用 ts-node-esm 正常运行代码， package.json 至少需要如下内容：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;module&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;dependencies&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;@types/crypto-js&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;^4.2.1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;crypto-js&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;^4.2.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="模块与包的存储路径">模块与包的存储路径&lt;/h2>
&lt;p>npm 工具会通过 ${PREFIX} 与 node_modules/ 组合来决定其所管理的各种依赖包应该保存在什么位置。&lt;/p>
&lt;p>其他工具也基本都符合这两点最基本的定义。&lt;/p>
&lt;h3 id="prefix-配置">PREFIX 配置&lt;/h3>
&lt;p>npm 有一个自带的配置 PREFIX，PREFIX 用来定位目录前缀，以决定将文件放在文件系统的何处。可以通过 &lt;code>npm config get prefix&lt;/code> 命令查看 PREFIX 的值。&lt;/p>
&lt;p>&lt;strong>PREFIX 通常默认为 Node.js 的安装路径&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Linux 中，我个人通常装在 &lt;code>/usr/local/nodejs/&lt;/code> 目录下。&lt;/li>
&lt;li>Windows 由于某些原因，使用 msi 安装包安装的 Node.js 会将该 PREFIX 改为 &lt;code>%APPDATA%/npm/&lt;/code>，而不是安装目录。
&lt;ul>
&lt;li>可以从 nodejs 安装路径下的 node_modules/npm/npmrc 文件中看到有这么一条配置：&lt;code>prefix=${APPDATA}\npm&lt;/code>&lt;/li>
&lt;li>但是我们可以使用 zip 包，手动安装 Node.js，详情见：&lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8.md#Windows">ECMAScript 环境安装与使用&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="node_modules-目录">node_modules 目录&lt;/h3>
&lt;p>当我们使用包管理命令安装各种第三方库(依赖包)及其衍生物通常会保存在名为 &lt;code>node_modules/&lt;/code> 目录下，通常会有两个地方有 node_modules 目录：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Locally(本地)&lt;/strong> # 这是默认的行为，安装的东西放在当前目录的 &lt;code>./node_modules/&lt;/code> 目录中
&lt;ul>
&lt;li>当我们想要在代码中使用 require() 或 import 导入模块时，通常安装在本地&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Globally(全局)&lt;/strong> # 使用 &lt;code>-g&lt;/code> 选项，将安装的东西放在 &lt;code>${PREFIX}/lib/node_modules/&lt;/code> 目录中
&lt;ul>
&lt;li>若安装的东西中具有可以在 CLI 执行的工具，则同时会在 &lt;code>${PREFIX}/bin/&lt;/code> 目录下生成指向原始文件的软链接，&lt;code>${PREFIX}/bin/&lt;/code> 目录通常都会加入到 &lt;code>${PATH}&lt;/code> 变量中。&lt;/li>
&lt;li>当我们安装的包可以在命令行执行时，通常安装在全局&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>注意：Windows 的全局 &lt;code>node_modules/&lt;/code> 目录与 Linux 不太一样，全局路径是 &lt;code>${PREFIX}/node_modeuls/&lt;/code>。也就是说生成的链接文件就在 &lt;code>${PREFIX}&lt;/code> 下。&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: package.json</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/package.json/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/package.json/</guid><description>
&lt;h2 id="概述">概述&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://nodejs.dev/learn/the-package-json-guide">dev 官网，学习-package.json 指南&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pnpm.io/package_json">pnpm 官方文档，配置-package.json&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>package.json 文件是项目的清单。 它包含包的所有元数据，包括依赖项、标题、作者等等。例如，它是用于工具的配置中心。 它也是 npm 和 yarn 等包管理工具管理依赖的地方。&lt;/p>
&lt;p>想要运行带有 ES6 语法规则的代码（比如导入包是使用的 import 关键字），需要添加 &lt;code>&amp;quot;type&amp;quot;: &amp;quot;module&amp;quot;&lt;/code> 配置。&lt;/p></description></item><item><title>Docs: TSConfig</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/TSConfig/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/TSConfig/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html">官方文档，项目配置-tsconfig.json 是什么&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.typescriptlang.org/tsconfig">官方文档，TSConfig 参考&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>TSConfig 通常是名为 tsconfig.json 或 jsconfig.json 的文件，当目录中出现了 tsconfig.json 文件，则说明该目录是 TypeScript 项目的根目录。tsconfig.json 文件指定了编译项目所需的根目录下的文件以及编译选项。&lt;/p>
&lt;h2 id="简单示例">简单示例&lt;/h2>
&lt;p>可以运行 ES6 语法（导入包时用的 import 关键字）逻辑的 TS 代码的配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;compilerOptions&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// &amp;#34;target&amp;#34;: &amp;#34;es2016&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">&amp;#34;module&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;ES6&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;esModuleInterop&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意，若环境中有 package.json 文件，需要搭配该文件中的 &lt;code>&amp;quot;type&amp;quot;: &amp;quot;module&amp;quot;&lt;/code> 配置，才可以正常使用 ES6 语法。&lt;/p>
&lt;h1 id="compileroptions">compilerOptions&lt;/h1>
&lt;h2 id="baseurl">baseUrl&lt;/h2>
&lt;h2 id="paths">paths&lt;/h2>
&lt;p>配置路径别名。&lt;/p>
&lt;p>若使用 Vite 打包代码，则需要在 vite.config.ts 文件中也同步配置 &lt;code>resolve.alias&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#a6e22e">defineConfig&lt;/span>({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">resolve&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">alias&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 让我们在导入时使用可以使用 @ 符号作为 src 目录的别名，而不是相对路径，比如：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// import App from &amp;#39;@/App.vue&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 而不是
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// import App from &amp;#39;../../App.vue&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;@&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">fileURLToPath&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">URL&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;./src&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">import&lt;/span>.&lt;span style="color:#a6e22e">meta&lt;/span>.&lt;span style="color:#a6e22e">url&lt;/span>)),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="最佳实践">最佳实践&lt;/h1>
&lt;h2 id="vue-环境配置示例">Vue 环境配置示例&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;extends&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;@vue/tsconfig/tsconfig.web.json&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;include&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;env.d.ts&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 两个 * 表示任意层数的所有目录
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;src/**/*&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;src/**/*.vue&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 导出所有接口目录到全局
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;src/api/**/*&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;compilerOptions&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;baseUrl&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;.&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 配置路径别名。这样在使用 import 导入时，我们可以通过 @/xxx 来代替 /src/xxx
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">&amp;#34;paths&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;@/*&amp;#34;&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;src/*&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;references&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;path&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;./tsconfig.config.json&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>include&lt;/strong> # 通过在 include 中指定文件或目录，我们可以将声明的 interface 等默认导出并在其他地方使用，而不用在每个需要使用的地方使用 import 关键字显式导入了。&lt;/p></description></item></channel></rss>