<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ECMAScript 环境安装与使用 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><description>Recent content in ECMAScript 环境安装与使用 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>ECMAScript 环境安装与使用</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid><description>概述 参考：
有两种运行时环境可以运行 ECMAScript 代码(Javascript、Typescript)
Browser# 浏览器就是 ECMAScript 的运行时环境。 Node.js # 在服务器或 PC 上安装 Node.js 环境以运行 ECMAScript 代码 Deno # GtiHub 项目，denoland/deno。据说要替代 Node.js，很尴尬的是。。。早期 18 年的 issue 中被各种国人无意义灌水 Bun # GtiHub 项目，oven-sh/bun 但是这两者可以提供的 API 能力各不相同
Browser 可以提供的 dockument、window 和其他关于 DOM 或其他 Web 平台 API 的对象。 Node.js 则可以提供很多操作系统相关的 API，比如文件的读写、进程管理、网络通信等等。 Node.js 与 Browser 都是基于 Chrome V8 引擎的 ECMAScript 运行时环境
你也许会想，直接在我的硬盘上创建好 HTML 和 JavaScript 文件，然后用浏览器打开，不就可以看到效果了吗？
这种方式运行部分 JavaScript 代码没有问题，但由于浏览器的安全限制，以 file:// 开头的地址无法执行如联网等 JavaScript 代码，最终，你还是需要架设一个 Web 服务器，然后以 http:// 开头的地址来正常执行所有 JavaScript 代码。</description></item><item><title>ECMAScript 模块与包</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript-%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/ECMAScript-%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/</guid><description>概述 参考：
MDN-参考，JavaScript-JavaScript 指南-JavaScript 模块 网道，ES6 教程-Module 的语法 https://www.zhangxinxu.com/wordpress/2018/08/browser-native-es6-export-import-module/ 历史上，JavaScript 一直没有 Module(模块) 体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的 require、Python 的 import，甚至就连 CSS 都有 @import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。
在 ES6 之前，社区制定了一些模块加载方案，最主要的有 2009 年 1 月发起的 CommonJS 和 AMD 两种，前者用于服务器，后者用于浏览器。
2013 年 5 月，npm 的作者宣布 Node.js 已经废弃 CommonJS，详见 GitHub issue-5132，nodejs/node-v0.x-archive &amp;gt; Wiki, Asynchronous_module_definition(异步模块定义，简称 AMD)
比如，CommonJS 模块就是对象，输入时必须查找对象属性。
// CommonJS 标准 let { stat, exists, readfile } = require(&amp;#34;fs&amp;#34;) // 等同于 js 代码 let _fs = require(&amp;#34;fs&amp;#34;) let stat = _fs.</description></item><item><title>package.json</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/package.json/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/package.json/</guid><description>概述 参考：
dev 官网，学习-package.json 指南 pnpm 官方文档，配置-package.json package.json 文件是项目的清单。 它包含包的所有元数据，包括依赖项、标题、作者等等。例如，它是用于工具的配置中心。 它也是 npm 和 yarn 等包管理工具管理依赖的地方。
想要运行带有 ES6 语法规则的代码（比如导入包是使用的 import 关键字），需要添加 &amp;quot;type&amp;quot;: &amp;quot;module&amp;quot; 配置。</description></item><item><title>Deno</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/Deno/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/Deno/</guid><description>概述 参考：
GitHub 项目，denoland/deno GitHub 项目，denolib/awesome-deno 阮一峰，Deno 运行时入门教程：Node.js 的替代品 https://docs.deno.com/runtime/manual/references/vscode_deno/ VSCode 中使用 Deno 的方式 Deno 也是一个服务器运行时，但是支持多种语言，可以直接运行 JavaScript、TypeScript 和 WebAssembly 程序。
它内置了 V8 引擎，用来解释 JavaScript。同时，也内置了 tsc 引擎，解释 TypeScript。它使用 Rust 语言开发，由于 Rust 原生支持 WebAssembly，所以它也能直接运行 WebAssembly。它的异步操作不使用 libuv 这个库，而是使用 Rust 语言的 Tokio 库，来实现事件循环（event loop）。
内置了 V8 引擎意味着可以随时随地运行那些依赖浏览器环境的库，再也不用在 js 代码中补浏览器环境了！内置了 tsc 引擎意味着再也不用面临 Node.js 那些让人头痛的无法运行 .ts 的问题。
Deno 运行代码时，并不依赖 tsconfig.json 文件或 package.json 文件。不用面临 CommonJS 和 ES6 语法的冲突配置问题。
Deno 甚至可以通过命令行工具的 deno compile 命令将程序编译成可执行的二进制文件（比如 windows 下就是 .exe 文件），然后直接执行！！就像 Go 的二进制文件一样。如果是编译了一个使用浏览器操作的文件，那么就会在 Shell 中显示像浏览器似的控制，浏览器弹窗就是 Shell 中的等待输入，诸如此类的效果。</description></item><item><title>TSConfig</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/TSConfig/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/TSConfig/</guid><description>概述 参考：
官方文档，项目配置-tsconfig.json 是什么 官方文档，TSConfig 参考 TSConfig 通常是名为 tsconfig.json 或 jsconfig.json 的文件，当目录中出现了 tsconfig.json 文件，则说明该目录是 TypeScript 项目的根目录。tsconfig.json 文件指定了编译项目所需的根目录下的文件以及编译选项。
简单示例 可以运行 ES6 语法（导入包时用的 import 关键字）逻辑的 TS 代码的配置
{ &amp;#34;compilerOptions&amp;#34;: { // &amp;#34;target&amp;#34;: &amp;#34;es2016&amp;#34;, &amp;#34;module&amp;#34;: &amp;#34;ES6&amp;#34;, &amp;#34;esModuleInterop&amp;#34;: true, } } 注意，若环境中有 package.json 文件，需要搭配该文件中的 &amp;quot;type&amp;quot;: &amp;quot;module&amp;quot; 配置，才可以正常使用 ES6 语法。
compilerOptions baseUrl paths 配置路径别名。
若使用 Vite 打包代码，则需要在 vite.config.ts 文件中也同步配置 resolve.alias：
export default defineConfig({ resolve: { alias: { // 让我们在导入时使用可以使用 @ 符号作为 src 目录的别名，而不是相对路径，比如： // import App from &amp;#39;@/App.</description></item></channel></rss>