<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Control structure</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Control-structure/</link><description>Recent content in Control structure on 断念梦</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Control-structure/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Control structure</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Control-structure/Control-structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Control-structure/Control-structure/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>Go 语言提供了 4 种条件结构和分支结构用作 &lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Control%20structure.md">Control structure(控制结构)&lt;/a>。在结构中，可以使用 &lt;code>break&lt;/code> 和 &lt;code>continue&lt;/code> 这样的关键字来中途改变结构的状态。还可以使用 &lt;code>return&lt;/code> 来结束某个函数的执行，或使用 &lt;code>goto&lt;/code> 和标签来调整程序的执行位置&lt;/p>
&lt;h1 id="for-循环">For 循环&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://juejin.cn/post/7153633858309586975">知乎，Golang那些坑-使用 for 循环的注意事项&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>用于测试某个条件(布尔型或逻辑型)的语句，初始化语句执行完成之后；如果该条件成立，则会执行 if 后由大括号括起来的代码块，然后执行修饰语句，之后再次判断条件语句是否成立，如此循环；直到条件语句不成立时，就忽略该代码块继续执行后续的代码。&lt;/p>
&lt;ul>
&lt;li>基本格式：&lt;code>for 初始化语句;条件语句;修饰语句 {代码块}&lt;/code>&lt;/li>
&lt;/ul>
&lt;h1 id="if-else-判断">if else 判断&lt;/h1>
&lt;h1 id="switch-判断">switch 判断&lt;/h1>
&lt;p>给定一个变量，当该变量满足某个条件时执行某个代码。&lt;/p>
&lt;h1 id="select">select&lt;/h1>
&lt;p>与 switch 类似&lt;/p>
&lt;h1 id="break-与-continue">break 与 continue&lt;/h1>
&lt;ul>
&lt;li>&lt;code>break&lt;/code> 用于退出当前当前代码块&lt;/li>
&lt;li>&lt;code>continue&lt;/code> 用于忽略当前循环，继续执行后续循环，只用于 for 结构体中 Note：注意！是退出当前代码块，如果循环有多层嵌套，那么只是退出当前循环；如果循环中套用 select 等，则也是退出当前控制结构。&lt;/li>
&lt;/ul>
&lt;h1 id="标签与-goto">标签与 goto&lt;/h1>
&lt;ul>
&lt;li>标签用于在出现标签关键字的时候，代码回到标签定义行再继续执行下面的代码。某一行以&lt;code>:&lt;/code>冒号结尾的单词即可定义标签。标签区分大小写&lt;/li>
&lt;/ul></description></item><item><title>Docs: 错误处理</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Control-structure/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Control-structure/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="defer">Defer&lt;/h2>
&lt;p>延缓。&lt;/p>
&lt;p>代码示例：&lt;a href="https://desistdaydream.github.io/5.Functions/defer.go">defer.go&lt;/a>&lt;/p>
&lt;p>关键字&lt;code>defer&lt;/code>允许我们推迟到函数返回之前（或任意位置执行 return 语句之后）一刻才执行某个语句或函数（为什么要在返回之后才执行这些语句?因为return语句同样可以包含一些操作，而不是单纯地返回某个值）。&lt;/p>
&lt;h2 id="panic">Panic&lt;/h2>
&lt;p>直译为&lt;code>恐慌&lt;/code>，在计算机中表示&lt;code>产生严重错误&lt;/code>&lt;/p>
&lt;p>代码示例：&lt;a href="https://desistdaydream.github.io/9.error_handing/panic.go">panic.go&lt;/a>&lt;/p>
&lt;p>当发生像数组越界或类型断言失败这样的严重错误时，会触发&lt;code>panic: runtime error运行时恐慌&lt;/code>伴随着程序的崩溃输出一个&lt;code>runtime.Error&lt;/code>接口类型的值。这个错误值有个&lt;code>RuntimeError()&lt;/code>方法用于区别普通错误。&lt;/p>
&lt;p>在多层嵌套的函数调用中调用panic，可以马上终止当前函数的执行，所有的defer语句都会保证执行并把控制权交还给接收到panic的函数调用者。这样向上冒泡直到最顶层，并执行(每层的)defer，在栈顶处程序崩溃，并在命令行中用传给panic的值报告错误情况：这个终止过程就是panicking。&lt;/p>
&lt;h2 id="recover">Recover&lt;/h2>
&lt;p>恢复。这个&lt;code>Recover&lt;/code>内建函数被用于从&lt;code>panic&lt;/code>或错误场景中恢复：让程序可以从panicking重新获得控制权，停止终止过程进而恢复正常执行。&lt;code>recover&lt;/code>只能在defer关键字的函数中使用，用于取得panic调用中传递过来的错误值，如果是正常执行，调用&lt;code>recover&lt;/code>会返回nil，且没有其他效果&lt;/p>
&lt;p>代码示例：&lt;a href="https://desistdaydream.github.io/9.error_handing/parsePackage.go">parsePackage.go&lt;/a>。有一个简单的 parse 包（示例 13.4）用来把输入的字符串解析为整数切片；这个包有自己特殊的 ParseError。当没有东西需要转换或者转换成整数失败时，这个包会 panic（在函数 fields2numbers 中）。但是可导出的 Parse 函数会从 panic 中 recover 并用所有这些信息返回一个错误给调用者。为了演示这个过程，在 panic_recover.go 中 调用了 parse 包（示例 13.4）；不可解析的字符串会导致错误并被打印出来。&lt;/p></description></item></channel></rss>