<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Goroutine 与 Channel on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Goroutine-AND-Channel/</link><description>Recent content in Goroutine 与 Channel on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Goroutine-AND-Channel/index.xml" rel="self" type="application/rss+xml"/><item><title>Goroutine AND Channel</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Goroutine-AND-Channel/Goroutine-AND-Channel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Goroutine-AND-Channel/Goroutine-AND-Channel/</guid><description>概述 参考:
公众号,马哥 Linux 运维-golang channel 使用总结 公众号，田飞雨-Golang GPM 模型剖析 Go 语言的并发 不要通过共享来通信，而要通过通信来共享。
通过 Goroutines(协程) 与 Channels(通道) 实现 并发编程
并发与并行的区别
Concurrency(并发) # 一个处理器或者内核上，一个并发程序可以使用多个线程来交替运行。反义词为顺序 实际例子：你有一张嘴，电话来了，你停了下来接了电话，吃一口说一句话，直到说完话并且吃完饭，这是并发 Parallelism(并行) # 多个处理器或者多核上，一个程序在某个时间、在多个处理器上同时运行。反义词为串行 实际例子：你有两张嘴，电话来了，你一边打电话一边吃饭，直到说完话并且吃完饭，这是并行 并行是并发的真子集。并发不全是并行，但并行一定并发。(单核并发不并行，多核并行也属于并发)，除非该程序无法使用多线程执行任务。
并行不一定会加快运行速度，因为并行运行的组件之间可能需要相互通信。比如运行在两个 CPU 上的两个组件之间需要互相通信。并发系统上，这种通信开销很小。但在多核的并行系统上，组件间的通信开销就很高了。所以，并行不一定会加快运行速度！
一个程序是运行在机器上的一个进程，进程是一个运行在自己内存空间里的独立执行体。一个进程由一个或多个操作系统线程组成，这些线程其实是共享同一个内存地址空间在一起工作的执行体。几乎所有正式的程序都是多线程的，以便让用户或计算机不必等待，或能够同时服务多个请求(e.g.Web 服务器)，或增加性能和吞吐量。
不要使用全局变量或共享内存，他们会给代码在并发运算的时候带来危险。
Goroutines(协程) 处理应用程序并发功能的就是 Goroutines(协程)
Go 协程是与其他函数或方法一起并发运行的函数或方法。
调用函数或者方法时，在前面加上关键字 go，可以让一个新的 Go 协程并发地运行。i.e.有关键字go的函数或方法，即算协程，可以并发运行。 main()函数算主协程，可以没有go关键字
一个基本的协程代码示例：
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) var wg sync.WaitGroup func hello(m string) { if m == &amp;#34;waitgroup&amp;#34; { // 让 WaitGroup 计数器 -1 defer wg.</description></item><item><title>panic: send on closed channel 解法</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Goroutine-AND-Channel/panic_-send-on-closed-channel-%E8%A7%A3%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Goroutine-AND-Channel/panic_-send-on-closed-channel-%E8%A7%A3%E6%B3%95/</guid><description>golang 为什么没有判断 close 的接口？ - 知乎
更多干货，关注公众号：奇伢云存储。原创不易，谢谢大家支持。
golang 为什么没有判断 close 的接口？ 关闭 channel 究竟做了什么？ closechan 一个判断 chan 是否 close 的函数 思考方法一：通过 “写”chan 实现 思考方法二：通过 “读”chan 实现 chan close 原则 其实并不需要 isChanClose 函数 !!! 怎么优雅关闭 chan ？ 方法一：panic-recover 方法二：sync.Once 方法三：事件同步来解决 总结 golang 为什么没有判断 close 的接口？ 相信大家初学 golang chan 的时候应该都遇到过 &amp;ldquo;send on closed channel&amp;rdquo; 的 panic 。这个 panic 是当你意图往一个已经 close 的 channel 里面投递元素的时候触发。那么你当你第一次遇到这个问题是否想过 channel 是否能提供一个接口方法来判断是否已经 close 了？我想过这个问题，但是把 chan 的源代码翻了个遍没有找到。为什么？
我先 hold 这个问题，我们捋一下跟 channel close 相关的事情，主要思考到 3 个问题：</description></item><item><title>并发控制</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Goroutine-AND-Channel/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Goroutine-AND-Channel/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</guid><description>概述 参考：
Go 包，标准库-context Go 包，标准库-sync-WaitGroup 类型 https://blog.wu-boy.com/2020/05/understant-golang-context-in-10-minutes/ context 是在Go 语言1.7 版才正式被纳入官方标准库内，为什么今天要介绍 context 使用方式呢？原因很简单，在初学 Go 时，写 API 时，常常不时就会看到在 http handler 的第一个参数就会是ctx context.Context，而这个 context 在这边使用的目的及含义到底是什么呢，本篇就是带大家了解什么是 context，以及使用的场景及方式，内容不会提到 context 的原始码，而是用几个实际例子来了解。
如果对于课程内容有兴趣，可以参考底下课程。
Go 语言基础实战(开发, 测试及部署) 一天学会 DevOps 自动化测试及部署 DOCKER 容器开发部署实战(课程刚启动，限时特价$900 TWD) 如果需要搭配购买请直接透过FB 联络我，直接汇款（价格再减100）
使用 WaitGroup 学 Go 时肯定要学习如何使用并发(goroutine)，而开发者该如何控制并发呢？其实有两种方式，一种是WaitGroup，另一种就是 context，而什么时候需要用到 WaitGroup 呢？很简单，就是当我们需要将同一件事情拆成不同的 Job 下去执行，最后需要等到全部的 Job 都执行完毕才继续执行主程式，这时候就需要用到 WaitGroup，看个实际例子
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) func main() { var wg sync.WaitGroup wg.Add(2) go func() { time.</description></item><item><title>并发问题</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Goroutine-AND-Channel/%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Goroutine-AND-Channel/%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/</guid><description>概述 常见并发报错：
fatal error:concurrent map read and map write Go 并发操作变量 常见错误使用 goroutine func goroutineRun(values []int) { for value := range values { go value.test() } } func goroutineRun(values []int) { for value := range values { go func() { fmt.Println(value) }() } } 这两段代码实际上是遍历数组的所有变量。由于闭包只是绑定到这个 value 变量上，并没有被保存到 goroutine 栈中，所以以上代码极有可能运行的结构都输出为切片的最后一个元素。因为这样写会导致 for 循环结束后才执行 goroutine 多线程操作，这时候 v alue 值只指向了最后一个元素。这样的结果不是我们所希望的，而且还会产生并发的资源抢占冲突所以是非常不推荐这样写的。
解决方法 for val := range values { go func(val interface{}) { fmt.Println(val) }(val) } 在这里将 val 作为一个参数传入 goroutine 中，每个 val 都会被独立计算并保存到 goroutine 的栈中，从而得到预期的结果。 另一种方法是在循环内定义新的变量，由于在循环内定义的变量在循环遍历的过程中是不共享的，因此也可以达到同样的效果：</description></item></channel></rss>