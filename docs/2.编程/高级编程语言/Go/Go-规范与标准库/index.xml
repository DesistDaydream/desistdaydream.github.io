<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go 规范与标准库 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/</link><description>Recent content in Go 规范与标准库 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/index.xml" rel="self" type="application/rss+xml"/><item><title>Go 规范与标准库</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/</guid><description>概述 参考：
官方文档，参考 - 规范 官方文档，参考 - 规范 的翻译 go.dev, Tour(Go 语言之旅，通过在线解析器体验 Go 语言的各种特性) 公众号，11个现代Go特性：用 gopls/modernize 让你的代码焕然一新 Go 是一种通用语言，专为系统编程而设计。它是一种强类型且自带垃圾回收功能的语言，并具有显式支持并发编程的能力(称为 goroutine)。Go 程序由 Packages(包) 构建，其属性允许有效得管理依赖关系。
Go 语言参考描述了 Go 语言的具体语法和语义 Go 标准库则是与 Go 语言一起发行的一些可选功能，以便人们可以从一开始就轻松得使用 Go 进行编程。 Keywords 参考：
官方文档，参考 - 规范 - 关键字 Go 语言非常简单，只有 25 个关键字(Keywords)可以使用，记住这 25 个关键字，就掌握了最基本的 Go 语言用法。这些关键字是 go 语言保留的，不能用作标识符
关键字在编程语言中是指该语言的一个功能，比如下文面的 var，就是指声明一个变量，func 就是定义一个函数等等。
Note: if-else 算两个关键字所以在这里一共只写了 24 个。
break # 控制结构 case # 控制结构 chan # 用于 channel 通讯 const # 语言基础里面的常量申明 continue # 用在 for 控制结构中，用以忽略本次循环的后续所有逻辑，执行下一次循环 default # 控制结构 defer # 用于在函数退出之前执行某语句的功能 fallthrough # 控制结构 for # 控制结构 func # 用于定义函数和方法 go # 用于并发 goto 控制结构 if-else # 控制结构 import 用于定义该文件引用某个包 interface # 用于定义接口 map # 用于声明 map 类型数据 package # 用于定义该文件所属的包 range # 用于读取 slice、map、channel 数据 return # 用于从函数返回。有时候也用来直接跳出当前函数，回到主程序继续执行 select # 用于选择不同类型的通讯 struct # 用于定义抽象数据类型 switch # 控制结构 type # 用于 Type Declarations(类型声明)，有两种形式： Definitions(定义) 自定义类型 Declarations(声明) 一个类型的别名。 其实所谓的类型的别名，也可以当作一种自定义的类型。 var # 用于 Declarations(声明) 变量 Lexical elements(词汇元素) 一些 Go 语言中抽象或具象名词，用于描述某些实体或行为。</description></item><item><title>Data type</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Data-type/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Data-type/</guid><description>概述 参考：
官方文档，参考 - 规范 - 类型 Data Type(数据类型) 用来对一组相关值进行分类，描述可对其执行的操作并定义它们的存储方式。
Go 语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。虽然数据类型有很多，但是这些数据类型都是对程序中一个变量或状态的间接引用。这意味着对任一引用类型数据的修改都会影响所有该引用的拷贝。所谓的引用，是对值的引用。注意引用与指针的区别，详见 pointer.go
Underlying Type(基本类型) 数据中最基本的类型，是构成其余数据类型以及对象的最小单位，当定义其他数据类型时，同样需要定义基础数据类型。基础数据类型也是 Go 语言的内置数据类型
Numeric(数字类型) Integer Type(整数类型) Floating Point Numbers(浮点数型) complex 复数共两种复数，complex64 和 complex128，分别对应 float32 和 float64 两种浮点数精度。内置的 complex 函数用于构建复数，内建的 real 和 imag 函数分别返回复数的实部和虚部 Strings(字符类型) Booleans(布尔类型) 注意：很多时候，Booleans 类型的值可以用数字表示 1 表示 true(真) 0 表示 false(假) Composite Type(复合类型) 是通过组合基础数据类型，来表达更复杂的数据结构
Arrays(数组) # 多个相同基础类型的数据组合在一起 Slices(切片) Maps(字典) Functions(函数，这里面主要指的是函数的参数的数据类型) Structs(结构体) # Interfaces(接口) Channels(通道) Pointers(指针) 自定义数据类型(类型定义) 变量或表达式的 Type 定义了对应存储值的属性特征，例如数值在内存的存储大小（或者是元素的 bit 个数），它们在内部是如何表达的，是否支持一些操作符，以及它们自己关联的方法集等。
在任何程序中都会存在一些变量有着相同的内部结构，但是却表示完全不同的概念。例如，一个 int 类型的变量可以用来表示一个循环的迭代索引、或者一个时间戳、或者一个文件描述符、或者一个月份；一个 float64 类型的变量可以用来表示每秒移动几米的速度、或者是不同温度单位下的温度；一个字符串可以用来表示一个密码或者一个颜色的名称。这些基于基本数据类型所生成的新数据类型都叫数据类型。再比如数组、切片、字典等，虽然在有的时候他们的基础数据类型可以使一样的，但是他们本身所表示的数据类型是不同的含义。</description></item><item><title>Variable</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Variable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Variable/</guid><description>概述 参考：
Go 官方文档，参考 - 规范 - 变量 Go 官方文档，参考 - 规范 - 声明和范围 Variable(变量)
How to Name a Variable(如何命名一个变量) Scope(范围) Constants(常量) Defining Multiple Variables 定义多个变量空白标识符_用于抛弃值，e.g.值 5 在：_, b = 5, 7中被抛弃。_空白标识符是一个只写变量，不能获得它的值。这样做是因为 Go 语言中必须使用所有被声明的变量，但有时候并不需要使用从一个函数得到的所有返回值(e.g.上例中的 5 与 7 是通过某个函数获得的值且该函数一定会获得 2 个值，但是其中一个却用不上)。 声明变量 格式：var VarID TYPE = EXP
VarID # 变量的标识符 TYPE # 详见 Data type EXP # 初始化时使用的表达式。i.e.给该变量一个值。 其中 TYPE 或者 = EXP 这两个部分可以省略其中之一，如果省略 TYPE，那么将根据初始化 EXP 来自动推导变量的类型；如果初始化的 EXP
引用变量 Variables Scope(变量范围) Variables Scope(变量范围) 就是变量的作用域，定义在哪里的变量，可以在哪里被引用，不可以在哪里被引用，都是变量范围所决定的。</description></item><item><title>Arrays AND Slices</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Arrays-AND-Slices/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Arrays-AND-Slices/</guid><description>概述 Array(数组) 与 Slice(切片)
Array(数组) 参考：
Go 语言之旅，Arrays Array(数组) 是具有相同的唯一类型的一组 已编号、且长度固定 的数据项序列。每个数据项称为 element(元素)、长度指的是元素的个数、编号指每个元素的 index(索引)，索引号从 0 开始。
[n]T 用以表示一个数组，该数组包含 n 个 T 类型的值。
Array 的声明 var ArrayID [LENGTH]TYPE ArrayID # 标识符(i.e.数组的名字) LENGTH # 数组长度(i.e.元素的个数) TYPE # 每个元素的数据的类型。 **[ ]** # 括号是数组类型的标识符，不要忘记写。 比如：var arr [10]int这定义了一个名为 arr 的数组，这个数组由 10 个 int 类型的数据组成。简化点的口头语，声明了一个长度为 10 的整形数组。
Array 的赋值 arr[0] = &amp;quot;Hello&amp;quot; 为数组的 0 号元素赋值。
Array 的实例化 数组声明后，默认初始化每个元素的值为 0，后续可以对每个元素进行赋值。数组可以有两种初始化方式
每次对一个元素进行赋值，一般使用循环来实现 使用{}大括号，直接对数组进行初始化 e.g.var arr = [5]int{1,5,23,2,10} Array 的引用 引用数组的长度 len(MapID) 使用 len() 函数，括号内为数组标识符。数组的长度也就是元素的数目，必须是固定的并且在声明该数组时就给出，数组长度最大为 2Gb。格式为 len(ARRAYS) len 是 length 的缩写，ARRAYS 是数组变量的名称。</description></item><item><title>Function</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Function/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Function/</guid><description>概述 参考：
Function(函数)
DRY 原则：Don&amp;rsquo;t Repeart Yourself(不要重复你自己)
Golang 有 3 种类型的函数：
普通的带有名字的函数 匿名函数或者 lambda 函数 Methods(方法) 除了 main()、init()函数外，其余所有类型的函数都可以有参数与返回值。函数参数、返回值以及它们的类型统称为函数签名。 Function 的声明 func FunctionName([Parameter]) [(ReturnValue)] { 代码块 } () 里的 Parameter 以及 returnValue 可以省略，但是至少要包含一个()，哪怕这个小括号内没有任何内容。i.e.一个函数可以没有参数，与返回值，仅仅执行本身所提供的功能 Parameter(形式参数) # 这是一个参数列表，包括参数名以及参数类型。参数一般情况是变量、或者另一个函数(这个函数也可以当做变量来使用，是函数类型的变量，在调用时，可以通过实参改变该函数)。 ReturnValue(返回值) # 同样包括参数名以及参数类型，参数一般是变量。可以直接定义变量名与类型，也可以省略变量名直接指明返回值的类型 其中 Parameter 与 returnValue 都是可省的，最简化的定义格式为 function Name(){} Function 的调用 调用函数 就是指 使用函数
格式为：
[Pack.]Function([ARG1, ARG2, ..., ARGn])
其中 Pack 与 ARG 都是可省的，若在同一个包中，则 Pack 可省，若不用传递参数，则 ARG 可省。
包名.函数名(实际参数)。Function是Pack包里的一个函数，括号里的是被调用函数的实参，这些实参的值被传递给被调用函数的形参，参数的传递是一一对应的，第一位传递给第一位，第二位传递给第二位，以此类推。在引用的时候参数可省略为空，但是括号必须要有
actual parameter(实际参数，简称 实参) # 一般用 arguments 表示，在调用函数时使用实参 formal parameter(形式参数，简称 形参) # 一般用 parameter 表示，在定义函数时使用形参 注意：</description></item><item><title>Pointer</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Pointer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Pointer/</guid><description>概述 参考：
Go 官方文档，参考 - 指针类型 在 Go 语言中，Pointer(指针) 可以有两种含义：
通过 &amp;amp; 符号获取一个变量的内存地址，即指针。通常使用十六进制数表示。这种方式称为指针引用 指针也可以表示一种数据类型。可以声明一个指针类型的变量，用以存储内存地址。 一个指针变量可以指向任何一个值的内存地址。这个内存地址，在 32 位机器上占用 4 个字节，在 64 位机器上占用 8 个字节，并且与其所指向的值得的大小无关。 在 Go 语言中，不能进行指针运算。
指针的引用 每一个变量都有指针，我们可以通过 &amp;amp; 符号引用该变量的指针，也就是获取该变量的内存地址。
我们平时说引用指针，并不是引用指针类型的变量，指针类型的变量也是一种变量，正常使用变量名称即可引用。
这里说要说的指针的引用是指引用一个变量的内存地址，即变量的指针 **格式：**在变量名称前加上 &amp;amp; 符号，即可获取该变量的内存地址，即该变量的指针。
&amp;amp;VarID 注意：若该变量的值为空，则该变量依然具有内存地址：
var a string fmt.Println(&amp;amp;a) 这将会输出：0xc000010250
指针变量的声明 格式：* 与 数据类型 的组合书写，即代表指针类型：
var VarID *TYPE 这里需要注意的是，当一个指针变量被声明后，它的值为nil，但是这个变量本身是具有指针的
func main() { // 声明一个 `字符串指针` 类型的变量 var VarID *string fmt.Println(VarID) fmt.Println(&amp;amp;VarID) } 输出结果：
&amp;lt;nil&amp;gt; 0xc000014088 一个指针类型的变量可以保存内存地址，同时自己也具有内存地址。
指针变量的赋值 格式：</description></item><item><title>Map AND Struct</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Map-AND-Struct/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Map-AND-Struct/</guid><description>概述 参考：
官方文档，参考 - 规范 - Map 类型 官方文档，参考 - 规范 - Struct 类型 Map(映射) map 是 key-value pairs(键值对) 的无序集合。这种结构也称 关联数组(associative array)、字典(dictionary)、散列表/哈希表(hash table)。这是一种快速寻找值的理想结构：给定 Key，对应的 Value 可以迅速定位。
map 的声明 var MapID map[KeyType]ValueType map 的实例化 MapID = make(map[KeyType]ValueType) 赋值 MapID[KEY] = VAL 实例化的同时进行赋值 MapID := map[KeyType]ValType{ KEY_1:VAL_1, KEY_2:VAL_2, ..., KEY_n:VAL_n } 这相当于：
MapID := make(map[KeyType]ValueType) MapID[&amp;#34;KEY_1&amp;#34;] = &amp;#34;VALUE_1&amp;#34; MapID[&amp;#34;KEY_2&amp;#34;] = &amp;#34;VALUE_2&amp;#34; map 的引用 下面是引用 map 中指定 KEY 的 VALUE 的方法：
MapID[KEY] 引用 map 的长度 map 的长度指的是键值对的个数，有几个键值对，长度就是几</description></item><item><title>Reflect</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Reflect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Reflect/</guid><description>概述 参考：
Go 包，标准库 - reflect Go 博客，反射法则 博客园-Stefno，深度解密 Go 语言之反射 Reflection(反射) 是用程序检查其所拥有的结构，尤其是类型的一种能力。可以通过反射来分析一个结构体。反射可以在运行时检查类型和变量，例如它的大小、方法和动态的调用这些方法。
reflect.TypeOf() 和 reflect.ValueOf() 两个函数返回被检查对象的类型和值。e.g. var x float64 = 3.4, 那么 reflect.TypeOf(x) 返回 float64，reflect.ValueOf(x) 返回 3.4
忠告：反射是一个强大并富有表达力的工具，但是它应该被小心地使用，原因有三：
基于反射的代码是比较脆弱的。对于每一个会导致编译器报告类型错误的问题，在反射中都有与之相对应的误用问题，不同的是编译器会在构建时马上报告错误，而反射则是在真正运行到的时候才会抛出 panic 异常，可能是写完代码很久之后了，而且程序也可能运行了很长的时间。 即使对应类型提供了相同文档，但是反射的操作不能做静态类型检查，而且大量反射的代码通常难以理解。总是需要小心翼翼地为每个导出的类型和其它接受 interface{} 或 reflect.Value 类型参数的函数维护说明文档。 基于反射的代码通常比正常的代码运行速度慢一到两个数量级。对于一个典型的项目，大部分函数的性能和程序的整体性能关系不大，所以使用反射可能会使程序更加清晰。测试是一个特别适合使用反射的场景，因为每个测试的数据集都很小。但是对于性能关键路径的函数，最好避免使用反射。 什么是反射 反射和 Interface 息息相关，而 Interface 是我们上一篇文章的内容。在开始正文前，和大家说点题外话。
直接看维基百科上的定义：
在计算机科学中，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。
那我就要问个问题了：不用反射就不能在运行时访问、检测和修改它本身的状态和行为吗？
问题的回答，其实要首先理解什么叫访问、检测和修改它本身状态或行为，它的本质是什么？
实际上，它的本质是程序在运行期探知对象的类型信息和内存结构，不用反射能行吗？可以的！使用汇编语言，直接和内层打交道，什么信息不能获取？但是，当编程迁移到高级语言上来之后，就不行了！就只能通过反射来达到此项技能。
不同语言的反射模型不尽相同，有些语言还不支持反射。《Go 语言圣经》中是这样定义反射的：
Go 语言提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法，但是在编译时并不知道这些变量的具体类型，这称为反射机制。
为什么要用反射 需要反射的 2 个常见场景：
有时你需要编写一个函数，但是并不知道传给你的参数类型是什么，可能是没约定好；也可能是传入的类型很多，这些类型并不能统一表示。这时反射就会用的上了。 有时候需要根据某些条件决定调用哪个函数，比如根据用户的输入来决定。这时就需要对函数和函数的参数进行反射，在运行期间动态地执行函数。 在讲反射的原理以及如何用之前，还是说几点不使用反射的理由：
与反射相关的代码，经常是难以阅读的。在软件工程中，代码可读性也是一个非常重要的指标。 Go 语言作为一门静态语言，编码过程中，编译器能提前发现一些类型错误，但是对于反射代码是无能为力的。所以包含反射相关的代码，很可能会运行很久，才会出错，这时候经常是直接 panic，可能会造成严重的后果。 反射对性能影响还是比较大的，比正常代码运行速度慢一到两个数量级。所以，对于一个项目中处于运行效率关键位置的代码，尽量避免使用反射特性。 反射是如何实现的 上一篇文章讲到了 interface，它是 Go 语言实现抽象的一个非常强大的工具。当向接口变量赋予一个实体类型的时候，接口会存储实体的类型信息，反射就是通过接口的类型信息实现的，反射建立在类型的基础上。</description></item><item><title>Generic</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Generic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Generic/</guid><description>概述 参考：
公众号-OSC 开源社区，使用 Go 泛型的最佳时机 公众号-OSC 开源社区，Go 语言之父介绍泛型 公众号-InfoQ，Go 中的泛型：激动人心的突破 Go 语言的 Generic(泛型) 让我们在定义接口、函数、结构体时将其中的类型参数化。我们从古老的 Ada 语言的第一个版本就开始使用泛型了，后来 C++ 的模板中也有泛型，直到 Java 和 C# 中的现代实现都是很常见的例子。
通过 类型参数，可以改变某个变量的类型。准确说是赋予某个变量类型，即 让一个变量从 泛型（宽泛的类型） 变为 定型（定义好的类型）。
泛型为 Go 添加了三个新的重要内容：
面向函数和类型的“类型形参” (type parameters) 将接口类型定义为类型集合，包括没有方法的接口类型 类型推断：在大多数情况下，在调用泛型函数时可省略“类型实参” (type arguments) 类型形参与约束 下面是一个初步理解泛型的最简单例子：
// 泛型 // 使用类型形参编写 Go 函数以处理多种类型 // comparable 是一个内置 Constraint(约束)，用来表示类型形参可以接收的类型实参的种类，所谓的“约束”就是指，T 被约束为可以使用哪几种类型。 // comparable 包含所有可以比较类型，包括：booleans、numbers、strings、pointers、channels、可比较的 arrays、structs 中的属性 // comparable 可以改为 any，表示 T 可以是任意类型 func Index[T comparable](s []T, x T) int { for i, v := range s { // 这里的 v 和 x 都是 T 类型 // 若上层调用时，传进来的 T 的约束类型为 string，则 s 和 x 也是 string 类型；若传进来的 T 的约束类型为 int，则 s 和 x 也是 int 类型 if v == x { return i } } return -1 } func main() { // Index() 函数适用于 int 类型的切片 si := []int{10, 20, 15, -10} fmt.</description></item><item><title>I/O</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/I_O/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/I_O/</guid><description>概述 参考：
Go 标准库，io Go 标准库，bufio 公众号 - 云原生生态圈，Go 写文件的几种姿势，你喜欢哪一种？ Introduction to bufio package in Golang Go 语言中文网，Go 语言 bufio 包介绍 [!Notes] 想要理解 io 标准库的逻辑，必须要理解 Method AND Interface 中的 Interface(接口) 的概念，这是理解 I/O 的前提，否则不要往下阅读！
io.Reader、io.Writer 是 io 包中的接口，用于处理 I/O 操作。
所有实现了 io.Reader 接口的类型都可以作为输入源，例如 文件、网络连接、etc. 所有实现了 io.Writer 接口的类型都可以作为输出目标，例如 文件、网络连接、etc. bufio 包用来帮助处理 buffered I/O(I/O 缓存)，通过 I/O 缓存我们可以减少对系统调用，提高性能。
读取用户的输入 大多数的程序都是处理输入，产生输出；这也正是计算的定义。但是程序如何获取要处理的输入数据呢？有一些程序生成自己的数据，但是通常情况下，输入来自于程序外部，e.g.文件、网络连接、其他程序的输出、敲键盘的用户、命令行参数或其它类似的输入源。想要使用 Go 语言的输入输出功能，一般不外乎下面 3 步
获取输入源的定位符，e.g.文件描述符、用户的标准输入、etc. 通过输入源的定位符，把输入内容放到缓冲区并充缓冲器发送给变量 打印缓冲区的变量即可实现输出输入源提供的数据 fmt 包的 Scan 和 Sscan 开头的函数。
Scanln 扫描来自标准输入的文本，将空格分隔的值一次存放到后续的参数内，直到碰到换行。Scanf 与 Scanln 类似，除了 Scanf 的第一个参数作用格式字符串，用来决定如何读取。以 Sscan 和以 Sscan 开头的函数则是从字符串读取，除此之外，与 Scanf 相同。</description></item><item><title>os</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/os/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/os/</guid><description>概述 参考：
Go 标准库，os os 包提供了 Operating system 功能的接口，不受不同平台的影响。
这是一个简单的示例，打开一个文件并读取其中的一些内容
file, err := os.Open(&amp;#34;file.go&amp;#34;) // For read access. if err != nil { log.Fatal(err) }</description></item><item><title>Template</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Template/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Template/</guid><description>概述 参考：
Go 标准库，text/template Go 标准库，html/template 骏马金龙，Go 标准库：Go template 用法详解 本文只介绍 template 的语法和用法，关于 template 包的函数、方法、template 的结构和原理，见：深入剖析 Go template。
入门示例 以下为 test.html 文件的内容，里面使用了一个 template 语法{{.}}。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta http-equiv=&amp;#34;Content-Type&amp;#34; content=&amp;#34;text/html; charset=utf-8&amp;#34; /&amp;gt; &amp;lt;title&amp;gt;Go Web&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; {{ . }} &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 以下是 test.html 同目录下的一个 go web 程序：
package main import ( &amp;#34;html/template&amp;#34; &amp;#34;net/http&amp;#34; ) func tmpl(w http.ResponseWriter, r *http.Request) { t1, err := template.ParseFiles(&amp;#34;test.html&amp;#34;) if err != nil { panic(err) } t1.</description></item><item><title>Unit test(单元测试)</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Unit-test%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Unit-test%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid><description>概述 参考：
官方文档，教程-添加一个测试 https://geektutu.com/post/quick-go-test.html 1 如何写好单元测试 单元测试(Unit Tests, UT) 是一个优秀项目不可或缺的一部分，特别是在一些频繁变动和多人合作开发的项目中尤为重要。你或多或少都会有因为自己的提交，导致应用挂掉或服务宕机的经历。如果这个时候你的修改导致测试用例失败，你再重新审视自己的修改，发现之前的修改还有一些特殊场景没有包含，恭喜你减少了一次上库失误。也会有这样的情况，项目很大，启动环境很复杂，你优化了一个函数的性能，或是添加了某个新的特性，如果部署在正式环境上之后再进行测试，成本太高。对于这种场景，几个小小的测试用例或许就能够覆盖大部分的测试场景。而且在开发过程中，效率最高的莫过于所见即所得了，单元测试也能够帮助你做到这一点，试想一下，假如你一口气写完一千行代码，debug 的过程也不会轻松，如果在这个过程中，对于一些逻辑较为复杂的函数，同时添加一些测试用例，即时确保正确性，最后集成的时候，会是另外一番体验。
如何写好单元测试呢？
首先，学会写测试用例。比如如何测试单个函数/方法；比如如何做基准测试；比如如何写出简洁精炼的测试代码；再比如遇到数据库访问等的方法调用时，如何 mock。
然后，写可测试的代码。高内聚，低耦合是软件工程的原则，同样，对测试而言，函数/方法写法不同，测试难度也是不一样的。职责单一，参数类型简单，与其他函数耦合度低的函数往往更容易测试。我们经常会说，“这种代码没法测试”，这种时候，就得思考函数的写法可不可以改得更好一些。为了代码可测试而重构是值得的。
接下来将介绍如何使用 Go 语言的标准库 testing 进行单元测试。
2 一个简单例子 Go 语言推荐测试文件和源代码文件放在一块，测试文件以 _test.go 结尾。比如，当前 package 有 calc.go 一个文件，我们想测试 calc.go 中的 Add 和 Mul 函数，那么应该新建 calc_test.go 作为测试文件。
example/ |--calc.go |--calc_test.go 假如 calc.go 的代码如下：
package main func Add(a int, b int) int { return a + b } func Mul(a int, b int) int { return a * b } 那么 calc_test.</description></item><item><title>嵌入静态文件</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/%E5%B5%8C%E5%85%A5%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/%E5%B5%8C%E5%85%A5%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/</guid><description>概述 参考：
Go 包，标准库-embed https://colobu.com/2021/01/17/go-embed-tutorial/ embed 包可以让我们在编译时，将各种静态文件也编译进 Go 的二进制文件中。所以称之为 embed(嵌入)。 要使用 embed 包，除了导入以外，还需要在在声明变量时，添加注释 //go:ebed /PATH/TO/FILE 以使用 go:embed 指令，embed 包将会读取所有 .go 文件中的 go:embed 指令，并将其中的文件加载到变量中，该变量将会保存需要嵌入的静态文件。
注意，注释中 // 和后面的 go:ebed 中间不能有空格
go:ebed 指令有 3 种格式导入静态文件 一、将一个文件嵌入为字符格式
package main import ( _ &amp;#34;embed&amp;#34; &amp;#34;fmt&amp;#34; ) //go:embed hello.txt var s string func main() { fmt.Println(s) } 二、将一个文件嵌入为 bytes 切片
package main import ( _ &amp;#34;embed&amp;#34; &amp;#34;fmt&amp;#34; ) //go:embed hello.txt var b []byte func main() { fmt.</description></item></channel></rss>