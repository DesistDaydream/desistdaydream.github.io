<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Method AND Interface on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Method-AND-Interface/</link><description>Recent content in Method AND Interface on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Method-AND-Interface/index.xml" rel="self" type="application/rss+xml"/><item><title>Method AND Interface</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Method-AND-Interface/Method-AND-Interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Method-AND-Interface/Method-AND-Interface/</guid><description>概述 参考：
公众号-新亮笔记，回答连个被频繁问道的代码写法问题 1.强制检查类型是否实现接口 2.强制接口中所有方法只能在本包中实现 Method 与 Interface 是 Go 语言是想面向对象编程的一种解决方式，但是更轻量。
Go 是面向对象的编程语言吗？
官方 FAQ 给出了标准答案: Yes and No。
当然，Go 有面向对象编程的类型和方法的概念，但是它没有继承(hierarchy)一说。Go 语言的接口实现和其它的编程语言不一样，Go 开发者的初衷就是保证它易于使用，用途更广泛。
还有一种“模拟”产生子类的方法，拿就是通过在类型中嵌入其它的类型，但是这是一种“组合”的方式，而不是继承。
没有了继承， Go 语言的对象变得比 C++和 Java 中更轻量级。
在 Go 语言中，接口定义了一套方法的集合，任何实现这些方法的对象都可以被认为实现了这个接口，这也称作 Duck Type。这不像其它语言比如 java 需要预先声明类型实现了某个或者某些接口，这使得 Go 接口和类型变得很轻量级，它解耦了接口和具体实现的硬绑定。显然这是 Go 的开发者深思熟虑的一个决定。
if something looks like a duck, swims like a duck and quacks like a duck then it’s probably a duck.
因为没有继承，你也只能通过 Go 接口实现面向对象编程的多态。本身 Go 接口在内部实现上也是一个(其实是两种,其中一种专门处理 interface{})结构体，它的虚函数指向具体的类型的实现。在编译代码的时候，Go 编译器还会做优化，不需要接口的时候，它会使用具体的方法来代替接口使用，这样进一步优化性能，这叫做 devirtualize 调用。</description></item><item><title>Go 接口设计原则</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Method-AND-Interface/Go-%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Method-AND-Interface/Go-%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</guid><description>Go 接口设计原则 参考：原文链接
1.1 平铺式的模块设计 那么作为interface数据类型，他存在的意义在哪呢？ 实际上是为了满足一些面向对象的编程思想。我们知道，软件设计的最高目标就是高内聚，低耦合。那么其中有一个设计原则叫开闭原则。什么是开闭原则呢，接下来我们看一个例子：
package main import &amp;#34;fmt&amp;#34; // 我们要写一个结构体,Banker 银行业务员 type Banker struct { } // 存款业务 func (this *Banker) Save() { fmt.Println( &amp;#34;进行了 存款业务...&amp;#34;) } // 转账业务 func (this *Banker) Transfer() { fmt.Println( &amp;#34;进行了 转账业务...&amp;#34;) } // 支付业务 func (this *Banker) Pay() { fmt.Println( &amp;#34;进行了 支付业务...&amp;#34;) } func main() { banker := &amp;amp;Banker{} banker.Save() banker.Transfer() banker.Pay() } 代码很简单，就是一个银行业务员，他可能拥有很多的业务，比如Save()存款、Transfer()转账、Pay()支付等。那么如果这个业务员模块只有这几个方法还好，但是随着我们的程序写的越来越复杂，银行业务员可能就要增加方法，会导致业务员模块越来越臃肿。
这样的设计会导致，当我们去给 Banker 添加新的业务的时候，会直接修改原有的 Banker 代码，那么 Banker 模块的功能会越来越多，出现问题的几率也就越来越大，假如此时 Banker 已经有 99 个业务了，现在我们要添加第 100 个业务，可能由于一次的不小心，导致之前 99 个业务也一起崩溃，因为所有的业务都在一个 Banker 类里，他们的耦合度太高，Banker 的职责也不够单一，代码的维护成本随着业务的复杂正比成倍增大。</description></item><item><title>接口设计示例 二</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Method-AND-Interface/%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E7%A4%BA%E4%BE%8B-%E4%BA%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Method-AND-Interface/%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E7%A4%BA%E4%BE%8B-%E4%BA%8C/</guid><description>这个示例与前文中的设计原则里的张三李四开车非常相似。只不过这里是咱自己总结的。。。不足的地方后续慢慢再改~
在下面的例子中，我们把 main() 中的代码当作外部代码，通过调用我们暴露出来的接口(这里的接口仅仅是一个函数)，来获取想要的数据。其实就等于说，除了 main() 以外，其他的代码都当作是其他 package 内的代码。然后通过 main() 调用。在网上的很多代码示例，都是这么来搞得。
只有一个 struct 现在我想要计算一个图形周长和面积。假定现在只有一个正方形，那么我定义一个正方形
// Square 正方形的属性 type Square struct { side float32 } 并且有两个方法来计算正方形的面积与周长
// Area 正方形求面积的方法，接收了正方形的结构体并使用结构体中的边长属性来计算面积 func (sq *Square) Area() float32 { return sq.side * sq.side } // Perimeter 正方形求周长的方法 func (sq *Square) Perimeter() float32 { return sq.side * 4 } 并且提供一个函数，供其他人调用以便获取图形的面积与周长，只需要调用 PrintResult() 函数，并传递参数即可。
// PrintResult 输出计算结果 func PrintResult(shape string, s*Square) { fmt.Printf(&amp;#34;%s的面积：%.2f\n&amp;#34;, shape, s.Area()) fmt.Printf(&amp;#34;%s的周长：%.2f\n&amp;#34;, shape, s.Perimeter()) } 下面这是一段完整的代码，我们可以在 main() 中调用 PrintResult() 来获取正方形的周长和面积。</description></item><item><title>接收设计示例 三</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Method-AND-Interface/%E6%8E%A5%E6%94%B6%E8%AE%BE%E8%AE%A1%E7%A4%BA%E4%BE%8B-%E4%B8%89/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Method-AND-Interface/%E6%8E%A5%E6%94%B6%E8%AE%BE%E8%AE%A1%E7%A4%BA%E4%BE%8B-%E4%B8%89/</guid><description>与 示例二 类型，只不过 示例二 的接口中包含两个方法，可以去掉一个，只计算面积或者周长，那么就与本示例类似了
package contract // Contract 临时工类型，属性有ID和基本工资 type Contract struct { EmpID int Basicpay int } // CalculateSalary 临时员工的工资只有基本工资 func (c Contract) CalculateSalary() int { return c.Basicpay } package permanent // Permanent 永久员工类型，属性有ID和基本工资与附加工资 type Permanent struct { EmpID int Basicpay int Pf int } // CalculateSalary 永久员工的工资是基本工资和附加工资的综合 func (p Permanent) CalculateSalary() int { return p.Basicpay + p.Pf } package main import ( &amp;#34;fmt&amp;#34; &amp;#34;reflect&amp;#34; ) // SalaryCalculator 薪酬计算器接口，包含一个计算薪酬的方法 type SalaryCalculator interface { CalculateSalary() int } // 在 salary/ 下定义了两个结构体及其方法，结构体实现了 SalaryCalculator 接口 // TotalExpense 通过迭代 SalaryCalculator 切片并总结各个员工的工资来计算总费用 func TotalExpense(s []SalaryCalculator) { expense := 0 // 通过接口的切片s来获取其内每个元素的值v，根据其所对应的结构体类型，来引用相应的方法。 // 虽然变量v的类型会变成不同的结构体类型，但是本质上，变量v依然是接口 for index, v := range s { fmt.</description></item></channel></rss>