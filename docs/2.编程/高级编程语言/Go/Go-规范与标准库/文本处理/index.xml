<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 文本处理</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/</link><description>Recent content in 文本处理 on 断念梦</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 文本处理</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;h1 id="格式化输出">格式化输出&lt;/h1>
&lt;p>像&lt;strong>表格&lt;/strong>一样输出数据，有多个包可以实现这种效果：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://pkg.go.dev/text/tabwriter">https://pkg.go.dev/text/tabwriter&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/olekukonko/tablewriter">https://github.com/olekukonko/tablewriter&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/bndr/gotabulate">https://github.com/bndr/gotabulate&lt;/a>
&lt;ul>
&lt;li>kubecm 项目使用这个库&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="格式化占位符">格式化占位符&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://pkg.go.dev/fmt#hdr-Printing">Go 包，标准库-fmt-hdr 打印&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cnblogs.com/qing123/articles/4353353.html">博客园，情三-golang fmt 格式“占位符”&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>格式化占位符，也可以称为 &lt;strong>format verbs(格式化动词)&lt;/strong>。这些动词可以在输出时，告诉数据应该以什么类型、样式输出。这类似于 C 语言的 printf 和 scanf，但是更简洁。&lt;/p>
&lt;p>以下面的代码为例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Human&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">people&lt;/span> = &lt;span style="color:#a6e22e">Human&lt;/span>{&lt;span style="color:#a6e22e">Name&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;zhangsan&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="普通占位符">普通占位符&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>占位符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>%v&lt;/td>
&lt;td>根据值来自动推断类型的默认格式&lt;/td>
&lt;td>Printf(&amp;quot;%v&amp;quot;, people)&lt;/td>
&lt;td>{zhangsan}，&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%+v&lt;/td>
&lt;td>打印结构体时，会添加字段名&lt;/td>
&lt;td>Printf(&amp;quot;%+v&amp;quot;, people)&lt;/td>
&lt;td>{Name:zhangsan}&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%#v&lt;/td>
&lt;td>相应值的 Go 语法表示&lt;/td>
&lt;td>Printf(&amp;quot;#v&amp;quot;, people)&lt;/td>
&lt;td>main.Human{Name:&amp;ldquo;zhangsan&amp;rdquo;}&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%T&lt;/td>
&lt;td>相应值的类型的 Go 语法表示&lt;/td>
&lt;td>Printf(&amp;quot;%T&amp;quot;, people)&lt;/td>
&lt;td>main.Human&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%%&lt;/td>
&lt;td>字面上的百分号，并非值的占位符&lt;/td>
&lt;td>Printf(&amp;quot;%%&amp;quot;)&lt;/td>
&lt;td>%&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="布尔占位符">布尔占位符&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>占位符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>%t&lt;/td>
&lt;td>true 或 false。&lt;/td>
&lt;td>Printf(&amp;quot;%t&amp;quot;, true)&lt;/td>
&lt;td>true&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="整数占位符">整数占位符&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>占位符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>%b&lt;/td>
&lt;td>二进制表示&lt;/td>
&lt;td>Printf(&amp;quot;%b&amp;quot;, 5)&lt;/td>
&lt;td>101&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%c&lt;/td>
&lt;td>相应 Unicode 码点所表示的字符&lt;/td>
&lt;td>Printf(&amp;quot;%c&amp;quot;, 0x4E2D)&lt;/td>
&lt;td>中&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%d&lt;/td>
&lt;td>十进制表示&lt;/td>
&lt;td>Printf(&amp;quot;%d&amp;quot;, 0x12)&lt;/td>
&lt;td>18&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%o&lt;/td>
&lt;td>八进制表示&lt;/td>
&lt;td>Printf(&amp;quot;%d&amp;quot;, 10)&lt;/td>
&lt;td>12&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%q&lt;/td>
&lt;td>单引号围绕的字符字面值，由 Go 语法安全地转义&lt;/td>
&lt;td>Printf(&amp;quot;%q&amp;quot;, 0x4E2D)&lt;/td>
&lt;td>&amp;lsquo;中&amp;rsquo;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%x&lt;/td>
&lt;td>十六进制表示，字母形式为小写 a-f&lt;/td>
&lt;td>Printf(&amp;quot;%x&amp;quot;, 13)&lt;/td>
&lt;td>d&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%X&lt;/td>
&lt;td>十六进制表示，字母形式为大写 A-F&lt;/td>
&lt;td>Printf(&amp;quot;%x&amp;quot;, 13)&lt;/td>
&lt;td>D&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%U&lt;/td>
&lt;td>Unicode 格式：U+1234，等同于 &amp;ldquo;U+%04X&amp;rdquo;&lt;/td>
&lt;td>Printf(&amp;quot;%U&amp;quot;, 0x4E2D)&lt;/td>
&lt;td>U+4E2D&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="浮点数和复数的组成部分实部和虚部">浮点数和复数的组成部分(实部和虚部)&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>占位符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>%b&lt;/td>
&lt;td>无小数部分的，指数为二的幂的科学计数法,与 strconv.FormatFloat 的 &amp;lsquo;b&amp;rsquo; 转换格式一致。&lt;/td>
&lt;td>&lt;/td>
&lt;td>-123456p-78&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%e&lt;/td>
&lt;td>科学计数法，例如 -1234.456e+78&lt;/td>
&lt;td>Printf(&amp;quot;%e&amp;quot;, 10.2)&lt;/td>
&lt;td>1.020000e+01&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%E&lt;/td>
&lt;td>科学计数法，例如 -1234.456E+78&lt;/td>
&lt;td>Printf(&amp;quot;%e&amp;quot;, 10.2)&lt;/td>
&lt;td>1.020000E+01&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%f&lt;/td>
&lt;td>有小数点而无指数，例如 123.456&lt;/td>
&lt;td>Printf(&amp;quot;%f&amp;quot;, 10.2)&lt;/td>
&lt;td>10.200000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%g&lt;/td>
&lt;td>根据情况选择 %e 或 %f 以产生更紧凑的(无末尾的 0)输出&lt;/td>
&lt;td>Printf(&amp;quot;%g&amp;quot;, 10.20)&lt;/td>
&lt;td>10.2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%G&lt;/td>
&lt;td>根据情况选择 %E 或 %f 以产生更紧凑的(无末尾的 0)输出&lt;/td>
&lt;td>Printf(&amp;quot;%G&amp;quot;, 10.20+2i)&lt;/td>
&lt;td>(10.2+2i)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>%2.f&lt;/code> 可以保留小数点后两位，修改数字以确定要保留小数点后的位数&lt;/p>
&lt;h2 id="字符串与字节切片">字符串与字节切片&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>占位符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>%s&lt;/td>
&lt;td>输出字符串表示(string 类型或[]byte)&lt;/td>
&lt;td>Printf(&amp;quot;%s&amp;quot;, []byte(&amp;ldquo;Go 语言&amp;rdquo;))&lt;/td>
&lt;td>Go 语言&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%q&lt;/td>
&lt;td>双引号围绕的字符串，由 Go 语法安全地转义&lt;/td>
&lt;td>Printf(&amp;quot;%q&amp;quot;, &amp;ldquo;Go 语言&amp;rdquo;)&lt;/td>
&lt;td>&amp;ldquo;Go 语言&amp;rdquo;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%x&lt;/td>
&lt;td>十六进制，小写字母，每字节两个字符&lt;/td>
&lt;td>Printf(&amp;quot;%x&amp;quot;, &amp;ldquo;golang&amp;rdquo;)&lt;/td>
&lt;td>676f6c616e67&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%X&lt;/td>
&lt;td>十六进制，大写字母，每字节两个字符&lt;/td>
&lt;td>Printf(&amp;quot;%X&amp;quot;, &amp;ldquo;golang&amp;rdquo;)&lt;/td>
&lt;td>676F6C616E67&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="指针">指针&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>占位符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>%p&lt;/td>
&lt;td>十六进制表示，前缀 0x&lt;/td>
&lt;td>Printf(&amp;quot;%p&amp;quot;, &amp;amp;people)&lt;/td>
&lt;td>0x4f57f0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="其它标记">其它标记&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>占位符&lt;/th>
&lt;th>说明&lt;/th>
&lt;th>举例&lt;/th>
&lt;th>输出&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>+&lt;/td>
&lt;td>总打印数值的正负号；对于%q(%+q)保证只输出 ASCII 编码的字符。&lt;/td>
&lt;td>Printf(&amp;quot;%+q&amp;quot;, &amp;ldquo;中文&amp;rdquo;)&lt;/td>
&lt;td>&amp;ldquo;\u4e2d\u6587&amp;rdquo;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-&lt;/td>
&lt;td>在右侧而非左侧填充空格(左对齐该区域)&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>#&lt;/td>
&lt;td>备用格式：为八进制添加前导 0(%#o)&lt;/td>
&lt;td>Printf(&amp;quot;%#U&amp;quot;, &amp;lsquo;中&amp;rsquo;)&lt;/td>
&lt;td>U+4E2D&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>为十六进制添加前导 0x(%#x)或 0X(%#X)，为 %p(%#p)去掉前导 0x；&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>如果可能的话，%q(%#q)会打印原始 (即反引号围绕的)字符串；&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>如果是可打印字符，%U(%#U)会写出该字符的 Unicode 编码形式(如字符 x 会被打印成 U+0078 &amp;lsquo;x&amp;rsquo;)。&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;rsquo; '&lt;/td>
&lt;td>(空格)为数值中省略的正负号留出空白(% d)；以十六进制(% x, % X)打印字符串或切片时，在字节之间用空格隔开&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>填充前导的 0 而非空格；对于数字，这会将填充移到正负号之后&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>golang 没有 &amp;lsquo;%u&amp;rsquo; 点位符，若整数为无符号类型，默认就会被打印成无符号的。&lt;/p>
&lt;p>宽度与精度的控制格式以 Unicode 码点为单位。宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。&lt;/p>
&lt;p>操作数的类型为 int 时，宽度与精度都可用字符&lt;code>*&lt;/code>表示。&lt;/p>
&lt;p>对于 %g/%G 而言，精度为所有数字的总数，例如：123.45，%.4g 会打印 123.5，(而 %6.2f 会打印 123.45)。&lt;/p>
&lt;p>%e 和 %f 的默认精度为 6&lt;/p>
&lt;p>对大多数的数值类型而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。&lt;/p>
&lt;p>而以字符串类型，精度为输出的最大字符数，如果必要的话会直接截断。&lt;/p></description></item><item><title>Docs: JSON 数据格式处理</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/JSON-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/JSON-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%A4%84%E7%90%86/</guid><description/></item><item><title>Docs: YAML 数据处理</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/YAML-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/YAML-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</guid><description>
&lt;p>YAML解析库 沿用了 JSON解析库 的相关说法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;io/ioutil&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;log&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;gopkg.in/yaml.v2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//Nginx nginx 配置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Nginx&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Port&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#e6db74">`yaml:&amp;#34;Port&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">LogPath&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`yaml:&amp;#34;LogPath&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Path&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`yaml:&amp;#34;Path&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//Config 系统配置配置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Config&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`yaml:&amp;#34;SiteName&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Addr&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`yaml:&amp;#34;SiteAddr&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">HTTPS&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#e6db74">`yaml:&amp;#34;Https&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">SiteNginx&lt;/span> &lt;span style="color:#a6e22e">Nginx&lt;/span> &lt;span style="color:#e6db74">`yaml:&amp;#34;Nginx&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">setting&lt;/span> &lt;span style="color:#a6e22e">Config&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">config&lt;/span>, &lt;span style="color:#a6e22e">errRead&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ioutil&lt;/span>.&lt;span style="color:#a6e22e">ReadFile&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;./info.yaml&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">errRead&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Print&lt;/span>(&lt;span style="color:#a6e22e">errRead&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">errUnmarshal&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">yaml&lt;/span>.&lt;span style="color:#a6e22e">Unmarshal&lt;/span>(&lt;span style="color:#a6e22e">config&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">setting&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">errUnmarshal&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Fatalf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;error: %v&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">errUnmarshal&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">setting&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">setting&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">setting&lt;/span>.&lt;span style="color:#a6e22e">Addr&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">setting&lt;/span>.&lt;span style="color:#a6e22e">HTTPS&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">setting&lt;/span>.&lt;span style="color:#a6e22e">SiteNginx&lt;/span>.&lt;span style="color:#a6e22e">Port&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">setting&lt;/span>.&lt;span style="color:#a6e22e">SiteNginx&lt;/span>.&lt;span style="color:#a6e22e">LogPath&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">setting&lt;/span>.&lt;span style="color:#a6e22e">SiteNginx&lt;/span>.&lt;span style="color:#a6e22e">Path&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 正则处理</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/%E6%AD%A3%E5%88%99%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/%E6%AD%A3%E5%88%99%E5%A4%84%E7%90%86/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.cnblogs.com/williamjie/p/9686311.html">原文链接&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Go 遵循 &lt;a href="docs/8.%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Regular%20Expression(%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F).md">Regular Expression(正则表达式)&lt;/a> 语法&lt;/p>
&lt;p>手机号码正则匹配&lt;/p>
&lt;pre>&lt;code>String PHONE_NUMBER_REG = &amp;quot;^(13[0-9]|14[579]|15[0-3,5-9]|16[6]|17[0135678]|18[0-9]|19[89])\\d{8}$&amp;quot;;
/**
* JS 使用
*/
&amp;quot;18016381232&amp;quot;.match(/^(13[0-9]|14[579]|15[0-3,5-9]|16[6]|17[0135678]|18[0-9]|19[89])\d{8}$/)
&lt;/code>&lt;/pre>
&lt;h2 id="元字符">元字符&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>代码&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>.&lt;/td>
&lt;td>匹配除换行符以外的任意字符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\w&lt;/td>
&lt;td>匹配字母或数字或下划线或汉字&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\s&lt;/td>
&lt;td>匹配任意的空白符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\d&lt;/td>
&lt;td>匹配数字&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\b&lt;/td>
&lt;td>匹配单词的开始或结束&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>^&lt;/td>
&lt;td>匹配字符串的开始&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$&lt;/td>
&lt;td>匹配字符串的结束&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="字符转义">字符转义&lt;/h2>
&lt;p>如果你想查找元字符本身的话，比如你查找.,或者*,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用.和*。当然，要查找\本身，你也得用\.&lt;/p>
&lt;p>例如：deerchao.net 匹配 deerchao.net，C:\Windows 匹配 C:\Windows&lt;/p>
&lt;h2 id="重复">重复：&lt;/h2>
&lt;p>你已经看过了前面的*,+,{2},{5,12}这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等)：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>代码/语法&lt;/td>
&lt;td>说明&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>*&lt;/td>
&lt;td>重复零次或更多次&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>+&lt;/td>
&lt;td>重复一次或更多次&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>?&lt;/td>
&lt;td>重复零次或一次&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>{n}&lt;/td>
&lt;td>重复 n 次&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>{n,}&lt;/td>
&lt;td>重复 n 次或更多次&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>{n,m}&lt;/td>
&lt;td>重复 n 到 m 次&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>下面是一些使用重复的例子：&lt;/p>
&lt;p>&lt;code>Windows\d+&lt;/code> 匹配 Windows 后面跟 1 个或更多数字&lt;/p>
&lt;p>&lt;code>^\w+&lt;/code> 匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)&lt;/p>
&lt;h2 id="字符类">字符类：&lt;/h2>
&lt;p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母 a,e,i,o,u),应该怎么办？&lt;/p>
&lt;p>很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。&lt;/p>
&lt;p>我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\d 就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）。&lt;/p>
&lt;p>下面是一个更复杂的表达式：(?0\d{2}[) -]?\d{8}。&lt;/p>
&lt;p>“(”和“)”也是元字符，后面的分组节里会提到，所以在这里需要使用转义。&lt;/p>
&lt;p>这个表达式可以匹配几种格式的电话号码，像(010)88886666，或 022-22334455，或 02912345678 等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现 0 次或 1 次(?),然后是一个 0，后面跟着 2 个数字(\d{2})，然后是)或-或空格中的一个，它出现 1 次或不出现(?)，最后是 8 个数字(\d{8})。&lt;/p>
&lt;h2 id="分枝条件">分枝条件：&lt;/h2>
&lt;p>不幸的是，刚才那个表达式也能匹配 010)12345678 或(022-87654321 这样的“不正确”的格式。要解决这个问题，我们需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：&lt;/p>
&lt;p>&lt;code>0\d{2}-\d{8}|0\d{3}-\d{7}&lt;/code> 这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8 位本地号(如 010-12345678)，一种是 4 位区号，7 位本地号(0376-2233445)。&lt;/p>
&lt;p>&lt;code>(?0\d{2})?\[- ]?\d{8}|0\d{2}\[- ]?\d{8}&lt;/code> 这个表达式匹配 3 位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持 4 位区号的。&lt;/p>
&lt;p>&lt;code>\d{5}-\d{4}|\d{5}&lt;/code> 这个表达式用于匹配美国的邮政编码。美国邮编的规则是 5 位数字，或者用连字号间隔的 9 位数字。之所以要给出这个例子是因为它能说明一个问题：&lt;strong>使用分枝条件时，要注意各个条件的顺序&lt;/strong>。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配 5 位的邮编(以及 9 位邮编的前 5 位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。&lt;/p>
&lt;h2 id="分组">分组&lt;/h2>
&lt;p>我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。&lt;/p>
&lt;p>(\d{1,3}.){3}\d{1,3}是一个简单的 IP 地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配 1 到 3 位的数字，(\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复 3 次，最后再加上一个一到三位的数字(\d{1,3})。&lt;/p>
&lt;p>IP 地址中每个数字都不能大于 255. 经常有人问我, 01.02.03.04 这样前面带有 0 的数字, 是不是正确的 IP 地址呢? 答案是: 是的, IP 地址里的数字可以包含有前导 0 (leading zeroes).&lt;/p>
&lt;p>不幸的是，它也将匹配 256.300.888.999 这种不可能存在的 IP 地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的 IP 地址：((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。&lt;/p>
&lt;p>理解这个表达式的关键是理解 2[0-4]\d|25[0-5]|[01]?\d\d?，这里我就不细说了，你自己应该能分析得出来它的意义。&lt;/p>
&lt;h2 id="反义">反义&lt;/h2>
&lt;p>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>代码/语法&lt;/td>
&lt;td>说明&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\W&lt;/td>
&lt;td>匹配任意不是字母，数字，下划线，汉字的字符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\S&lt;/td>
&lt;td>匹配任意不是空白符的字符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\D&lt;/td>
&lt;td>匹配任意非数字的字符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\B&lt;/td>
&lt;td>匹配不是单词开头或结束的位置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>[^x]&lt;/td>
&lt;td>匹配除了 x 以外的任意字符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>[^aeiou]&lt;/td>
&lt;td>匹配除了 aeiou 这几个字母以外的任意字符&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>例子：\S+匹配不包含空白符的字符串。&lt;/p>
&lt;p>&amp;lt;a[^&amp;gt;]+&amp;gt;匹配用尖括号括起来的以 a 开头的字符串。&lt;/p>
&lt;h2 id="后向引用">后向引用&lt;/h2>
&lt;p>使用小括号指定一个子表达式后，&lt;strong>匹配这个子表达式的文本&lt;/strong>(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为 1，第二个为 2，以此类推。&lt;/p>
&lt;p>呃……其实,组号分配还不像我刚说得那么简单：&lt;/p>
&lt;ul>
&lt;li>分组 0 对应整个正则表达式&lt;/li>
&lt;li>实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号&lt;/li>
&lt;li>你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．&lt;/li>
&lt;/ul>
&lt;p>后向引用用于重复搜索前面某个分组匹配的文本。例如，\1 代表分组 1 匹配的文本。难以理解？请看示例：&lt;/p>
&lt;p>\b(\w+)\b\s+\1\b 可以用来匹配重复的单词，像 go go, 或者 kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为 1 的分组中，然后是 1 个或几个空白符(\s+)，最后是分组 1 中捕获的内容（也就是前面匹配的那个单词）(\1)。&lt;/p>
&lt;p>你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：&lt;code>(?&amp;lt;Word&amp;gt;\w+)&lt;/code> (或者把尖括号换成&amp;rsquo;也行：(?&amp;lsquo;Word&amp;rsquo;\w+)),这样就把\w+的组名指定为 Word 了。要反向引用这个分组捕获的内容，你可以使用 &lt;code>\k&amp;lt;Word&amp;gt;&lt;/code>,所以上一个例子也可以写成这样：&lt;code>\b(?&amp;lt;Word&amp;gt;\w+)\b\s+\k&amp;lt;Word&amp;gt;\b&lt;/code>。&lt;/p>
&lt;p>使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>分类&lt;/th>
&lt;th>代码/语法&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>捕获&lt;/td>
&lt;td>&lt;code>(exp)&lt;/code>&lt;/td>
&lt;td>匹配 exp,并捕获文本到自动命名的组里&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>捕获&lt;/td>
&lt;td>&lt;code>(?&amp;lt;name&amp;gt;exp)&lt;/code>&lt;/td>
&lt;td>匹配 exp,并捕获文本到名称为 name 的组里，也可以写成(?&amp;rsquo;name&amp;rsquo;exp)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>捕获&lt;/td>
&lt;td>&lt;code>(?:exp)&lt;/code>&lt;/td>
&lt;td>匹配 exp,不捕获匹配的文本，也不给此分组分配组号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>零宽断言&lt;/td>
&lt;td>&lt;code>(?=exp)&lt;/code>&lt;/td>
&lt;td>匹配 exp 前面的位置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>零宽断言&lt;/td>
&lt;td>&lt;code>(?&amp;lt;=exp)&lt;/code>&lt;/td>
&lt;td>匹配 exp 后面的位置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>零宽断言&lt;/td>
&lt;td>&lt;code>(?!exp)&lt;/code>&lt;/td>
&lt;td>匹配后面跟的不是 exp 的位置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>零宽断言&lt;/td>
&lt;td>&lt;code>(?\&amp;lt;!exp)&lt;/code>&lt;/td>
&lt;td>匹配前面不是 exp 的位置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>注释&lt;/td>
&lt;td>&lt;code>(?#comment)&lt;/code>&lt;/td>
&lt;td>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？&lt;/p>
&lt;h2 id="零宽断言">零宽断言&lt;/h2>
&lt;p>地球人，是不是觉得这些术语名称太复杂，太难记了？我也有同感。知道有这么一种东西就行了，它叫什么，随它去吧！人若无名，便可专心练剑；物若无名，便可随意取舍……&lt;/p>
&lt;p>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧：&lt;/p>
&lt;p>断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。&lt;/p>
&lt;p>(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式 exp。比如\b\w+(?=ing\b)，匹配以 ing 结尾的单词的前面部分(除了 ing 以外的部分)，如查找 I&amp;rsquo;m singing while you&amp;rsquo;re dancing.时，它会匹配 sing 和 danc。&lt;/p>
&lt;p>(?&amp;lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式 exp。比如(?&amp;lt;=\bre)\w+\b 会匹配以 re 开头的单词的后半部分(除了 re 以外的部分)，例如在查找 reading a book 时，它匹配 ading。&lt;/p>
&lt;p>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&amp;lt;=\d)\d{3})+\b，用它对 1234567890 进行查找时结果是 234567890。&lt;/p>
&lt;p>下面这个例子同时使用了这两种断言：(?&amp;lt;=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。&lt;/p>
&lt;h2 id="负向零宽断言">负向零宽断言&lt;/h2>
&lt;p>前面我们提到过怎么查找&lt;strong>不是某个字符或不在某个字符类里&lt;/strong>的字符的方法(反义)。但是如果我们只是想要&lt;strong>确保某个字符没有出现，但并不想去匹配它&lt;/strong>时怎么办？例如，如果我们想查找这样的单词&amp;ndash;它里面出现了字母 q,但是 q 后面跟的不是字母 u,我们可以尝试这样：&lt;/p>
&lt;p>\b\w&lt;em>q[^u]\w&lt;/em>\b 匹配包含&lt;strong>后面不是字母 u 的字母 q&lt;/strong>的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果 q 出现在单词的结尾的话，像&lt;strong>Iraq&lt;/strong>,&lt;strong>Benq&lt;/strong>，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果 q 是单词的最后一个字符的话，后面的[^u]将会匹配 q 后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w*\b 将会匹配下一个单词，于是\b\w&lt;em>q[^u]\w&lt;/em>\b 就能匹配整个 Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不&lt;strong>消费&lt;/strong>任何字符。现在，我们可以这样来解决这个问题：\b\w*q(?!u)\w*\b。&lt;/p>
&lt;p>零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式 exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b 匹配不包含连续字符串 abc 的单词。&lt;/p>
&lt;p>同理，我们可以用(?&amp;lt;!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式 exp：(?&amp;lt;![a-z])\d{7}匹配前面不是小写字母的七位数字。&lt;/p>
&lt;p>请详细分析表达式(?&amp;lt;=&amp;lt;(\w+)).*(?=&amp;lt;/\1)，这个表达式最能表现零宽断言的真正用途。&lt;/p>
&lt;p>一个更复杂的例子：(?&amp;lt;=&amp;lt;(\w+)).&lt;em>(?=&amp;lt;/\1)匹配不包含属性的简单 HTML 标签内里的内容。(?&amp;lt;=&amp;lt;(\w+))指定了这样的前缀：被尖括号括起来的单词(比如可能是&amp;lt;b)，然后是.&lt;/em>(任意的字符串),最后是一个后缀(?=&amp;lt;/\1)。注意后缀里的/，它用到了前面提过的字符转义；\1 则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是&lt;!-- raw HTML omitted -->的话，后缀就是&lt;!-- raw HTML omitted -->了。整个表达式匹配的是&lt;!-- raw HTML omitted -->和&lt;!-- raw HTML omitted -->之间的内容(再次提醒，不包括前缀和后缀本身)。&lt;/p>
&lt;h2 id="注释">注释&lt;/h2>
&lt;p>小括号的另一种用途是通过语法(?#comment)来包含注释。例如：&lt;code>2\[0-4]\d(?#200-249)|25[0-5](?#250-255)|\[01]?\d\d?(?#0-199)&lt;/code>。&lt;/p>
&lt;p>要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：&lt;/p>
&lt;pre tabindex="0">&lt;code> (?&amp;lt;= # 断言要匹配的文本的前缀
&amp;lt;(\w+)&amp;gt; # 查找尖括号括起来的字母或数字(即HTML/XML标签)
) # 前缀结束
.* # 匹配任意文本
(?= # 断言要匹配的文本的后缀
&amp;lt;\/\1&amp;gt; # 查找尖括号括起来的内容：前面是一个&amp;#34;/&amp;#34;，后面是先前捕获的标签
) # 后缀结束
golang 实现
&lt;/code>&lt;/pre>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">lib&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;regexp&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">IsEmail&lt;/span>(&lt;span style="color:#a6e22e">email&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">email&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">isOk&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">regexp&lt;/span>.&lt;span style="color:#a6e22e">MatchString&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;^[_a-z0-9-]+(\\.[_a-z0-9-]+)*@[a-z0-9-]+(\\.[a-z0-9-]+)*(\\.[a-z]{2,4})$&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">email&lt;/span>); &lt;span style="color:#a6e22e">isOk&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">IsPhone&lt;/span>(&lt;span style="color:#a6e22e">phoneStr&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">phoneStr&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">isOk&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">regexp&lt;/span>.&lt;span style="color:#a6e22e">MatchString&lt;/span>(&lt;span style="color:#e6db74">`^\([\d]{3}\) [\d]{3}-[\d]{4}$`&lt;/span>, &lt;span style="color:#a6e22e">phoneStr&lt;/span>); &lt;span style="color:#a6e22e">isOk&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">isOk&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>1 数字：^[0-9]*$
2 n位的数字：^\d{n}$
3 至少n位的数字：^\d{n,}$
4 m-n位的数字：^\d{m,n}$
5 零和非零开头的数字：^(0|[1-9][0-9]*)$
6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$
7 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$
8 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$
9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$
10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$
11 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$
12 非零的负整数：^\-[1-9][]0-9&amp;quot;*$ 或 ^-[1-9]\d*$
13 非负整数：^\d+$ 或 ^[1-9]\d*|0$
14 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$
15 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$
16 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$
17 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$
18 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$
19 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$
二、校验字符的表达式
1 汉字：^[\u4e00-\u9fa5]{0,}$
2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$
3 长度为3-20的所有字符：^.{3,20}$
4 由26个英文字母组成的字符串：^[A-Za-z]+$
5 由26个大写英文字母组成的字符串：^[A-Z]+$
6 由26个小写英文字母组成的字符串：^[a-z]+$
7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$
8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$
9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$
10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$
11 可以输入含有^%&amp;amp;',;=?$\&amp;quot;等字符：[^%&amp;amp;',;=?$\x22]+ 12 禁止输入含有~的字符：[^~\x22]+
三、特殊需求表达式
1 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?
3 InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;amp;=]*)?$
4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$
5 电话号码(&amp;quot;XXX-XXXXXXX&amp;quot;、&amp;quot;XXXX-XXXXXXXX&amp;quot;、&amp;quot;XXX-XXXXXXX&amp;quot;、&amp;quot;XXX-XXXXXXXX&amp;quot;、&amp;quot;XXXXXXX&amp;quot;和&amp;quot;XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$
6 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}
7 身份证号(15位、18位数字)：^\d{15}|\d{18}$
8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$
9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$
11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$
12 日期格式：^\d{4}-\d{1,2}-\d{1,2}
13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$
14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$
15 钱的输入格式：
16 1.有四种钱的表示形式我们可以接受:&amp;quot;10000.00&amp;quot; 和 &amp;quot;10,000.00&amp;quot;, 和没有 &amp;quot;分&amp;quot; 的 &amp;quot;10000&amp;quot; 和 &amp;quot;10,000&amp;quot;：^[1-9][0-9]*$
17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符&amp;quot;0&amp;quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$
18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$
19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$
20 5.必须说明的是,小数点后面至少应该有1位数,所以&amp;quot;10.&amp;quot;是不通过的,但是 &amp;quot;10&amp;quot; 和 &amp;quot;10.2&amp;quot; 是通过的：^[0-9]+(.[0-9]{2})?$
21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$
22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$
23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$
24 备注：这就是最终结果了,别忘了&amp;quot;+&amp;quot;可以用&amp;quot;*&amp;quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里
25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$
26 中文字符的正则表达式：[\u4e00-\u9fa5]
27 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))
28 空白行的正则表达式：\n\s*\r (可以用来删除空白行)
29 HTML标记的正则表达式：&amp;lt;(\S*?)[^&amp;gt;]*&amp;gt;.*?|&amp;lt;.*? /&amp;gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)
30 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)
31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)
32 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)
33 IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)
34 IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))
package main
import (
&amp;quot;regexp&amp;quot;
)
const (
regular = &amp;quot;^(13[0-9]|14[57]|15[0-35-9]|18[07-9])\\\\d{8}$&amp;quot;
)
func validate(mobileNum string) bool {
reg := regexp.MustCompile(regular)
return reg.MatchString(mobileNum)
}
func main() {
if validate(&amp;quot;13888888888&amp;quot;) {
println(&amp;quot;是手机号&amp;quot;)
return
}
println(&amp;quot;不是手机号&amp;quot;)
}
//该片段来自
------------------------------------------------------------
Golang中的正则表达式
------------------------------------------------------------
用法：
------------------------------
单一：
. 匹配任意一个字符，如果设置 s = true，则可以匹配换行符
[字符类] 匹配“字符类”中的一个字符，“字符类”见后面的说明
[^字符类] 匹配“字符类”外的一个字符，“字符类”见后面的说明
\小写Perl标记 匹配“Perl类”中的一个字符，“Perl类”见后面的说明
\大写Perl标记 匹配“Perl类”外的一个字符，“Perl类”见后面的说明
[:ASCII类名:] 匹配“ASCII类”中的一个字符，“ASCII类”见后面的说明
[:^ASCII类名:] 匹配“ASCII类”外的一个字符，“ASCII类”见后面的说明
\pUnicode普通类名 匹配“Unicode类”中的一个字符(仅普通类)，“Unicode类”见后面的说明
\PUnicode普通类名 匹配“Unicode类”外的一个字符(仅普通类)，“Unicode类”见后面的说明
\p{Unicode类名} 匹配“Unicode类”中的一个字符，“Unicode类”见后面的说明
\P{Unicode类名} 匹配“Unicode类”外的一个字符，“Unicode类”见后面的说明
------------------------------
复合：
xy 匹配 xy（x 后面跟随 y）
x|y 匹配 x 或 y (优先匹配 x)
------------------------------
重复：
x* 匹配零个或多个 x，优先匹配更多(贪婪)
x+ 匹配一个或多个 x，优先匹配更多(贪婪)
x? 匹配零个或一个 x，优先匹配一个(贪婪)
x{n,m} 匹配 n 到 m 个 x，优先匹配更多(贪婪)
x{n,} 匹配 n 个或多个 x，优先匹配更多(贪婪)
x{n} 只匹配 n 个 x
x*? 匹配零个或多个 x，优先匹配更少(非贪婪)
x+? 匹配一个或多个 x，优先匹配更少(非贪婪)
x?? 匹配零个或一个 x，优先匹配零个(非贪婪)
x{n,m}? 匹配 n 到 m 个 x，优先匹配更少(非贪婪)
x{n,}? 匹配 n 个或多个 x，优先匹配更少(非贪婪)
x{n}? 只匹配 n 个 x
------------------------------
分组：
(子表达式) 被捕获的组，该组被编号 (子匹配)
(?P&amp;lt;命名&amp;gt;子表达式) 被捕获的组，该组被编号且被命名 (子匹配)
(?:子表达式) 非捕获的组 (子匹配)
(?标记) 在组内设置标记，非捕获，标记影响当前组后的正则表达式
(?标记:子表达式) 在组内设置标记，非捕获，标记影响当前组内的子表达式
标记的语法是：
xyz (设置 xyz 标记)
-xyz (清除 xyz 标记)
xy-z (设置 xy 标记, 清除 z 标记)
可以设置的标记有：
i 不区分大小写 (默认为 false)
m 多行模式：让 ^ 和 $ 匹配整个文本的开头和结尾，而非行首和行尾(默认为 false)
s 让 . 匹配 \n (默认为 false)
U 非贪婪模式：交换 x* 和 x*? 等的含义 (默认为 false)
------------------------------
位置标记：
^ 如果标记 m=true 则匹配行首，否则匹配整个文本的开头（m 默认为 false）
$ 如果标记 m=true 则匹配行尾，否则匹配整个文本的结尾（m 默认为 false）
\A 匹配整个文本的开头，忽略 m 标记
\b 匹配单词边界
\B 匹配非单词边界
\z 匹配整个文本的结尾，忽略 m 标记
------------------------------
转义序列：
\a 匹配响铃符 （相当于 \x07）
注意：正则表达式中不能使用 \b 匹配退格符，因为 \b 被用来匹配单词边界，
可以使用 \x08 表示退格符。
\f 匹配换页符 （相当于 \x0C）
\t 匹配横向制表符（相当于 \x09）
\n 匹配换行符 （相当于 \x0A）
\r 匹配回车符 （相当于 \x0D）
\v 匹配纵向制表符（相当于 \x0B）
\123 匹配 8 進制编码所代表的字符（必须是 3 位数字）
\x7F 匹配 16 進制编码所代表的字符（必须是 3 位数字）
\x{10FFFF} 匹配 16 進制编码所代表的字符（最大值 10FFFF ）
\Q...\E 匹配 \Q 和 \E 之间的文本，忽略文本中的正则语法
\\ 匹配字符 \
\^ 匹配字符 ^
\$ 匹配字符 $
\. 匹配字符 .
* 匹配字符 *
\+ 匹配字符 +
\? 匹配字符 ?
\{ 匹配字符 {
\} 匹配字符 }
\( 匹配字符 (
\) 匹配字符 )
\[ 匹配字符 [
\] 匹配字符 ]
\| 匹配字符 |
------------------------------
可以将“命名字符类”作为“字符类”的元素：
[\d] 匹配数字 (相当于 \d)
[^\d] 匹配非数字 (相当于 \D)
[\D] 匹配非数字 (相当于 \D)
[^\D] 匹配数字 (相当于 \d)
[[:name:]] 命名的“ASCII 类”包含在“字符类”中 (相当于 [:name:])
[^[:name:]] 命名的“ASCII 类”不包含在“字符类”中 (相当于 [:^name:])
[\p{Name}] 命名的“Unicode 类”包含在“字符类”中 (相当于 \p{Name})
[^\p{Name}] 命名的“Unicode 类”不包含在“字符类”中 (相当于 \P{Name})
------------------------------------------------------------
说明：
------------------------------
“字符类”取值如下（“字符类”包含“Perl类”、“ASCII类”、“Unicode类”）：
x 单个字符
A-Z 字符范围(包含首尾字符)
\小写字母 Perl类
[:ASCII类名:] ASCII类
\p{Unicode脚本类名} Unicode类 (脚本类)
\pUnicode普通类名 Unicode类 (普通类)
------------------------------
“Perl 类”取值如下：
\d 数字 (相当于 [0-9])
\D 非数字 (相当于 [^0-9])
\s 空白 (相当于 [\t\n\f\r ])
\S 非空白 (相当于[^\t\n\f\r ])
\w 单词字符 (相当于 [0-9A-Za-z_])
\W 非单词字符 (相当于 [^0-9A-Za-z_])
------------------------------
“ASCII 类”取值如下
[:alnum:] 字母数字 (相当于 [0-9A-Za-z])
[:alpha:] 字母 (相当于 [A-Za-z])
[:ascii:] ASCII 字符集 (相当于 [\x00-\x7F])
[:blank:] 空白占位符 (相当于 [\t ])
[:cntrl:] 控制字符 (相当于 [\x00-\x1F\x7F])
[:digit:] 数字 (相当于 [0-9])
[:graph:] 图形字符 (相当于 [!-~])
[:lower:] 小写字母 (相当于 [a-z])
[:print:] 可打印字符 (相当于 [ -~] 相当于 [ [:graph:]])
[:punct:] 标点符号 (相当于 [!-/:-@[-反引号{-~])
[:space:] 空白字符(相当于 [\t\n\v\f\r ])
[:upper:] 大写字母(相当于 [A-Z])
[:word:] 单词字符(相当于 [0-9A-Za-z_])
[:xdigit:] 16 進制字符集(相当于 [0-9A-Fa-f])
------------------------------
“Unicode 类”取值如下---普通类：
C -其他- (other)
Cc 控制字符 (control)
Cf 格式 (format)
Co 私人使用区 (private use)
Cs 代理区 (surrogate)
L -字母- (letter)
Ll 小写字母 (lowercase letter)
Lm 修饰字母 (modifier letter)
Lo 其它字母 (other letter)
Lt 首字母大写字母 (titlecase letter)
Lu 大写字母 (uppercase letter)
M -标记- (mark)
Mc 间距标记 (spacing mark)
Me 关闭标记 (enclosing mark)
Mn 非间距标记 (non-spacing mark)
N -数字- (number)
Nd 十進制数字 (decimal number)
Nl 字母数字 (letter number)
No 其它数字 (other number)
P -标点- (punctuation)
Pc 连接符标点 (connector punctuation)
Pd 破折号标点符号 (dash punctuation)
Pe 关闭的标点符号 (close punctuation)
Pf 最后的标点符号 (final punctuation)
Pi 最初的标点符号 (initial punctuation)
Po 其他标点符号 (other punctuation)
Ps 开放的标点符号 (open punctuation)
S -符号- (symbol)
Sc 货币符号 (currency symbol)
Sk 修饰符号 (modifier symbol)
Sm 数学符号 (math symbol)
So 其他符号 (other symbol)
Z -分隔符- (separator)
Zl 行分隔符 (line separator)
Zp 段落分隔符 (paragraph separator)
Zs 空白分隔符 (space separator)
------------------------------
“Unicode 类”取值如下---脚本类：
Arabic 阿拉伯文
Armenian 亚美尼亚文
Balinese 巴厘岛文
Bengali 孟加拉文
Bopomofo 汉语拼音字母
Braille 盲文
Buginese 布吉文
Buhid 布希德文
Canadian_Aboriginal 加拿大土著文
Carian 卡里亚文
Cham 占族文
Cherokee 切诺基文
Common 普通的，字符不是特定于一个脚本
Coptic 科普特文
Cuneiform 楔形文字
Cypriot 塞浦路斯文
Cyrillic 斯拉夫文
Deseret 犹他州文
Devanagari 梵文
Ethiopic 衣索比亚文
Georgian 格鲁吉亚文
Glagolitic 格拉哥里文
Gothic 哥特文
Greek 希腊
Gujarati 古吉拉特文
Gurmukhi 果鲁穆奇文
Han 汉文
Hangul 韩文
Hanunoo 哈鲁喏文
Hebrew 希伯来文
Hiragana 平假名（日语）
Inherited 继承前一个字符的脚本
Kannada 坎那达文
Katakana 片假名（日语）
Kayah_Li 克耶字母
Kharoshthi 卡罗须提文
Khmer 高棉文
Lao 老挝文
Latin 拉丁文
Lepcha 雷布查文
Limbu 林布文
Linear_B B类线形文字（古希腊）
Lycian 利西亚文
Lydian 吕底亚文
Malayalam 马拉雅拉姆文
Mongolian 蒙古文
Myanmar 缅甸文
New_Tai_Lue 新傣仂文
Nko Nko文
Ogham 欧甘文
Ol_Chiki 桑塔利文
Old_Italic 古意大利文
Old_Persian 古波斯文
Oriya 奥里亚文
Osmanya 奥斯曼亚文
Phags_Pa 八思巴文
Phoenician 腓尼基文
Rejang 拉让文
Runic 古代北欧文字
Saurashtra 索拉什特拉文（印度县城）
Shavian 萧伯纳文
Sinhala 僧伽罗文
Sundanese 巽他文
Syloti_Nagri 锡尔赫特文
Syriac 叙利亚文
Tagalog 塔加拉文
Tagbanwa 塔格巴努亚文
Tai_Le 德宏傣文
Tamil 泰米尔文
Telugu 泰卢固文
Thaana 塔安那文
Thai 泰文
Tibetan 藏文
Tifinagh 提非纳文
Ugaritic 乌加里特文
Vai 瓦伊文
Yi 彝文
------------------------------------------------------------
注意：
　　对于 [a-z] 这样的正则表达式，如果要在 [] 中匹配 - ，可以将 - 放在 [] 的开头或结尾，例如 [-a-z] 或 [a-z-]
　　可以在 [] 中使用转义字符：\f、\t、\n、\r、\v、\377、\xFF、\x{10FFFF}、\\、\^、\$、\.、*、\+、\?、\{、\}、\(、\)、\[、\]、\|（具体含义见上面的说明）
　　如果在正则表达式中使用了分组，则在执行正则替换的时候，“替换内容”中可以使用 $1、${1}、$name、${name} 这样的“分组引用符”获取相应的分组内容。其中 $0 代表整个匹配项，$1 代表第 1 个分组，$2 代表第 2 个分组，……。
　　如果“分组引用符”是 $name 的形式，则在解析的时候，name 是取尽可能长的字符串，比如：$1x 相当于 ${1x}，而不是${1}x，再比如：$10 相当于 ${10}，而不是 ${1}0。
　　由于 $ 字符会被转义，所以要在“替换内容”中使用 $ 字符，可以用 \$ 代替。
　　上面介绍的正则表达式语法是“Perl 语法”，除了“Perl 语法”外，Go 语言中还有另一种“POSIX 语法”，“POSIX 语法”除了不能使用“Perl 类”之外，其它都一样。
------------------------------------------------------------
// 示例
func main() {
text := `Hello 世界！123 Go.`
// 查找连续的小写字母
reg := regexp.MustCompile(`[a-z]+`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;ello&amp;quot; &amp;quot;o&amp;quot;]
// 查找连续的非小写字母
reg = regexp.MustCompile(`[^a-z]+`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;H&amp;quot; &amp;quot; 世界！123 G&amp;quot; &amp;quot;.&amp;quot;]
// 查找连续的单词字母
reg = regexp.MustCompile(`[\w]+`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Hello&amp;quot; &amp;quot;123&amp;quot; &amp;quot;Go&amp;quot;]
// 查找连续的非单词字母、非空白字符
reg = regexp.MustCompile(`[^\w\s]+`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;世界！&amp;quot; &amp;quot;.&amp;quot;]
// 查找连续的大写字母
reg = regexp.MustCompile(`[[:upper:]]+`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;H&amp;quot; &amp;quot;G&amp;quot;]
// 查找连续的非 ASCII 字符
reg = regexp.MustCompile(`[[:^ascii:]]+`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;世界！&amp;quot;]
// 查找连续的标点符号
reg = regexp.MustCompile(`[\pP]+`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;！&amp;quot; &amp;quot;.&amp;quot;]
// 查找连续的非标点符号字符
reg = regexp.MustCompile(`[\PP]+`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Hello 世界&amp;quot; &amp;quot;123 Go&amp;quot;]
// 查找连续的汉字
reg = regexp.MustCompile(`[\p{Han}]+`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;世界&amp;quot;]
// 查找连续的非汉字字符
reg = regexp.MustCompile(`[\P{Han}]+`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Hello &amp;quot; &amp;quot;！123 Go.&amp;quot;]
// 查找 Hello 或 Go
reg = regexp.MustCompile(`Hello|Go`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Hello&amp;quot; &amp;quot;Go&amp;quot;]
// 查找行首以 H 开头，以空格结尾的字符串
reg = regexp.MustCompile(`^H.*\s`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Hello 世界！123 &amp;quot;]
// 查找行首以 H 开头，以空白结尾的字符串（非贪婪模式）
reg = regexp.MustCompile(`(?U)^H.*\s`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Hello &amp;quot;]
// 查找以 hello 开头（忽略大小写），以 Go 结尾的字符串
reg = regexp.MustCompile(`(?i:^hello).*Go`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Hello 世界！123 Go&amp;quot;]
// 查找 Go.
reg = regexp.MustCompile(`\QGo.\E`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Go.&amp;quot;]
// 查找从行首开始，以空格结尾的字符串（非贪婪模式）
reg = regexp.MustCompile(`(?U)^.* `)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Hello &amp;quot;]
// 查找以空格开头，到行尾结束，中间不包含空格字符串
reg = regexp.MustCompile(` [^ ]*$`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot; Go.&amp;quot;]
// 查找“单词边界”之间的字符串
reg = regexp.MustCompile(`(?U)\b.+\b`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Hello&amp;quot; &amp;quot; 世界！&amp;quot; &amp;quot;123&amp;quot; &amp;quot; &amp;quot; &amp;quot;Go&amp;quot;]
// 查找连续 1 次到 4 次的非空格字符，并以 o 结尾的字符串
reg = regexp.MustCompile(`[^ ]{1,4}o`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Hello&amp;quot; &amp;quot;Go&amp;quot;]
// 查找 Hello 或 Go
reg = regexp.MustCompile(`(?:Hell|G)o`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.FindAllString(text, -1))
// [&amp;quot;Hello&amp;quot; &amp;quot;Go&amp;quot;]
// 查找 Hello 或 Go，替换为 Hellooo、Gooo
reg = regexp.MustCompile(`(?PHell|G)o`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.ReplaceAllString(text, &amp;quot;${n}ooo&amp;quot;))
// &amp;quot;Hellooo 世界！123 Gooo.&amp;quot;
// 交换 Hello 和 Go
reg = regexp.MustCompile(`(Hello)(.*)(Go)`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.ReplaceAllString(text, &amp;quot;$3$2$1&amp;quot;))
// &amp;quot;Go 世界！123 Hello.&amp;quot;
// 特殊字符的查找
reg = regexp.MustCompile(`[\f\t\n\r\v\123\x7F\x{10FFFF}\\\^\$\.*\+\?\{\}\(\)\[\]\|]`)
fmt.Printf(&amp;quot;%q\n&amp;quot;, reg.ReplaceAllString(&amp;quot;\f\t\n\r\v\123\x7F\U0010FFFF\\^$.*+?{}()[]|&amp;quot;, &amp;quot;-&amp;quot;))
// &amp;quot;----------------------&amp;quot;
}
&lt;/code>&lt;/pre></description></item></channel></rss>