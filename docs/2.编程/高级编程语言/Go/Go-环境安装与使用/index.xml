<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Go 环境安装与使用</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><description>Recent content in Go 环境安装与使用 on 断念梦</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Go 环境安装与使用</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/Go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/Go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://golang.org/doc/install">官方文档，下载并安装 Go&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://golang.org/doc/manage-install">官方文档，安装多个版本的 Go&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pkg.go.dev/cmd/go">Go 包，标准库-cmd-go&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/goproxy/goproxy.cn/issues/61">GitHub 项目-goproxy-goproxy.io 与 goproxy.cn 说明&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>我们可以通过一个名为 go 的二进制文件实现绝大部分日常的 编码、编译 等工作，只要安装好 Go 的环境即可。&lt;/p>
&lt;h1 id="安装-go">安装 Go&lt;/h1>
&lt;h2 id="linux-安装">Linux 安装&lt;/h2>
&lt;p>从&lt;a href="https://golang.org/dl/">官网&lt;/a>下载 linux 版的 &lt;code>.tar.gz&lt;/code> 包&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export GoVersion&lt;span style="color:#f92672">=&lt;/span>1.20.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://go.dev/dl/go&lt;span style="color:#e6db74">${&lt;/span>GoVersion&lt;span style="color:#e6db74">}&lt;/span>.linux-amd64.tar.gz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo tar -C /usr/local -xvzf go&lt;span style="color:#e6db74">${&lt;/span>GoVersion&lt;span style="color:#e6db74">}&lt;/span>.linux-amd64.tar.gz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置环境变量，以便让 shell 可以执行 go 命令并立刻生效&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo tee /etc/profile.d/go.sh &amp;gt; /dev/null &amp;lt;&amp;lt;-&lt;span style="color:#e6db74">&amp;#34;EOF&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># export GOPATH=/opt/gopath&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># export PATH=$PATH:\$GOPATH/bin:/usr/local/go/bin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>$PATH:/usr/local/go/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export GO111MODULE&lt;span style="color:#f92672">=&lt;/span>on
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export GOPROXY&lt;span style="color:#f92672">=&lt;/span>https://goproxy.cn,https://goproxy.io,direct
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export CGO_ENABLED&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>EOF
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>source /etc/profile.d/go.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>CGO_ENABLED 开启后 Go 代码最终编译的可执行文件都是要有外部依赖的。不过我们依然可以通过 disable CGO_ENABLED 来编译出纯静态的 Go 程序，常用于交叉编译
CGO_ENABLED 关闭即可编译出纯静态的 Go 程序，可以用于 alpine 镜像中。&lt;/p>
&lt;/blockquote>
&lt;h2 id="windows-安装">Windows 安装&lt;/h2>
&lt;p>从&lt;a href="https://golang.org/dl/">官网&lt;/a>下载 Windows 版的 msi 安装包&lt;/p>
&lt;p>双击安装 Golang&lt;/p>
&lt;p>配置环境变量，执行命令&lt;/p>
&lt;ul>
&lt;li>go env -w GOPATH=D:\Tools\GoPath&lt;/li>
&lt;li>go env -w GOPROXY=https://goproxy.cn,https://goproxy.io,direct&lt;/li>
&lt;li>go env -w GO111MODULE=on&lt;/li>
&lt;/ul>
&lt;h2 id="安装多个版本的-go">安装多个版本的 Go&lt;/h2>
&lt;p>获取其余版本的 golang&lt;/p>
&lt;ul>
&lt;li>go install golang.org/dl/goX.XX.X@latest&lt;/li>
&lt;li>goX.XX.X download&lt;/li>
&lt;/ul>
&lt;p>新下载的 golang 版本可以像这样使用，在 go 后面加上版本号&lt;/p>
&lt;ul>
&lt;li>goX.XX.X version&lt;/li>
&lt;/ul>
&lt;p>通过 goX.XX.X env 命令查看该 go 版本的变量，可以看到，默认的 GOROOT 是在 ~/sdk/goX.XX.X 目录下的&lt;/p>
&lt;p>所以如果想要切换默认的 go 版本(比如某个程序调用 go 命令时)，只需要将环境变量 GOROOT 指向该目录即可，之后使用 go 命令即可为当前指定的版本&lt;/p>
&lt;h1 id="初始化项目">初始化项目&lt;/h1>
&lt;p>Go 的项目通常由 &lt;a href="https://www.typescriptlang.org/">Go Module&lt;/a> 管理，项目目录中通常必须包含如下几个文件：&lt;/p>
&lt;ul>
&lt;li>go.mod&lt;/li>
&lt;li>go.sum&lt;/li>
&lt;/ul>
&lt;p>go 相关工具通过 &lt;code>go.mod&lt;/code> 与 &lt;code>go.sum&lt;/code> 两个文件管理项目及其依赖&lt;/p>
&lt;p>使用 &lt;code>go mod init &amp;lt;NAME&amp;gt;&lt;/code> 命令在当前目录会创建一个 go.mod 文件。有任何新的 import，都可以通过 &lt;code>go mod tidy&lt;/code> 生成依赖文件再生成 &lt;code>go.sum&lt;/code> 文件。&lt;/p>
&lt;h1 id="编译-go">编译 Go&lt;/h1>
&lt;p>若想在 Windows 中编译依赖 gcc 的项目，则需要安装 gcc 编译器（i.e.&lt;a href="https://sourceforge.net/projects/mingw-w64/">MinGW-w64&lt;/a>）在 file 标签中，下载 &lt;a href="https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-win32/seh/x86_64-8.1.0-release-win32-seh-rt_v6-rev0.7z">x86_64-win32-seh&lt;/a> 这个版本并安装即可。这是一个 tar 包，解压完成后，需要在 Windows 的 ${PATH} 环境变量中，添加解压出来的 bin 目录，通常都在 &lt;code>PATH\TO\x86_64-8.1.0-release-win32-seh-rt_v6-rev0\mingw64\bin&lt;/code> 这里&lt;/p>
&lt;h2 id="交叉编译">交叉编译&lt;/h2>
&lt;p>Linux 下编译出 Windows 的程序。需要安装 Windows 版的 gcc 工具（i.e.&lt;a href="https://www.mingw-w64.org/">MinGW-w64&lt;/a>）(有的环境还需要安装 gcc-multilib 包)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt-get install gcc-mingw-w64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GOOS&lt;span style="color:#f92672">=&lt;/span>windows GOARCH&lt;span style="color:#f92672">=&lt;/span>amd64 CGO_ENABLED&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> CC&lt;span style="color:#f92672">=&lt;/span>x86_64-w64-mingw32-gcc go build
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="在容器中编译">在容器中编译&lt;/h2>
&lt;h3 id="golang-镜像">golang 镜像&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -it -v /&lt;span style="color:#e6db74">${&lt;/span>YourPackageSrc&lt;span style="color:#e6db74">}&lt;/span>:/go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -w /go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> golang:1.17 go build
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>多次使用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -it --network host --name golang &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /root/projects:/root/projects &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /root/go:/go &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> golang:1.17 /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一次性构建&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -it -v /root/projects/&lt;span style="color:#e6db74">${&lt;/span>Project&lt;span style="color:#e6db74">}&lt;/span>:/go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -w /go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> golang:1.17 go build cmd/XX.go
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="go-mingw-镜像">go-mingw 镜像&lt;/h3>
&lt;p>镜像，用于使用基于官方 Go Docker 镜像的 MinGW-w64 工具链为 Windows 构建 Go 二进制文件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run --rm -it -v /&lt;span style="color:#e6db74">${&lt;/span>YourPackageSrc&lt;span style="color:#e6db74">}&lt;/span>:/go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -w /go/work &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -e GOPROXY&lt;span style="color:#f92672">=&lt;/span>https://goproxy.cn,https://goproxy.io,direct
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x1unix/go-mingw go build
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="go-关联文件与配置">Go 关联文件与配置&lt;/h1>
&lt;p>Go 程序的很多关联文件都可以通过 Go 环境变量进行配置，所以绝大部分关联文件都以变量的形式记录。
&lt;strong>$GOPATH&lt;/strong> # GOPATH 环境变量列出了寻找 Go 代码的位置。&lt;strong>同时也是存储 Go 模块的目录，即 go mod 相关命令保存数据的目录&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>./pkg/mod/&lt;/strong> # 存储下载的源代码。&lt;/li>
&lt;li>&lt;strong>./bin/&lt;/strong> # 存储编译的命令。下载的依赖包中若包含二进制文件，也会保存在这个目录中&lt;/li>
&lt;/ul>
&lt;h2 id="go-环境变量">Go 环境变量&lt;/h2>
&lt;p>Go 通过环境变量来配置其运行行为，通过 go env 命令可以看到当前使用的环境变量：
&lt;strong>GO111MODULE=&amp;ldquo;on|off&amp;rdquo;&lt;/strong> # 设置是否使用 go mod，该环境变量将于 1.17 版本删除，并从此开始仅支持 go mod
GOARCH=&amp;ldquo;amd64&amp;rdquo;
GOBIN=&amp;quot;&amp;quot;
GOCACHE=&amp;quot;/root/.cache/go-build&amp;quot;
GOENV=&amp;quot;/root/.config/go/env&amp;quot;
GOEXE=&amp;quot;&amp;quot;
GOFLAGS=&amp;quot;&amp;quot;
GOHOSTARCH=&amp;ldquo;amd64&amp;rdquo;
GOHOSTOS=&amp;ldquo;linux&amp;rdquo;
GOINSECURE=&amp;quot;&amp;quot;
GOMODCACHE=&amp;quot;/root/go/pkg/mod&amp;quot;
GONOPROXY=&amp;quot;&amp;quot;
GONOSUMDB=&amp;quot;&amp;quot;
GOOS=&amp;ldquo;linux&amp;rdquo;
&lt;strong>GOPATH=&lt;!-- raw HTML omitted -->&lt;/strong> # 设置 gopath 所在路径。默认值：&lt;code>~/go&lt;/code>
GOPRIVATE=&amp;quot;&amp;quot;
**GOPROXY=&lt;!-- raw HTML omitted --> **# 设置 go get、go install 命令时，所使用的代理服务器。可以加快获取第三方库的速度。
&lt;strong>GOROOT=&lt;!-- raw HTML omitted -->&lt;/strong> # Go 的安装路径。默认值：Go 的安装路径，Linux 中通常为 /usr/local/go
GOSUMDB=&amp;ldquo;sum.golang.org&amp;rdquo;
GOTMPDIR=&amp;quot;&amp;quot;
GOTOOLDIR=&amp;quot;/usr/local/go/pkg/tool/linux_amd64&amp;quot;
GOVCS=&amp;quot;&amp;quot;
GOVERSION=&amp;ldquo;go1.16.4&amp;rdquo;
GCCGO=&amp;ldquo;gccgo&amp;rdquo;
AR=&amp;ldquo;ar&amp;rdquo;
CC=&amp;ldquo;gcc&amp;rdquo;
CXX=&amp;ldquo;g++&amp;rdquo;
&lt;strong>CGO_ENABLED=&amp;ldquo;0&amp;rdquo;&lt;/strong> # CGO_ENABLED 开启后 Go 代码最终编译的可执行文件都是要有外部依赖的。不过我们依然可以通过 disable CGO_ENABLED 来编译出纯静态的 Go 程序，常用于交叉编译。CGO_ENABLED 关闭即可编译出纯静态的 Go 程序，可以用于 alpine 镜像中。
GOMOD=&amp;quot;/dev/null&amp;quot;
CGO_CFLAGS=&amp;quot;-g -O2&amp;quot;
CGO_CPPFLAGS=&amp;quot;&amp;quot;
CGO_CXXFLAGS=&amp;quot;-g -O2&amp;quot;
CGO_FFLAGS=&amp;quot;-g -O2&amp;quot;
CGO_LDFLAGS=&amp;quot;-g -O2&amp;quot;
PKG_CONFIG=&amp;ldquo;pkg-config&amp;rdquo;
GOGCCFLAGS=&amp;quot;-fPIC -m64 -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build1775394647=/tmp/go-build -gno-record-gcc-switches&amp;quot;&lt;/p>
&lt;h2 id="goproxy-说明">goproxy 说明&lt;/h2>
&lt;p>我把老哥的 Issue 转移到这里来了哈，这个项目才是 &lt;a href="https://goproxy.cn/">goproxy.cn&lt;/a> 的源代码。&lt;a href="https://github.com/goproxy/goproxy">Goproxy&lt;/a> 是这个项目所基于的底层 Go module proxy 实现，它针对的不只是国内的开发者，所以既不建议用中文也不适合讨论 &lt;a href="https://goproxy.cn/">goproxy.cn&lt;/a>。这里讨论老哥你的问题才更为合适。
我先说一下 &lt;a href="https://goproxy.cn/">goproxy.cn&lt;/a> 和 &lt;a href="https://goproxy.io/">goproxy.io&lt;/a> 的背景。io 是由坤哥（&lt;a href="https://github.com/oiooj">@oiooj&lt;/a>）开发出来的，要早于 cn 出现几个月，目前由他跑在他所任职的公司腾讯云的香港区服务器上。cn 是由我发起的，现在完全属于七牛云，也备案在他们名下，自然所有的 CDN 资源和服务器资源都是由他们提供的，我目前跟 cn 的关系是属于它的维护者，并不是拥有者。
再说一下为什么会有两个这么相似的域名且功能类似的项目存在。我注册 cn 是去年二月底，当时是直接查询的 cn 后缀，因为我想的是这种项目肯定也就咱们中国是刚需要单独再来一套，所以并没有查询别的后缀，因为我认为 cn 实在是太合适了。并且由于当时我还在忙我的本科毕设和其他的一下事情，二月份我并没有开始开发 cn，等开发完了跟七牛云的 CEO 许叔（&lt;a href="https://github.com/xushiwei">@xushiwei&lt;/a>）谈交给他们运营时候，我才第一次听同学说到了 io。但当时我点进 io 的 GitHub 仓库一看发现并没有任何地方提到中国并且全是英文就下意识以为它是个国外项目，就没做过多研究，并且的 io 服务器当时也在美国我访问速度有些慢，就也没在意了。
最后再说一下为什么两个项目没有合并了一起发展。这个我和坤哥是有讨论过的，因为有人找上了我跟坤哥。并且坤哥也同意了最后我的提议合并了两个项目，将 cn 留作国内的公共代理，将 io 的代理类流量重定向到 cn 并后续将 io 用作一款搭代理的开源软件来面向全球提供给大家替换掉 JFrog 的一款商业产品，目前只有这一种解决方案才能保持两个功能独立且都能继续存活下去。坤哥之所以能同意我的这个提议一方面是坤哥所任职的公司加班过于严重，还有一方面是他自身没有精力维护了。然后之所以选择留 cn 做公共代理一方面是这两个域名里面只有 cn 能做备案能挂上 CDN 服务，因为这种类型的项目 CDN 服务是刚需，还有一方面是 io 这个域名后缀做全球化项目比 cn 更为合适，所以留 io 作国内代理把 cn 用作面向全球的搭代理的软件就显得很别扭了。
为什么两个项目现在没有合并呢？这个就不是因为我们两个作者了，因为我们两个作者已经达成了一致可以合并。这里面还有第三方地插足（为保其名誉我暂时不提具体是谁），其认为公共代理必须交由其所掌控的“社区”来运营，cn 已经过户给了一家商业公司无法再过户给其所掌控的“社区”，所以 cn 在其眼里就变成了一个其所描述的邪恶公司所拥有的商业产品，于是其要求我和七牛商谈放弃 cn 并全力投入为其做别的开发，于是被我拒绝。最后坤哥在中间处境比较尴尬，所以合并的事儿也就暂时搁置了。
最后，简单来总结一下就是，&lt;a href="https://goproxy.cn/">goproxy.cn&lt;/a> 和 &lt;a href="https://goproxy.io/">goproxy.io&lt;/a> 目前并无直接关系。或许之后没有了第三方地插足它们两个会合并变得有关系，但在那之前它们唯一能联系在一起的是它们都可以用作为 Go module proxy。至于哪个快、哪个稳、哪个香、用哪个，这个需要老哥你自己做判断了，我跟坤哥的关系并不差，所以我现在不会妄加评论。更何况现在 &lt;code>GOPROXY&lt;/code> 不是支持逗号列表嘛。❤️&lt;/p>
&lt;h2 id="gopath">GOPATH&lt;/h2>
&lt;p>注意：以下对 GOPATH 的理解是在 golang1.13 版本之前&lt;/p>
&lt;p>GOPATH 就是 go 项目的工作目录，是开发人员写代码的目录。&lt;/p>
&lt;p>GOPATH 里面一般包含 bin、pkg、src 这 3 个文件夹。&lt;/p>
&lt;p>项目文件夹一般是放在 src 目录中&lt;/p>
&lt;p>一般情况下，如果自己在开发多个项目，那么最好一个项目对应一个 GOPATH 路径。这时候只需要切换 GOPATH 环境变量的值，就可以编译运行对应的项目了。(比如我有两个项目目录/root/cobra 和/root/bee，这俩目录可以分别作为 GOPATH 变量的值，想开发哪个，就把 GOPATH 变量的值改为对应的目录路径)&lt;/p>
&lt;p>这样做的目的主要是为了让每个项目所依赖的库等东西，可以分开而不会冲突&lt;/p>
&lt;p>现在有 go module 之后，就可以不用把项目放在 GOPATH 路径下了。具体 go module 的作用详见 1.4.Go module 的介绍及使用.1 新功能 module 的介绍及使用&lt;/p></description></item><item><title>Docs: Go Module</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/Go-Module/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/Go-Module/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://go.dev/ref/mod">官方文档，参考-Go Modules 参考&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/6gJkSyGAFR0v6kow2uVklA">公众号，Go Modules 终极入门&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/benben_2015/article/details/82227338">https://blog.csdn.net/benben_2015/article/details/82227338&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Go Moduel(Go 模块)&lt;/strong> 是实现 &lt;a href="https://en.wikipedia.org/wiki/Modular_programming">Modular Programming(模块化编程)&lt;/a> 的工具。是 Go 语言中正式官宣的项目依赖解决方案，Go modules（前身为 vgo）发布于 Go1.11，成长于 Go1.12，丰富于 Go1.13，正式于 Go1.14 已经准备好，并且可以用在生产上（ready for production）了，Go 官方也鼓励所有用户从其他依赖项管理工具迁移到 Go modules。&lt;/p>
&lt;p>module 是一个相关 Go 包的集合，它是源代码更替和版本控制的单元。模块由源文件形成的 go.mod 文件的根目录定义，包含 go.mod 文件的目录也被称为模块根。moudles 取代旧的的基于 GOPATH 方法来指定在工程中使用哪些源文件或导入包。模块路径是导入包的路径前缀，go.mod 文件定义模块路径，并且列出了在项目构建过程中使用的特定版本。&lt;/p>
&lt;p>使用 go module 时，GOPATH 不再用于解析导入。但是，它仍然用于存储下载的源代码（在$GOPATH/pkg/mod 中）和编译的命令（在 GOPATH / bin 中）。&lt;/p>
&lt;p>当程序编译时，会读取 go.mod 文件中的路径，来加载其编译所需的各种库&lt;/p>
&lt;p>Go moudles 目前集成在 Go 的工具链中，只要安装了 Go，自然而然也就可以使用 Go moudles 了，而 Go modules 的出现也解决了在 Go1.11 前的几个常见争议问题：&lt;/p>
&lt;ul>
&lt;li>Go 语言长久以来的依赖管理问题。&lt;/li>
&lt;li>“淘汰”现有的 &lt;a href="https://pkg.go.dev/cmd/go#hdr-GOPATH_environment_variable">GOPATH 的使用模式(即.解析导入能力)&lt;/a>。&lt;/li>
&lt;li>统一社区中的其它的依赖管理工具（提供迁移功能）。&lt;/li>
&lt;/ul>
&lt;h1 id="gopath">GOPATH&lt;/h1>
&lt;p>Go Module 出现后，GOPATH 路径变为纯粹的第三方依赖库的保存路径。目录结构通常如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># tree -L 3 $GOPATH&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── godef
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── gomodifytags
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── go-outline
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── gopkgs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── goplay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── gopls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── gotests
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── staticcheck
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── pkg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── mod
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── 9fans.net
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── cache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── fyne.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── github.com
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── gopkg.in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   ├── gorm.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │   └── mvdan.cc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── sumdb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── sum.golang.org
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>bin 下是安装的某些第三方依赖库后生成的二进制文件&lt;/p>
&lt;h2 id="早期-gopath-模式痛点">早期 GOPATH 模式痛点&lt;/h2>
&lt;p>我们先看看第一个问题，GOPATH 是什么，我们可以输入如下命令查看：&lt;/p>
&lt;pre>&lt;code>$ go env
GOPATH=&amp;quot;/root/go&amp;quot;
...
&lt;/code>&lt;/pre>
&lt;p>我们输入 go env 命令行后可以查看到 GOPATH 变量的结果，我们进入到该目录下进行查看，如下：&lt;/p>
&lt;pre>&lt;code>go
├── bin
├── pkg
└── src
├── github.com
├── golang.org
├── google.golang.org
├── gopkg.in
....
&lt;/code>&lt;/pre>
&lt;p>GOPATH 目录下一共包含了三个子目录，分别是：&lt;/p>
&lt;ul>
&lt;li>bin：存储所编译生成的二进制文件。&lt;/li>
&lt;li>pkg：存储预编译的目标文件，以加快程序的后续编译速度。&lt;/li>
&lt;li>src：存储所有项目的源代码。在编写 Go 应用程序，程序包和库时，一般会以$GOPATH/src/github.com/foo/bar 的路径进行存放。&lt;/li>
&lt;/ul>
&lt;p>因此在使用 GOPATH 模式下，我们需要将项目代码存放在固定的$GOPATH/src 目录下，并且如果执行 go get 来拉取外部依赖会自动下载并安装到 $GOPATH 目录下。&lt;/p>
&lt;p>为什么弃用 GOPATH 模式&lt;/p>
&lt;p>在 GOPATH 的 $GOPATH/src 下进行 .go 文件或源代码的存储，我们可以称其为 GOPATH 的模式，这个模式，看起来好像没有什么问题，那么为什么我们要弃用呢，参见如下原因：&lt;/p>
&lt;ul>
&lt;li>GOPATH 模式下没有版本控制的概念，具有致命的缺陷，至少会造成以下问题：
&lt;ul>
&lt;li>在执行 go get 的时候，你无法传达任何的版本信息的期望，也就是说你也无法知道自己当前更新的是哪一个版本，也无法通过指定来拉取自己所期望的具体版本。&lt;/li>
&lt;li>在运行 Go 应用程序的时候，你无法保证其它人与你所期望依赖的第三方库是相同的版本，也就是说在项目依赖库的管理上，你无法保证所有人的依赖版本都一致。&lt;/li>
&lt;li>你没办法处理 v1、v2、v3 等等不同版本的引用问题，因为 GOPATH 模式下的导入路径都是一样的，都是 github.com/foo/bar。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Go 语言官方从 Go1.11 起开始推进 Go modules（前身 vgo），Go1.13 起不再推荐使用 GOPATH 的使用模式，Go modules 也渐趋稳定，因此新项目也没有必要继续使用 GOPATH 模式。&lt;/li>
&lt;/ul>
&lt;p>在 GOPATH 模式下的产物&lt;/p>
&lt;p>Go1 在 2012 年 03 月 28 日发布，而 Go1.11 是在 2018 年 08 月 25 日才正式发布（数据来源：GitHub Tag），在这个空档的时间内，并没有 Go modules 这一个东西，最早期可能还好说，因为刚发布，用的人不多，所以没有明显暴露，但是后期 Go 语言使用的人越来越多了，那怎么办？&lt;/p>
&lt;p>这时候社区中逐渐的涌现出了大量的依赖解决方案，百花齐放，让人难以挑选，其中包括我们所熟知的 vendor 目录的模式，以及曾经一度被认为是“官宣”的 dep 的这类依赖管理工具。&lt;/p>
&lt;p>但为什么 dep 没有正在成为官宣呢，其实是因为随着 Russ Cox 与 Go 团队中的其他成员不断深入地讨论，发现 dep 的一些细节似乎越来越不适合 Go，因此官方采取了另起 proposal 的方式来推进，其方案的结果一开始先是释出 vgo（Go modules 的前身，知道即可，不需要深入了解），最终演变为我们现在所见到的 Go modules，也在 Go1.11 正式进入了 Go 的工具链。&lt;/p>
&lt;p>因此与其说是 “在 GOPATH 模式下的产物”，不如说是历史为当前提供了重要的教训，因此出现了 Go modules。&lt;/p>
&lt;h1 id="go-module-的使用和管理">Go Module 的使用和管理&lt;/h1>
&lt;p>可以这么说，一个自己新建的项目，就是一个模块，一个模块就是一个目录下的所有文件的集合。所以才说一个模块就是一个 Go Package 的合集。&lt;/p>
&lt;h2 id="go-module-相关环境变量">Go Module 相关环境变量&lt;/h2>
&lt;pre>&lt;code>$ go env
GO111MODULE=&amp;quot;auto&amp;quot; # 使用module功能必须要让该变量变为on
GOPROXY=&amp;quot;https://proxy.golang.org,direct&amp;quot;
GONOPROXY=&amp;quot;&amp;quot;
GOSUMDB=&amp;quot;sum.golang.org&amp;quot;
GONOSUMDB=&amp;quot;&amp;quot;
GOPRIVATE=&amp;quot;&amp;quot;
...
&lt;/code>&lt;/pre>
&lt;h3 id="go111module">GO111MODULE&lt;/h3>
&lt;p>Go 语言提供了 GO111MODULE 这个环境变量来作为 Go modules 的开关，其允许设置以下参数：&lt;/p>
&lt;ul>
&lt;li>auto：只要项目包含了 go.mod 文件的话启用 Go modules，目前在 Go1.11 至 Go1.14 中仍然是默认值。&lt;/li>
&lt;li>on：启用 Go modules，推荐设置，将会是未来版本中的默认值。&lt;/li>
&lt;li>off：禁用 Go modules，不推荐设置。&lt;/li>
&lt;/ul>
&lt;p>GO111MODULE 的小历史&lt;/p>
&lt;p>你可能会留意到 GO111MODULE 这个名字比较 “奇特”，实际上在 Go 语言中经常会有这类阶段性的变量， GO111MODULE 这个命名代表着 Go 语言在 1.11 版本添加的，针对 Module 的变量。&lt;/p>
&lt;p>像是在 Go1.5 版本的时候，也发布了一个系统环境变量 GO15VENDOREXPERIMENT，作用是用于开启 vendor 目录的支持，当时其默认值也不是开启，仅仅作为 experimental。其随后在 Go1.6 版本时也将默认值改为了开启，并且最后作为了 official，GO15VENDOREXPERIMENT 系统变量就退出了历史舞台。&lt;/p>
&lt;p>而未来 GO111MODULE 这一个系统环境变量也会面临这个问题，也会先调整为默认值为 on（曾经在 Go1.13 想想改为 on，并且已经合并了 PR，但最后因为种种原因改回了 auto），然后再把 GO111MODULE 的支持给去掉，我们猜测应该会在 Go2 将 GO111MODULE 给去掉，因为如果直接去掉 GO111MODULE 的支持，会存在兼容性问题。&lt;/p>
&lt;h3 id="goproxy">GOPROXY&lt;/h3>
&lt;p>这个环境变量主要是用于设置 Go 模块代理（Go module proxy），其作用是用于使 Go 在后续拉取模块版本时能够脱离传统的 VCS 方式，直接通过镜像站点来快速拉取。&lt;/p>
&lt;p>GOPROXY 的默认值是：&lt;a href="https://proxy.golang.org,direct">https://proxy.golang.org,direct&lt;/a>，这有一个很严重的问题，就是 proxy.golang.org 在国内是无法访问的，因此这会直接卡住你的第一步，所以你必须在开启 Go modules 的时，同时设置国内的 Go 模块代理，执行如下命令：&lt;/p>
&lt;pre>&lt;code> go env -w GOPROXY=https://goproxy.cn,direct
&lt;/code>&lt;/pre>
&lt;p>GOPROXY 的值是一个以英文逗号 “,” 分割的 Go 模块代理列表，允许设置多个模块代理，假设你不想使用，也可以将其设置为 “off” ，这将会禁止 Go 在后续操作中使用任何 Go 模块代理。&lt;/p>
&lt;p>direct 是什么&lt;/p>
&lt;p>而在刚刚设置的值中，我们可以发现值列表中有 “direct” 标识，它又有什么作用呢？&lt;/p>
&lt;p>实际上 “direct” 是一个特殊指示符，用于指示 Go 回源到模块版本的源地址去抓取（比如 GitHub 等），场景如下：当值列表中上一个 Go 模块代理返回 404 或 410 错误时，Go 自动尝试列表中的下一个，遇见 “direct” 时回源，也就是回到源地址去抓取，而遇见 EOF 时终止并抛出类似 “invalid version: unknown revision&amp;hellip;” 的错误。&lt;/p>
&lt;h3 id="gosumdb">GOSUMDB&lt;/h3>
&lt;p>它的值是一个 Go checksum database，用于在拉取模块版本时（无论是从源站拉取还是通过 Go module proxy 拉取）保证拉取到的模块版本数据未经过篡改，若发现不一致，也就是可能存在篡改，将会立即中止。&lt;/p>
&lt;p>GOSUMDB 的默认值为：sum.golang.org，在国内也是无法访问的，但是 GOSUMDB 可以被 Go 模块代理所代理（详见：Proxying a Checksum Database）。&lt;/p>
&lt;p>因此我们可以通过设置 GOPROXY 来解决，而先前我们所设置的模块代理 goproxy.cn 就能支持代理 sum.golang.org，所以这一个问题在设置 GOPROXY 后，你可以不需要过度关心。&lt;/p>
&lt;p>另外若对 GOSUMDB 的值有自定义需求，其支持如下格式：&lt;/p>
&lt;ul>
&lt;li>格式 1：+。&lt;/li>
&lt;li>格式 2：+ 。&lt;/li>
&lt;/ul>
&lt;p>也可以将其设置为 “off”，也就是禁止 Go 在后续操作中校验模块版本。&lt;/p>
&lt;h3 id="gonoproxygonosumdbgoprivate">GONOPROXY/GONOSUMDB/GOPRIVATE&lt;/h3>
&lt;p>这三个环境变量都是用在当前项目依赖了私有模块，例如像是你公司的私有 git 仓库，又或是 github 中的私有库，都是属于私有模块，都是要进行设置的，否则会拉取失败。&lt;/p>
&lt;p>更细致来讲，就是依赖了由 GOPROXY 指定的 Go 模块代理或由 GOSUMDB 指定 Go checksum database 都无法访问到的模块时的场景。&lt;/p>
&lt;p>而一般建议直接设置 GOPRIVATE，它的值将作为 GONOPROXY 和 GONOSUMDB 的默认值，所以建议的最佳姿势是直接使用 GOPRIVATE。&lt;/p>
&lt;p>并且它们的值都是一个以英文逗号 “,” 分割的模块路径前缀，也就是可以设置多个，例如：&lt;/p>
&lt;pre>&lt;code> go env -w GOPRIVATE=&amp;quot;git.example.com,github.com/eddycjy/mquote&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>设置后，前缀为 git.xxx.com 和 github.com/eddycjy/mquote 的模块都会被认为是私有模块。&lt;/p>
&lt;p>如果不想每次都重新设置，我们也可以利用通配符，例如：&lt;/p>
&lt;pre>&lt;code> go env -w GOPRIVATE=&amp;quot;*.example.com&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>这样子设置的话，所有模块路径为 example.com 的子域名（例如：git.example.com）都将不经过 Go module proxy 和 Go checksum database，需要注意的是不包括 example.com 本身。&lt;/p>
&lt;p>具体使用步骤：&lt;/p>
&lt;ul>
&lt;li>通过 go 命令行，进入到你当前的工程目录下，在命令行设置临时环境变量 set GO111MODULE=on；&lt;/li>
&lt;li>执行命令 go mod init NAME 在当前目录下生成一个 go.mod 文件，执行这条命令时，当前目录不能存在 go.mod 文件。如果之前生成过，要先删除；&lt;/li>
&lt;li>如果你工程中存在一些不能确定版本的包，那么生成的 go.mod 文件可能就不完整，因此继续执行下面的命令；&lt;/li>
&lt;li>执行 go mod tidy 命令，它会添加缺失的模块以及移除不需要的模块。执行后会生成 go.sum 文件(模块下载条目)。添加参数-v，例如 go mod tidy -v 可以将执行的信息，即删除和添加的包打印到命令行；&lt;/li>
&lt;li>执行命令 go mod verify 来检查当前模块的依赖是否全部下载下来，是否下载下来被修改过。如果所有的模块都没有被修改过，那么执行这条命令之后，会打印 all modules verified。&lt;/li>
&lt;li>执行命令 go mod vendor 生成 vendor 文件夹，该文件夹下将会放置你 go.mod 文件描述的依赖包，文件夹下同时还有一个文件 modules.txt，它是你整个工程的所有模块。在执行这条命令之前，如果你工程之前有 vendor 目录，应该先进行删除。同理 go mod vendor -v 会将添加到 vendor 中的模块打印出来；&lt;/li>
&lt;/ul>
&lt;h2 id="gomod-文件">go.mod 文件&lt;/h2>
&lt;p>go.mod 文件定义 module 路径以及列出其他需要在 build 时引入的模块的特定的版本。例如下面的例子中，go.mod 声明 example.com/m 路径是 module 的根目录，同时也声明了 module 依赖特定版本的 golang.org/x/text 和 gopkg.in/yaml.v2。&lt;/p>
&lt;p>go.mod 文件中有如下几个关键字：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>module&lt;/strong> # 定义 module 路径，该路径不用与当前路径相同，只是 module 所用的一个名称，可以代指当前目录。(比如/root/lichenhao/cobra/目录下，创建一个 go.mod 文件，可以定义 module 路径为 cobratest，这个 cobratest 模块路径名，就表示/root/lichenhao/cobra/这个目录)to define the module path;&lt;/li>
&lt;li>&lt;strong>go&lt;/strong> # to set the expected language version;&lt;/li>
&lt;li>&lt;strong>require&lt;/strong> # to require a particular module at a given version or later;&lt;/li>
&lt;li>&lt;strong>exclude&lt;/strong> # to exclude a particular module version from use; and&lt;/li>
&lt;li>&lt;strong>replace&lt;/strong> # to replace a module version with a different module version.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">module&lt;/span> &lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">module&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">repo&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#ae81ff">1.13&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">require&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.0&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">20200220041913&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">e066a990ce6f&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>go.mod 文件还可以指定要替换和排除的版本，命令行会自动根据 go.mod 文件来维护需求声明中的版本。如果想获取更多的有关 go.mod 文件的介绍，可以使用命令 go help go.mod。&lt;/p>
&lt;p>go.mod 文件用 // 注释，而不用 /**/。文件的每行都有一条指令，由一个动作加上参数组成。例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">module&lt;/span> &lt;span style="color:#a6e22e">my&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">require&lt;/span> &lt;span style="color:#a6e22e">other&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v1&lt;/span>&lt;span style="color:#ae81ff">.0.2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">require&lt;/span> &lt;span style="color:#a6e22e">new&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v2&lt;/span>&lt;span style="color:#ae81ff">.3.4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">exclude&lt;/span> &lt;span style="color:#a6e22e">old&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v1&lt;/span>&lt;span style="color:#ae81ff">.2.3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">replace&lt;/span> &lt;span style="color:#a6e22e">bad&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v1&lt;/span>&lt;span style="color:#ae81ff">.4.5&lt;/span> =&amp;gt; &lt;span style="color:#a6e22e">good&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v1&lt;/span>&lt;span style="color:#ae81ff">.4.5&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面三个动词 require、exclude、replace 分别表示：项目需要的依赖包及版本、排除某些包的特别版本、取代当前项目中的某些依赖包。&lt;/p>
&lt;p>相同动作的命令可以放到一个动词+括号组成的结构中，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">require&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">new&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v2&lt;/span>&lt;span style="color:#ae81ff">.3.4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">old&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">thing&lt;/span> &lt;span style="color:#a6e22e">v1&lt;/span>&lt;span style="color:#ae81ff">.2.3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="其他命令的支持">其他命令的支持&lt;/h3>
&lt;p>旧的版本，构建编译命令 &lt;code>go build&lt;/code> 中的参数没有 &lt;code>-mod&lt;/code> 参数，最新的版本现在多了这个，用来对 &lt;code>go.mod&lt;/code> 文件进行更新或其他使用控制。形式如：&lt;code>go build -mod [mode]&lt;/code>，其中 mode 有以下几种取值：readonly，release，vendor。当执行 &lt;code>go build -mod=vendor&lt;/code> 的时候，会在生成可执行文件的同时将项目的依赖包放到主模块的 &lt;code>vendor&lt;/code> 目录下。&lt;/p>
&lt;p>&lt;code>go get -m [packages]&lt;/code> 会将下载的依赖包放到 &lt;code>GOPATH/pkg/mod&lt;/code> 目录下，并且将依赖写入到 &lt;code>go.mod&lt;/code> 文件。&lt;code>go get -u=patch&lt;/code> 会更新主模块下的所有依赖包。&lt;/p>
&lt;p>如果遇到不熟悉的导入包，任何可以查找包含该引入包模块的 &lt;code>go&lt;/code> 命令，都会自动将该模块的最新版本添加到 &lt;code>go.mod&lt;/code> 文件中。同时也会添加缺失的模块，以及删除无用的 module。例如：go build, go test 或者 go list 命令。另外，有一个专门的命令 &lt;code>go mod tidy&lt;/code>，用来查看和添加缺失的 module 需求声明以及移除不必要的。&lt;/p>
&lt;p>&lt;code>go.mod&lt;/code> 文件是可读，也是可编辑的。&lt;code>go&lt;/code> 命令行会自动更新 &lt;code>go.mod&lt;/code> 文件来维持一个标准格式以及精确的引入声明。&lt;/p>
&lt;h2 id="gosum-文件">go.sum 文件&lt;/h2>
&lt;p>在第一次拉取模块依赖后，会发现多出了一个 go.sum 文件，其详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了那些模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#ae81ff">4&lt;/span>&lt;span style="color:#a6e22e">QHXKo7J8a6J&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">k8UA6CiHhswJQs0sm2foAQQUq8GFHM&lt;/span>=
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#66d9ef">go&lt;/span>.&lt;span style="color:#a6e22e">mod&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#a6e22e">ZtlkDs7Mriynl7wsDQ4cU23okEtVYqHwl7F1eDh4qPg&lt;/span>=
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">module&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">tour&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#a6e22e">cc&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#a6e22e">pgV0LnR8Fhou0zNHughT7IbSnLvfUZ&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#a6e22e">X3fvshrv8&lt;/span>=
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">module&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">tour&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#66d9ef">go&lt;/span>.&lt;span style="color:#a6e22e">mod&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#a6e22e">uL1FOiQJZ4&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#a6e22e">hzqQ5mv4Sm7nJcwYu41F3nZmkiWx5I&lt;/span>=
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以看到一个模块路径可能有如下两种：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#ae81ff">4&lt;/span>&lt;span style="color:#a6e22e">QHXKo7J8a6J&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">k8UA6CiHhswJQs0sm2foAQQUq8GFHM&lt;/span>=
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">github&lt;/span>.&lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">eddycjy&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">mquote&lt;/span> &lt;span style="color:#a6e22e">v0&lt;/span>&lt;span style="color:#ae81ff">.0.1&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#66d9ef">go&lt;/span>.&lt;span style="color:#a6e22e">mod&lt;/span> &lt;span style="color:#a6e22e">h1&lt;/span>:&lt;span style="color:#a6e22e">ZtlkDs7Mriynl7wsDQ4cU23okEtVYqHwl7F1eDh4qPg&lt;/span>=
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>h1 hash 是 Go modules 将目标模块版本的 zip 文件开包后，针对所有包内文件依次进行 hash，然后再把它们的 hash 结果按照固定格式和算法组成总的 hash 值。&lt;/p>
&lt;p>而 h1 hash 和 go.mod hash 两者，要不就是同时存在，要不就是只存在 go.mod hash。那什么情况下会不存在 h1 hash 呢，就是当 Go 认为肯定用不到某个模块版本的时候就会省略它的 h1 hash，就会出现不存在 h1 hash，只存在 go.mod hash 的情况。&lt;/p>
&lt;h1 id="go-mod-命令行工具">go mod 命令行工具&lt;/h1>
&lt;p>go mod 提供了一系列操作模块的命令，所有的 go 命令中现在已经内置了对 module 的支持，而不仅仅是 go mod 命令。例如使用 go get 时，会经常自动在后台添加、移除、升级、降级依赖包版本。&lt;/p>
&lt;h2 id="syntax语法">Syntax(语法)&lt;/h2>
&lt;p>&lt;strong>go mod [ARGUMENTS]&lt;/strong>&lt;/p>
&lt;p>COMMAND：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>download&lt;/strong> # 下载模块到本地缓存，具体可以通过命令 go env 查看，其中环境变量 GOCACHE 就是缓存的地址，如果该文件夹的内容太大，可以通过命令 go clean -cache&lt;/li>
&lt;li>&lt;strong>edit&lt;/strong> # 从工具或脚本中编辑 go.mod 文件&lt;/li>
&lt;li>&lt;strong>graph&lt;/strong> # 打印模块需求图&lt;/li>
&lt;li>&lt;strong>init&lt;/strong> # 在当前目录下初始化新的模块&lt;/li>
&lt;li>&lt;strong>tidy&lt;/strong> # 添加缺失的模块以及移除无用的模块&lt;/li>
&lt;li>&lt;strong>vendor&lt;/strong> # 导出项目所有的依赖到 vendor 目录&lt;/li>
&lt;li>&lt;strong>verify&lt;/strong> # 验证依赖项是否达到预期的目的&lt;/li>
&lt;li>&lt;strong>why&lt;/strong> # 查看为什么需要包或模块&lt;/li>
&lt;/ul>
&lt;h2 id="go-mod-download">go mod download&lt;/h2>
&lt;p>&lt;strong>go mod download [-dir] [-json] [modules]&lt;/strong>&lt;/p>
&lt;p>使用此命令来下载指定的模块，模块的格式可以根据主模块依赖的形式或者 path@version 形式指定。如果没有指定参数，此命令会将主模块下的所有依赖下载下来。&lt;/p>
&lt;p>go mod download 命令非常有用，主要用来预填充本地缓存或者计算 Go 模块代理的回答。默认情况下，下载错误会输出到标准输出，正常情况下没有任何输出。-json 参数会以 JSON 的格式打印下载的模块对象，对应的 Go 对象结构是这样。&lt;/p>
&lt;p>type Module struct { Path string //module path Version string //module version Error string //error loading module Info string //absolute path to cached .info file GoMod string //absolute path to cached .mod file Zip string //absolute path to cached .zip file Dir string //absolute path to cached source root directory Sum string //checksum for path, version (as in go.sum) GoModSum string //checksum for go.mod (as in go.sum)}&lt;/p>
&lt;h2 id="go-mod-init">go mod init&lt;/h2>
&lt;p>&lt;strong>go mod init [ModuleName]&lt;/strong>
一般情况 ModuleName 是以后 import 时所使用的路径&lt;/p>
&lt;p>此命令会在当前目录中初始化和创建一个新的 go.mod 文件，当然你也可以手动创建一个 go.mod 文件，然后包含一些 module 声明，这样就比较麻烦。go mod init 命令可以帮助我们自动创建&lt;/p>
&lt;p>例如：&lt;code>go mod init example.com/m&lt;/code>&lt;/p>
&lt;p>使用这条命令时，go.mod 文件必须提前不能存在。初始化会根据引入包声明来推测模块的路径或者如果你工程中之前已经存在一些依赖包管理工具，例如 godep，glide 或者 dep。那么 go mod init 同样也会根据依赖包管理配置文件来推断。&lt;/p>
&lt;h2 id="go-mod-tidy">go mod tidy&lt;/h2>
&lt;p>&lt;strong>go mod tidy [-v]&lt;/strong>&lt;/p>
&lt;p>默认情况下，Go 不会移除 go.mod 文件中的无用依赖。所以当你的依赖中有些使用不到了，可以使用 go mod tidy 命令来清除它。&lt;/p>
&lt;p>它会添加缺失的模块以及移除不需要的模块。执行后会生成 go.sum 文件(模块下载条目)。添加参数-v，例如 go mod tidy -v 可以将执行的信息，即移除的模块打印到标准输出。&lt;/p>
&lt;h2 id="go-mod-vendor">go mod vendor&lt;/h2>
&lt;p>go mod vendor [-v]&lt;/p>
&lt;p>此命令会将 build 阶段需要的所有依赖包放到主模块所在的 vendor 目录中，并且测试所有主模块的包。同理 go mod vendor -v 会将添加到 vendor 中的模块打印到标准输出。&lt;/p>
&lt;h2 id="go-mod-verify">go mod verify&lt;/h2>
&lt;p>此命令会检查当前模块的依赖是否已经存储在本地下载的源代码缓存中，以及检查自从下载下来是否有修改。如果所有的模块都没有修改，那么会打印 all modules verified，否则会打印变化的内容。&lt;/p>
&lt;p>虚拟版本号&lt;/p>
&lt;p>go.mod 文件和 go 命令通常使用语义版本作为描述模块版本的标准形式，这样可以比较不同版本的先后顺序。例如模块的版本是 v1.2.3，那么通过重新对版本号进行标签处理，得到该版本的虚拟版本。形式如：v0.0.0-yyyymmddhhmmss-abcdefabcdef。其中时间是提交时的 UTC 时间，最后的后缀是提交的哈希值前缀。时间部分确保两个虚拟版本号可以进行比较，以确定两者顺序。&lt;/p>
&lt;p>下面有三种形式的虚拟版本号：&lt;/p>
&lt;ul>
&lt;li>vX.0.0-yyyymmddhhmmss-abcdefabcdef，这种情况适合用在在目标版本提交之前 ，没有更早的的版本。（这种形式本来是唯一的形式，所以一些老的 go.mod 文件使用这种形式）&lt;/li>
&lt;li>vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdef，这种情况被用在当目标版本提交之前的最新版本提交是 vX.Y.Z-pre。&lt;/li>
&lt;li>vX.Y.(Z+1)-0.yyyymmddhhmmss-abcdefabcdef，同理，这种情况是当目标版本提交之前的最新版本是 vX.Y.Z。&lt;/li>
&lt;/ul>
&lt;p>虚拟版本的生成不需要你去手动操作，go 命令会将接收的 commit 哈希值自动转化为虚拟版本号。&lt;/p></description></item><item><title>Docs: 重大变化</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/%E9%87%8D%E5%A4%A7%E5%8F%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/%E9%87%8D%E5%A4%A7%E5%8F%98%E5%8C%96/</guid><description>
&lt;h1 id="曾领导六大开源项目go-语言负责人从-google-离职">曾领导六大开源项目，Go 语言负责人从 Google 离职&lt;/h1>
&lt;blockquote>
&lt;p>原文：&lt;a href="https://mp.weixin.qq.com/s/PbTs1_W1r7bnABVIAtTjCw">https://mp.weixin.qq.com/s/PbTs1_W1r7bnABVIAtTjCw&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>Steve Francia 于 6 年前加入 Google，是 Go 语言的产品负责人，今天他在个人社交平台宣布将离开 Google。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/fd5b6f4f-d29a-4323-82ba-b1c300c36932/640" alt="">&lt;/p>
&lt;blockquote>
&lt;p>6 年后，我将离开 Google。我为 Go 团队在过去六年里所取得的成就感到非常自豪，我也从未像现在这样对 Go 的未来充满期待。&lt;/p>
&lt;/blockquote>
&lt;p>你可能不熟悉 Steve Francia 这个名字，但你一定会对他的履历刮目相看。Steve Francia 在开源领域拥有超过 25 年的工作经验，领导了六大开源项目（Go、Docker、Hugo、MongoDB、Drupal、Cobra；其中他更是 Hugo、Cobra、Viper 和 spf13-vim 的作者），他还帮助 Google 定义了开源战略，也是 Github 上最受欢迎的前 50 名工程师。&lt;/p>
&lt;p>Steve Francia 在 6 年前加入了 Go 团队，目标是将 Go 从一种小众的语言变成一种主流的、企业级的语言。现在回过头来看，Steve Francia 已经完成，甚至可以说是超额完成了这个目标。&lt;/p>
&lt;p>在这段时间里，Go 团队交付了 VS Code Go 和 Gopls、大大改善了 Go 的开发体验、改进了 Go 的文档，以及改进了开发者安装 Go 的方式。Go 语言也从主要由 Googlers 编写，发展到如今主要由社区贡献者编写。&lt;/p>
&lt;p>Go 的用户数量在这段时期也增长了 10 倍，Go 用户的使用频率也从偶尔使用增加到每天都使用。如今超过 75% 的 CNCF 项目都是用 Go 编写的。&lt;/p>
&lt;p>有了这些丰富的经历和显著的成就后，Steve Francia 为什么会选择在这个时候离开 Google 呢？&lt;/p>
&lt;p>Steve Francia 在个人博客中表示：&lt;/p>
&lt;blockquote>
&lt;p>随着过去几次 Go 的发布，我越来越深地感受到我与 Go 团队的旅程即将结束。在我刚加入的时候，有很多关于 Go 和在 Google 工作的知识需要学习，（现在）我的学习速度明显放慢了。我很纠结，我喜欢这个团队和我们正在做的工作，但我个人却感到停滞不前。&lt;strong>随着 Go 1.18 的发布，我觉得我在 Go 团队的任务已经完成了。&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>Steve Francia 已经透露离职后的去向：&lt;/p>
&lt;blockquote>
&lt;p>回顾我的职业生涯，我非常幸运地处于许多不同行业创新的前沿。接下来我将把注意力放在数据科学和机器学习上。Two Sigma 在过去的二十年里，一直处于数据科学、分布式计算和机器学习创新的前沿，对开源有深入的投资。我看到他们在推动机器学习和数据科学发展方面的潜力，并感受到与我第一次加入 MongoDB、Docker 和 Go 时一样的兴奋和激动。我很高兴能加入 Two Sigma 这个才华横溢的团队。&lt;/p>
&lt;p>我会怀念我在 Google 的时光。&lt;/p>
&lt;/blockquote></description></item></channel></rss>