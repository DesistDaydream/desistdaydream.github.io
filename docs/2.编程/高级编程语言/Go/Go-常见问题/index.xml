<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Go 常见问题</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</link><description>Recent content in Go 常见问题 on 断念梦</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 内存逃逸</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://cloud.tencent.com/developer/article/1797578">腾讯云，简单聊聊内存逃逸&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.51cto.com/u_13482767/5674384">51CTO，Go 语言中的逃逸分析作用&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>前置知识： &lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Heap%20and%20Stack.md">Heap and Stack&lt;/a>，必须要了解编程中，哪些情况会使用到 Stack，哪些情况会使用到 Heap。&lt;/p>
&lt;p>Go 语言的内存逃逸通常都是指从变量所在的内存地址(i.e. 指针)从 Stack 变为 Heap，此时指针的值将会发生改变。下面是一个最直观的示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">in1&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>{&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">in2&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>{&lt;span style="color:#e6db74">&amp;#34;4&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;5&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">v1&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">in1&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;循环 %v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 外层循环并不会发生逃逸现象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// fmt.Printf(&amp;#34;v1-Dec: %v\n&amp;#34;, &amp;amp;v1)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">v2&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">in2&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;v1-Hex: &amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">v1&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;v2-Hex: &amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">v2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// TODO: fmt 有逃逸问题？ https://juejin.cn/post/6955453411969990670, append 好像也有类似的内存逃逸现象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 正常情况下，v2 的指针应该也是一样的，但是用了 fmt 之后，指针的值在外层循环的下一次迭代中产生了变化
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;v1-Dec: %v, v2-Dec: %v\n&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">v1&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">v2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出结果：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>循环 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>v1-Hex: 0xc0000cc2c0 v2-Hex: 0xc0000b66a0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>v1-Dec: 0xc0000cc2c0, v2-Dec: 0xc0000b66a0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>v1-Hex: 0xc0000cc2c0 v2-Hex: 0xc0000b66a0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>v1-Dec: 0xc0000cc2c0, v2-Dec: 0xc0000b66a0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>循环 2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>v1-Hex: 0xc0000cc2c0 v2-Hex: 0xc0000b66b0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>v1-Dec: 0xc0000cc2c0, v2-Dec: 0xc0000b66b0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>v1-Hex: 0xc0000cc2c0 v2-Hex: 0xc0000b66b0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>v1-Dec: 0xc0000cc2c0, v2-Dec: 0xc0000b66b0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>循环 3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>v1-Hex: 0xc0000cc2c0 v2-Hex: 0xc0000b66c0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>v1-Dec: 0xc0000cc2c0, v2-Dec: 0xc0000b66c0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>v1-Hex: 0xc0000cc2c0 v2-Hex: 0xc0000b66c0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>v1-Dec: 0xc0000cc2c0, v2-Dec: 0xc0000b66c0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>go 程序变量&lt;/code>会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在&lt;code>栈上&lt;/code>分配。否则就说它 &lt;code>逃逸&lt;/code> 了，必须在&lt;code>堆上分配&lt;/code>。&lt;/p>
&lt;p>能引起变量逃逸到堆上的&lt;strong>典型情况&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>在方法内把局部变量指针返回&lt;/strong> 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。&lt;/li>
&lt;li>&lt;strong>发送指针或带有指针的值到 channel 中。&lt;/strong> 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。&lt;/li>
&lt;li>&lt;strong>在一个切片上存储指针或带指针的值。&lt;/strong> 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。&lt;/li>
&lt;li>&lt;strong>slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。&lt;/strong> slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。&lt;/li>
&lt;li>&lt;strong>在 interface 类型上调用方法。&lt;/strong> 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。&lt;/li>
&lt;/ul>
&lt;h2 id="举例">&lt;strong>举例&lt;/strong>&lt;/h2>
&lt;ul>
&lt;li>通过一个例子加深理解，接下来尝试下怎么通过 &lt;code>go build -gcflags=-m&lt;/code> 查看逃逸的情况。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">type&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span> &lt;span style="color:#a6e22e">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 这是上面提到的 &amp;#34;在方法内把局部变量指针返回&amp;#34; 的情况
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">func&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">A&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span>(&lt;span style="color:#a6e22e">A&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">a&lt;/span>.&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#75715e">//返回局部变量a,在C语言中妥妥野指针，但在go则ok，但a会逃逸到堆
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span>.&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; world&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">c&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行&lt;code>go build -gcflags=-m main.go&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">go&lt;/span> &lt;span style="color:#a6e22e">build&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">gcflags&lt;/span>&lt;span style="color:#f92672">=-&lt;/span>&lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>.&lt;span style="color:#a6e22e">go&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#a6e22e">command&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">line&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">arguments&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">main&lt;/span>.&lt;span style="color:#a6e22e">go&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">7&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">6&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">can&lt;/span> &lt;span style="color:#a6e22e">inline&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">main&lt;/span>.&lt;span style="color:#a6e22e">go&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">13&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">inlining&lt;/span> &lt;span style="color:#a6e22e">call&lt;/span> &lt;span style="color:#a6e22e">to&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">main&lt;/span>.&lt;span style="color:#a6e22e">go&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">13&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">inlining&lt;/span> &lt;span style="color:#a6e22e">call&lt;/span> &lt;span style="color:#a6e22e">to&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">/var/folders/45/qx9lfw2s2zzgvhzg3mtzkwzc0000gn/T/go-build409982591/b001/_gomod_.go:6:6: can inline init.0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">main&lt;/span>.&lt;span style="color:#a6e22e">go&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">7&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">leaking&lt;/span> &lt;span style="color:#a6e22e">param&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">main&lt;/span>.&lt;span style="color:#a6e22e">go&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span>(&lt;span style="color:#a6e22e">A&lt;/span>) &lt;span style="color:#a6e22e">escapes&lt;/span> &lt;span style="color:#a6e22e">to&lt;/span> &lt;span style="color:#a6e22e">heap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">main&lt;/span>.&lt;span style="color:#a6e22e">go&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">13&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">io&lt;/span>.&lt;span style="color:#a6e22e">Writer&lt;/span>(&lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Stdout&lt;/span>) &lt;span style="color:#a6e22e">escapes&lt;/span> &lt;span style="color:#a6e22e">to&lt;/span> &lt;span style="color:#a6e22e">heap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">main&lt;/span>.&lt;span style="color:#a6e22e">go&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">13&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#a6e22e">escapes&lt;/span> &lt;span style="color:#a6e22e">to&lt;/span> &lt;span style="color:#a6e22e">heap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">main&lt;/span>.&lt;span style="color:#a6e22e">go&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">15&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">9&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;!&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">escapes&lt;/span> &lt;span style="color:#a6e22e">to&lt;/span> &lt;span style="color:#a6e22e">heap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">main&lt;/span>.&lt;span style="color:#a6e22e">go&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">13&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span>(&lt;span style="color:#a6e22e">A&lt;/span>) &lt;span style="color:#a6e22e">does&lt;/span> &lt;span style="color:#a6e22e">not&lt;/span> &lt;span style="color:#a6e22e">escape&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">main&lt;/span>.&lt;span style="color:#a6e22e">go&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">14&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">11&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span>.&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; world&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">does&lt;/span> &lt;span style="color:#a6e22e">not&lt;/span> &lt;span style="color:#a6e22e">escape&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">main&lt;/span>.&lt;span style="color:#a6e22e">go&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">13&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span> []&lt;span style="color:#66d9ef">interface&lt;/span> {} &lt;span style="color:#a6e22e">literal&lt;/span> &lt;span style="color:#a6e22e">does&lt;/span> &lt;span style="color:#a6e22e">not&lt;/span> &lt;span style="color:#a6e22e">escape&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">autogenerated&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">os&lt;/span>.(&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">File&lt;/span>).&lt;span style="color:#a6e22e">close&lt;/span> .&lt;span style="color:#66d9ef">this&lt;/span> &lt;span style="color:#a6e22e">does&lt;/span> &lt;span style="color:#a6e22e">not&lt;/span> &lt;span style="color:#a6e22e">escape&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>复制&lt;/p>
&lt;ul>
&lt;li>&lt;code>./main.go:8:10: new(A) escapes to heap&lt;/code> 说明 &lt;code>new(A)&lt;/code> 逃逸了,符合上述提到的常见情况中的第一种。&lt;/li>
&lt;li>&lt;code>./main.go:14:11: main a.s + &amp;quot; world&amp;quot; does not escape&lt;/code> 说明 &lt;code>b&lt;/code> 变量没有逃逸，因为它只在方法内存在，会在方法结束时被回收。&lt;/li>
&lt;li>&lt;code>./main.go:15:9: b + &amp;quot;!&amp;quot; escapes to heap&lt;/code> 说明 &lt;code>c&lt;/code> 变量逃逸，通过&lt;code>fmt.Println(a ...interface{})&lt;/code>打印的变量，都会发生逃逸，感兴趣的朋友可以去查查为什么。&lt;/li>
&lt;/ul></description></item><item><title>Docs: Go 常见问题</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</guid><description>
&lt;h1 id="goroutines-与-oschdir">goroutines 与 os.Chdir&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/golang/go/issues/27658">GitHub 项目,golang/go-issue-27658&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>In short, the bug report is that if two different goroutines call os.Chdir concurrently, it is unpredictable which will take effect.
简而言之，错误报告是，如果两种不同的 Goroutines 同时调用 OS.Chdir，则这将生效是不可预测的。
That is true. os.Chdir is a process-wide attribute, not a per-goroutine or per-thread attribute. Even if we could figure out a way to change that&amp;ndash;nothing comes to mind&amp;ndash;we could not change it now because it would break existing Go programs that call os.Chdir in one goroutine and expect it to affect another goroutine.
那是真实的。 OS.Chdir 是一个流程范围的属性，而不是每个 goroutine 或 per-thread 属性。即使我们能够弄清楚改变的方式 - 没有什么意思 - 没有什么想到的 - 我们现在无法改变它，因为它会破坏一个大峡谷中调用 OS.Chdir 的现有 Go 程序，并期望它会影响另一个大花序。
Closing as unfortunate.
关闭不幸。&lt;/p></description></item><item><title>Docs: Go 在容器运行时要注意的细节</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Go-%E5%9C%A8%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%86%E8%8A%82/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Go-%E5%9C%A8%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%86%E8%8A%82/</guid><description>
&lt;p>在云原生时代，Go语言由于在部署时只需要一个二进制文件就能够运行起来而备受青睐。&lt;/p>
&lt;p>但有一个细节问题，如果不妥善处理，则很可能导致Go程序出现明显的性能下降和延迟。&lt;/p>
&lt;p>&lt;strong>1 问题描述&lt;/strong>&lt;/p>
&lt;p>在Go语言中，Go scheduler的P数量非常重要，因为它会极大地影响Go在运行时的表现。在目前的Go语言中，P的数量默认是系统的CPU核数。&lt;/p>
&lt;p>在容器化的环境中，Go程序所获取的CPU核数是错误的，它所获取的是宿主机的CPU核数。&lt;/p>
&lt;p>即使容器和宿主机的CPU核数是共享的，但在集群中我们会针对每个Pod分配指定的核数，因此实际上我们需要的是Pod的核数，而不是宿主机的CPU核数。&lt;/p>
&lt;p>&lt;strong>2 会造成什么后果&lt;/strong>&lt;/p>
&lt;p>前文曾提到Go的M: N调度模型，其要求M必须与P进行绑定，然后才能不断地在M上循环寻找可运行的G来执行相应的任务。&lt;/p>
&lt;p>注意，M必须与P进行绑定，其绑定的这个P，要求必须是空闲状态。但在容器化的部署环境中，P的数量由于被“错误”设置，因此拥有大量空闲的P。可以这样理解，只要有足够多的M，那么P就可以都被绑定。&lt;/p>
&lt;p>这时又产生了另外一个问题，M的数量是否会不断增加呢？答案是会的。在程序运行过程中，由于产生了网络I/O阻塞，导致M会随着程序的不断执行而不断增加，，即能够达到前面假设的情况。最终导致Go程序的延迟加大，程序响应缓慢。&lt;/p>
&lt;p>&lt;strong>3 解决方法&lt;/strong>&lt;/p>
&lt;p>产生这个问题的本质原因是Go程序没有正确地获得我们所期望的CPU核数（应当获取具体分配给Pod的配额），因此解决方案有两种：&lt;/p>
&lt;ul>
&lt;li>结合部署情况，主动设置正确的GOMAXPROCS核数。&lt;/li>
&lt;li>通过cgroup信息，读取容器内的正确GOMAXPROCS核数。&lt;/li>
&lt;/ul>
&lt;p>目前，Go尚没有非常完美的办法来解决这个问题，因此这里推荐使用Uber公司推出的 uber-go/automaxprocs开源库，它会在Go程序运行时根据cgroup的挂载信息来修改 GOMAXPROCS核数，并基于一定规则选择一个最合适的数值。&lt;/p>
&lt;p>使用方式如下：&lt;/p>
&lt;pre>&lt;code>import _ &amp;quot;go.uber.org/automaxprocs&amp;quot;
func main() {...}
&lt;/code>&lt;/pre>
&lt;p>我们只需在Go程序启动时进行引用即可，如果有特殊的需求，那么主动设置GOMAXPROCS也是可以的。&lt;/p></description></item><item><title>Docs: 解决vscode编写go代码时提示过慢(gopls)</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E8%A7%A3%E5%86%B3vscode%E7%BC%96%E5%86%99go%E4%BB%A3%E7%A0%81%E6%97%B6%E6%8F%90%E7%A4%BA%E8%BF%87%E6%85%A2gopls/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E8%A7%A3%E5%86%B3vscode%E7%BC%96%E5%86%99go%E4%BB%A3%E7%A0%81%E6%97%B6%E6%8F%90%E7%A4%BA%E8%BF%87%E6%85%A2gopls/</guid><description>
&lt;p>前言&lt;/p>
&lt;p>之前用的 vscode 的自动代码提示，发现太慢了，隔 3，4 秒才会出提示，所以换为 Google 推荐的 &lt;strong>gopls&lt;/strong>来代替。&lt;/p>
&lt;h2 id="下载过程">下载过程&lt;/h2>
&lt;p>方案一&lt;/p>
&lt;p>打开 VS Code 的&lt;strong>setting&lt;/strong>, 搜索 &lt;strong>go.useLanguageServe&lt;/strong>, 并勾选上.&lt;/p>
&lt;p>默认情况下, 会提示叫你 reload，重新打开之后，右下角会自动弹出下载的框框，点击 &lt;strong>install&lt;/strong>即可。&lt;/p>
&lt;p>如果下载时间过长，不成功，可以看&lt;strong>方案二&lt;/strong>&lt;/p>
&lt;p>方案二&lt;/p>
&lt;p>直接上 github 下载，下载下来 之后&lt;code>go install github.com/golang/tools/cmd/gopls&lt;/code>安装&lt;/p>
&lt;p>方案三&lt;/p>
&lt;p>&lt;code>go get golang.org/x/tools/gopls@latest&lt;/code>，不需要加 u 可以去 github 上看看文档是怎么说的&lt;/p>
&lt;p>github&lt;/p>
&lt;h2 id="配置过程">配置过程&lt;/h2>
&lt;p>在 github 文档里有提示 &lt;code>Use the VSCode-Go plugin, with the following configuration:&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;go.useLanguageServer&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;[go]&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;editor.snippetSuggestions&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;none&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;editor.formatOnSave&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;editor.codeActionsOnSave&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;source.organizeImports&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;gopls&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;usePlaceholders&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#75715e">// add parameter placeholders when completing a function
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Experimental settings
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">&amp;#34;completeUnimported&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#75715e">// autocomplete unimported packages
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">&amp;#34;watchFileChanges&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#75715e">// watch file changes outside of the editor
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">&amp;#34;deepCompletion&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#75715e">// enable deep completion
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;files.eol&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;\n&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#75715e">// formatting only supports LF line endings
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以现在需要配置一下 &lt;code>setting.json&lt;/code>配置文件。&lt;/p>
&lt;p>在 VSCode 中按下&lt;code>Ctrl + Shift + P&lt;/code>，在搜索框中输入&lt;code>settings&lt;/code>,找到&lt;code>Open Settings:JSON&lt;/code> 添加上面那段代码即可~&lt;/p></description></item><item><title>Docs: 如何避免 Go 命令行执行产生“孤儿”进程？</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D-Go-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%A7%E8%A1%8C%E4%BA%A7%E7%94%9F%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D-Go-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%A7%E8%A1%8C%E4%BA%A7%E7%94%9F%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/</guid><description>
&lt;p>原文链接：&lt;a href="https://mp.weixin.qq.com/s/MJKlUBF9_vpGt2z9r7WjsA">如何避免 Go 命令行执行产生 “孤儿” 进程？&lt;/a>&lt;/p>
&lt;p>在 Go 程序当中，如果我们要执行命令时，通常会使用 exec.Command ，也比较好用，通常状况下，可以达到我们的目的，如果我们逻辑当中，需要终止这个进程，则可以快速使用 cmd.Process.Kill() 方法来结束进程。但当我们要执行的命令会启动其他子进程来操作的时候，会发生什么情况？&lt;/p>
&lt;h1 id="一--孤儿进程的产生">一   孤儿进程的产生&lt;/h1>
&lt;p>测试小程序：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">kill&lt;/span>(cmd &lt;span style="color:#f92672">*&lt;/span>exec.Cmd) &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> cmd &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cmd.Process.Kill()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cmd := exec.Command(&lt;span style="color:#e6db74">&amp;#34;/bin/bash&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;-c&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;watch top &amp;gt;top.log&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time.AfterFunc(&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">*&lt;/span>time.Second, kill(cmd))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err := cmd.Run()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.Printf(&lt;span style="color:#e6db74">&amp;#34;pid=%d err=%s&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, cmd.Process.Pid, err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行小程序：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-makefile" data-lang="makefile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">go&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">run&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">main.go&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pid&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">27326&lt;/span> err&lt;span style="color:#f92672">=&lt;/span>signal: killed
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看进程信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">ps -j&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">USER&lt;/span> &lt;span style="color:#e6db74">PID PPID PGID SESS JOBC STAT TT TIME COMMAND&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">king&lt;/span> &lt;span style="color:#e6db74">24324 1 24303 0 0 S s012 0:00.01 watch top&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到这个 &amp;ldquo;watch top&amp;rdquo; 的 PPID 为 1，说明这个进程已经变成了 “孤儿” 进程。&lt;/p>
&lt;p>那为什么会这样，这并不符合我们预期，那么可以从 Go 的文档中找到答案：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/bcfb3cc6-d9c4-43e0-9fba-6045555a2155/640" alt="">&lt;/p>
&lt;h1 id="二--通过进程组来解决掉所有子进程">二   通过进程组来解决掉所有子进程&lt;/h1>
&lt;p>在 linux 当中，是有会话、进程组和进程组的概念，并且 Go 也是使用 linux 的 kill(2) 方法来发送信号的，那么是否可以通过 kill 来将要结束进程的子进程都结束掉？&lt;/p>
&lt;p>linux 的 kill(2) 的定义如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;signal.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">kill&lt;/span>(pid_t pid, &lt;span style="color:#66d9ef">int&lt;/span> sig);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>并在方法的描述中，可以看到如下内容：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/bcfb3cc6-d9c4-43e0-9fba-6045555a2155/640" alt="">&lt;/p>
&lt;p>如果 pid 为正数的时候，会给指定的 pid 发送 sig 信号，如果 pid 为负数的时候，会给这个进程组发送 sig 信号，那么我们可以通过进程组来将所有子进程退出掉？改一下 Go 程序中 kill 方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">kill&lt;/span>(cmd &lt;span style="color:#f92672">*&lt;/span>exec.Cmd) &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> cmd &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> syscall.Kill(&lt;span style="color:#f92672">-&lt;/span>cmd.Process.Pid, syscall.SIGKILL)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cmd := exec.Command(&lt;span style="color:#e6db74">&amp;#34;/bin/bash&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;-c&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;watch top &amp;gt;top.log&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time.AfterFunc(&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">*&lt;/span>time.Second, kill(cmd))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err := cmd.Run()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.Printf(&lt;span style="color:#e6db74">&amp;#34;pid=%d err=%s&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, cmd.Process.Pid, err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再次执行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>.&lt;span style="color:#66d9ef">go&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>会发现程序卡住了，我们来看一下当前执行的进程：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">ps -j&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">USER&lt;/span> &lt;span style="color:#e6db74">PID PPID PGID SESS JOBC STAT TT TIME COMMAND&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">king&lt;/span> &lt;span style="color:#e6db74">27655 91597 27655 0 1 S+ s012 0:01.10 go run main.go&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">king&lt;/span> &lt;span style="color:#e6db74">27672 27655 27655 0 1 S+ s012 0:00.03 ..../exe/main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">king&lt;/span> &lt;span style="color:#e6db74">27673 27672 27655 0 1 S+ s012 0:00.00 /bin/bash -c watch top &amp;gt;top.log&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">king&lt;/span> &lt;span style="color:#e6db74">27674 27673 27655 0 1 S+ s012 0:00.01 watch top&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到我们 go run 产生了一个子进程 27672（command 那里是 go 执行的临时目录，比较长，因此添加了省略号），27672 产生了 27673（watch top &amp;gt;top.log）进程，27673 产生了 27674（watch top）进程。那为什么没有将这些子进程都关闭掉呢？&lt;/p>
&lt;p>其实之类犯了一个低级错误，从上图中，我们可以看到他们的进程组 ID 为 27655，但是我们传递的是 cmd 的 id 即 27673，这个并不是进程组的 ID，因此程序并没有 kill，导致 cmd.Run() 一直在执行。&lt;/p>
&lt;p>在 Linux 中，进程组中的第一个进程，被称为进程组 Leader，同时这个进程组的 ID 就是这个进程的 ID，从这个进程中创建的其他进程，都会继承这个进程的进程组和会话信息；从上面可以看出 go run main.go 程序 PID 和 PGID 同为 27655，那么这个进程就是进程组 Leader，我们不能 kill 这个进程组，除非想 “自杀”，哈哈哈。&lt;/p>
&lt;p>那么我们给要执行的进程，新建一个进程组，在 Kill 不就可以了嘛。在 linux 当中，通过 setpgid 方法来设置进程组 ID，定义如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">setpgid&lt;/span>(pid_t pid, pid_t pgid);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果将 pid 和 pgid 同时设置成 0，也就是 setpgid(0,0)，则会使用当前进程为进程组 leader 并创建新的进程组。&lt;/p>
&lt;p>那么在 Go 程序中，可以通过 cmd.SysProcAttr 来设置创建新的进程组，修改后的代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">kill&lt;/span>(cmd &lt;span style="color:#f92672">*&lt;/span>exec.Cmd) &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> cmd &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> syscall.Kill(&lt;span style="color:#f92672">-&lt;/span>cmd.Process.Pid, syscall.SIGKILL)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cmd := exec.Command(&lt;span style="color:#e6db74">&amp;#34;/bin/bash&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;-c&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;watch top &amp;gt;top.log&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cmd.SysProcAttr = &amp;amp;syscall.SysProcAttr{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Setpgid: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time.AfterFunc(&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">*&lt;/span>time.Second, kill(cmd))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err := cmd.Run()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.Printf(&lt;span style="color:#e6db74">&amp;#34;pid=%d err=%s&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, cmd.Process.Pid, err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再次执行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-makefile" data-lang="makefile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">go&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">run&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">main.go&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pid&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">29397&lt;/span> err&lt;span style="color:#f92672">=&lt;/span>signal: killed
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再次查看进程：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ps&lt;/span> &lt;span style="color:#e6db74">-j&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">USER&lt;/span> &lt;span style="color:#e6db74">PID PPID PGID SESS JOBC STAT TT TIME COMMAND&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>发现 watch 的进程都不存在了，那我们在看看是否还会有孤儿进程：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">ps&lt;/span> &lt;span style="color:#e6db74">-j&lt;/span> &lt;span style="color:#e6db74">|&lt;/span> &lt;span style="color:#e6db74">head&lt;/span> &lt;span style="color:#e6db74">-1&lt;/span>;&lt;span style="color:#66d9ef">ps&lt;/span> &lt;span style="color:#e6db74">-j&lt;/span> &lt;span style="color:#e6db74">|&lt;/span> &lt;span style="color:#e6db74">awk&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&lt;/span>{&lt;span style="color:#f92672">if&lt;/span> &lt;span style="color:#e6db74">(&lt;/span>$3 ==&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#e6db74">&amp;amp;&amp;amp;&lt;/span> $1 &lt;span style="color:#e6db74">!=&amp;#34;root&amp;#34;)&lt;/span>{&lt;span style="color:#f92672">print&lt;/span> $0}}&amp;#39; &lt;span style="color:#e6db74">|&lt;/span> &lt;span style="color:#e6db74">head&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">USER&lt;/span> &lt;span style="color:#e6db74">PID&lt;/span> &lt;span style="color:#e6db74">PPID&lt;/span> &lt;span style="color:#e6db74">PGID&lt;/span> &lt;span style="color:#e6db74">SESS&lt;/span> &lt;span style="color:#e6db74">JOBC&lt;/span> &lt;span style="color:#e6db74">STAT&lt;/span> &lt;span style="color:#e6db74">TT&lt;/span> &lt;span style="color:#e6db74">TIME&lt;/span> &lt;span style="color:#e6db74">COMMAND&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>已经没有孤儿进程了，问题至此已经完全解决。&lt;/p>
&lt;h1 id="三--子进程监听父进程是否退出-只能在-linux-下执行">三   子进程监听父进程是否退出 (只能在 linux 下执行)&lt;/h1>
&lt;p>假设要调用的程序也是我们自己写的其他应用程序，那么可以使用 Linux 的 prctl 方法来处理， prctl 方法的定义如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/prctl.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">prctl&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> option, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> arg2, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> arg3,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> arg4, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> arg5);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个方法有一个重要的 option：PR_SET_PDEATHSIG，通过这个来接收父进程的退出。&lt;/p>
&lt;p>让我们来再次构造一个有问题的程序。&lt;/p>
&lt;p>有两个文件，分别为 main.go 和 child.go 文件，main.go 会调用 child.go 文件。&lt;/p>
&lt;p>main.go 文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;os/exec&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">cmd&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">exec&lt;/span>.&lt;span style="color:#a6e22e">Command&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;./child&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">cmd&lt;/span>.&lt;span style="color:#a6e22e">Run&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>child.go 文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>package main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;time&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time.Sleep(&lt;span style="color:#ae81ff">200&lt;/span> &lt;span style="color:#f92672">*&lt;/span> time.Millisecond)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.Println(time.Now())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 Linux 环境中分别编译这两个文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#a6e22e">build&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">o&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>.&lt;span style="color:#66d9ef">go&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#a6e22e">build&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">o&lt;/span> &lt;span style="color:#a6e22e">child&lt;/span> &lt;span style="color:#a6e22e">child&lt;/span>.&lt;span style="color:#66d9ef">go&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行 main 二进制文件：&lt;/p>
&lt;pre>&lt;code>./main &amp;amp;
&lt;/code>&lt;/pre>
&lt;p>查看他们的进程：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ps&lt;/span> &lt;span style="color:#e6db74">-ef&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">UID&lt;/span> &lt;span style="color:#e6db74">PID PPID C STIME TTY TIME CMD&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#e6db74">1 0 0 06:05 pts/0 00:00:00 /bin/bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#e6db74">11514 1 0 12:12 pts/0 00:00:00 ./main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#e6db74">11520 11514 0 12:12 pts/0 00:00:00 ./child&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到 main 和 child 的进程，child 是 main 的子进程，我们将 main 进程 kill 掉，在查看进程状态：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">kill&lt;/span> &lt;span style="color:#e6db74">-9 11514&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ps&lt;/span> &lt;span style="color:#e6db74">-ef&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">UID&lt;/span> &lt;span style="color:#e6db74">PID PPID C STIME TTY TIME CMD&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#e6db74">1 0 0 06:05 pts/0 00:00:00 /bin/bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#e6db74">11520 1 0 12:12 pts/0 00:00:00 ./child&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以看到 child 的进程，他的 PPID 已经变成了 1，说明这个进程已经变成了孤儿进程。&lt;/p>
&lt;p>那接下来我们可以使用 PR_SET_PDEATHSIG 来保证父进程退出，子进程也退出，大致方式有两种：使用 CGO 调用和使用 syscall.RawSyscall 来调用。&lt;/p>
&lt;h2 id="1-使用-cgo">1  使用 CGO&lt;/h2>
&lt;p>将 child 修改成如下内容：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;time&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> C.killTest()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time.Sleep(&lt;span style="color:#ae81ff">200&lt;/span> &lt;span style="color:#f92672">*&lt;/span> time.Millisecond)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.Println(time.Now())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>程序中，使用 CGO，为了简单的展示，在 Go 文件中编写了 C 的 killTest 方法，并调用了 prctl 方法，然后在 Go 程序中调用 killTest 方法，让我们重新编译执行一下，再看看进程：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">go&lt;/span> &lt;span style="color:#e6db74">build -o child child.go&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">./main&lt;/span> &lt;span style="color:#e6db74">&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ps&lt;/span> &lt;span style="color:#e6db74">-ef&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">UID&lt;/span> &lt;span style="color:#e6db74">PID PPID C STIME TTY TIME CMD&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#e6db74">1 0 0 06:05 pts/0 00:00:00 /bin/bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#e6db74">11663 1 0 12:28 pts/0 00:00:00 ./main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#e6db74">11669 11663 0 12:28 pts/0 00:00:00 ./child&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再次 kill 掉 main，并查看进程：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">kill&lt;/span> &lt;span style="color:#e6db74">-9 11663&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ps&lt;/span> &lt;span style="color:#e6db74">-ef&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">UID&lt;/span> &lt;span style="color:#e6db74">PID PPID C STIME TTY TIME CMD&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#e6db74">1 0 0 06:05 pts/0 00:00:00 /bin/bash&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到 child 的进程也已经退出了，说明 CGO 调用的 prctl 生效了。&lt;/p>
&lt;h2 id="2-syscallrawsyscall-方法">2  syscall.RawSyscall 方法&lt;/h2>
&lt;p>也可以采用 Go 中提供的 syscall.RawSyscall 方法来替代调用 CGO，在 Go 的文档中，可以查看到 syscall 包中定义的常量（查看 linux，如果是本地 godoc，需要指定 GOOS=linux），可以看到我们要用的几个常量以及他们对应的数值：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ....
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">PR_SET_PDEATHSIG&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ....
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .....
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">SYS_PRCTL&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">157&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .....
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 PR_SET_PDEATHSIG 操作的值为 1，SYS_PRCTL 的值为 157，那么将 child.go 修改成如下内容：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;os&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;syscall&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;time&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">errno&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">syscall&lt;/span>.&lt;span style="color:#a6e22e">RawSyscall&lt;/span>(uintptr(&lt;span style="color:#a6e22e">syscall&lt;/span>.&lt;span style="color:#a6e22e">SYS_PRCTL&lt;/span>), uintptr(&lt;span style="color:#a6e22e">syscall&lt;/span>.&lt;span style="color:#a6e22e">PR_SET_PDEATHSIG&lt;/span>), uintptr(&lt;span style="color:#a6e22e">syscall&lt;/span>.&lt;span style="color:#a6e22e">SIGKILL&lt;/span>), &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">errno&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Exit&lt;/span>(int(&lt;span style="color:#a6e22e">errno&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Sleep&lt;/span>(&lt;span style="color:#ae81ff">200&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Millisecond&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Now&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再次编译并执行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">go&lt;/span> &lt;span style="color:#e6db74">build -o child child.go&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">./main&lt;/span> &lt;span style="color:#e6db74">&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ps&lt;/span> &lt;span style="color:#e6db74">-ef&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">UID&lt;/span> &lt;span style="color:#e6db74">PID PPID C STIME TTY TIME CMD&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#e6db74">1 0 0 06:05 pts/0 00:00:00 /bin/bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#e6db74">12208 1 0 12:46 pts/0 00:00:00 ./main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#e6db74">12214 12208 0 12:46 pts/0 00:00:00 ./child&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将 main 进程结束掉：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">kill&lt;/span> &lt;span style="color:#e6db74">-9 12208&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ps&lt;/span> &lt;span style="color:#e6db74">-ef&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">UID&lt;/span> &lt;span style="color:#e6db74">PID PPID C STIME TTY TIME CMD&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#e6db74">1 0 0 06:05 pts/0 00:00:00 /bin/bash&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>child 进程已经退出了，也达成了最终效果。&lt;/p>
&lt;h1 id="四--总结">四   总结&lt;/h1>
&lt;p>当我们使用 Go 程序执行其他程序的时候，如果其他程序也开启了其他进程，那么在 kill 的时候可能会把这些进程变成孤儿进程，一直执行并滞留在内存中。当然，如果我们程序非法退出，或者被 kill 调用，也会导致我们执行的进程变成孤儿进程，那么为了解决这个问题，从两个思路来解决：&lt;/p>
&lt;ul>
&lt;li>给要执行的程序创建新的进程组，并调用 syscall.Kill，传递负值 pid 来关闭这个进程组中所有的进程（比较完美的解决方法）。&lt;/li>
&lt;li>如果要调用的程序也是我们自己编写的，那么可以使用 PR_SET_PDEATHSIG 来感知父进程退出，那么这种方式需要调用 Linxu 的 prctrl，可以使用 CGO 的方式，也可以使用 syscall.RawSyscall 的方式。&lt;/li>
&lt;/ul>
&lt;p>但不管使用哪种方式，都只是提供了一种思路，在我们编写服务端服务程序的时候，需要特殊关注，防止孤儿进程消耗服务器资源。&lt;/p></description></item></channel></rss>