<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go 常见问题 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</link><description>Recent content in Go 常见问题 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/index.xml" rel="self" type="application/rss+xml"/><item><title>内存逃逸</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/</guid><description>概述 参考：
腾讯云，简单聊聊内存逃逸 51CTO，Go 语言中的逃逸分析作用 前置知识： Heap and Stack，必须要了解编程中，哪些情况会使用到 Stack，哪些情况会使用到 Heap。
Go 语言的内存逃逸通常都是指从变量所在的内存地址(i.e. 指针)从 Stack 变为 Heap，此时指针的值将会发生改变。下面是一个最直观的示例：
in1 := []int{1, 2, 3} in2 := []string{&amp;#34;4&amp;#34;, &amp;#34;5&amp;#34;} for i, v1 := range in1 { fmt.Printf(&amp;#34;循环 %v\n&amp;#34;, i+1) // 外层循环并不会发生逃逸现象 // fmt.Printf(&amp;#34;v1-Dec: %v\n&amp;#34;, &amp;amp;v1) for _, v2 := range in2 { println(&amp;#34;v1-Hex: &amp;#34;, &amp;amp;v1, &amp;#34;v2-Hex: &amp;#34;, &amp;amp;v2) // TODO: fmt 有逃逸问题？ https://juejin.cn/post/6955453411969990670, append 好像也有类似的内存逃逸现象 // 正常情况下，v2 的指针应该也是一样的，但是用了 fmt 之后，指针的值在外层循环的下一次迭代中产生了变化 fmt.Printf(&amp;#34;v1-Dec: %v, v2-Dec: %v\n&amp;#34;, &amp;amp;v1, &amp;amp;v2) } } 输出结果：</description></item><item><title>Go 常见问题</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</guid><description>goroutines 与 os.Chdir 参考：
GitHub 项目,golang/go-issue-27658 简而言之，错误报告是，如果两种不同的 Goroutines 同时调用 OS.Chdir，则这将生效是不可预测的。
那是真实的。 OS.Chdir 是一个流程范围的属性，而不是每个 goroutine 或 per-thread 属性。即使我们能够弄清楚改变的方式 - 没有什么意思 - 没有什么想到的 - 我们现在无法改变它，因为它会破坏一个大峡谷中调用 OS.Chdir 的现有 Go 程序，并期望它会影响另一个大花序。 Closing as unfortunate. 关闭不幸。</description></item><item><title>Go 在容器运行时要注意的细节</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Go-%E5%9C%A8%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%86%E8%8A%82/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Go-%E5%9C%A8%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%86%E8%8A%82/</guid><description>在云原生时代，Go语言由于在部署时只需要一个二进制文件就能够运行起来而备受青睐。
但有一个细节问题，如果不妥善处理，则很可能导致Go程序出现明显的性能下降和延迟。
1 问题描述
在Go语言中，Go scheduler的P数量非常重要，因为它会极大地影响Go在运行时的表现。在目前的Go语言中，P的数量默认是系统的CPU核数。
在容器化的环境中，Go程序所获取的CPU核数是错误的，它所获取的是宿主机的CPU核数。
即使容器和宿主机的CPU核数是共享的，但在集群中我们会针对每个Pod分配指定的核数，因此实际上我们需要的是Pod的核数，而不是宿主机的CPU核数。
2 会造成什么后果
前文曾提到Go的M: N调度模型，其要求M必须与P进行绑定，然后才能不断地在M上循环寻找可运行的G来执行相应的任务。
注意，M必须与P进行绑定，其绑定的这个P，要求必须是空闲状态。但在容器化的部署环境中，P的数量由于被“错误”设置，因此拥有大量空闲的P。可以这样理解，只要有足够多的M，那么P就可以都被绑定。
这时又产生了另外一个问题，M的数量是否会不断增加呢？答案是会的。在程序运行过程中，由于产生了网络I/O阻塞，导致M会随着程序的不断执行而不断增加，，即能够达到前面假设的情况。最终导致Go程序的延迟加大，程序响应缓慢。
3 解决方法
产生这个问题的本质原因是Go程序没有正确地获得我们所期望的CPU核数（应当获取具体分配给Pod的配额），因此解决方案有两种：
结合部署情况，主动设置正确的GOMAXPROCS核数。 通过cgroup信息，读取容器内的正确GOMAXPROCS核数。 目前，Go尚没有非常完美的办法来解决这个问题，因此这里推荐使用Uber公司推出的 uber-go/automaxprocs开源库，它会在Go程序运行时根据cgroup的挂载信息来修改 GOMAXPROCS核数，并基于一定规则选择一个最合适的数值。
使用方式如下：
import _ &amp;quot;go.uber.org/automaxprocs&amp;quot; func main() {...} 我们只需在Go程序启动时进行引用即可，如果有特殊的需求，那么主动设置GOMAXPROCS也是可以的。</description></item><item><title>如何避免 Go 命令行执行产生“孤儿”进程？</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D-Go-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%A7%E8%A1%8C%E4%BA%A7%E7%94%9F%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D-Go-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%A7%E8%A1%8C%E4%BA%A7%E7%94%9F%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/</guid><description>原文链接：如何避免 Go 命令行执行产生 “孤儿” 进程？
在 Go 程序当中，如果我们要执行命令时，通常会使用 exec.Command ，也比较好用，通常状况下，可以达到我们的目的，如果我们逻辑当中，需要终止这个进程，则可以快速使用 cmd.Process.Kill() 方法来结束进程。但当我们要执行的命令会启动其他子进程来操作的时候，会发生什么情况？
一 孤儿进程的产生 测试小程序：
func kill(cmd *exec.Cmd) func() { return func() { if cmd != nil { cmd.Process.Kill() } } } func main() { cmd := exec.Command(&amp;#34;/bin/bash&amp;#34;, &amp;#34;-c&amp;#34;, &amp;#34;watch top &amp;gt;top.log&amp;#34;) time.AfterFunc(1*time.Second, kill(cmd)) err := cmd.Run() fmt.Printf(&amp;#34;pid=%d err=%s\n&amp;#34;, cmd.Process.Pid, err) } 执行小程序：
go run main.go pid=27326 err=signal: killed 查看进程信息：
ps -j USER PID PPID PGID SESS JOBC STAT TT TIME COMMAND king 24324 1 24303 0 0 S s012 0:00.</description></item></channel></rss>