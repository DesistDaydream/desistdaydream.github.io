<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Middleware on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Middleware/</link><description>Recent content in Middleware on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Middleware/index.xml" rel="self" type="application/rss+xml"/><item><title>GO中间件(Middleware )</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Middleware/GO%E4%B8%AD%E9%97%B4%E4%BB%B6Middleware/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Middleware/GO%E4%B8%AD%E9%97%B4%E4%BB%B6Middleware/</guid><description>原文链接：GO 中间件 (Middleware) - SegmentFault 思否
中间件是一种计算机软件，可为操作系统提供的软件应用程序提供服务，以便于各个软件之间的沟通，特别是系统软件和应用软件。广泛用于 web 应用和面向服务的体系结构等。
纵观 GO 语言，中间件应用比较普遍，主要应用：
记录对服务器发送的请求（request） 处理服务器响应（response ） 请求和处理之间做一个权限认证工作 远程调用 安全 等等 中间件处理程序是简单的http.Handler，它包装另一个http.Handler做请求的一些预处理和 / 或后处理。它被称为 “中间件”，因为它位于 Go Web 服务器和实际处理程序之间的中间位置。
下面是一些中间件例子
记录日志中间件 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; ) func logging(f http.HandlerFunc) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { log.Println(r.URL.Path) f(w, r) } } func foo(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, &amp;#34;foo&amp;#34;) } func bar(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, &amp;#34;bar&amp;#34;) } func main() { http.</description></item><item><title>Middleware</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Middleware/Middleware/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Middleware/Middleware/</guid><description>概述 参考：
原文链接：https://chai2010.gitbooks.io/advanced-go-programming-book/content/ch5-web/ch5-03-middleware.html 本章将对现在流行的 Web 框架中的中间件(middleware)技术原理进行分析，并介绍如何使用中间件技术将业务和非业务代码功能进行解耦。
代码泥潭 先来看一段代码：
// middleware/hello.go package main func hello(wr http.ResponseWriter, r *http.Request) { wr.Write([]byte(&amp;#34;hello&amp;#34;)) } func main() { http.HandleFunc(&amp;#34;/&amp;#34;, hello) err := http.ListenAndServe(&amp;#34;:8080&amp;#34;, nil) ... } 这是一个典型的 Web 服务，挂载了一个简单的路由。我们的线上服务一般也是从这样简单的服务开始逐渐拓展开去的。 现在突然来了一个新的需求，我们想要统计之前写的 hello 服务的处理耗时，需求很简单，我们对上面的程序进行少量修改：
// middleware/hello_with_time_elapse.go var logger = log.New(os.Stdout, &amp;#34;&amp;#34;, 0) func hello(wr http.ResponseWriter, r *http.Request) { timeStart := time.Now() wr.Write([]byte(&amp;#34;hello&amp;#34;)) timeElapsed := time.Since(timeStart) logger.Println(timeElapsed) } 这样便可以在每次接收到 http 请求时，打印出当前请求所消耗的时间。 完成了这个需求之后，我们继续进行业务开发，提供的 API 逐渐增加，现在我们的路由看起来是这个样子：
// middleware/hello_with_more_routes.go // 省略了一些相同的代码 package main func helloHandler(wr http.</description></item></channel></rss>