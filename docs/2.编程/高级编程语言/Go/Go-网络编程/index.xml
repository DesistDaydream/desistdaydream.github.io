<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go 网络编程 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link><description>Recent content in Go 网络编程 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>Gin</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Gin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Gin/</guid><description>概述 参考：
GitHub 项目，gin-gonic/gin https://youngxhui.top/categories/gin/</description></item><item><title>Go 网络编程</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Go-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Go-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid><description>概述 参考：
Go 标准库 ，net 公众号，开发内功修炼-在 golang 中是如何对 epoll 进行封装的？(关于 go 实现 net 的底层逻辑分析) Go 标准库，net/url(URL 解析与转译) 公众号-马哥 Linux 运维，go 标准库 net/url 学习笔记 在协程没有流行以前，传统的网络编程中，同步阻塞是性能低下的代名词，一次切换就得是 3 us 左右的 CPU 开销。各种基于 epoll 的异步非阻塞的模型虽然提高了性能，但是基于回调函数的编程方式却非常不符合人的的直线思维模式。开发出来的代码的也不那么容易被人理解。
Golang 的出现，可以说是将协程编程模式推向了一个高潮。这种新的编程方式既兼顾了同步编程方式的简单易用，也在底层通过协程和 epoll 的配合避免了线程切换的性能高损耗。换句话说就是既简单易用，性能又还不挺错。
net 包 net 包中包含如下几个包
http # http 包提供 HTTP 客户端和服务端的实现。 mail # Package mail implements parsing of mail messages. netip # Package netip defines an IP address type that&amp;rsquo;s a small value type. rpc # Package rpc provides access to the exported methods of an object across a network or other I/O connection.</description></item><item><title>net 包中的 TCP</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/net-%E5%8C%85%E4%B8%AD%E7%9A%84-TCP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/net-%E5%8C%85%E4%B8%AD%E7%9A%84-TCP/</guid><description>概述 参考：
知乎，TCP 漫谈之 keepalive 和 time_wait TCP 是一个有状态通讯协议，所谓的有状态是指通信过程中通信的双方各自维护连接的状态。
一、TCP keepalive
先简单回顾一下 TCP 连接建立和断开的整个过程。（这里主要考虑主流程，关于丢包、拥塞、窗口、失败重试等情况后面详细讨论。） 首先是客户端发送 syn（Synchronize Sequence Numbers：同步序列编号）包给服务端，告诉服务端我要连接你，syn 包里面主要携带了客户端的 seq 序列号；服务端回发一个 syn+ack，其中 syn 包和客户端原理类似，只不过携带的是服务端的 seq 序列号，ack 包则是确认客户端允许连接；最后客户端再次发送一个 ack 确认接收到服务端的 syn 包。这样客户端和服务端就可以建立连接了。整个流程称为“三次握手”。
建立连接后，客户端或者服务端便可以通过已建立的 socket 连接发送数据，对端接收数据后，便可以通过 ack 确认已经收到数据。数据交换完毕后，通常是客户端便可以发送 FIN 包，告诉另一端我要断开了；另一端先通过 ack 确认收到 FIN 包，然后发送 FIN 包告诉客户端我也关闭了；最后客户端回应 ack 确认连接终止。整个流程成为“四次挥手”。TCP 的性能经常为大家所诟病，除了 TCP+IP 额外的 header 以外，它建立连接需要三次握手，关闭连接需要四次挥手。如果只是发送很少的数据，那么传输的有效数据是非常少的。是不是建立一次连接后续可以继续复用呢？的确可以这样做，但这又带来另一个问题，如果连接一直不释放，端口被占满了咋办。为此引入了今天讨论的第一个话题 TCP keepalive。所谓的 TCP keepalive 是指 TCP 连接建立后会通过 keepalive 的方式一直保持，不会在数据传输完成后立刻中断，而是通过 keepalive 机制检测连接状态。Linux 控制 keepalive 有三个参数：保活时间 net.ipv4.tcp_keepalive_time、保活时间间隔 net.ipv4.tcp_keepalive_intvl、保活探测次数 net.ipv4.tcp_keepalive_probes，默认值分别是 7200 秒（2 小时）、75 秒和 9 次探测。如果使用 TCP 自身的 keepalive 机制，在 Linux 系统中，最少需要经过 2 小时 + 9*75 秒后断开。譬如我们 SSH 登录一台服务器后可以看到这个 TCP 的 keepalive 时间是 2 个小时，并且会在 2 个小时后发送探测包，确认对端是否处于连接状态。 之所以会讨论 TCP 的 keepalive，是因为发现服器上有泄露的 TCP 连接：</description></item></channel></rss>