<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python 规范与标准库 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/Python-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/</link><description>Recent content in Python 规范与标准库 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/Python-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/index.xml" rel="self" type="application/rss+xml"/><item><title>Python 规范与标准库</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/Python-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Python-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/Python-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Python-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/</guid><description>概述 参考：
Python 语言参考描述了 Python 语言的具体语法和语义 Python 标准库则是与 Python 语言一起发行的一些可选功能，以便人们可以从一开始就轻松得使用 Python 进行编程。 内置模块 内置模块属于Python 规范与标准库的一部分。这部分内置模块内嵌到解释器里面（也就是说无法在文件系统中找到与模块名相同的同名文件），它们给一些虽并非语言核心但却内嵌的操作提供接口，要么是为了效率，要么是给操作系统基础操作例如系统调入提供接口。 这些模块集是一个配置选项， 并且还依赖于底层的操作系统。 例如，winreg 模块只在 Windows 系统上提供。一个特别值得注意的模块 sys，它被内嵌到每一个 Python 编译器中，sys 模块是 CPython 非常重要的内置模块，也是很多功能的基础模块。
&amp;gt;&amp;gt;&amp;gt; import sys &amp;gt;&amp;gt;&amp;gt; sys.builtin_module_names (&amp;#39;_abc&amp;#39;, &amp;#39;_ast&amp;#39;, &amp;#39;_bisect&amp;#39;, &amp;#39;_blake2&amp;#39;, &amp;#39;_codecs&amp;#39;, &amp;#39;_codecs_cn&amp;#39;, &amp;#39;_codecs_hk&amp;#39;, &amp;#39;_codecs_iso2022&amp;#39;, &amp;#39;_codecs_jp&amp;#39;, &amp;#39;_codecs_kr&amp;#39;, &amp;#39;_codecs_tw&amp;#39;, &amp;#39;_collections&amp;#39;, &amp;#39;_contextvars&amp;#39;, &amp;#39;_csv&amp;#39;, &amp;#39;_datetime&amp;#39;, &amp;#39;_functools&amp;#39;, &amp;#39;_heapq&amp;#39;, &amp;#39;_imp&amp;#39;, &amp;#39;_io&amp;#39;, &amp;#39;_json&amp;#39;, &amp;#39;_locale&amp;#39;, &amp;#39;_lsprof&amp;#39;, &amp;#39;_md5&amp;#39;, &amp;#39;_multibytecodec&amp;#39;, &amp;#39;_opcode&amp;#39;, &amp;#39;_operator&amp;#39;, &amp;#39;_pickle&amp;#39;, &amp;#39;_random&amp;#39;, &amp;#39;_sha1&amp;#39;, &amp;#39;_sha256&amp;#39;, &amp;#39;_sha3&amp;#39;, &amp;#39;_sha512&amp;#39;, &amp;#39;_signal&amp;#39;, &amp;#39;_sre&amp;#39;, &amp;#39;_stat&amp;#39;, &amp;#39;_statistics&amp;#39;, &amp;#39;_string&amp;#39;, &amp;#39;_struct&amp;#39;, &amp;#39;_symtable&amp;#39;, &amp;#39;_thread&amp;#39;, &amp;#39;_tracemalloc&amp;#39;, &amp;#39;_warnings&amp;#39;, &amp;#39;_weakref&amp;#39;, &amp;#39;_winapi&amp;#39;, &amp;#39;_xxsubinterpreters&amp;#39;, &amp;#39;array&amp;#39;, &amp;#39;atexit&amp;#39;, &amp;#39;audioop&amp;#39;, &amp;#39;binascii&amp;#39;, &amp;#39;builtins&amp;#39;, &amp;#39;cmath&amp;#39;, &amp;#39;errno&amp;#39;, &amp;#39;faulthandler&amp;#39;, &amp;#39;gc&amp;#39;, &amp;#39;itertools&amp;#39;, &amp;#39;marshal&amp;#39;, &amp;#39;math&amp;#39;, &amp;#39;mmap&amp;#39;, &amp;#39;msvcrt&amp;#39;, &amp;#39;nt&amp;#39;, &amp;#39;sys&amp;#39;, &amp;#39;time&amp;#39;, &amp;#39;winreg&amp;#39;, &amp;#39;xxsubtype&amp;#39;, &amp;#39;zlib&amp;#39;) 注意：并不是所有内置模块都能在 sys.</description></item><item><title>Control structure</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/Python-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Control-structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/Python-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Control-structure/</guid><description>概述 参考：
Python 语言提供了多种条件结构和分支结构用作 Control structure(控制结构)
with 参考：
官方文档，参考 - 8.复合语句 - 8.5 with 语句 with 语句用于包装带有使用上下文管理器 (参见 with 语句上下文管理器 一节) 定义的方法的代码块的执行。 这允许对普通的 try&amp;hellip;except&amp;hellip;finally 使用模式进行封装以方便地重用。语法如下：
with EXPRESSION as TARGET: SUITE EXPRESSION 的返回值赋值给 TARGET 变量，在 SUITE 中可以处理 TARGET。
用白话解释：Python 中的 with 语句用于异常处理，封装了 try…except…finally 编码范式，提高了易用性。with 语句使代码更清晰、更具可读性， 它简化了文件流等公共资源的管理。在处理文件时使用 with 关键字是一种很好的做法。
file = open(&amp;#39;./test_runoob.txt&amp;#39;, &amp;#39;w&amp;#39;) file.write(&amp;#39;hello world !&amp;#39;) file.close() # 使用 try 的话 file = open(&amp;#39;./test_runoob.txt&amp;#39;, &amp;#39;w&amp;#39;) try: file.write(&amp;#39;hello world&amp;#39;) finally: file.close() 以上代码我们对可能发生异常的代码处进行 try 捕获，发生异常时执行 except 代码块，finally 代码块是无论什么情况都会执行，所以文件会被关闭，不会因为执行异常而占用资源。</description></item><item><title>Data type</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/Python-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Data-type/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/Python-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Data-type/</guid><description>概述 参考：
官方文档，参考 - 数据模型 object(对象) 是 Python 中对数据的抽象。Python 程序中的所有数据都是由对象或对象间关系来表示的。 （从某种意义上说，按照冯·诺依曼的“存储程序计算机”模型，代码本身也是由对象来表示的。）
Python 中的 object 概念类似于 JS 中的 object 概念。但是又不完全一样。
Python 变量的本质是对对象的引用
每个 object 都有一个 Identity(标识符)、Type(类型)、Value(值)。一个对象被创建后，它的 Identity 就绝不会改变；你可以将其理解为该对象在内存中的地址。 &amp;lsquo;is&amp;rsquo; 运算符可以比较两个对象的标识号是否相同；id() 函数能返回一个代表其标识号的整数。
CPython 实现细节： 在 CPython 中，id(x) 就是存放 x 的内存的地址。从某个角度来看，获取变量的值，就是获取变量所引用的对象的值。
对于 Python 和 JS 中的 object 来说，这个 object 就像全能的超人一样。。。。o(╯□╰)o。。。而 Go 语言中的全能超人则是 struct
对象的 Type 决定该对象所支持的操作 (例如 &amp;ldquo;对象是否有长度属性？&amp;rdquo; 比如数组类型的长度) 并且定义了该类型的对象可能的取值。type() 函数能返回一个对象的类型 (类型本身也是对象)。与 Identity 一样，一个对象的 Type 也是不可改变的。
下面的代码可以让我们对 Python 对象有更形象的感受：
s = &amp;#34;Hello, World!&amp;#34; # 变量的本质是对象的引用 # 在 Python 中有一个与 ESMAScript 中类似的 object(对象) 概念。 # 在 Python 中，所有的数据都是对象，每一个对象都有唯一的标识符、类型和值。与 JavaScript 不同的是，在 Python 中，变量本身并不拥有内存空间，它只是指向一个对象的引用。因此，我们在 Python 中声明变量时，并不需要显式地指定它的类型。 print(&amp;#34;对象标识符: &amp;#34;, id(s)) print(&amp;#34;对象的类型: &amp;#34;, type(s)) print(&amp;#34;对象的值: &amp;#34;, s) # 由于变量就是对对象的引用，那么就可以调用这个对象的属性和方法。例如： print(s.</description></item><item><title>WSGI</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/Python-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/WSGI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/Python-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/WSGI/</guid><description>概述 参考：
Wiki, Web Server Gateway Interface Web Server Gateway Interface(Web 服务器网关接口，简称 WSGI) 是一种简单的 Web 服务器调用约定，用于将请求转发到用 Python 编程语言编写的 Web 应用程序或框架。 WSGI 的当前版本（版本 1.0.1）在 Python 增强提案 (PEP) 3333 中指定。</description></item><item><title>Python 类</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/Python-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Class/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/Python-%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/Class/</guid><description>概述 参考：
官方文档，教程-9.类 廖雪峰 Python 教程，面向对象编程 Classes(类) 提供了一种将数据与功能捆绑到一起的手段。创建一个新的 class(类) 就意味着创造了一个新的 object 的类型，进而可以使用这个新的类型创建多个 instances(实例)。每个类实例都可以添加 attributes(属性) 以维护其自身的状态，同时还可以有 methods(方法) 用于修改其状态(方法在类中定义)。
与其他编程语言相比，Python 的类机制增加了包含最少新语法和语义的类。它是 C ++和 Modula-3 中发现的类机制的混合物。 Python 类提供面向对象编程的所有标准功能：类继承机制允许多个基类，派生类可以覆盖其基类或类的任何方法，方法可以调用具有相同名称的基类的方法。对象可以包含任意数量和类型的数据。正如模块所面临的那样，类 Python 的动态性质的课程：它们是在运行时创建的，并且可以在创建后进一步修改。
struct 格式的 class 从 3.7 版本开始，可以使用 dataclass 装饰器让 class 声明中不再写 __init__ 方法，就像这样
from dataclasses import dataclass @dataclass class Employee: name: str dept: str salary: int john = Employee(&amp;#39;john&amp;#39;, &amp;#39;computer lab&amp;#39;, 1000) print(john.dept) print(john.salary) 运行结果：
&amp;#39;computer lab&amp;#39; 1000</description></item></channel></rss>