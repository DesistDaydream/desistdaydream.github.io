<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦的站点 – 编程工具</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-tools/</link><description>Recent content in 编程工具 on 断念梦的站点</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-tools/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Programming tools</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-tools/Programming-tools/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-tools/Programming-tools/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;/blockquote>
&lt;p>Programming tools(编程工具)&lt;/p>
&lt;h1 id="构建系统">构建系统&lt;a class="td-heading-self-link" href="#%e6%9e%84%e5%bb%ba%e7%b3%bb%e7%bb%9f" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming%20tools/Make.md">Make&lt;/a>&lt;/p>
&lt;p>Meson # Python 实现的构建系统&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/mesonbuild/meson">https://github.com/mesonbuild/meson&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.techgrow.cn/posts/68d93948.html">https://www.techgrow.cn/posts/68d93948.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Ninja # C++ 编写的小型构件系统&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/ninja-build/ninja">https://github.com/ninja-build/ninja&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cnblogs.com/sandeepin/p/ninja.html">https://www.cnblogs.com/sandeepin/p/ninja.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="辅助">辅助&lt;a class="td-heading-self-link" href="#%e8%be%85%e5%8a%a9" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;h2 id="lint">Lint&lt;a class="td-heading-self-link" href="#lint" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Lint_(software)">Wiki, Lint&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Lint 或 Linter 是一种静态代码分析工具，用于标记 编程错误、Bug、风格错误、可疑结构 等。该术语源自一个检查 C 语言代码的 Unix 程序。&lt;/p>
&lt;p>现在泛指所有可以实现这种功能的程序，通常，每种编程语言都会开发出一个对应的 Linter，比如 Go 语言的 Staticcheck 就是 gopls。&lt;/p>
&lt;h1 id="ai-代码补全">AI 代码补全&lt;a class="td-heading-self-link" href="#ai-%e4%bb%a3%e7%a0%81%e8%a1%a5%e5%85%a8" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;h2 id="copilot">Copilot&lt;a class="td-heading-self-link" href="#copilot" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;a href="https://www.v2ex.com/t/975443">现在网上卖的 Github Copilot 授权程序是什么原理？&lt;/a>&lt;/p>
&lt;p>cocopilot &lt;a href="https://zhile.io/2023/09/09/github-got-banned.html">https://zhile.io/2023/09/09/github-got-banned.html&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://gitee.com/Tzeao/share-copilot">https://gitee.com/Tzeao/share-copilot&lt;/a>&lt;/p>
&lt;h2 id="tabnine">Tabnine&lt;a class="td-heading-self-link" href="#tabnine" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h2 id="codegeex">CodeGeeX&lt;a class="td-heading-self-link" href="#codegeex" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;a href="https://github.com/THUDM/CodeGeeX2">GitHub 项目，THUDM/CodeGeeX2&lt;/a>&lt;/p>
&lt;p>介绍: &lt;a href="https://www.bilibili.com/video/BV1Mj411676S">https://www.bilibili.com/video/BV1Mj411676S&lt;/a>&lt;/p>
&lt;p>清华开源的更强大的多语言代码生成模型&lt;/p>
&lt;h2 id="codewhisperer">CodeWhisperer&lt;a class="td-heading-self-link" href="#codewhisperer" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;a href="https://github.com/aws/aws-toolkit-vscode">https://github.com/aws/aws-toolkit-vscode&lt;/a>&lt;/p>
&lt;p>介绍: &lt;a href="https://www.bilibili.com/video/BV1WN411B7ZX">https://www.bilibili.com/video/BV1WN411B7ZX&lt;/a>&lt;/p>
&lt;p>亚马逊出的 AI 代码补全&lt;/p>
&lt;h2 id="fitten-code">Fitten Code&lt;a class="td-heading-self-link" href="#fitten-code" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;a href="https://code.fittentech.com/">https://code.fittentech.com/&lt;/a>&lt;/p>
&lt;h1 id="反编译器">反编译器&lt;a class="td-heading-self-link" href="#%e5%8f%8d%e7%bc%96%e8%af%91%e5%99%a8" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;h2 id="ilspy">ILSpy&lt;a class="td-heading-self-link" href="#ilspy" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/icsharpcode/ILSpy">GitHub 项目，icsharpcode/ILSpy&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>ILSpy 是开源的 .NET 程序集浏览器和反编译器&lt;/p></description></item><item><title>Docs: SCM</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-tools/SCM/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-tools/SCM/</guid><description/></item><item><title>Docs: Clang</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-tools/Clang/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-tools/Clang/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Clang">Wiki, Clang&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Clang (/ˈklæŋ/) 是 C、C++、Objective-C 和 Objective-C++ 编程语言以及 OpenMP、OpenCL、RenderScript、CUDA、SYCL 和 HIP 的 &lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming%20tools/Compiler.md">Compiler&lt;/a>(编译器) 前端框架。它充当 GNU 编译器集合 (GCC) 的直接替代品，支持其大部分编译标志和非官方语言扩展。它包括一个静态分析器和几个代码分析工具。&lt;/p></description></item><item><title>Docs: Compiler</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-tools/Compiler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-tools/Compiler/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/">Wiki, Compiler&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在计算机中，&lt;strong>Compiler(编译器)&lt;/strong> 是一个计算机程序，它将用一种编程语言（源语言）编写的计算机代码翻译成另一种语言（目标语言）。术语 “编译器” 主要用于指将源代码从高级编程语言翻译成低级编程语言（例如汇编语言、目标代码或机器代码）以创建可执行程序。&lt;/p></description></item><item><title>Docs: LLVM</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-tools/LLVM/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-tools/LLVM/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/llvm/llvm-project">GitHub 项目，llvm/llvm-project&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/LLVM">Wiki, LLVM&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>LLVM 是一组 &lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming%20tools/Compiler.md">Compiler&lt;/a>(编译器) 和 工具链技术，可以用于为任何编程语言开发前端（Notes: 不是 Web 开发中的前端），为任何指令集架构开发后端。LLVM 围绕一种与语言无关的中间表示（IR）设计，这种表示作为一种可移植的高级汇编语言，可以通过多次转换进行优化。&lt;/p>
&lt;blockquote>
&lt;p>[!Tip]
然而，LLVM项目逐渐演变为一个涵盖多个子项目的综合性项目，这与大多数当前开发者所理解的虚拟机关系不大。这使得该首字母缩略词变得“令人困惑”和“不合适”，因此自2011年以来，LLVM 官方不再是一个缩略词，而是一个适用于 LLVM 综合项目的品牌。该项目包括 LLVM &lt;a href="https://en.wikipedia.org/wiki/Intermediate_representation">intermediate representation&lt;/a>(中间表示，简称 IR)、LLVM 调试器、LLVM 对 C++ 标准库的实现（完全支持 C++ 11 和C++ 14）等。LLVM 由 LLVM 基金会管理。编译工程师 Tanya Lattner 于 2014 年成为其主席。&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: Utility</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-tools/Utility/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-tools/Utility/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>MGit # 在 Android 上使用 git 管理代码仓库&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://f-droid.org/packages/com.manichord.mgit/">https://f-droid.org/packages/com.manichord.mgit/&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: Make 命令教程</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-tools/Make/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/Programming-tools/Make/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/make.1.html">Manual(手册)，make(1)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Make_(software)">Wiki, Make(software)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ruanyifeng.com/blog/2015/02/make.html">阮一峰博客，Make 命令教程&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="make">Make&lt;a class="td-heading-self-link" href="#make" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>代码变成可执行文件，叫做&lt;a href="https://www.ruanyifeng.com/blog/2014/11/compiler.html">编译&lt;/a>（compile）；先编译这个，还是先编译那个（即编译的安排），叫做&lt;a href="https://en.wikipedia.org/wiki/Software_build">构建&lt;/a>（build）。&lt;/p>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Make_%28software%29">Make&lt;/a>是最常用的构建工具，诞生于 1977 年，主要用于 C 语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用 Make 构建。&lt;/p>
&lt;p>本文介绍 Make 命令的用法，从简单的讲起，不需要任何基础，只要会使用命令行，就能看懂。我的参考资料主要是 Isaac Schlueter 的&lt;a href="https://gist.github.com/isaacs/62a2d1825d04437c6f08">《Makefile 文件教程》&lt;/a>和&lt;a href="https://www.gnu.org/software/make/manual/make.html">《GNU Make 手册》&lt;/a>。&lt;/p>
&lt;h2 id="一make-的概念">一、Make 的概念&lt;a class="td-heading-self-link" href="#%e4%b8%80make-%e7%9a%84%e6%a6%82%e5%bf%b5" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>Make 这个词，英语的意思是&amp;quot;制作&amp;quot;。Make 命令直接用了这个意思，就是要做出某个文件。比如，要做出文件 a.txt，就可以执行下面的命令。&lt;/p>
&lt;pre>&lt;code> $ make a.txt
&lt;/code>&lt;/pre>
&lt;p>但是，如果你真的输入这条命令，它并不会起作用。因为 Make 命令本身并不知道，如何做出 a.txt，需要有人告诉它，如何调用其他命令完成这个目标。&lt;/p>
&lt;p>比如，假设文件 a.txt 依赖于 b.txt 和 c.txt ，是后面两个文件连接（cat 命令）的产物。那么，make 需要知道下面的规则。&lt;/p>
&lt;pre>&lt;code> a.txt: b.txt c.txt
cat b.txt c.txt &amp;gt; a.txt
&lt;/code>&lt;/pre>
&lt;p>也就是说，make a.txt 这条命令的背后，实际上分成两步：第一步，确认 b.txt 和 c.txt 必须已经存在，第二步使用 cat 命令 将这个两个文件合并，输出为新文件。&lt;/p>
&lt;p>像这样的规则，都写在一个叫做 Makefile 的文件中，Make 命令依赖这个文件进行构建。Makefile 文件也可以写为 makefile， 或者用命令行参数指定为其他文件名。&lt;/p>
&lt;pre>&lt;code> $ make -f rules.txt
$ make --file=rules.txt
&lt;/code>&lt;/pre>
&lt;p>上面代码指定 make 命令依据 rules.txt 文件中的规则，进行构建。&lt;/p>
&lt;p>总之，make 只是一个根据指定的 Shell 命令进行构建的工具。它的规则很简单，你规定要构建哪个文件、它依赖哪些源文件，当那些文件有变动时，如何重新构建它。&lt;/p>
&lt;h2 id="二makefile-文件的格式">二、Makefile 文件的格式&lt;a class="td-heading-self-link" href="#%e4%ba%8cmakefile-%e6%96%87%e4%bb%b6%e7%9a%84%e6%a0%bc%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>构建规则都写在 Makefile 文件里面，要学会如何 Make 命令，就必须学会如何编写 Makefile 文件。&lt;/p>
&lt;h3 id="21-概述">2.1 概述&lt;a class="td-heading-self-link" href="#21-%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>Makefile 文件由一系列规则（rules）构成。每条规则的形式如下。&lt;/p>
&lt;pre>&lt;code> &amp;lt;target&amp;gt; : &amp;lt;prerequisites&amp;gt;
[tab] &amp;lt;commands&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>上面第一行冒号前面的部分，叫做&amp;quot;目标&amp;quot;（target），冒号后面的部分叫做&amp;quot;前置条件&amp;quot;（prerequisites）；第二行必须由一个 tab 键起首，后面跟着&amp;quot;命令&amp;quot;（commands）。&lt;/p>
&lt;p>&amp;ldquo;目标&amp;quot;是必需的，不可省略；&amp;ldquo;前置条件&amp;quot;和&amp;quot;命令&amp;quot;都是可选的，但是两者之中必须至少存在一个。&lt;/p>
&lt;p>每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。&lt;/p>
&lt;h3 id="22-目标target">2.2 目标（target）&lt;a class="td-heading-self-link" href="#22-%e7%9b%ae%e6%a0%87target" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>一个目标（target）就构成一条规则。目标通常是文件名，指明 Make 命令所要构建的对象，比如上文的 a.txt 。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。&lt;/p>
&lt;p>除了文件名，目标还可以是某个操作的名字，这称为&amp;quot;伪目标&amp;rdquo;（phony target）。&lt;/p>
&lt;pre>&lt;code> clean:
rm *.o
&lt;/code>&lt;/pre>
&lt;p>上面代码的目标是 clean，它不是文件名，而是一个操作的名字，属于&amp;quot;伪目标 &amp;ldquo;，作用是删除对象文件。&lt;/p>
&lt;pre>&lt;code> $ make clean
&lt;/code>&lt;/pre>
&lt;p>但是，如果当前目录中，正好有一个文件叫做 clean，那么这个命令不会执行。因为 Make 发现 clean 文件已经存在，就认为没有必要重新构建了，就不会执行指定的 rm 命令。&lt;/p>
&lt;p>为了避免这种情况，可以明确声明 clean 是&amp;quot;伪目标&amp;rdquo;，写法如下。&lt;/p>
&lt;pre>&lt;code> .PHONY: clean
clean:
rm *.o temp
&lt;/code>&lt;/pre>
&lt;p>声明 clean 是&amp;quot;伪目标&amp;quot;之后，make 就不会去检查是否存在一个叫做 clean 的文件，而是每次运行都执行对应的命令。像.PHONY 这样的内置目标名还有不少，可以查看&lt;a href="https://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets">手册&lt;/a>。&lt;/p>
&lt;p>如果 Make 命令运行时没有指定目标，默认会执行 Makefile 文件的第一个目标。&lt;/p>
&lt;pre>&lt;code> $ make
&lt;/code>&lt;/pre>
&lt;p>上面代码执行 Makefile 文件的第一个目标。&lt;/p>
&lt;h3 id="23-前置条件prerequisites">2.3 前置条件（prerequisites）&lt;a class="td-heading-self-link" href="#23-%e5%89%8d%e7%bd%ae%e6%9d%a1%e4%bb%b6prerequisites" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>前置条件通常是一组文件名或其他 Target(目标)，之间用空格分隔。它指定了&amp;quot;目标&amp;quot;是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的 last-modification 时间戳比目标的时间戳新），&amp;ldquo;目标&amp;quot;就需要重新构建。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-makefile" data-lang="makefile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">result.txt&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#000">source&lt;/span>.&lt;span style="color:#000">txt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cp source.txt result.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面代码中，构建 result.txt 的前置条件是 source.txt 。如果当前目录中，source.txt 已经存在，那么&lt;code>make result.txt&lt;/code>可以正常运行，否则必须再写一条规则，来生成 source.txt 。&lt;/p>
&lt;pre>&lt;code> source.txt:
echo &amp;quot;this is the source&amp;quot; &amp;gt; source.txt
&lt;/code>&lt;/pre>
&lt;p>上面代码中，source.txt 后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件还不存在，每次调用&lt;code>make source.txt&lt;/code>，它都会生成。&lt;/p>
&lt;pre>&lt;code>$ make result.txt
$ make result.txt
&lt;/code>&lt;/pre>
&lt;p>上面命令连续执行两次&lt;code>make result.txt&lt;/code>。第一次执行会先新建 source.txt，然后再新建 result.txt。第二次执行，Make 发现 source.txt 没有变动（时间戳晚于 result.txt），就不会执行任何操作，result.txt 也不会重新生成。&lt;/p>
&lt;p>如果需要生成多个文件，往往采用下面的写法。&lt;/p>
&lt;pre>&lt;code> source: file1 file2 file3
&lt;/code>&lt;/pre>
&lt;p>上面代码中，source 是一个伪目标，只有三个前置文件，没有任何对应的命令。&lt;/p>
&lt;pre>&lt;code> $ make source
&lt;/code>&lt;/pre>
&lt;p>执行&lt;code>make source&lt;/code>命令后，就会一次性生成 file1，file2，file3 三个文件。这比下面的写法要方便很多。&lt;/p>
&lt;pre>&lt;code>$ make file1
$ make file2
$ make file3
&lt;/code>&lt;/pre>
&lt;h3 id="24-命令commands">2.4 命令（commands）&lt;a class="td-heading-self-link" href="#24-%e5%91%bd%e4%bb%a4commands" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>命令（commands）表示如何更新目标文件，由一行或多行的 Shell 命令组成。它是构建&amp;quot;目标&amp;quot;的具体指令，它的运行结果通常就是生成目标文件。&lt;/p>
&lt;p>每行命令之前必须有一个 tab 键。如果想用其他键，可以用内置变量.RECIPEPREFIX 声明。&lt;/p>
&lt;pre>&lt;code> .RECIPEPREFIX = &amp;gt;
all:
&amp;gt; echo Hello, world
&lt;/code>&lt;/pre>
&lt;p>上面代码用.RECIPEPREFIX 指定，大于号（&amp;gt;）替代 tab 键。所以，每一行命令的起首变成了大于号，而不是 tab 键。&lt;/p>
&lt;p>需要注意的是，每行命令在一个单独的 shell 中执行。这些 Shell 之间没有继承关系。&lt;/p>
&lt;pre>&lt;code> var-lost:
export foo=bar
echo &amp;quot;foo=[$$foo]&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>上面代码执行后（&lt;code>make var-lost&lt;/code>），取不到 foo 的值。因为两行命令在两个不同的进程执行。一个解决办法是将两行命令写在一行，中间用分号分隔。&lt;/p>
&lt;pre>&lt;code> var-kept:
export foo=bar; echo &amp;quot;foo=[$$foo]&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>另一个解决办法是在换行符前加反斜杠转义。&lt;/p>
&lt;pre>&lt;code> var-kept:
export foo=bar; \
echo &amp;quot;foo=[$$foo]&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>最后一个方法是加上&lt;code>.ONESHELL:&lt;/code>命令。&lt;/p>
&lt;pre>&lt;code> .ONESHELL:
var-kept:
export foo=bar;
echo &amp;quot;foo=[$$foo]&amp;quot;
&lt;/code>&lt;/pre>
&lt;h2 id="三makefile-文件的语法">三、Makefile 文件的语法&lt;a class="td-heading-self-link" href="#%e4%b8%89makefile-%e6%96%87%e4%bb%b6%e7%9a%84%e8%af%ad%e6%b3%95" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="31-注释">3.1 注释&lt;a class="td-heading-self-link" href="#31-%e6%b3%a8%e9%87%8a" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>井号（#）在 Makefile 中表示注释。&lt;/p>
&lt;pre>&lt;code> result.txt: source.txt
cp source.txt result.txt
&lt;/code>&lt;/pre>
&lt;h3 id="32-回声echoing">3.2 回声（echoing）&lt;a class="td-heading-self-link" href="#32-%e5%9b%9e%e5%a3%b0echoing" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>正常情况下，make 会打印每条命令，然后再执行，这就叫做回声（echoing）。&lt;/p>
&lt;pre>&lt;code> test:
&lt;/code>&lt;/pre>
&lt;p>执行上面的规则，会得到下面的结果。&lt;/p>
&lt;pre>&lt;code> $ make test
&lt;/code>&lt;/pre>
&lt;p>在命令的前面加上@，就可以关闭回声。&lt;/p>
&lt;pre>&lt;code> test:
@
&lt;/code>&lt;/pre>
&lt;p>现在再执行&lt;code>make test&lt;/code>，就不会有任何输出。&lt;/p>
&lt;p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的 echo 命令前面加上@。&lt;/p>
&lt;pre>&lt;code> test:
@ @echo TODO
&lt;/code>&lt;/pre>
&lt;h3 id="33-通配符">3.3 通配符&lt;a class="td-heading-self-link" href="#33-%e9%80%9a%e9%85%8d%e7%ac%a6" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>通配符（wildcard）用来指定一组符合条件的文件名。Makefile 的通配符与 Bash 一致，主要有星号（_）、问号（？）和 [&amp;hellip;] 。比如， _.o 表示所有后缀名为 o 的文件。&lt;/p>
&lt;pre>&lt;code> clean:
rm -f *.o
&lt;/code>&lt;/pre>
&lt;h3 id="34-模式匹配">3.4 模式匹配&lt;a class="td-heading-self-link" href="#34-%e6%a8%a1%e5%bc%8f%e5%8c%b9%e9%85%8d" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>Make 命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。&lt;/p>
&lt;pre>&lt;code> %.o: %.c
&lt;/code>&lt;/pre>
&lt;p>等同于下面的写法。&lt;/p>
&lt;pre>&lt;code> f1.o: f1.c
f2.o: f2.c
&lt;/code>&lt;/pre>
&lt;p>使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。&lt;/p>
&lt;h3 id="35-变量和赋值符">3.5 变量和赋值符&lt;a class="td-heading-self-link" href="#35-%e5%8f%98%e9%87%8f%e5%92%8c%e8%b5%8b%e5%80%bc%e7%ac%a6" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>Makefile 允许使用等号自定义变量。&lt;/p>
&lt;pre>&lt;code> txt = Hello World
test:
@echo $(txt)
&lt;/code>&lt;/pre>
&lt;p>上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中。&lt;/p>
&lt;p>调用 Shell 变量，需要在美元符号前，再加一个美元符号，这是因为 Make 命令会对美元符号转义。&lt;/p>
&lt;pre>&lt;code> test:
@echo $$HOME
&lt;/code>&lt;/pre>
&lt;p>有时，变量的值可能指向另一个变量。&lt;/p>
&lt;pre>&lt;code> v1 = $(v2)
&lt;/code>&lt;/pre>
&lt;p>上面代码中，变量 v1 的值是另一个变量 v2。这时会产生一个问题，v1 的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。&lt;/p>
&lt;p>为了解决类似问题，Makefile 一共提供了四个赋值运算符 （=、:=、？=、+=），它们的区别请看&lt;a href="https://stackoverflow.com/questions/448910/makefile-variable-assignment">StackOverflow&lt;/a>。&lt;/p>
&lt;pre>&lt;code> VARIABLE = value
VARIABLE := value
VARIABLE ?= value
VARIABLE += value
&lt;/code>&lt;/pre>
&lt;h3 id="36-内置变量implicit-variables">3.6 内置变量（Implicit Variables）&lt;a class="td-heading-self-link" href="#36-%e5%86%85%e7%bd%ae%e5%8f%98%e9%87%8fimplicit-variables" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>Make 命令提供一系列内置变量，比如，&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/e6ba0987-73ba-41d6-831e-246ad899c89b/latex" alt="">(MAKE) 指向当前使用的 Make 工具。这主要是为了跨平台的兼容性，详细的内置变量清单见&lt;a href="https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html">手册&lt;/a>。&lt;/p>
&lt;pre>&lt;code> output:
$(CC) -o output input.c
&lt;/code>&lt;/pre>
&lt;h3 id="37-自动变量automatic-variables">3.7 自动变量（Automatic Variables）&lt;a class="td-heading-self-link" href="#37-%e8%87%aa%e5%8a%a8%e5%8f%98%e9%87%8fautomatic-variables" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>Make 命令还提供一些自动变量，它们的值与当前规则有关。主要有以下几个。&lt;/p>
&lt;p>&lt;strong>（1）$@&lt;/strong>&lt;/p>
&lt;p>$@指代当前目标，就是 Make 命令当前构建的那个目标。比如，&lt;code>make foo&lt;/code>的 $@ 就指代 foo。&lt;/p>
&lt;pre>&lt;code> a.txt b.txt:
touch $@
&lt;/code>&lt;/pre>
&lt;p>等同于下面的写法。&lt;/p>
&lt;pre>&lt;code> a.txt:
touch a.txt
b.txt:
touch b.txt
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>（2）$&amp;lt;&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/e6ba0987-73ba-41d6-831e-246ad899c89b/latex" alt="">&amp;lt; 就指代 p1。&lt;/p>
&lt;pre>&lt;code> a.txt: b.txt c.txt
cp $&amp;lt; $@
&lt;/code>&lt;/pre>
&lt;p>等同于下面的写法。&lt;/p>
&lt;pre>&lt;code> a.txt: b.txt c.txt
cp b.txt a.txt
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>（3）$?&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/e6ba0987-73ba-41d6-831e-246ad899c89b/latex" alt="">?就指代 p2。&lt;/p>
&lt;p>&lt;strong>（4）$^&lt;/strong>&lt;/p>
&lt;p>$^ 指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。&lt;/p>
&lt;p>&lt;strong>（5）$*&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/e6ba0987-73ba-41d6-831e-246ad899c89b/latex" alt="">* 就表示 f1。&lt;/p>
&lt;p>&lt;strong>（6）$(@D) 和 $(@F)&lt;/strong>&lt;/p>
&lt;p>$(@D) 和 $(@F) 分别指向 &lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/e6ba0987-73ba-41d6-831e-246ad899c89b/latex" alt="">(@F) 的值为 input.c。&lt;/p>
&lt;p>&lt;strong>（7）$(&amp;lt;D) 和 $(&amp;lt;F)&lt;/strong>&lt;/p>
&lt;p>$(&amp;lt;D) 和 $(&amp;lt;F) 分别指向 $&amp;lt; 的目录名和文件名。&lt;/p>
&lt;p>所有的自动变量清单，请看&lt;a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html">手册&lt;/a>。下面是自动变量的一个例子。&lt;/p>
&lt;pre>&lt;code> dest/%.txt: src/%.txt
@[ -d dest ] || mkdir dest
cp $&amp;lt; $@
&lt;/code>&lt;/pre>
&lt;p>上面代码将 src 目录下的 txt 文件，拷贝到 dest 目录下。首先判断 dest 目录是否存在，如果不存在就新建，然后，$&amp;lt; 指代前置文件（src/%.txt）， $@ 指代目标文件（dest/%.txt）。&lt;/p>
&lt;h3 id="38-判断和循环">3.8 判断和循环&lt;a class="td-heading-self-link" href="#38-%e5%88%a4%e6%96%ad%e5%92%8c%e5%be%aa%e7%8e%af" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>Makefile 使用 Bash 语法，完成判断和循环。&lt;/p>
&lt;pre>&lt;code> ifeq ($(CC),gcc)
libs=$(libs_for_gcc)
else
libs=$(normal_libs)
endif
&lt;/code>&lt;/pre>
&lt;p>上面代码判断当前编译器是否 gcc ，然后指定不同的库文件。&lt;/p>
&lt;pre>&lt;code> LIST = one two three
all:
for i in $(LIST); do \
echo $$i; \
done
all:
for i in one two three; do \
echo $i; \
done
&lt;/code>&lt;/pre>
&lt;p>上面代码的运行结果。&lt;/p>
&lt;pre>&lt;code> one
two
three
&lt;/code>&lt;/pre>
&lt;h3 id="39-函数">3.9 函数&lt;a class="td-heading-self-link" href="#39-%e5%87%bd%e6%95%b0" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>Makefile 还可以使用函数，格式如下。&lt;/p>
&lt;pre>&lt;code> $(function arguments)
${function arguments}
&lt;/code>&lt;/pre>
&lt;p>Makefile 提供了许多&lt;a href="https://www.gnu.org/software/make/manual/html_node/Functions.html">内置函数&lt;/a>，可供调用。下面是几个常用的内置函数。&lt;/p>
&lt;p>&lt;strong>（1）shell 函数&lt;/strong>&lt;/p>
&lt;p>shell 函数用来执行 shell 命令&lt;/p>
&lt;pre>&lt;code> srcfiles := $(shell echo src/{00..99}.txt)
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>（2）wildcard 函数&lt;/strong>&lt;/p>
&lt;p>wildcard 函数用来在 Makefile 中，替换 Bash 的通配符。&lt;/p>
&lt;pre>&lt;code> srcfiles := $(wildcard src/*.txt)
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>（3）subst 函数&lt;/strong>&lt;/p>
&lt;p>subst 函数用来文本替换，格式如下。&lt;/p>
&lt;pre>&lt;code> $(subst from,to,text)
&lt;/code>&lt;/pre>
&lt;p>下面的例子将字符串&amp;quot;feet on the street&amp;quot;替换成&amp;quot;fEEt on the strEEt&amp;rdquo;。&lt;/p>
&lt;pre>&lt;code> $(subst ee,EE,feet on the street)
&lt;/code>&lt;/pre>
&lt;p>下面是一个稍微复杂的例子。&lt;/p>
&lt;pre>&lt;code> comma:= ,
empty:=
space:= $(empty) $(empty)
foo:= a b c
bar:= $(subst $(space),$(comma),$(foo))
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>（4）patsubst 函数&lt;/strong>&lt;/p>
&lt;p>patsubst 函数用于模式匹配的替换，格式如下。&lt;/p>
&lt;pre>&lt;code> $(patsubst pattern,replacement,text)
&lt;/code>&lt;/pre>
&lt;p>下面的例子将文件名&amp;quot;x.c.c bar.c&amp;rdquo;，替换成&amp;quot;x.c.o bar.o&amp;quot;。&lt;/p>
&lt;pre>&lt;code> $(patsubst %.c,%.o,x.c.c bar.c)
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>（5）替换后缀名&lt;/strong>&lt;/p>
&lt;p>替换后缀名函数的写法是：变量名 + 冒号 + 后缀名替换规则。它实际上 patsubst 函数的一种简写形式。&lt;/p>
&lt;pre>&lt;code> min: $(OUTPUT:.js=.min.js)
&lt;/code>&lt;/pre>
&lt;p>上面代码的意思是，将变量 OUTPUT 中的后缀名 .js 全部替换成 .min.js 。&lt;/p>
&lt;h2 id="四makefile-的实例">四、Makefile 的实例&lt;a class="td-heading-self-link" href="#%e5%9b%9bmakefile-%e7%9a%84%e5%ae%9e%e4%be%8b" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>（1）执行多个目标&lt;/strong>&lt;/p>
&lt;pre>&lt;code>.PHONY: cleanall cleanobj cleandiff
cleanall : cleanobj cleandiff
rm program
cleanobj :
rm *.o
cleandiff :
rm *.diff
&lt;/code>&lt;/pre>
&lt;p>上面代码可以调用不同目标，删除不同后缀名的文件，也可以调用一个目标（cleanall），删除所有指定类型的文件。&lt;/p>
&lt;p>&lt;strong>（2）编译 C 语言项目&lt;/strong>&lt;/p>
&lt;pre>&lt;code> edit : main.o kbd.o command.o display.o
cc -o edit main.o kbd.o command.o display.o
main.o : main.c defs.h
cc -c main.c
kbd.o : kbd.c defs.h command.h
cc -c kbd.c
command.o : command.c defs.h command.h
cc -c command.c
display.o : display.c defs.h
cc -c display.c
clean :
rm edit main.o kbd.o command.o display.o
.PHONY: edit clean
&lt;/code>&lt;/pre>
&lt;p>今天，Make 命令的介绍就到这里。下一篇文章我会介绍，&lt;a href="https://www.ruanyifeng.com/blog/2015/03/build-website-with-make.html">如何用 Make 来构建 Node.js 项目&lt;/a>。&lt;/p>
&lt;p>（完）&lt;/p></description></item></channel></rss>