<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>API on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/</link><description>Recent content in API on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/index.xml" rel="self" type="application/rss+xml"/><item><title>API</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/API/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/API/</guid><description>概述 参考：
Wiki, API Application Programming Interface(应用程序接口，简称 API)。它定义了可以进行的调用或请求的类型，如何进行调用，应使用的数据格式，遵循的约定等。它还可以提供扩展机制，以便用户可以通过各种方式扩展现有功能。在不同程度上。API 可以是完全自定义的，特定于组件的，也可以基于行业标准设计以确保互操作性。通过信息隐藏，API 支持模块化编程，从而使用户可以独立于实现使用接口。
目的 在构建应用程序时，API（应用程序编程接口）通过抽象化底层实现并仅公开开发人员需要的对象或动作来简化编程。电子邮件客户端的图形界面可能会为用户提供执行获取和突出显示新电子邮件的所有步骤的按钮，而用于文件输入/输出的 API 可能会为开发人员提供一种将文件从一个位置复制到另一个位置的功能，而无需要求开发人员了解幕后发生的文件系统操作。
术语的历史 1978 年的一张图建议将 API 的概念扩展为一个通用的编程接口，而不仅仅是应用程序。
“API” 一词的含义已经扩展了其历史。首先，它仅描述了面向面向最终用户的程序（称为应用程序）的接口。此起源仍反映在名称“应用程序编程接口”中。如今，术语 API 的范围更广，不仅包括实用程序软件，甚至包括硬件接口。
API 的概念比该术语要古老得多。英国计算机科学家 Wilkes 和 Wheeler 在 1940 年代为 EDSAC 计算机开发了模块化软件库。约书亚·布洛赫（Joshua Bloch）声称威尔克斯和惠勒（Wilker and Wheeler）“潜在地发明”了该 API，因为它更多地是被发现而不是被发明的概念。
尽管创造 API 一词的人是在 Univac 1108 上实现软件，但他们的 API 的目标是使独立于硬件的程序成为可能。
术语“应用程序接口”（没有-ing后缀）首先被记录在称为纸张数据结构和技术对于远程计算机图形在呈现 AFIPS 在 1968 年会议[6] [4]所述的本文使用的作者该术语描述应用程序（在这种情况下为图形程序）与计算机系统其余部分的交互。一致的应用程序接口（包括 Fortran 子例程调用）旨在使程序员摆脱处理图形显示设备的特性，并在更换计算机或显示器时提供硬件独立性。
术语被引入到的场数据库由 CJ 日期中称为 1974 纸的关系和网络途径：应用程序编程接口的比较。 API 成为用于数据库管理系统的 ANSI/SPARC 框架的一部分。该框架将应用程序编程接口与其他接口（例如查询接口）分开对待。1970 年代的数据库专业人员发现，这些不同的接口可以组合在一起。一个足够丰富的应用程序接口也可以支持其他接口。
这种观察导致 API 支持所有类型的编程，而不仅是应用程序编程。到 1990 年，API 被技术专家 Carl Malamud 定义为“程序员可以用来执行某些任务的一组服务” 。</description></item><item><title>ABI</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/ABI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/ABI/</guid><description>概述 参考：
Wiki, Application binary interface https://www.jianshu.com/p/bd77c842f281 Application binary interface(应用程序二进制接口，简称 ABI) 是两个二进制程序模块之间的接口。通常，这俩模块一个是库或操作系统设施，另一个是用户运行的程序。
ABI 定义如何以机器代码访问数据结构或计算例程，这是一种低级、依赖于硬件的格式。相比之下，应用程序编程接口 (API) 在源代码中定义这种访问，这是一种相对高级、独立于硬件、通常是人类可读的格式。 ABI 的一个常见方面是调用约定，它确定如何将数据作为计算例程的输入提供或从计算例程读取数据。 x86 调用约定就是这样的示例。
保持一个稳定的 ABI 要比保持稳定的 API 要难得多。比如，在内核中 int register_netdevice(struct net_device *dev) 这个内核函数原型基本上是不会变的，所以保持这个 API 稳定是很简单的，但它的 ABI 就未必了，就算是这个函数定义本身没变，即 API 没变，而 struct net_device 的定义变了，里面多了或者少了某一个字段，它的 ABI 就变了，你之前编译好的二进制模块就很可能会出错了，必须重新编译才行。</description></item><item><title>GraphQL</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/GraphQL/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/GraphQL/</guid><description>概述 参考：
GitHub 组织，GraphQL 官网 公众号 - K8S中文社区，我为什么要放弃 RESTful，选择拥抱 GraphQL 原文: https://www.toutiao.com/article/6833818331884028419/ REST 作为一种现代网络应用非常流行的软件架构风格，自从 Roy Fielding 博士在 2000 年他的博士论文中提出来到现在已经有了 20 年的历史。它的简单易用性，可扩展性，伸缩性受到广大 Web 开发者的喜爱。
REST 的 API 配合 JSON 格式的数据交换，使得前后端分离、数据交互变得非常容易，而且也已经成为了目前 Web 领域最受欢迎的软件架构设计模式。
但随着 REST API 的流行和发展，它的缺点也暴露了出来：
滥用 REST 接口 ，导致大量相似度很高（具有重复性）的 API 越来越冗余。 对于前端而言：REST API 粒度较粗 ，难以一次性符合前端的数据要求，前端需要分多次请求接口数据。增加了前端人员的工作量。 对于后端而言：前端需要的数据往往在不同的地方具有相似性，但却又不同 ，比如针对同样的用户信息，有的地方只需要用户简要信息（比如头像、昵称），有些地方需要详细的信息，这就需要开发不同的接口来满足这些需求。当这样的相似但又不同的地方多的时候，就需要开发更多的接口来满足前端的需要。增加了后端开发人员的工作量和重复度。 那我们来分析一下，当前端需求变化，涉及到改动旧需求时 ，会有以下这些情况：
做加法：
产品需求增加，页面需要增加功能，数据也就相应的要增加显示，那么REST接口也需要做增加，这种无可厚非。
做减法：
产品需求减少，页面需要减少功能，或者减少某些信息显示，那么数据就要做减法。
一种通常懒惰的做法是，前端不与后端沟通，仅在前端对数据选择性显示。
因为后端接口能够满足数据需要，仅仅是在做显示的时候对数据进行了选择性显示，但接口的数据是存在冗余的，这种情况一个是存在数据泄露风险，另外就是数据量过大时造成网络流量过大，页面加载缓慢，用户流量费白白消耗，用户体验就会下降。
另外一种做法就是告知后端，要么开发新的接口，要么，修改旧接口，删掉冗余字段。
但一般来说，开发新接口往往是后端开发人员会选择的方案，因为这个方案对现有系统的影响最低，不会有额外的风险。
修改旧接口删除冗余数据的方案往往开发人员不会选择，这是为什么呢？
这就涉及到了系统的稳定性问题了，旧接口往往不止是一个地方在用，很有可能很多页面、设置不同客户端、不同服务都调用了这个接口获取数据，不做详细的调查，是不可能知道到底旧接口被调用了多少次，一旦改动旧接口，涉及范围可能非常大，往往会引起其他地方出现崩溃。改动旧接口成本太高，所以往往不会被采取。
同时做加减法：
既有加法，又有减法，其实这种就跟新需求没啥区别，前端需要重做页面，后端需要新写接口满足前端需要，但是旧接口还是不能轻举妄动（除非确定只有这一处调用才可以删除）。
往往这个时候，其实用到的数据大多都是来自于同一个DO或者DTO，不过是在REST接口组装数据时，用不同的VO来封装不同字段，或者，使用同样的VO，组装数据时做删减。
看到这些问题是不是觉得令人头大？
所以需求频繁改动是万恶之源 ，当产品小哥哥改动需求时，程序员小哥哥可能正提着铁锹赶来&amp;hellip;&amp;hellip;
那么有没有一种方案或者框架，可以使得在用到同一个领域模型（DO或者DTO）的数据时，前端对于这个模型的数据字段需求的改动，后端可以根据前端的改动和需要，自动适配，自动组装需要的字段，返回给前端呢？如果能这样做的话，那么后端程序猿小哥可能要开心死了，前端妹子也不用那么苦口婆心地劝说后端小哥哥了。所以GraphQL隆重出世了！那么问题来了！
Part 1 What is GraphQL GraphQL简介 GraphQL是一种新的API标准，它提供了一种比REST更有效、更强大和更灵活的替代方案。</description></item><item><title>OpenAPI</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/OpenAPI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/OpenAPI/</guid><description>概述 参考：
官网 GitHub 社区，OAI Swagger OpenAPI Initiative(开放应用程序接口倡议，简称 OAI)。是由具有前瞻性的行业专家联合创建的，他们认识到标准化 API 描述方式的巨大价值。作为 Linux 基金会下的开放治理结构，OAI 致力于创建、发展 和 推广供所有人可用的中立的描述格式。
OAI 现阶段包含一个规范
OpenAPI Specification(简称 OAS) # 最初基于 SmartBear Software 捐赠的 Swagger 规范。 OAS 可以描述为一个文件，可以描述为一个规范的内容。人们常常在不同场景下，不加区分得统一用 OAS 来描述。比如 Swagger Codegen 项目中的描述中。 This is the Swagger Codegen project, which allows generation of API client libraries (SDK generation), server stubs and documentation automatically given an OpenAPI Spec.(这是 Swagger Codegen 项目，该项目允许在给定 OpenAPI 规范的情况下自动生成 API 客户端库（生成 SDK），服务器存根和文档。) 这里描述的指定的的 OpenAPI Spec 就是指 OAS，也就是说，而已根据 OAS 文件来生成代码。 OpenAPI Specification 参考:</description></item><item><title>Webservice And REST</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/Webservice-And-REST/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/Webservice-And-REST/</guid><description>概述 参考：
阮一峰，RESTful API 设计指南 思否，REST架构的思考 Server Side(服务端) Server Side(服务端) 的 WebAPI 是由一个或多个公开暴露的 Endpoints(端点) 组成的编程接口
Endpoints(端点) Endpoints(端点，简称 ep) 是与服务端 WebAPI 交互的重要方面，因为 Endpoints 指定了客户端可以访问的资源位置。通常，是通过 URI 进行访问，HTTP 请求发送到这个 URI 上，从而期望从这个 URI 上得到响应。
Web services expose one or more endpoints to which messages can be sent. A web service endpoint is an entity, processor, or resource that can be referenced and to which web services messages can be addressed. Endpoint references convey the information needed to address a web service endpoint.</description></item><item><title>Mock API</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/Mock-API/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/Mock-API/</guid><description>API 文档虽然满足了阅读者对接接口的需求，但是在 API 起初设计的过程中，通常需要等待几天、甚至数周时间才能实时调用接口，从而真正开始接口调试工作。
而通过创建 Mock API，您即可提前交付模拟真实 API 响应的沙盒环境，以便 API 使用者提前开始调试工作，同时您也可以并行开发接口实现。
此外，您也可以在设计过程中得到 API 使用者对 API 设计的及时反馈，并进行迭代以得到更好的 API。
什么是 Mock API Mock API Server 通过提供真实 API 响应的范例数据来模拟真实的 API 服务，它将部署在 CODING 提供的公网服务器上，并且支持路由及参数校验，且在此基础上可限制访问的 IP 或 Token 授权方式。
目前 Mock API 支持静态模拟，即基于 API 响应范例的 Mock，暂不支持动态模拟（自定义数据模拟规则）。
功能特性 基于 API 文件数据生成 Mock API。您仅需完善 API 规则及范例，无需额外设置即可使用 Mock API。
Mock API 支持参数校验，并可在请求有误时返回响应错误信息。大大降低 API 使用者在对接 API 时的错误率，方便调试及跟踪。
自定义 Mock API 响应数据。通过修改 API 范例数据，可让每个 API 的模拟数据趋于完美。
每篇文档 Mock API 均有独立域名，并支持 HTTPS / HTTP 双协议。方便统一配置，也方便记忆，地址参考：http://c3wfvv32.</description></item><item><title>OpenAPI Tools</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/OpenAPI-Tools/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/OpenAPI-Tools/</guid><description>参考：OpenAPI Generator</description></item><item><title>OpenAPI 格式</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/OpenAPI-%E6%A0%BC%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/OpenAPI-%E6%A0%BC%E5%BC%8F/</guid><description>参考：官方 v3.0.3 版本文档
根字段 参考：官方文档
openapi: &amp;lt;STRING&amp;gt; # 必须的。This string MUST be the semantic version number of the OpenAPI Specification version that the OpenAPI document uses. The openapi field SHOULD be used by tooling specifications and clients to interpret the OpenAPI document. This is not related to the API info.version string. info: &amp;lt;Object&amp;gt; # 必须的。Provides metadata about the API. The metadata MAY be used by tooling as required. servers([]Object) # 一组可用的服务器，用于提供到目标服务器的连接信息。当我们测试 API 时，将会连接其中一个。如果未提供 servers 属性或为空数组，则默认值为 URL 值为/的服务器对象。 paths: &amp;lt;Object&amp;gt; # 必须的。API 的可用路径及其操作。文档中内容最多的字段 components: &amp;lt;Object&amp;gt; # An element to hold various schemas for the specification.</description></item><item><title>Swagger 工具</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/Swagger-%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/Swagger-%E5%B7%A5%E5%85%B7/</guid><description>参考：官方工具列表
Swagger 衍生出来的一系列项目和工具，就可以做到生成各种格式的接口文档，生成多种语言的客户端和服务端的代码，以及在线接口调试页面等等。这样，如果按照新的开发模式，在开发新版本或者迭代版本的时候，只需要更新 Swagger 描述文件，就可以自动生成接口文档和客户端服务端代码，做到调用端代码、服务端代码以及接口文档的一致性。
Swagger UI 参考：官网
Swagger UI allows anyone — be it your development team or your end consumers — to visualize and interact with the API’s resources without having any of the implementation logic in place. It’s automatically generated from your OpenAPI (formerly known as Swagger) Specification, with the visual documentation making it easy for back end implementation and client side consumption.
Swagger UI 允许任何人（无论您是开发团队还是最终用户）都可以可视化 API 资源并与之交互，而无需任何实现逻辑。它是根据您的 OpenAPI（以前称为 Swagger）规范自动生成的，具有可视化文档，可简化后端实现和客户端使用。</description></item><item><title>Swagger 介绍</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/Swagger-%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/Swagger-%E4%BB%8B%E7%BB%8D/</guid><description>概述 参考：
官网 Swagger 相关工具 Swagger 有两种含义
Swagger Specification(规范) # 用于描述现代 API 的行业标准，已被广泛采用。 规范就是用 JSON 或 YAML 来描述的一组 API。 Swagger ToolsSet(工具集) # 实现 Swagger 规范 的一系列工具的集合。 Swagger 衍生出来的一系列工具，可以做到生成各种格式的接口文档，生成多种语言的客户端和服务端的代码，以及在线接口调试页面等等 注意：Swagger 规范已于 2015 年捐赠给 Linux 基金会后改名为 OpenAPI，并定义最新的规范为 OpenAPI 3.0。
所以，3.0 之前的规范，准确来说叫 Swagger 1.0、 Swagger 2.0，而 Swagger 3.0 就应该称为 OpenAPI 3.0 了 所以现在，Swagger 这个词语，更多的是用来描述一系列工具的合集。借助 Swagger 开源和专业工具集，为用户，团队和企业简化 API 开发。
Swagger 背景
随着互联网技术的发展，现在的网站架构基本都是由原来的后端渲染，变成了前端渲染、前后端分离的形式，而且前端技术和后端技术在各自的道路上越走越远。前后端的唯一联系，变成了 API 接口；API 文档变成了前后端开发人员联系的纽带。最早的时候，大家都是手写 API 文档的，在什么地方写的都有，有的在 confluence 上、有的直接在项目的 README.md 文件中写。并且，每个项目的写法、格式都不一样。
此时，就出现问题了，大家都需要写 API、用 API，那么何不出台一个规范，来规范所有项目的 API 文档的写法规范。这就是 Swagger 的由来。</description></item></channel></rss>