<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – API</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/</link><description>Recent content in API on 断念梦</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: API</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/API/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/API/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://en.wikipedia.org/wiki/API">wiki，API&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Application Programming Interface(应用程序接口，简称 API)&lt;/strong>。它定义了可以进行的调用或请求的类型，如何进行调用，应使用的数据格式，遵循的约定等。它还可以提供扩展机制，以便用户可以通过各种方式扩展现有功能。在不同程度上。[1] API 可以是完全自定义的，特定于组件的，也可以基于行业标准设计以确保互操作性。通过&lt;a href="https://en.wikipedia.org/wiki/Information_hiding">信息隐藏&lt;/a>，API 支持&lt;a href="https://en.wikipedia.org/wiki/Modular_programming">模块化编程&lt;/a>，从而使用户可以独立于实现使用接口。&lt;/p>
&lt;h2 id="目的">目的&lt;/h2>
&lt;p>在构建应用程序时，API（应用程序编程接口）通过抽象化底层实现并仅公开开发人员需要的对象或动作来简化编程。电子邮件客户端的图形界面可能会为用户提供执行获取和突出显示新电子邮件的所有步骤的按钮，而用于文件输入/输出的 API 可能会为开发人员提供一种将文件从一个位置复制到另一个位置的功能，而无需要求开发人员了解幕后发生的文件系统操作。[2]&lt;/p>
&lt;h2 id="术语的历史">术语的历史&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/folw44/1616163705351-3d45137b-c5db-4656-839f-5fa583e353e3.png" alt="">&lt;/p>
&lt;p>1978 年的一张图建议将 API 的概念扩展为一个通用的编程接口，而不仅仅是应用程序。[3]&lt;/p>
&lt;p>“ &lt;em>API&lt;/em> ”一词的含义已经扩展了其历史。首先，它仅描述了面向面向最终用户的程序（称为应用程序）的接口。此起源仍反映在名称“应用程序编程接口”中。如今，术语 API 的范围更广，不仅包括实用程序软件，甚至包括硬件接口。[4]&lt;/p>
&lt;p>API 的概念比该术语要古老得多。英国计算机科学家 Wilkes 和 Wheeler 在 1940 年代为 EDSAC 计算机开发了模块化软件库。约书亚·布洛赫（Joshua Bloch）声称威尔克斯和惠勒（Wilker and Wheeler）“潜在地发明”了该 API，因为它更多地是被发现而不是被发明的概念。[4]&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/folw44/1616163705346-76236d7f-ccd5-42d5-81dd-04fdda266f7a.jpeg" alt="">&lt;/p>
&lt;p>尽管创造 API 一词的人是在 Univac 1108 上实现软件，但他们的 API 的目标是使独立于硬件的程序成为可能。[5]&lt;/p>
&lt;p>术语“应用程序接口”（没有_-ing_后缀）首先被记录在称为纸张_数据结构和技术对于远程计算机图形_在呈现 AFIPS 在 1968 年会议[6] [4]所述的本文使用的作者该术语描述应用程序（在这种情况下为图形程序）与计算机系统其余部分的交互。一致的应用程序接口（包括 Fortran 子例程调用）旨在使程序员摆脱处理图形显示设备的特性，并在更换计算机或显示器时提供硬件独立性。[5]&lt;/p>
&lt;p>术语被引入到的场数据库由 CJ 日期[7]中称为 1974 纸_的关系和网络途径：应用程序编程接口的比较_。[8] API 成为用于数据库管理系统的 ANSI / SPARC 框架的一部分。该框架将应用程序编程接口与其他接口（例如查询接口）分开对待。1970 年代的数据库专业人员发现，这些不同的接口可以组合在一起。一个足够丰富的应用程序接口也可以支持其他接口。[3]&lt;/p>
&lt;p>这种观察导致 API 支持所有类型的编程，而不仅是应用程序编程。到 1990 年，API 被技术专家 Carl Malamud 定义为“程序员可以用来执行某些任务的一组服务” 。[9]&lt;/p>
&lt;p>随着 Web API 的出现，API 的概念再次得到扩展。罗伊·菲尔丁（Roy Fielding）的论文《_建筑风格》和_2000 年在加州大学欧文分校（UC Irvine）_的基于网络的软件体系结构设计_概述了代表性状态转移（REST），并描述了“菲林丁”与传统的“图书馆应用程序接口”的“基于网络的应用程序编程接口”的概念。基于”的 API。[10] XML 和 JSON Web API 于 2000 年开始得到广泛的商业采用，并一直持续到 2020 年。&lt;/p>
&lt;p>现在，Web API 是术语 API 的最常见含义。[11]以这种方式使用时，术语“ API”与术语“通信协议”和“远程过程调用”在含义上有一些重叠。&lt;/p>
&lt;h2 id="用法">用法&lt;/h2>
&lt;h3 id="库和框架">库和框架&lt;/h3>
&lt;p>API 通常与软件库有关。当库是这套规则的“实际实现”时，API 描述并规定了“预期行为”（一种规范）。&lt;/p>
&lt;p>单个 API 可以采用共享同一编程接口的不同库的形式进行多种实现（或者没有一种实现是抽象的）。&lt;/p>
&lt;p>将 API 与实现分开，可以允许以一种语言编写的程序使用以另一种语言编写的库。例如，由于 Scala 和 Java 可以编译为兼容的字节码，因此 Scala 开发人员可以利用任何 Java API。[12]&lt;/p>
&lt;p>API 的使用取决于所涉及的编程语言的类型。诸如 Lua 之类的过程语言的 API 可以主要由执行代码，操纵数据或处理错误的基本例程组成，而诸如 Java 之类的面向对象语言的 API 则可以提供类及其类方法的规范。[13] [14]&lt;/p>
&lt;p>语言绑定也是 API。通过将一种语言的特性和功能映射到以另一种语言实现的接口，语言绑定允许在以另一种语言进行开发时使用以一种语言编写的库或服务。[15]诸如 SWIG 和 F2PY（一种从 Fortran 到 Python 的接口生成器）之类的工具有助于创建此类接口。[16]&lt;/p>
&lt;p>API 也可以与软件框架相关：框架可以基于实现了多个 API 的多个库，但是与 API 的正常使用不同，对框架内建行为的访问是通过使用新类扩展其内容来实现的插入框架本身。&lt;/p>
&lt;p>而且，整个控制程序流程可以通过控制反转或类似的机制而不受调用者的控制，而不受框架的控制。[17] [18]&lt;/p>
&lt;h3 id="操作系统">操作系统&lt;/h3>
&lt;p>API 可以指定应用程序和操作系统之间的接口。[19] 例如，POSIX 指定一组通用 API，这些 API 旨在使为 POSIX 兼容操作系统编写的应用程序能够为另一个 POSIX 兼容操作系统编译。&lt;/p>
&lt;p>Linux 和 Berkeley 软件发行版是实现 POSIX API 的操作系统的示例。[20]&lt;/p>
&lt;p>Microsoft 已显示出对向后兼容 API 的坚定承诺，尤其是在其 Windows API（Win32）库中，因此较旧的应用程序可以使用称为“兼容模式”的可执行程序特定设置在新版 Windows 上运行。[21]&lt;/p>
&lt;p>API 与应用程序二进制接口（ABI）的不同之处在于，API 是基于源代码的，而 ABI 是基于二进制的。例如，POSIX 提供 API，而 Linux Standard Base 提供 ABI。&lt;/p>
&lt;h3 id="远程-api">远程 API&lt;/h3>
&lt;p>远程 API 允许开发人员通过协议（特定于通信的标准）来操纵远程资源，该协议允许不同的技术一起工作，而不论语言或平台如何。例如，Java 数据库连接 API 允许开发人员使用相同的功能集查询许多不同类型的数据库，而 Java 远程方法调用 API 使用 Java 远程方法协议来允许调用可远程操作但在本地运行的功能开发人员。[24] [25]&lt;/p>
&lt;p>因此，远程 API 对于维护面向对象程序设计中的对象抽象很有用。在代理对象上本地执行的方法调用，使用远程协议在远程对象上调用相应的方法，并获取要在本地用作返回值的结果。&lt;/p>
&lt;p>代理对象的修改也将导致远程对象的相应修改。[26]&lt;/p>
&lt;h3 id="web-api">Web API&lt;/h3>
&lt;p>主要文章：Web API&lt;/p>
&lt;p>Web API 是企业和使用其资产的应用程序之间进行交互的已定义接口，这也是服务水平协议（SLA），用于指定功能提供者并为其 API 用户公开服务路径或 URL。API 方法是一种体系结构方法，它围绕为服务于不同类型消费者的不同应用程序提供一组服务的程序接口而发展。[27]&lt;/p>
&lt;p>当在 Web 开发的上下文中使用 API 时，通常将其定义为一组规范，例如超文本传输协议（HTTP）请求消息以及响应消息的结构定义，通常以可扩展标记语言（XML））或 JavaScript 对象符号（JSON）格式。例如运输公司的 API，可以将其添加到以电子商务为中心的网站上，以方便订购运输服务，并自动包括当前的运输价格，而站点开发人员不必在网络数据库中输入运输者的价格表。尽管“ Web API”在历史上实际上是 Web 服务的代名词，但最近的趋势（所谓的 Web 2.0）已从基于简单对象访问协议（SOAP）的 Web 服务和面向服务的体系结构（SOA）转向更直接的表示状态转移（REST）样式的 Web 资源和面向资源的体系结构（ROA）。[28]这种趋势的一部分与语义 Web 向资源描述框架（RDF）的发展有关，RDF 是一种促进基于 Web 的本体工程技术的概念。Web API 允许将多个 API 组合到称为 mashup 的新应用程序中。[29] 在社交媒体领域，Web API 使 Web 社区可以促进在社区和应用程序之间共享内容和数据。这样，可以将在一个地方动态创建的内容发布并更新到 Web 上的多个位置。[30]例如，Twitter 的 REST API 允许开发人员访问 Twitter 的核心数据，而 Search API 为开发人员提供了与 Twitter 搜索和趋势数据进行交互的方法。[31]&lt;/p>
&lt;h2 id="设计">设计&lt;/h2>
&lt;p>API 的设计对其使用有重大影响。[2]信息隐藏的原理将编程接口的作用描述为通过隐藏模块的实现细节来实现模块化编程，从而使模块用户无需了解模块内部的复杂性。[32]因此，API 的设计试图仅提供用户期望的工具。[2]编程接口的设计是软件体系结构的重要组成部分，是复杂软件的组织。[33]&lt;/p>
&lt;h2 id="发布政策">发布政策&lt;/h2>
&lt;p>API 是技术公司更常见的集成方式之一。提供和使用 API 的组件被视为业务生态系统的成员。[34]&lt;/p>
&lt;p>发布 API 的主要策略是：[35]&lt;/p>
&lt;ul>
&lt;li>
&lt;p>私有：该 API 仅供内部公司使用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>合作伙伴：只有特定的业务合作伙伴可以使用 API。例如，Uber 和 Lyft 等租用公司的车辆允许经过批准的第三方开发人员直接在其应用程序内订购游乐设施。这使公司可以通过选择哪些应用程序可以访问 API 来进行质量控制，并为其提供额外的收入来源。[36]&lt;/p>
&lt;/li>
&lt;li>
&lt;p>公开：该 API 供公众使用。例如，Microsoft 公开了 Windows API，Apple 发行了其 API Cocoa，因此可以为其平台编写软件。通常，并非所有人都能访问所有公共 API。例如，Cloudflare 或 Voxility 等 Internet 服务提供商使用 RESTful API，以允许客户和转售商访问其基础结构信息，DDoS 统计信息，网络性能或仪表板控件。[37]可以通过“ API 令牌”或客户身份验证来授予对此类 API 的访问权限。[38]&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="公共-api-的含义">公共 API 的含义&lt;/h3>
&lt;p>API 公开时的重要因素是其“接口稳定性”。对 API 的更改（例如，向函数调用添加新参数）可能会破坏与依赖该 API 的客户端的兼容性。[39]&lt;/p>
&lt;p>当公开展示的 API 的某些部分可能发生更改并因此不稳定时，应将特定 API 的这些部分明确记录为“不稳定”。例如，在 Google Guava 库中，被视为不稳定的部分或可能即将更改的部分都标有 Java 注释 &lt;code>@Beta&lt;/code>。[40]&lt;/p>
&lt;p>公共 API 有时可以声明其自身的某些部分_已弃用_或废除。这通常意味着应将 API 的一部分视为要删除或以向后不兼容的方式进行修改的候选对象。因此，这些更改使开发人员可以脱离 API 的某些部分，这些部分将来将被删除或不再受支持。[41]&lt;/p>
&lt;p>客户端代码可能包含 API 设计人员不打算使用的创新用法或机会用法。换句话说，对于具有大量用户基础的库，当元素成为公共 API 的一部分时，可以多种方式使用它。[42] 2020 年 2 月 19 日，Akamai 发布了他们的年度“互联网状况”报告，展示了针对全球金融服务中针对公共 API 平台的网络犯罪分子的增长趋势。从 2017 年 12 月到 2019 年 11 月，Akamai 见证了 854.2 亿次凭证违规攻击。大约 20％（即 165.5 亿）与定义为 API 端点的主机名相对。其中，4.735 亿针对金融服务部门组织。[43]&lt;/p>
&lt;h2 id="文档">文档&lt;/h2>
&lt;p>API 文档描述了 API 提供的服务以及如何使用这些服务，旨在涵盖客户出于实际目的需要了解的所有内容。&lt;/p>
&lt;p>文档对于使用 API 开发和维护应用程序至关重要。[44] API 文档通常在文档文件中找到，但也可以在社交媒体（例如博客，论坛和问答网站）中找到。[45]&lt;/p>
&lt;p>传统的文档文件通常通过具有一致外观和结构的文档系统（例如 Javadoc 或 Pydoc）来呈现。但是，文档中包含的内容类型因 API 而异。[46]&lt;/p>
&lt;p>为了清楚起见，API 文档可能包括对 API 中的类和方法的描述以及“典型的使用场景，代码段，设计原理，性能讨论和合同”，但是 API 服务本身的实现细节通常是省略。&lt;/p>
&lt;p>该文档还涵盖了如何使用 API 的限制和限制。例如，对于一个 API 函数文档可以注意到，它的参数不能为 null，该函数本身没有线程安全的，[47]因为 API 文档往往是全面的，它是作家保持更新文档和挑战用户仔细阅读它，可能会产生错误。[39]&lt;/p>
&lt;p>API 文档可以使用 Java 注释之类的元数据信息来丰富。编译器，工具和_运行时_环境可以使用此元数据来实现自定义行为或自定义处理。[48]&lt;/p>
&lt;p>可以以数据驱动的方式生成 API 文档。通过观察使用给定 API 的许多程序，可以推断出典型用法以及所需的合同和指令。[49]然后，可以使用模板从挖掘的数据生成自然语言。&lt;/p></description></item><item><title>Docs: GraphQL</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/GraphQL/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/GraphQL/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/ao7ry12KLyOxGHG3SRNthQ">公众号-K8S中文社区，我为什么要放弃 RESTful，选择拥抱 GraphQL&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>REST作为一种现代网络应用非常流行的软件架构风格，自从Roy Fielding博士在2000年他的博士论文中提出来到现在已经有了20年的历史。它的简单易用性，可扩展性，伸缩性受到广大Web开发者的喜爱。&lt;/p>
&lt;p>REST 的 API 配合JSON格式的数据交换，使得前后端分离、数据交互变得非常容易，而且也已经成为了目前Web领域最受欢迎的软件架构设计模式。&lt;/p>
&lt;p>但随着REST API的流行和发展，它的缺点也暴露了出来：&lt;/p>
&lt;ul>
&lt;li>滥用REST接口 ，导致大量相似度很高（具有重复性）的API越来越冗余。&lt;/li>
&lt;li>对于前端而言：REST API粒度较粗 ，难以一次性符合前端的数据要求，前端需要分多次请求接口数据。增加了前端人员的工作量。&lt;/li>
&lt;li>对于后端而言：前端需要的数据往往在不同的地方具有相似性，但却又不同 ，比如针对同样的用户信息，有的地方只需要用户简要信息（比如头像、昵称），有些地方需要详细的信息，这就需要开发不同的接口来满足这些需求。当这样的相似但又不同的地方多的时候，就需要开发更多的接口来满足前端的需要。增加了后端开发人员的工作量和重复度。&lt;/li>
&lt;/ul>
&lt;p>那我们来分析一下，当前端需求变化，涉及到改动旧需求时 ，会有以下这些情况：&lt;/p>
&lt;p>做加法：&lt;/p>
&lt;p>产品需求增加，页面需要增加功能，数据也就相应的要增加显示，那么REST接口也需要做增加，这种无可厚非。&lt;/p>
&lt;p>做减法：&lt;/p>
&lt;p>产品需求减少，页面需要减少功能，或者减少某些信息显示，那么数据就要做减法。&lt;/p>
&lt;p>一种通常懒惰的做法是，前端不与后端沟通，仅在前端对数据选择性显示。&lt;/p>
&lt;p>因为后端接口能够满足数据需要，仅仅是在做显示的时候对数据进行了选择性显示，但接口的数据是存在冗余的，这种情况一个是存在数据泄露风险，另外就是数据量过大时造成网络流量过大，页面加载缓慢，用户流量费白白消耗，用户体验就会下降。&lt;/p>
&lt;p>另外一种做法就是告知后端，要么开发新的接口，要么，修改旧接口，删掉冗余字段。&lt;/p>
&lt;p>但一般来说，开发新接口往往是后端开发人员会选择的方案，因为这个方案对现有系统的影响最低，不会有额外的风险。&lt;/p>
&lt;p>修改旧接口删除冗余数据的方案往往开发人员不会选择，这是为什么呢？&lt;/p>
&lt;p>这就涉及到了系统的稳定性问题了，旧接口往往不止是一个地方在用，很有可能很多页面、设置不同客户端、不同服务都调用了这个接口获取数据，不做详细的调查，是不可能知道到底旧接口被调用了多少次，一旦改动旧接口，涉及范围可能非常大，往往会引起其他地方出现崩溃。改动旧接口成本太高，所以往往不会被采取。&lt;/p>
&lt;p>同时做加减法：&lt;/p>
&lt;p>既有加法，又有减法，其实这种就跟新需求没啥区别，前端需要重做页面，后端需要新写接口满足前端需要，但是旧接口还是不能轻举妄动（除非确定只有这一处调用才可以删除）。&lt;/p>
&lt;p>往往这个时候，其实用到的数据大多都是来自于同一个DO或者DTO，不过是在REST接口组装数据时，用不同的VO来封装不同字段，或者，使用同样的VO，组装数据时做删减。&lt;/p>
&lt;p>看到这些问题是不是觉得令人头大？&lt;/p>
&lt;p>所以需求频繁改动是万恶之源 ，当产品小哥哥改动需求时，程序员小哥哥可能正提着铁锹赶来&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>那么有没有一种方案或者框架，可以使得在用到同一个领域模型（DO或者DTO）的数据时，前端对于这个模型的数据字段需求的改动，后端可以根据前端的改动和需要，自动适配，自动组装需要的字段，返回给前端呢？如果能这样做的话，那么后端程序猿小哥可能要开心死了，前端妹子也不用那么苦口婆心地劝说后端小哥哥了。所以&lt;strong>GraphQL&lt;/strong>隆重出世了！那么问题来了！&lt;/p>
&lt;h2 id="part-1-what-is-graphql">Part 1 What is GraphQL&lt;/h2>
&lt;h3 id="graphql简介">GraphQL简介&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>GraphQL是一种新的API标准，它提供了一种比REST更有效、更强大和更灵活的替代方案。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>它是由Facebook开发并开源的，现在由来自世界各地的公司和个人组成的大型社区维护。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>GraphQL本质上是一种基于api的查询语言，现在大多数应用程序都需要从服务器中获取数据，这些数据存储可能存储在数据库中，API的职责是提供与应用程序需求相匹配的存储数据的接口。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>它是数据库无关的，而且可以在使用API的任何环境中有效使用，我们可以理解为GraphQL是基于API之上的一层封装，目的是为了更好，更灵活的适用于业务的需求变化。简单的来说，它&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJJicticxjdRnm4GpRCWqib0zbUaxuLl7OlRqo9T45Ka0MMC5JqIWGnd5MA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>它的工作模式是这样子的：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJmgPRfF4BOAHuRYtyiapUMVfEeHicA8OY4H1aUQHse8rOX5KicHSJxia0aA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;h3 id="graphql-对比-rest-api-有什么好处">GraphQL 对比 REST API 有什么好处？&lt;/h3>
&lt;p>&lt;strong>REST API 的接口灵活性差、接口操作流程繁琐，GraphQL 的声明式数据获取，使得接口数据精确返回，数据查询流程简洁，照顾了客户端的灵活性。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>客户端拓展功能时要不断编写新接口（依赖于服务端），GraphQL 中一个服务仅暴露一个 GraphQL 层，消除了服务器对数据格式的硬性规定，客户端按需请求数据，可进行单独维护和改进。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>REST API 基于HTTP协议，不能灵活选择网络协议，而传输层无关、数据库技术无关使得 GraphQL 有更加灵活的技术栈选择，能够实现在网络协议层面优化应用。&lt;/strong>&lt;/p>
&lt;p>举个经典的例子：前端向后端请求一个book对象的数据及其作者信息。我用动图来分别演示下REST和GraphQL是怎么样的一个过程。先看REST API的做法：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_gif/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJX9ogCWNfB0Ync50unNEM23nMXOs2b67VXBHAFXNW9lUkah2znfpa9Q/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1" alt="">&lt;/p>
&lt;p>再来看GraphQL是怎么做的：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_gif/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJAP4uUPiarZwUZ7VuMdKbkSoMzflASr8kVqWnuwicicLZGULBiadIlHN4Ew/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1" alt="">&lt;/p>
&lt;p>可以看出其中的区别：&lt;/p>
&lt;p>与REST多个endpoint不同，每一个的 GraphQL 服务其实对外只提供了一个用于调用内部接口的端点，所有的请求都访问这个暴露出来的唯一端点。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJeRA5MAm6C9jN2KnxuYEXNEUazialS1fiaKibTWve6GwdLUmiaxFQFhtE1Q/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJLNUQCiadzw03HAOMHBphX41iaW4tib44sGAuGnVqXPS7Yrfia8uJ1Cr0nw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>实际上将多个 HTTP 请求聚合成了一个请求，将多个 restful 请求的资源变成了一个从根资源 POST 访问其他资源的 Comment 和 Author 的图，多个请求变成了一个请求的不同字段，从原有的分散式请求变成了集中式的请求，因此GraphQL又可以被看成是图数据库的形式。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJ5qGb1kwhMhibTIMmPMAvwxUZ3FZ7iaDKnmFdAT6aGkXTawb90aD9lKkw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>那我们已经能看到GraphQL的先进性，接下来看看它是怎么做的。&lt;/p>
&lt;h3 id="graphql-思考模式">GraphQL 思考模式&lt;/h3>
&lt;p>使用GraphQL接口设计获取数据需要三步：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_gif/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJDBibHF529ic6dPNHPNVJq6V3zLmolRf4aMsutLZfuV01VYt7mfGVzW4g/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1" alt="">&lt;/p>
&lt;p>GraphQL获取数据三步骤:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>首先要设计数据模型，用来描述数据对象，它的作用可以看做是VO，用于告知GraphQL如何来描述定义的数据，为下一步查询返回做准备；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>前端使用模式查询语言（Schema）来描述需要请求的数据对象类型和具体需要的字段（称之为声明式数据获取）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>后端GraphQL通过前端传过来的请求，根据需要，自动组装数据字段，返回给前端。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>GraphQL的这种思考模式是不是完美解决了之前遇到的问题呢？先总结它的好处：&lt;/p>
&lt;p>在它的设计思想中，GraphQL 以图的形式将整个 Web 服务中的资源展示出来，客户端可以按照其需求自行调用，类似添加字段的需求其实就不再需要后端多次修改了。&lt;/p>
&lt;p>创建GraphQL服务器的最终目标是：允许查询通过图和节点的形式去获取数据。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJZCXezQJic1hcI0ZMib0JNUw5HcveZkqyiatnBxAubHFZgV1jEkk3ib8dZQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;h3 id="graphql执行逻辑">GraphQL执行逻辑&lt;/h3>
&lt;p>有人会问：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>使用了GraphQL就要完全抛弃REST了吗？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>GraphQL需要直接对接数据库吗？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用GraphQL需要对现有的后端服务进行大刀阔斧的修改吗？答案是：NO！不需要！&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>它完全可以以一种不侵入的方式来部署，将它作为前后端的中间服务，也就是，现在开始逐渐流行的 前端 —— 中端 —— 后端 的三层结构模式来部署！&lt;/p>
&lt;p>那就来看一下这样的部署模式图：&lt;/p>
&lt;p>！[]&lt;/p>
&lt;p>也就是说，完全可以搭建一个GraphQL服务器，专门来处理前端请求，并处理后端服务获取的数据，重新进行组装、筛选、过滤，将完美符合前端需要的数据返回。&lt;/p>
&lt;p>新的开发需求可以直接就使用GraphQL服务来获取数据了，以前已经上线的功能无需改动，还是使用原有请求调用REST接口的方式，最低程度的降低更换GraphQL带来的技术成本问题！&lt;/p>
&lt;p>如果没有那么多成本来支撑改造，那么就不需要改造！&lt;/p>
&lt;p>只有当原有需求发生变化，需要对原功能进行修改时，就可以换成GraphQL了。&lt;/p>
&lt;h3 id="graphql应用的基本架构">GraphQL应用的基本架构&lt;/h3>
&lt;p>下图是一个 GraphQL 应用的基本架构，其中客户端只和 GraphQL 层进行 API 交互，而 GraphQL 层再往后接入各种数据源。这样一来，只要是数据源有的数据， GraphQL 层都可以让客户端按需获取，不必专门再去定接口了。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJDcicPXRUubfOZ5maVmkrRicpAeuMfIQzTAPeBvzgQFA2apicibUJAwsaQw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>一个GraphQL服务仅暴露一个 GraphQL Endpoint，可以按照业务来进行区分，部署多个GraphQL服务，分管不同的业务数据，这样就可以避免单服务器压力过大的问题了。&lt;/p>
&lt;h3 id="graphql特点总结">GraphQL特点总结&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>声明式数据获取（可以对API进行查询）: 声明式的数据查询带来了接口的精确返回，服务器会按数据查询的格式返回同样结构的 JSON 数据、真正照顾了客户端的灵活性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一个微服务仅暴露一个 GraphQL 层：一个微服务只需暴露一个GraphQL endpoint，客户端请求相应数据只通过该端点按需获取，不需要再额外定义其他接口。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>传输层无关、数据库技术无关：带来了更灵活的技术栈选择，比如我们可以选择对移动设备友好的协议，将网络传输数据量最小化，实现在网络协议层面优化应用。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="part-2-schema--type">Part 2 Schema &amp;amp; Type&lt;/h2>
&lt;h3 id="graphql支持的数据操作">GraphQL支持的数据操作&lt;/h3>
&lt;p>GraphQL对数据支持的操作有：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>查询（Query）：获取数据的基本查询。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>变更（Mutation）：支持对数据的增删改等操作。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>订阅（Subscription）：用于监听数据变动、并靠websocket等协议推送变动的消息给对方。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_gif/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJkxCC9NmxBjgEBa4bzibYMoXMucQnzIiaKmTsmbicNra8yGjgr3aia1naCg/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1" alt="">&lt;/p>
&lt;h3 id="graphql的核心概念图表模式schema">GraphQL的核心概念：图表模式（Schema）&lt;/h3>
&lt;p>要想要设计GraphQL的数据模型，用来描述你的业务数据，那么就必须要有一套Schema语法来做支撑。&lt;/p>
&lt;p>想要描述数据，就必须离不开数据类型的定义。所以GraphQL设计了一套Schema模式（可以理解为语法），其中最重要的就是数据类型的定义和支持。&lt;/p>
&lt;p>那么类型（Type）就是模式（Schema）最核心的东西了。&lt;/p>
&lt;p>&lt;strong>什么是类型？&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对于数据模型的抽象是通过类型（Type）来描述的，每一个类型有若干字段（Field）组成，每个字段又分别指向某个类型（Type）。这很像Java、C#中的类（Class）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>GraphQL的Type简单可以分为两种，一种叫做Scalar Type(标量类型)，另一种叫做Object Type(对象类型)。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>那么就分别来介绍下两种类型。&lt;/p>
&lt;h3 id="标量类型scalar-type">标量类型（Scalar Type）&lt;/h3>
&lt;p>标量是GraphQL类型系统中最小的颗粒。类似于Java、C#中的基本类型。&lt;/p>
&lt;p>其中内建标量主要有：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>String&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Int&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Float&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Boolean&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Enum&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ID&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_gif/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJ8eklJCGsDwfM01Kcb5vQyBwAI4ygNuqB4PYkH28wD97nhkcG6W1ZRg/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1" alt="">&lt;/p>
&lt;p>上面的类型仅仅是GraphQL默认内置的类型，当然，为了保证最大的灵活性，GraphQL还可以很灵活的自行创建标量类型。&lt;/p>
&lt;h3 id="对象类型object-type">对象类型（Object Type）&lt;/h3>
&lt;p>仅有标量类型是不能满足复杂抽象数据模型的需要，这时候我们可以使用对象类型。&lt;/p>
&lt;p>通过对象模型来构建GraphQL中关于一个数据模型的形状，同时还可以声明各个模型之间的内在关联（一对多、一对一或多对多）。&lt;/p>
&lt;p>对象类型的定义可以参考下图：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJYnPDb5rbHRhUoCzUZ32JChX46B9A9C6c8etY0dHxTNeEBujSHfxAkg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>对象模型引入关联关系&lt;/p>
&lt;p>是不是很方便呢？我们可以像设计类图一样来设计GraphQL的对象模型。&lt;/p>
&lt;h3 id="类型修饰符type-modifier">类型修饰符（Type Modifier）&lt;/h3>
&lt;p>那么，类型系统仅仅只有类型定义是不够的，我们还需要对类型进行更广泛性的描述。&lt;/p>
&lt;p>类型修饰符就是用来修饰类型，以达到额外的数据类型要求控制。&lt;/p>
&lt;p>比如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>列表：[Type]&lt;/p>
&lt;/li>
&lt;li>
&lt;p>非空：Type!&lt;/p>
&lt;/li>
&lt;li>
&lt;p>列表非空：[Type]!&lt;/p>
&lt;/li>
&lt;li>
&lt;p>非空列表，列表内容类型非空：[Type!]!&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>在描述数据模型（模式Schema）时，就可以对字段施加限制条件。&lt;/p>
&lt;p>例如定义了一个名为User的对象类型，并对其字段进行定义和施加限制条件：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJ7TfFm8vPeicfpNDMfdBNia4QZyUdUXIHiaTEprVib7o5RZJfBHKLb5wIew/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>那么，返回数据时，像下面这种情况就是不允许的：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJNdC3YaGxiazN50gOBia3CjjW9zicHiaibfHzPibvnseLxtAxaYvk46GW1QIg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>Graphql会根据Schema Type来自动返回正确的数据：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJcLE4MbiaqhCgEkWaLPaHrolULibz7zEIsqtGslY2MLNQNnVE4XajdwzQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>正确的表示&lt;/p>
&lt;h3 id="其他类型">其他类型&lt;/h3>
&lt;p>除了上面的，Graphql还有一些其他类型来更好的引入面向对象的设计思想：&lt;/p>
&lt;p>接口类型（Interfaces）：其他对象类型实现接口必须包含接口所有的字段，并具有相同的类型修饰符，才算实现接口。&lt;/p>
&lt;p>比如定义了一个接口类型：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJ2h59oFHA2r9WQzmlCibU3mLRviap22dok1amNcB1zf9KrsCyibMZTBWaQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>那么就可以实现该接口：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJIepDverV4iaOlic3uIJ03Ym8a92PJLuB3jRA4pfLu32MjKHeTVcdDRqA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>联合类型（Union Types）：联合类型和接口十分相似，但是它并不指定类型之间的任何共同字段。几个对象类型共用一个联合类型。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJm5Ps5UYMMT5p9VvP06al6y8UyGPw1wv8iaZThPIrzhzXRDhw6O5BT7A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>输入类型（Input Types）：更新数据时有用，与常规对象只有关键字修饰不一样，常规对象时 type 修饰，输入类型是 input 修饰。&lt;/p>
&lt;p>比如定义了一个输入类型：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJrfy3scXveeLQibAGjcibkEFp7fILiarfTic464e2orlczuPZQh1TMuicxJg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>前端发送变更请求时就可以使用（通过参数来指定输入的类型）：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJOZGvNmchM1yyrZDuwIw3txdkfmh5vy8c6Coibk3ibul06icMtbJh3CiagQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>所以，这样面向对象的设计方式，真的对后端开发人员特别友好！而且前端MVVM框架流行以来，面向对象的设计思想也越来越流行，前端使用Graphql也会得心应手。&lt;/p>
&lt;h3 id="part-3-graphql技术接入架构">Part 3 GraphQL技术接入架构&lt;/h3>
&lt;h3 id="graphql-技术接入架构">Graphql 技术接入架构&lt;/h3>
&lt;p>那么，该怎么设计来接入我们现有的系统中呢？&lt;/p>
&lt;p>将Graphql服务直连数据库的方式：最简洁的配置，直接操作数据库能减少中间环节的性能消耗。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJPZSibb8jBn5JSSWJicYOGqWhAcr2oXIia9RrgiaBTPWhV23rx36P4eUw4g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>集成现有服务的GraphQL层：这种配置适合于旧服务的改造，尤其是在涉及第三方服务时、依然可以通过原有接口进行交互。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJ5Q4VGOTmutAwLPzNAYY5t41HibAMtkXtF56DdNbnKs0uSN0NNXqzSvA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>直连数据库和集成服务的混合模式：前两种方式的混合。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk56wvyQ3wR1jpaMISleicaNAJmpGDldVhrdSPN7gYXibFia5Ev0AgPV0FWs9xYwQibNPMWfibzp98Hct6Mw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>可以说是非常灵活了！你都不用担心会给你带来任何的麻烦。&lt;/p>
&lt;h2 id="part04graphql开源生态圈">PART04GraphQL开源生态圈&lt;/h2>
&lt;h3 id="服务端实现">服务端实现&lt;/h3>
&lt;p>在服务端， GraphQL 服务器可用任何可构建 Web 服务器的语言实现。有以下语言的实现供参考：&lt;/p>
&lt;p>C# / .NET、Clojure、Elixir、Erlang、Go、Groovy、Java、JavaScript、Julia、Kotlin、Perl、PHP、Python、R、Ruby、Rust、Scala、Swift&amp;hellip; 种类繁多，几乎流行的语言都有支持。&lt;/p>
&lt;h3 id="客户端实现">客户端实现&lt;/h3>
&lt;p>在客户端，Graphql Client目前有下面的语言支持：C# / .NET、Clojurescript、Elm、Flutter、Go、Java / Android、JavaScript、Julia、Swift / Objective-C、iOS、Python、R。覆盖了众多客户端设计语言，而其他语言的支持也在推进中。&lt;/p>
&lt;h3 id="graphql的一些服务">Graphql的一些服务&lt;/h3>
&lt;p>整理了下目前比较流行的服务框架：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Apollo Engine:一个用于监视 GraphQL 后端的性能和使用的服务。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Graphcool (github): 一个 BaaS（后端即服务），它为你的应用程序提供了一个 GraphQL 后端，且具有用于管理数据库和存储数据的强大的 web ui。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Tipe (github): 一个 SaaS（软件即服务）内容管理系统，允许你使用强大的编辑工具创建你 的内容，并通过 GraphQL 或 REST API 从任何地方访问它。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>AWS AppSync：完全托管的 GraphQL 服务，包含实时订阅、离线编程和同步、企业级安全特性以及细粒度的授权控制。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Hasura：一个 BaaS（后端即服务），允许你在 Postgres 上创建数据表、定义权限并使用 GraphQL 接口查询和操作。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="graphql的一些工具">Graphql的一些工具&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>graphiql (npm): 一个交互式的运行于浏览器中的 GraphQL IDE。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Graphql Language Service: 一个用于构建 IDE 的 GraphQL 语言服务（诊断、自动完成等） 的接口。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>quicktype (github): 在 TypeScript、Swift、golang、C#、C++ 等语言中为 GraphQL 查 询生成类型。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>转自：师兄睿谈&lt;/p>
&lt;p>链接：https://www.toutiao.com/article/6833818331884028419/&lt;/p>
&lt;hr></description></item><item><title>Docs: API 相关工具</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/API-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/API-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/</guid><description/></item><item><title>Docs: Mock API</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/Mock-API/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/Mock-API/</guid><description>
&lt;p>API 文档虽然满足了阅读者对接接口的需求，但是在 API 起初设计的过程中，通常需要等待几天、甚至数周时间才能实时调用接口，从而真正开始接口调试工作。&lt;/p>
&lt;p>而通过创建 Mock API，您即可提前交付模拟真实 API 响应的沙盒环境，以便 API 使用者提前开始调试工作，同时您也可以并行开发接口实现。&lt;/p>
&lt;p>此外，您也可以在设计过程中得到 API 使用者对 API 设计的及时反馈，并进行迭代以得到更好的 API。&lt;/p>
&lt;h3 id="什么是-mock-api">什么是 Mock API&lt;/h3>
&lt;p>Mock API Server 通过提供真实 API 响应的范例数据来模拟真实的 API 服务，它将部署在 CODING 提供的公网服务器上，并且支持路由及参数校验，且在此基础上可限制访问的 IP 或 Token 授权方式。&lt;/p>
&lt;blockquote>
&lt;p>目前 Mock API 支持静态模拟，即基于 API 响应范例的 Mock，暂不支持动态模拟（自定义数据模拟规则）。&lt;/p>
&lt;/blockquote>
&lt;h3 id="功能特性">功能特性&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>基于 API 文件数据生成 Mock API。您仅需完善 API 规则及范例，无需额外设置即可使用 Mock API。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Mock API 支持参数校验，并可在请求有误时返回响应错误信息。大大降低 API 使用者在对接 API 时的错误率，方便调试及跟踪。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>自定义 Mock API 响应数据。通过修改 API 范例数据，可让每个 API 的模拟数据趋于完美。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每篇文档 Mock API 均有独立域名，并支持 HTTPS / HTTP 双协议。方便统一配置，也方便记忆，地址参考：&lt;a href="http://c3wfvv32.mock.coding.iohttps://c3wfvv32.mock.coding.io">http://c3wfvv32.mock.coding.iohttps://c3wfvv32.mock.coding.io&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>支持 Token / IP 白名单授权方式。由于 Mock API 部署在公网，用户开启上述安全配置可有效防止他人随意调用 Mock API，掌握接口规则。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="使用场景">使用场景&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>API 对接/调试通常在公司项目中，API 使用者（如前端、App、自动化 API 测试开发人员）的开发进度会比后端 API 开发人员提前开始开发实现。而使用基于 API 文档的 Mock API 可提供模拟真实 API 响应的沙盒环境，以便 API 使用者提前开始调试工作。另一方面 API 使用者可以及时反馈 API 设计问题，在完成 API 实现之前提早完善 API 设计，使得 API 开发工作更加高效和趋于完美。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>API 测试当您需要对部分 API 进行统一测试时，您可以替换其他 API 为 Mock API，而无需关心其他依赖 API 是否满足测试条件。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>外部 API 服务通常外部 API 服务可能会有不可靠、收费、访问限制等情况，您也可以替换外部 API 服务为 Mock API，通过 Mock 外部 API 服务的真实数据来调试程序逻辑。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="使用工作流">使用工作流&lt;/h3>
&lt;ol>
&lt;li>设计阶段&lt;/li>
&lt;/ol>
&lt;p>API 参数/规范设计&lt;/p>
&lt;ul>
&lt;li>
&lt;p>OpenAPI：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在线编辑 Swagger 文件：&lt;a href="http://editor.swagger.io">http://editor.swagger.io&lt;/a>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Spring 框架编写 API 结构注解。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Postman：IDE 在线编辑。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>apiDoc：代码注释设计接口规范。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>生成范例数据&lt;/li>
&lt;/ol>
&lt;p>用于 Mock API 所需的 API 范例数据&lt;/p>
&lt;ul>
&lt;li>
&lt;p>OpenAPI：Swagger Editor 可自动通过参数生成 Example。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Postman：使用 Postman 内置 Mock Server，针对各 API 编写 Mock 数据规则，访问 Mock API 获取 Mock 数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>apiDoc：使用 &lt;a href="https://github.com/cdcabrera/apidoc-mock">https://github.com/cdcabrera/apidoc-mock&lt;/a> 搭建 Mock Server，然后请求各 Mock API 获取 Mock 数据。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>生成 Mock API&lt;/li>
&lt;/ol>
&lt;p>通过 CODING API 文档导入 API 文件并发布，自动更新 Mock API 规则及数据。&lt;/p></description></item><item><title>Docs: OpenAPI Tools</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/OpenAPI-Tools/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/OpenAPI-Tools/</guid><description>
&lt;p>参考：&lt;a href="https://github.com/OpenAPITools/openapi-generator">OpenAPI Generator&lt;/a>&lt;/p></description></item><item><title>Docs: OpenAPI 格式</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/OpenAPI-%E6%A0%BC%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/OpenAPI-%E6%A0%BC%E5%BC%8F/</guid><description>
&lt;p>参考：&lt;a href="http://spec.openapis.org/oas/v3.0.3">官方 v3.0.3 版本文档&lt;/a>&lt;/p>
&lt;h1 id="根字段">根字段&lt;/h1>
&lt;p>参考：&lt;a href="http://spec.openapis.org/oas/v3.0.3#fixed-fields">官方文档&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>openapi: &lt;!-- raw HTML omitted -->&lt;/strong> # &lt;strong>必须的&lt;/strong>。This string MUST be the semantic version number of the OpenAPI Specification version that the OpenAPI document uses. The openapi field SHOULD be used by tooling specifications and clients to interpret the OpenAPI document. This is not related to the API info.version string.&lt;/li>
&lt;li>&lt;strong>info: &lt;!-- raw HTML omitted -->&lt;/strong> # &lt;strong>必须的&lt;/strong>。Provides metadata about the API. The metadata MAY be used by tooling as required.&lt;/li>
&lt;li>&lt;strong>servers: &amp;lt;[]Object&amp;gt;&lt;/strong> # 一组可用的服务器，用于提供到目标服务器的连接信息。当我们测试 API 时，将会连接其中一个。如果未提供 servers 属性或为空数组，则默认值为 URL 值为/的服务器对象。&lt;/li>
&lt;li>&lt;strong>paths: &lt;!-- raw HTML omitted --> &lt;strong>#&lt;/strong> 必须的&lt;/strong>。API 的可用路径及其操作。&lt;strong>文档中内容最多的字段&lt;/strong>&lt;/li>
&lt;li>&lt;strong>components: &lt;!-- raw HTML omitted -->&lt;/strong> # An element to hold various schemas for the specification.&lt;/li>
&lt;li>&lt;strong>security: &amp;lt;[]Object&amp;gt;&lt;/strong> # A declaration of which security mechanisms can be used across the API. The list of values includes alternative security requirement objects that can be used. Only one of the security requirement objects need to be satisfied to authorize a request. Individual operations can override this definition. To make security optional, an empty security requirement ({}) can be included in the array.&lt;/li>
&lt;li>&lt;strong>tags: &amp;lt;[]Object&amp;gt;&lt;/strong> # A list of tags used by the specification with additional metadata. The order of the tags can be used to reflect on their order by the parsing tools. Not all tags that are used by the Operation Object must be declared. The tags that are not declared MAY be organized randomly or based on the tools’ logic. Each tag name in the list MUST be unique.&lt;/li>
&lt;li>&lt;strong>externalDocs: &lt;!-- raw HTML omitted -->&lt;/strong> # Additional external documentation.&lt;/li>
&lt;/ul>
&lt;h2 id="根字段示例">根字段示例&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">openapi&lt;/span>: &lt;span style="color:#ae81ff">3.0.1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">info&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">title&lt;/span>: &lt;span style="color:#ae81ff">Prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#ae81ff">v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">tags&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">查询接口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Prometheus 信息接口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">servers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;http://test-prometheus.desistdaydream.ltd/api/v1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;北京测试Prom&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">path&lt;/span>: &lt;span style="color:#ae81ff">......内容非常多，详见下文单独示例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">components&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">schemas&lt;/span>: {}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="server-字段">server 字段&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>url: &lt;!-- raw HTML omitted -->&lt;/strong> #** 必须的。**A URL to the target host. This URL supports Server Variables and MAY be relative, to indicate that the host location is relative to the location where the OpenAPI document is being served. Variable substitutions will be made when a variable is named in {brackets}.&lt;/li>
&lt;li>&lt;strong>description: &lt;!-- raw HTML omitted -->&lt;/strong> # An optional string describing the host designated by the URL. CommonMark syntax MAY be used for rich text representation.&lt;/li>
&lt;li>&lt;strong>variables: &amp;lt;map[string]Object&amp;gt;&lt;/strong> # A map between a variable name and its value. The value is used for substitution in the server’s URL template.&lt;/li>
&lt;/ul>
&lt;h1 id="paths-字段">paths 字段&lt;/h1></description></item><item><title>Docs: OpenAPI 介绍</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/OpenAPI-%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/OpenAPI-%E4%BB%8B%E7%BB%8D/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>参考：&lt;a href="https://www.openapis.org/">官网&lt;/a>、&lt;a href="https://github.com/OAI">GitHub 社区&lt;/a>、&lt;a href="https://swagger.io/">Swagger&lt;/a>&lt;/p>
&lt;p>&lt;strong>OpenAPI Initiative(开放应用程序接口倡议，简称 OAI)&lt;/strong>。是由具有前瞻性的行业专家联合创建的，他们认识到标准化 API 描述方式的巨大价值。作为 Linux 基金会下的开放治理结构，OAI 致力于创建、发展 和 推广供所有人可用的中立的描述格式。&lt;/p>
&lt;p>OAI 现阶段包含一个规范&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>OpenAPI Specification(简称 OAS)&lt;/strong> # 最初基于 SmartBear Software 捐赠的 Swagger 规范。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>OAS 可以描述为一个文件，可以描述为一个规范的内容。人们常常在不同场景下，不加区分得统一用 OAS 来描述。比如 Swagger Codegen 项目中的描述中。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>This is the Swagger Codegen project, which allows generation of API client libraries (SDK generation), server stubs and documentation automatically given an OpenAPI Spec.(这是 Swagger Codegen 项目，该项目允许在给定 OpenAPI 规范的情况下自动生成 API 客户端库（生成 SDK），服务器存根和文档。)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这里描述的&lt;code>指定的的 OpenAPI Spec&lt;/code> 就是指 OAS，也就是说，而已根据 OAS 文件来生成代码。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>OpenAPI &lt;strong>Specification&lt;/strong>&lt;/p>
&lt;p>参考：&lt;a href="http://spec.openapis.org/oas/v3.0.3">官方文档 v3.0.3&lt;/a>、&lt;a href="https://swagger.io/specification/">Swagger 官网上的 OAS 文档&lt;/a>、&lt;a href="https://github.com/OAI/OpenAPI-Specification">GitHub OAS 项目&lt;/a>&lt;/p>
&lt;p>&lt;strong>The OpenAPI Specification(开放应用程序接口规范，简称 OAS), 以前称为 Swagger 规范&lt;/strong>，是定义 &lt;strong>RESTful 风格接口&lt;/strong>的&lt;strong>世界标准&lt;/strong>。OAS 使开发人员能够设计与技术无关的 API 接口，从而构成其 API 开发和使用的基础。&lt;/p>
&lt;blockquote>
&lt;p>由于 OAS 是接着 Swagger 的，所以，OAS 最早的版本就是 3.0，所谓的 OAS 2.0 实际上是 Swagger 2.0。因为那时候 Swagger 还没有变为 OpenAPI&lt;/p>
&lt;/blockquote>
&lt;p>OAS 是 Linux 基金会合作项目 OpenAPI Initiative 中的一个社区驱动的开放规范。&lt;/p>
&lt;p>OpenAPI 规范（OAS）为 HTTP API 定义了标准的，与编程语言无关的接口描述，使人和计算机都可以发现和理解服务的功能，而无需访问源代码，其他文档或检查网络流量。通过 OpenAPI 正确定义后，使用者可以使用最少的实现逻辑来理解远程服务并与之交互。与接口描述针对低级编程所做的类似，OpenAPI 规范消除了调用服务时的猜测。&lt;/p>
&lt;p>机器可读的 API 定义文档的用例包括但不限于：交互式文档；文档，客户端和服务器的代码生成；和测试用例的自动化。OpenAPI 文档描述了 API 服务，并以 YAML 或 JSON 格式表示。这些文档可以静态生成和提供，也可以从应用程序动态生成。&lt;/p>
&lt;p>OpenAPI 规范不需要重写现有的 API。它不需要将任何软件绑定到服务-所描述的服务甚至可能不是其描述的创建者所拥有。但是，它确实需要在 OpenAPI 规范的结构中描述服务的功能。并非所有服务都可以用 OpenAPI 来描述-该规范并非旨在涵盖 HTTP API 的所有可能样式，而是包括对 REST API 的 支持。OpenAPI 规范没有规定特定的开发过程，例如设计优先或代码优先。通过与 HTTP API 建立清晰的交互，它确实有助于这两种技术。&lt;/p>
&lt;p>这个 GitHub 项目是 OpenAPI 的起点。在这里，您将找到有关 OpenAPI 规范所需的信息，其外观的简单示例以及有关该项目的一些常规信息。&lt;/p>
&lt;h2 id="最佳实践">最佳实践&lt;/h2>
&lt;p>通常，设计 API 规范有两个方向，Design-First（设计优先） 或 Code-First（编码优先）&lt;/p>
&lt;h3 id="design-first设计优先">Design-First(设计优先)&lt;/h3>
&lt;p>即优先设计 API 规范，设计完成后再着手进行代码开发工作。采用 Design-First 就意味着，将设计 API 路由、参数等工作提前，后续整个软件开发的流程都需要围绕着 API 规范为核心，当然这需要有一定的设计经验的开发人员才能胜任。Design-First 有很多好处：更多可参考：&lt;a href="https://swagger.io/blog/api-design/design-first-or-code-first-api-development">https://swagger.io/blog/api-design/design-first-or-code-first-api-development&lt;/a>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>提高开发效率。开发团队将根据 API 规范进行并行开发和对接工作，而无需等待接口逻辑开发完毕。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>降低接口开发的成本，无需修改代码逻辑即可轻松地修改 API 规范，因为 API 描述语言（如：OpenAPI）与编码语言无关&lt;/p>
&lt;/li>
&lt;li>
&lt;p>开发人员更加专注于设计 API 规范，对比 Code-First 可以描写更多 API 的细节，如：校验规则、范例数据等，同时开发人员对 API 的全局一致性、扩展性、规范性也有更好的把控。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在联调开发的过程中可以提前发现和解决问题，避免问题在开发完毕后修改的成本过高。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由于 API 描述更加标准化，可以方便做更多的 API 生态延伸，比如基于 API 规范生成 Mock API Server，开发 API 自动化测试代码，接入 API 网关等。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="code-first编码优先">Code-First(编码优先)&lt;/h3>
&lt;p>即通过代码中关于 API 描述特性、注解或注释自动生成 API 描述文件的设计方式，如：JAVA 生态的 SpringFox。适合倾向于在代码上编写 API 规范，通过自动化设施自动生成文档的团队。Code-First 的优点：虽然 Code-First 省去了开发者设计 API 描述文件的阶段，提高了 API 开发者的效率，但是从整个团队的角度来看，效率并不一定提升了，反而有可能降低了效率。不同 API 开发者的经验和习惯的不同，极有可能在编码的过程中对 API 的限制条件考虑不全，又或者框架生成 API 文档的程序完善度不够，种种因素导致最终生成的 API 的描述无法达到理想标准。而很多 API 开发者习惯开发完成后才推送代码，并生成 API 文档，也导致了团队的进程阻塞于此，拖后了整个团队的开发进程。另一方面，API 在开发完成如果没有测试，很有可能导致 API 对接者在对接的过程中遇到重重阻碍。CODING 也希望各位开发者重视 API 设计的重要性，如果您喜欢 Code-First 设计方向，我们的建议是：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>节省时间。对于 API 开发者，编码的同时可以获得一份满足基本要求的 API 文档。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>方便接入自动化 CI/CD 流程中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>选用完善程度比较高的生成组件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对 API 的描述尽可能的细致、完整&lt;/p>
&lt;/li>
&lt;li>
&lt;p>优先设计路由、请求、响应等规则，详细的逻辑代码在 API 设计完成后再着手开发。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Design-First 和 Code-First 针对不同的场景有着各自的优势，不同团队对两者考虑的方向也不同，但是对 API 描述的完善不管是哪个方向都是最重要的。&lt;/p></description></item><item><title>Docs: Swagger 工具</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/Swagger-%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/Swagger-%E5%B7%A5%E5%85%B7/</guid><description>
&lt;p>参考：&lt;a href="https://swagger.io/tools/open-source/open-source-integrations/">官方工具列表&lt;/a>&lt;/p>
&lt;p>Swagger 衍生出来的一系列项目和工具，就可以做到生成各种格式的接口文档，生成多种语言的客户端和服务端的代码，以及在线接口调试页面等等。这样，如果按照新的开发模式，在开发新版本或者迭代版本的时候，只需要更新 Swagger 描述文件，就可以自动生成接口文档和客户端服务端代码，做到调用端代码、服务端代码以及接口文档的一致性。&lt;/p>
&lt;h1 id="swagger-ui">Swagger UI&lt;/h1>
&lt;p>参考：&lt;a href="https://swagger.io/tools/swagger-ui/">官网&lt;/a>&lt;/p>
&lt;p>Swagger UI allows anyone — be it your development team or your end consumers — to visualize and interact with the API’s resources without having any of the implementation logic in place. It’s automatically generated from your OpenAPI (formerly known as Swagger) Specification, with the visual documentation making it easy for back end implementation and client side consumption.&lt;/p>
&lt;p>Swagger UI 允许任何人（无论您是开发团队还是最终用户）都可以可视化 API 资源并与之交互，而无需任何实现逻辑。它是根据您的 OpenAPI（以前称为 Swagger）规范自动生成的，具有可视化文档，可简化后端实现和客户端使用。&lt;/p>
&lt;h1 id="swagger-editor">Swagger Editor&lt;/h1>
&lt;p>参考：&lt;a href="https://swagger.io/tools/swagger-editor/">官网&lt;/a>、&lt;a href="https://editor.swagger.io/">官方在线编辑器&lt;/a>&lt;/p>
&lt;p>在第一个完全专用于基于 OpenAPI 的 API 的开源编辑器上设计，描述和记录您的 API。 Swagger 编辑器是使用 OpenAPI 规范（以前称为 Swagger）的简单方法，它支持 Swagger 2.0 和 OpenAPI 3.0。&lt;/p>
&lt;h1 id="swagger-codegen">Swagger Codegen&lt;/h1>
&lt;p>参考：&lt;a href="https://github.com/swagger-api/swagger-codegen">GitHub&lt;/a>&lt;/p>
&lt;h1 id="swagger-hub">Swagger Hub&lt;/h1>
&lt;p>参考：&lt;a href="https://swagger.io/tools/swaggerhub/">官网&lt;/a>&lt;/p>
&lt;p>类似于 Docker Hub，只不过可以存储 API 描述文件&lt;/p></description></item><item><title>Docs: Swagger 介绍</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/Swagger-%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/Swagger-%E4%BB%8B%E7%BB%8D/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://swagger.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://swagger.io/tools/open-source/open-source-integrations/">Swagger 相关工具&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Swagger 有两种含义&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Swagger Specification(规范)&lt;/strong> # 用于描述现代 API 的行业标准，已被广泛采用。
&lt;ul>
&lt;li>规范就是用 JSON 或 YAML 来描述的一组 API。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Swagger ToolsSet(工具集)&lt;/strong> # 实现 Swagger 规范 的一系列工具的集合。
&lt;ul>
&lt;li>Swagger 衍生出来的一系列工具，可以做到生成各种格式的接口文档，生成多种语言的客户端和服务端的代码，以及在线接口调试页面等等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>注意：Swagger 规范已于 2015 年捐赠给 Linux 基金会后改名为 OpenAPI，并定义最新的规范为 OpenAPI 3.0。&lt;/p>
&lt;blockquote>
&lt;p>所以，3.0 之前的规范，准确来说叫 Swagger 1.0、 Swagger 2.0，而 Swagger 3.0 就应该称为 OpenAPI 3.0 了
所以现在，Swagger 这个词语，更多的是用来描述一系列工具的合集。借助 Swagger 开源和专业工具集，为用户，团队和企业简化 API 开发。&lt;/p>
&lt;/blockquote>
&lt;p>Swagger 背景&lt;/p>
&lt;p>随着互联网技术的发展，现在的网站架构基本都是由原来的后端渲染，变成了前端渲染、前后端分离的形式，而且前端技术和后端技术在各自的道路上越走越远。前后端的唯一联系，变成了 API 接口；API 文档变成了前后端开发人员联系的纽带。最早的时候，大家都是手写 API 文档的，在什么地方写的都有，有的在 confluence 上、有的直接在项目的 README.md 文件中写。并且，每个项目的写法、格式都不一样。&lt;/p>
&lt;p>此时，就出现问题了，大家都需要写 API、用 API，那么何不出台一个规范，来规范所有项目的 API 文档的写法规范。&lt;strong>这就是 Swagger 的由来&lt;/strong>。&lt;/p>
&lt;p>Swagger 诞生于 2010 年，起初只是一个用于设计 RESTful 风格 API 的开源规范。为了更好得实现和可视化规范中定义得 API，还开发了诸如 Swagger UI、Swagger Editor、Swagger Codegen 等工具。由 Specification(规范) 和 Tools(工具) 组成的 Swagger 项目非常流行，并由此创造了一个庞大的社区驱动工具的生态系统。&lt;/p>
&lt;p>2015 年，Swagger 项目被 SmartBear 软件公司收购。其中 &lt;strong>Swagger Specification(Swagger 规范)&lt;/strong> 被捐赠给 Linux 基金会，并更名为 &lt;strong>OpenAPI&lt;/strong>。OpenAPI 继续致力于，正式规范 REST API 的描述方式。OpenAPI Initiative(倡议) 的创建则是为了以开放和透明的方式指导 &lt;strong>OpenAPI Specification(简称 OAS)&lt;/strong> 的开发。&lt;/p>
&lt;p>自此，Swagger 成为最受欢迎的工具套件，可以在整个 API 生命周期中充分利用 OAS 的力量。&lt;/p>
&lt;h1 id="swagger-与-openapi-的区别">Swagger 与 OpenAPI 的区别&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://smartbear.com/blog/what-is-the-difference-between-swagger-and-openapi/">SmartBear 博客&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>2017 年 OpenAPI 3.0 正式发布，这是 &lt;a href="https://www.openapis.org/blog/2017/07/26/the-oai-announces-the-openapi-specification-3-0-0">OpenAPI 规范 的第一个版本&lt;/a>。&lt;/p>
&lt;p>对于那些参与 API 开发的人来说，OAS 3.0 的发布是……很大的事情。&lt;/p>
&lt;p>为什么？该版本如此重要的最显着原因之一是，OpenAPI 3.0 是该规范的第一个正式版本，因为它是 &lt;a href="https://smartbear.com/news/news-releases/smartbear-launches-open-api-initiative-with-key-in/">由 SmartBear Software 捐赠给 OpenAPI Initiative&lt;/a>， 并在 2015 年从 Swagger 规范重命名为 OpenAPI 规范。&lt;/p>
&lt;p>在我们探讨 OpenAPI 3.0 对 API 空间如此重要的一些原因之前，首先必须弄清有关 OpenAPI 及其对 Swagger 的含义的一些问题，这一点很重要。&lt;/p>
&lt;p>在过去的两年中，关于从 Swagger 转换为 OpenAPI 的问题很多。而且，关于 OpenAPI 和 Swagger 之间的区别，何时使用一个名称代替另一个名称以及 OpenAPI 和 Swagger 之间的关系还有很多困惑。&lt;/p>
&lt;h2 id="让我们从澄清-swagger-与-openapi-开始">让我们从澄清 Swagger 与 OpenAPI 开始&lt;/h2>
&lt;p>理解差异的最简单方法是：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>OpenAPI = 规范&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Swagger = 实现规范的工具&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>OpenAPI 是规范的正式名称。该规范的开发是由 OpenAPI Initiative 推动的，该倡议涉及更多来自技术领域不同领域的 30 个组织-包括 Microsoft，Google，IBM 和 CapitalOne。领导 Swagger 工具开发的公司 Smartbear Software 也是 OpenAPI Initiative 的成员，帮助领导了规范的发展。&lt;/p>
&lt;p>Swagger 是与用于实现 OpenAPI 规范的一些最著名，使用最广泛的工具相关联的名称。Swagger 工具集包括开源工具，免费工具和商业工具的组合，可在 API 生命周期的不同阶段使用。&lt;/p>
&lt;p>这些工具包括：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Swagger 编辑器&lt;/strong>：使用 Swagger 编辑器，您可以在浏览器内的 YAML 中编辑 OpenAPI 规范，并实时预览文档。&lt;/li>
&lt;li>&lt;strong>Swagger UI：&lt;/strong> Swagger UI 是 HTML，Javascript 和 CSS 资产的集合，这些资产通过符合 OAS 的 API 动态生成精美的文档。&lt;/li>
&lt;li>&lt;strong>Swagger Codegen：&lt;/strong> 允许在给定 OpenAPI 规范的情况下自动生成 API 客户端库（SDK 生成），服务器存根和文档。&lt;/li>
&lt;li>&lt;strong>Swagger Parser：&lt;/strong> 用于从 Java 解析 OpenAPI 定义的独立库&lt;/li>
&lt;li>&lt;strong>Swagger Core：&lt;/strong> 与 Java 相关的库，用于创建，使用和使用 OpenAPI 定义&lt;/li>
&lt;li>&lt;strong>Swagger Inspector（免费）&lt;/strong> ：API 检查工具，可让您从现有 API 生成 OpenAPI 定义&lt;/li>
&lt;li>&lt;strong>SwaggerHub（免费和商业）&lt;/strong>：API 设计和文档，为使用 OpenAPI 的团队而构建。&lt;/li>
&lt;/ul>
&lt;p>由于 Swagger 工具是由参与创建原始 Swagger 规范的团队开发的，因此通常仍将这些工具视为该规范的代名词。但是 Swagger 工具并不是唯一可用于实现 OpenAPI 规范的工具。有各种各样的 API 设计，文档，测试，管理和监视解决方案都支持该规范的 2.0 版，并且正在积极致力于增加 3.0 支持。&lt;/p>
&lt;p>您可以在&lt;a href="https://github.com/OAI/OpenAPI-Specification/blob/master/IMPLEMENTATIONS.md">GitHub&lt;/a>上找到支持最新版本的 OpenAPI 规范的工具的完整列表 。&lt;/p>
&lt;h2 id="swagger-工具为什么没有将其名称更改为-openapi">Swagger 工具为什么没有将其名称更改为 OpenAPI？&lt;/h2>
&lt;p>Swagger 生态系统一直由规范和围绕它的核心开源工具组成，其中最著名的是 Swagger UI，Swagger 编辑器和 Swagger Codegen。规范之所以被广泛采用的一个重要原因是其附带的工具。&lt;/p>
&lt;p>SmartBear 捐赠了该规范，但由于开发人员，技术作家，测试人员和设计师与该工具有着密切的联系，因此流行的开源 Swagger 工具仍保留了原始品牌。该规范不是，也从未完全与 Swagger 工具相关联。实际上，决定捐赠该规范并组成 OpenAPI Initiative 是为了确保 OpenAPI 完全与供应商无关。这就是为什么我们很高兴看到 API 领域有这么多，包括也支持其他定义格式（例如 API 蓝图和 RAML）的公司加入了该计划的原因。&lt;/p>
&lt;p>Swagger 团队始终致力于使用 OpenAPI 规范构建功能最强大，易于使用的工具，以设计，记录，开发和测试 API，并将继续发展和发展我们的工具集以支持 OpenAPI。这些工具将继续保持 Swagger 名称。 Swagger.io 是 Swagger 工具和开源 Swagger 项目的在线主页，还将继续成为学习 Swagger 工具的理想之地，并且我们还将继续为 OpenAPI 规范的知识做出贡献，通过有关使用 OpenAPI 的培训，教程，网络研讨会和文档。&lt;/p>
&lt;h2 id="了解-openapi-和-swagger-社区">了解 OpenAPI 和 Swagger 社区&lt;/h2>
&lt;p>尽管为 OpenAPI 做出贡献的人们和为 Swagger 工具做出贡献的人们之间总是存在重叠，但是这两个社区是彼此独立的。&lt;/p>
&lt;p>如本文所述，OpenAPI Initiative 是一个开放的，与供应商无关的组织，欢迎任何想要帮助发展或利用其 API 开发中的规范的人参与。邀请组织加入不断增加的对规范做出贡献的成员列表，并且欢迎个人参加，方法是在 GitHub 上分享想法和反馈，或者参加每月在世界各地举行的许多 OAS 聚会之一。 在此处了解有关如何做出贡献的更多信息。&lt;/p>
&lt;p>Swagger 工具拥有自己的社区，致力于帮助改进某些现有 Swagger 项目，并引入新的想法和功能要求。Swagger 社区是由 SmartBear Software 的团队培育的，该团队投资于开源 Swagger 工具的开发，但也受到世界各地成千上万 Swagger 用户的贡献的推动。如果您想加入 Swagger 社区，我们邀请您 在 GitHub 上找到我们 或加入 Swagger API Meetup 组。 您还可以在 Swagger 博客或 Twitter 上的@SwaggerAPI 上找到最新新闻和更新 。&lt;/p>
&lt;h2 id="期待-openapi-的美好未来">期待 OpenAPI 的美好未来&lt;/h2>
&lt;p>我们期待看到 OpenAPI 成为 API 领域中每个人都认可的名称，我们很高兴成为不断壮大的 OpenAPI Initiative 成员社区的一部分。&lt;/p>
&lt;p>希望本文有助于阐明有关 OpenAPI 及其与 Swagger 的关系的一些问题。&lt;/p>
&lt;p>回顾一下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>该规范在 2015 年重命名为 OpenAPI 规范。OpenAPI3.0 是该规范的最新版本。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SmartBear Software 支持的 Swagger 工具是实现 OpenAPI 规范的最受欢迎的工具之一，并且将继续维护 Swagger 名称（Swagger 编辑器，Swagger UI，SwaggerHub 等）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>还有数百种与 Swagger 不相关的其他开源和专业工具都支持 OpenAPI 2.0 规范，并且支持 3.0 的工具列表也在不断增长。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>OpenAPI 和 Swagger 都有开源社区，欢迎所有贡献者加入以分享他们的想法并参与其中。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="swagger-20-与-openapi-格式对比">Swagger 2.0 与 OpenAPI 格式对比&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.jianshu.com/p/879baf1cff07">简书大佬&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/xxryy5/1616163614015-5221ca71-70a5-495b-a656-b5bc9a0122ec.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/xxryy5/1616163614002-f8ab633b-9c2b-42c9-acf2-f9cdd34bf2b1.png" alt="">&lt;/p></description></item><item><title>Docs: Web API 与 REST</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/Web-API-%E4%B8%8E-REST/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/API/Web-API-%E4%B8%8E-REST/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Web_API">Wiki，WebAPI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Representational_state_transfer">Wiki，REST&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html">阮一峰&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://segmentfault.com/a/1190000004311893">思否&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>WebAPI 是用于 Web 服务器或 Web 浏览器的应用程序变成接口。这是一个 Web 开发概念，&lt;/p>
&lt;h2 id="server-side服务端">Server Side(服务端)&lt;/h2>
&lt;p>&lt;strong>Server Side(服务端) 的 WebAPI&lt;/strong> 是由一个或多个公开暴露的 &lt;strong>Endpoints(端点)&lt;/strong> 组成的编程接口&lt;/p>
&lt;h3 id="endpoints端点">Endpoints(端点)&lt;/h3>
&lt;p>&lt;strong>Endpoints(端点，简称 ep)&lt;/strong> 是与服务端 WebAPI 交互的重要方面，因为 Endpoints 指定了客户端可以访问的资源位置。通常，是通过 URI 进行访问，HTTP 请求发送到这个 URI 上，从而期望从这个 URI 上得到响应。&lt;/p>
&lt;p>Web services expose one or more endpoints to which messages can be sent. A web service endpoint is an entity, processor, or resource that can be referenced and to which web services messages can be addressed. Endpoint references convey the information needed to address a web service endpoint. Clients need to know this information before they can access a service.&lt;/p>
&lt;p>Endpoint 这个词以前经常被用来描述进程间通信。例如&lt;/p>
&lt;ul>
&lt;li>在客户端与服务器之间的通讯，客户端是一个 Endpoint 和服务器是另外一个 Endpoint。&lt;/li>
&lt;li>根据不同的情况下，一个 Endpoint 可能指的地址，如一个 TCP 通信的（主机：端口）对，也可能是指与这个地址相对应的一个软件实体。例如，如果大家使用“ &lt;a href="https://www.example.com">www.example.com&lt;/a>:80 ”来描述一个 Endpoint。这些 Endpoint 可能是指实际的端口上的主机名称（即地址）&lt;/li>
&lt;li>也可能是指与地址相关的的网页服务器（即在这个地址之上运行的软件地址） 。&lt;/li>
&lt;li>邮寄信件时，将信件投递到邮箱，那么邮箱就是一个 ep&lt;/li>
&lt;li>寄送快递时，快递员上门取件，快递员就是一个 ep&lt;/li>
&lt;li>webservice 服务，一个服务地址：&lt;a href="http://www.url.com/service1">http://www.url.com/service1&lt;/a>是一个 ep&lt;/li>
&lt;/ul>
&lt;h2 id="client-side客户端">Client Side(客户端)&lt;/h2>
&lt;p>&lt;strong>Client Side(客户端) 的 WebAPI&lt;/strong> 也是一个编程接口，用于扩展 Web 浏览器或其他 HTTP 客户端内的功能。&lt;/p>
&lt;h1 id="rest">REST&lt;/h1>
&lt;h2 id="概述-1">概述&lt;/h2>
&lt;p>&lt;strong>Representational State Transfer(表述性状态传递，简称 REST)&lt;/strong> 是交互式应用程序(通常使用多个 Web 服务实现)的软件架构的事实标准。说白了就是两个应用程序的交互标准。规定了两个程序互相传递数据的格式(JSON、XML 等)、内容、方法(增删改查)等等。这种格式，称为 REST 风格的接口&lt;/p>
&lt;p>REST 是由 Roy Thomas Fielding 博士在他的论文 《Architectural Styles and the Design of Network-based Software Architectures》中提出的一个术语。REST 本身只是为分布式超媒体系统设计的一种架构风格，而不是标准。&lt;/p>
&lt;h2 id="rest-规范">REST 规范&lt;/h2>
&lt;p>原有的 B/S 架构有两种规范：
&lt;strong>1. 无状态性&lt;/strong>
无状态性是在客户－服务器约束的基础上添加的又一层规范。他要求通信必须在本质上是无状态的，即从客户到服务器的每个 request 都必须包含理解该 request 所必须的所有信息。这个规范改善了系统的可见性（无状态性使得客户端和服务器端不必保存对方的详细信息，服务器只需要处理当前 request，而不必了解所有的 request 历史），可靠性（无状态性减少了服务器从局部错误中恢复的任务量），可伸缩性（无状态性使得服务器端可以 很容易的释放资源，因为服务器端不必在多个 request 中保存状态）。同时，这种规范的缺点也是显而易见得，由于不能将状态数据保存在服务器上的共享上 下文中，因此增加了在一系列 request 中发送重复数据的开销,严重的降低了效率。
&lt;strong>2. 缓存&lt;/strong>
为了改善无状态性带来的网络的低效性，我们填加了缓存约束。缓存约束允许隐式或显式地标记一个 response 中的数据，这样就赋予了客户端缓存 response 数据的功能，这样就可以为以后的 request 共用缓存的数据，部分或全部的消除一部分交互，增加了网络的效率。但是用于客户端缓存了信 息，也就同时增加了客户端与服务器数据不一致的可能，从而降低了可靠性。
B/S 架构的优点是其部署非常方便，但在用户体验方面却不是很理想。为了改善这种情况，我们引入了 REST。 
REST 在原有的架构上增加了三个新规范：统一接口，分层系统和按需代码。
&lt;strong>3. 统一接口&lt;/strong>
REST 架构风格的核心特征就是强调组件之间有一个统一的接口，这表现在 REST 世界里，网络上所有的事物都被抽象为资源，而 REST 就是通过通用的链接器接口对 资源进行操作。这样设计的好处是保证系统提供的服务都是解耦的，极大的简化了系统，从而改善了系统的交互性和可重用性。并且 REST 针对 Web 的常见情况 做了优化，使得 REST 接口被设计为可以高效的转移大粒度的超媒体数据，这也就导致了 REST 接口对其它的架构并不是最优的。
&lt;strong>4. 分层系统&lt;/strong>
分层系统规则的加入提高了各种层次之间的独立性，为整个系统的复杂性设置了边界，通过封装遗留的服务，使新的服务器免受遗留客户端的影响，这也就提高了系统的可伸缩性。
&lt;strong>5. 按需代码&lt;/strong>
REST 允许对客户端功能进行扩展。比如，通过下载并执行 applet 或脚本形式的代码，来扩展客户端功能。但这在改善系统可扩展性的同时，也降低了可见性。所以它只是 REST 的一个可选的约束。&lt;/p>
&lt;h2 id="rest-的设计准则">REST 的设计准则  &lt;/h2>
&lt;p>REST 架构是针对 Web 应用而设计的，其目的是为了降低开发的复杂性，提高系统的可伸缩性。REST 提出了如下设计准则：&lt;/p>
&lt;ul>
&lt;li>网络上的所有事物都被抽象为资源（resource）；&lt;/li>
&lt;li>每个资源对应一个唯一的资源标识符（resource identifier）；&lt;/li>
&lt;li>通过通用的连接器接口（generic connector interface）对资源进行操作；&lt;/li>
&lt;li>对资源的各种操作不会改变资源标识符；&lt;/li>
&lt;li>所有的操作都是无状态的（stateless）。&lt;/li>
&lt;/ul>
&lt;h4 id="注意">注意：&lt;/h4>
&lt;ol>
&lt;li>REST 中的资源所指的不是数据，而是数据和表现形式的组合，比如“最新访问的 10 位会员”和“最活跃的 10 为会员”在数据上可能有重叠或者完全相同，而 由于他们的表现形式不同，所以被归为不同的资源，这也就是为什么 REST 的全名是 Representational State Transfer 的原因。资源标识符就是 URI(Uniform Resource Identifier)，不管是图片，Word 还是视频文件，甚至只是一种虚拟的服务，也不管你是 xml 格式,txt 文件格式还是其它文件格式，全部通过 URI 对资源进行唯一的标识。&lt;/li>
&lt;li>REST 是基于 Http 协议的，任何对资源的操作行为都是通过 Http 协议来实现。以往的 Web 开发大多数用的都是 Http 协议中的 GET 和 POST 方 法，对其他方法很少使用，这实际上是因为对 Http 协议认识片面的理解造成的。Http 不仅仅是一个简单的运载数据的协议，而是一个具有丰富内涵的网络软 件的协议。他不仅仅能对互联网资源进行唯一定位，而且还能告诉我们如何对该资源进行操作。Http 把对一个资源的操作限制在 4 个方法以内：GET, POST,PUT 和 DELETE，这正是对资源 CRUD 操作的实现。由于资源和 URI 是一一对应的，执行这些操作的时候 URI 是没有变化的，这和以往的 Web 开发有很大的区别。正由于这一点，极大的简化了 Web 开发，也使得 URI 可以被设计成更为直观的反映资源的结构，这种 URI 的设计被称作 RESTful 的 URI。这位开发人员引入了一种新的思维方式：通过 URL 来设计系统结构。当然了，这种设计方式对一些特定情况也是不适用的，也就是说不 是所有的 URI 都可以 RESTful 的。&lt;/li>
&lt;/ol>
&lt;h2 id="思考">思考&lt;/h2>
&lt;ol>
&lt;li>以上的信息参考自&lt;a href="http://www.cnblogs.com/EasyLive2006/archive/2009/11/03/1595152.html">http://www.cnblogs.com/EasyLive2006/archive/2009/11/03/1595152.html&lt;/a>并整理；&lt;/li>
&lt;li>对于网站开发，我们常用的操作就是 GET，和 POST 方式，比如获取数据采用 GET 方式，提交数据采用 POST 方式，但不管是哪种方式，提交数据还是获取数据，后端都要对参数进行处理并对这些操作进行相应。而 REST 的架构把 PUT 和 DELETE 两种数据提交方式用上了，整个操作就会更加的清晰明了，非常的有逻辑性。&lt;/li>
&lt;li>REST 的 HTTP 协议操作与数据库的 CURD 操作对比:
HTTP 请求数据库请求 GETSELECTPOSTINSERTPUTUPDATEDELETEDELETE&lt;/li>
&lt;li>从以上对比表来看，前端与后端的数据交互更加像是另外一层的数据库交互操作，然而，知道这个没什么卵用，这个是基于 REST 思想的一种 HTTP 协议规范，但如果后端不按照其对应的数据操作来进行处理，没有什么卵用；
举个例子：比如采用 DELETE 方式发送请求，但后端却处理成增加数据或者修改数据，POST 数据后端处理成删除；但是，我们目前是没有采用这种思想来进行操作的，不管是修改，删除，增加，查询，采用的都是 POST 或者 GET 方式。&lt;/li>
&lt;li>数据交互形式：后端返回 json/xml 或者其他前端所期望的数据，但不管什么数据，需要有一个明确的规范和完善的资源管理机制&lt;/li>
&lt;li>如果运用了 REST 这种设计思想，我们可以干什么呢？&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>1). 我们的前端服务器完全可以和数据服务器（REST 服务器）分离，前端服务器处理服务器请求，加载前端骨架（这里不叫框架，叫骨架我觉得更加贴切，REST 服务器上的就是肉），然后前端再更具不同的服务需求，像 REST 请求数据或者更具不同的操作，像 REST 服务器提交增删改的请求等等
2). 不过我觉得把 REST 叫做面向 Api(接口)服务设计来说应该也是很贴切的，REST 服务就是接口。
3). 有了 REST 服务器，不管是电脑端还是手机端，或者是 APP，按照 REST 的接口来进行数据交互，完全不用关心后端实现，也就是说，前端和后端真正的实现了完全的分离设计。&lt;/p>
&lt;/blockquote>
&lt;h2 id="后记">后记&lt;/h2>
&lt;p>关于之后的信息，应该要整理一个简版的前后端代码模型来理解，这个我晚上抽点时间来理一个模型，还有几个方面需要整理：&lt;/p>
&lt;ol>
&lt;li>代码模型实现&lt;/li>
&lt;li>架构的不合理性&lt;/li>
&lt;li>不适合 REST 架构的场景&lt;/li>
&lt;li>其他&lt;/li>
&lt;/ol></description></item></channel></rss>