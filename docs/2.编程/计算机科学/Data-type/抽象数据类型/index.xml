<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>抽象数据类型 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-type/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><description>Recent content in 抽象数据类型 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-type/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>抽象数据类型</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-type/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-type/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>概述 参考：
Wiki, AbstractDataType(抽象数据类型) 在计算机科学中，Abstract Data Type(抽象数据类型，简称 ADT) 是数据类型的数学模型，从数据用户的角度由其行为（语义）定义，特别是根据可能的值、对数据的可能操作来定义。这种类型，以及这些操作的行为。该数学模型与数据结构形成对比，数据结构是数据的具体表示，并且是实现者而不是用户的观点。例如，堆栈具有遵循后进先出规则的入栈/出栈操作，并且可以使用列表或数组来具体实现。另一个例子是一个存储值的集合，没有任何特定的顺序，也没有重复的值。值本身不是从集合中检索的，而是测试成员资格值以获得布尔值“in”或“not in”。</description></item><item><title>Pointer(指针)</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-type/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Pointer%E6%8C%87%E9%92%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-type/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Pointer%E6%8C%87%E9%92%88/</guid><description>概述 参考：
Wiki, Pointer Pointer(指针) 在计算机科学中，是许多编程语言中存储内存地址的对象。这可以是位于计算机内存中的另一个值，或者在某些情况下，是内存映射计算机硬件的值。指针引用内存中的某个位置，获取存储在该位置的值称为取消引用该指针。打个比方，一本书索引中的页码可以被认为是指向相应页面的指针；将通过翻到具有给定页码的页面并阅读在该页面上找到的文本来取消引用这样的指针。指针变量的实际格式和内容取决于底层计算机体系结构。
彻底理解 C 语言中的指针 原文：公众号，码农的荒岛求生-彻底理解 C 语言中的指针
假定给你一块非常小的内存，这块内存只有8字节，这里也没有高级语言，没有操作系统，你操作的数据单位是单个字节，你该怎样读写这块内存呢？
注意这里的限定，再读一遍，没有高级语言，没有操作系统，在这样的限制之下， 你必须直面内存读写的本质 。
这个本质是什么呢？
本质是你需要意识到内存就是一个一个装有字节的小盒子，这些小盒子从0到N编好了序号。
这时如果你想计算1+2，那么你必须先把1和2分别放到两个小盒子中，假设我们使用Store指令，把数字1放到第6号小盒子，那么用指令表示就是这样：
store 1 6 注意看这条指令，这里出现了两个数字：1和6，虽然都是数字，但这两个数字的含义是不同的， 一个代表数值，一个代表内存地址 。
与写对应的是读，假设我们使用load指令，就像这样：
load r1 6 现在依然有一个问题，这条指令到底是数字6写入r1寄存器还是把第6号小盒子中装的数字写入r1寄存器？
可以看到，数字在这里是有歧义的，它既可以表示数值也可以表示地址，为加以区分我们需要给数字添加一个标识，比如对于前面加上$符号的就表示数值，否则就是地址：
store $1 6load r1 6 这样就不会有歧义了。
现在第6号内存中装入了数值1：
即地址6代表数字1：
地址6 -&amp;gt; 数字1 但“地址6”对人类来说太不友好了，人类更喜欢代号，也就是起名字，假设我们给“地址6”换一个名字，叫做a，a代表的就是地址6，a中存储的值就是1，用人类在代数中直观的表示就是：
a = 1 就这样所谓的变量一词诞生了。
我们可以看到，从表面上看变量a等价于数值1，但背后还隐藏着一个重要的信息， 那就是变量a代表的数字1存储在第6号内存地址上 ，即变量a或者说符号a背后的含义是：
表示数值1 该数值存储在第6号内存地址 到现在为止第2个信息好像不太重要，先不用管它。
既然有变量a，就会有变量b，如果有这样一个表示：
b = a 把a的值给到b，这个赋值在内存中该怎么表示呢？
很简单，我们为变量b也找一个小盒子，假设变量b放在第2号小盒子上：
可以看到，我们完全copy了一份变量a的数据。
现在有了变量，接下来让我们升级一下，假设变量a不仅仅可以表示占用1个字节的数据，也可以表示占用任意多内存的数据，就像这样：
现在变量a占据5个字节，足足占用了整个内存的一大半空间，此时如果我们依然想要表示b = a会怎样呢？
如果你依然采用copy 的方法会发现我们的内存空间已经不够用了，因为整个内存大小就8字节，采用copy的方法仅这两个变量代表的数据就将占据10字节。
怎么办呢？
不要忘了变量a背后可是有两个含义的，再让我们看一下：
表示数值1 该数值存储在第6号内存地址 重点看一下第2个含义，这个含义告诉我们什么呢？</description></item><item><title>Tree Data Structure(树型数据结构)</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-type/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Tree-Data-Structure%E6%A0%91%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-type/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Tree-Data-Structure%E6%A0%91%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>概述 参考：Wiki-TreeDataStructure
在计算机科学中，Tree 是一种广泛使用的抽象数据类型，它模拟分层树结构，其根值和具有父节点的子级子树表示为一组链接节点。
可以将树数据结构递归定义为节点的集合（从根节点开始），其中每个节点都是由值组成的数据结构，以及对节点（“子级”）的引用列表，其中约束，即没有重复的引用，也没有指向根的约束。或者，可以将树抽象为一个整体（全局地）定义为有序树，并为每个节点分配一个值。这两种观点都很有用：虽然一棵树可以作为一个整体进行数学分析，但是当实际上表示为数据结构时，它通常由节点表示和使用（而不是作为一组节点和节点之间的邻接表），例如表示一个有向图）。例如，从整体上看一棵树，可以谈论给定节点的“父节点”，但是通常，给定节点作为数据结构仅包含其子节点列表，但不包含引用。给它的父母（如果有的话）。
术语 1、结点(Node)：表示树中的数据元素，由数据项和数据元素之间的关系组成。在图 1 中，共有 10 个结点。 2、结点的度(Degree of Node)：结点所拥有的子树的个数，在图 1 中，结点 A 的度为 3。 3、树的度(Degree of Tree)：树中各结点度的最大值。在图 1 中，树的度为 3。 4、叶子结点(Leaf Node)：度为 0 的结点，也叫终端结点。在图 1 中，结点 E、F、G、H、I、J 都是叶子结点。 5、分支结点(Branch Node)：度不为 0 的结点，也叫非终端结点或内部结点。在图 1 中，结点 A、B、C、D 是分支结点。 6、孩子(Child)：结点子树的根。在图 1 中，结点 B、C、D 是结点 A 的孩子。 7、双亲(Parent)：结点的上层结点叫该结点的双亲。在图 1 中，结点 B、C、D 的双亲是结点 A。 8、祖先(Ancestor)：从根到该结点所经分支上的所有结点。在图 1 中，结点 E 的祖先是 A 和 B。 9、子孙(Descendant)：以某结点为根的子树中的任一结点。在图 1 中，除 A 之外的所有结点都是 A 的子孙。 10、兄弟(Brother)：同一双亲的孩子。在图 1 中，结点 B、C、D 互为兄弟。 11、结点的层次(Level of Node)：从根结点到树中某结点所经路径上的分支数称为该结点的层次。根结点的层次规定为 1，其余结点的层次等于其双亲结点的层次加 1。 12、堂兄弟(Sibling)：同一层的双亲不同的结点。在图 1 中，G 和 H 互为堂兄弟。 13、树的深度(Depth of Tree)：树中结点的最大层次数。在图 1 中，树的深度为 3。 14、无序树(Unordered Tree)：树中任意一个结点的各孩子结点之间的次序构成无关紧要的树。通常树指无序树。 15、有序树(Ordered Tree)：树中任意一个结点的各孩子结点有严格排列次序的树。二叉树是有序树，因为二叉树中每个孩子结点都确切定义为是该结点的左孩子结点还是右孩子结点。 16、森林(Forest)：m(m≥0)棵树的集合。自然界中的树和森林的概念差别很大，但在数据结构中树和森林的概念差别很小。从定义可知，一棵树有根结点和 m 个子树构成，若把树的根结点删除，则树变成了包含 m 棵树的森林。当然，根据定义，一棵树也可以称为森林。</description></item></channel></rss>