<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦的站点 – Data type</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-type/</link><description>Recent content in Data type on 断念梦的站点</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-type/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Literal</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-type/Literal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-type/Literal/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Literal_(computer_programming)">Wiki, Literal(字面量)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在计算机科学中，&lt;strong>Literal(字面量)&lt;/strong> 是表示源代码中固定值的 snotation(表示法)。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如：整数、浮点数以及字符串；而有很多也对布尔类型和字符类型的值也支持字面量表示；还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值也支持字面量表示法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// b 为常量，10为字面量,数据类型为整数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">const&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">b&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// str 为变量，hello world！为字面量，数据类型为字符串
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">string&lt;/span> &lt;span style="color:#000">str&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;hello world！&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 复合数据类型</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-type/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-type/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description/></item><item><title>Docs: 抽象数据类型</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-type/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-type/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description/></item><item><title>Docs: Data type</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-type/Data-type/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-type/Data-type/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Data_type">Wiki, DataType&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在计算机科学和计算机编程中，&lt;strong>Data Type(数据类型，有时也简称 Type)&lt;/strong> 是数据的一个属性，这些属性将会让编译器知道程序员想要如何使用数据。&lt;/p>
&lt;p>&lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data%20type/Literal.md">Literal(字面量)&lt;/a> 与 &lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Variable.md">Variable(变量)&lt;/a> 相关，是用于初始化变量时指定的一个值。&lt;/p>
&lt;h2 id="数据类型的分类">数据类型的分类&lt;a class="td-heading-self-link" href="#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%88%86%e7%b1%bb" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>原始数据类型&lt;/li>
&lt;li>复合数据类型&lt;/li>
&lt;li>抽象数据类型&lt;/li>
&lt;li>其他类型&lt;/li>
&lt;li>TODO&lt;/li>
&lt;/ul>
&lt;h1 id="primitive-data-types原始数据类型">Primitive Data Types(原始数据类型)&lt;a class="td-heading-self-link" href="#primitive-data-types%e5%8e%9f%e5%a7%8b%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Primitive_data_type">原始数据类型&lt;/a>通常是语言实现的内置或基础类型。&lt;/p>
&lt;h3 id="machine-data-type机器数据类型">Machine Data Type(机器数据类型)&lt;a class="td-heading-self-link" href="#machine-data-type%e6%9c%ba%e5%99%a8%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>基于数字电子的计算机中的所有数据都表示为最低级别的&lt;a href="https://en.wikipedia.org/wiki/Bit">位&lt;/a>（替代 0 和 1）。数据的最小可寻址单元通常是一组称为&lt;a href="https://en.wikipedia.org/wiki/Byte">字节&lt;/a>的位（通常是一个&lt;a href="https://en.wikipedia.org/wiki/Octet_(computing)">八位组&lt;/a>，即 8 位）。由&lt;a href="https://en.wikipedia.org/wiki/Machine_code">机器代码&lt;/a>指令处理的单元称为&lt;a href="https://en.wikipedia.org/wiki/Word_(data_type)">字&lt;/a>（截至 2011 年，通常为 32 或 64 位）。大多数指令将字解释为&lt;a href="https://en.wikipedia.org/wiki/Binary_number">二进制数&lt;/a>，因此 32 位字可以表示从 0 到 232 - 1 或有符号整数值来自 -231 到 231 - 1 由于&lt;a href="https://en.wikipedia.org/wiki/Two%27s_complement">二进制补码&lt;/a>，机器语言和机器在大多数情况下不需要区分这些无符号和有符号数据类型。&lt;/p>
&lt;p>用于浮点算术的浮点数对字中的位使用不同的解释。有关详细信息，请参阅&lt;a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic">浮点运算&lt;/a>。&lt;/p>
&lt;p>机器数据类型需要在&lt;a href="https://en.wikipedia.org/wiki/Systems_programming">系统&lt;/a>或&lt;a href="https://en.wikipedia.org/wiki/Low-level_programming_language">低级编程语言中&lt;/a>公开或可用，允许对硬件进行细粒度控制。的&lt;a href="https://en.wikipedia.org/wiki/C_programming_language">C 编程语言&lt;/a>，例如，建筑材料整数类型不同的宽度，如和。如果目标平台上不存在相应的本机类型，编译器将使用确实存在的类型将它们分解为代码。例如，如果在 16 位平台上请求一个 32 位整数，编译器会默认将其视为两个 16 位整数的数组。 shortlong&lt;/p>
&lt;p>在更高级别的编程中，机器数据类型通常被隐藏或_抽象_为一个实现细节，如果暴露，会使代码的可移植性降低。例如，numeric 可以提供泛型类型而不是某些特定位宽的整数。&lt;/p>
&lt;h3 id="boolean-type布尔类型">Boolean Type(布尔类型)&lt;a class="td-heading-self-link" href="#boolean-type%e5%b8%83%e5%b0%94%e7%b1%bb%e5%9e%8b" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Boolean_type">Boolean(布尔)&lt;/a> 类型表示值 &lt;a href="https://en.wikipedia.org/wiki/Logical_truth">true(真)&lt;/a> 和 &lt;a href="https://en.wikipedia.org/wiki/Logical_truth">false(假)&lt;/a>。尽管只有两个值是可能的，但出于效率原因，它们很少被实现为单个二进制数字。许多编程语言没有明确的布尔类型，&lt;strong>而是将 0 解释为 false，将其他值解释为 true&lt;/strong>。布尔数据是指如何将语言解释为机器语言的逻辑结构。在这种情况下，布尔值 0 指的是逻辑 False。True 总是非零，尤其是被称为布尔值 1 的一。&lt;/p>
&lt;h3 id="numeric-type数字类型">Numeric Type(数字类型)&lt;a class="td-heading-self-link" href="#numeric-type%e6%95%b0%e5%ad%97%e7%b1%bb%e5%9e%8b" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Integer_(computing)">Integer(整数，简写 int)&lt;/a> 数据类型，或“非分数”。可以根据它们包含负值的能力进行子类型化（例如 unsigned 在 C 和 C++ 中）。也可具有小的预定义数目的亚型（如 short 和 long 在 C / C ++）; 或允许用户自由定义子范围，例如 1..12（例如&lt;a href="https://en.wikipedia.org/wiki/Pascal_(programming_language)">Pascal&lt;/a> / &lt;a href="https://en.wikipedia.org/wiki/Ada_(programming_language)">Ada&lt;/a>）。&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Floating_point">Floating Point(浮点)&lt;/a> 数据类型通常将值表示为高精度分数值（&lt;a href="https://en.wikipedia.org/wiki/Rational_numbers">有理数&lt;/a>，数学上），但有时会误导性地称为实数（令人联想到数学&lt;a href="https://en.wikipedia.org/wiki/Real_numbers">实数&lt;/a>）。它们通常对最大值和精度都有预定义的限制。通常以 a × 2 b 的形式在内部存储（其中 a 和 b 是整数），但以熟悉的&lt;a href="https://en.wikipedia.org/wiki/Decimal">十进制&lt;/a>形式显示。&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Fixed_point_(computing)">Fixed Point(定点)&lt;/a> 数据类型便于表示货币值。它们通常在内部实现为整数，从而导致预定义的限制。&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Bignum">Bignum&lt;/a>或&lt;a href="https://en.wikipedia.org/wiki/Arbitrary_precision">任意精度&lt;/a>数字类型缺乏预定义的限制。它们不是原始类型，出于效率原因很少使用。&lt;/li>
&lt;/ul>
&lt;h3 id="enumerations枚举">Enumerations(枚举)&lt;a class="td-heading-self-link" href="#enumerations%e6%9e%9a%e4%b8%be" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Enumerated_type">枚举类型&lt;/a>具有不同的值，其可以被比较和分配，但不一定必须在计算机的存储器中的任何特定的具体表示; 编译器和解释器可以任意表示它们。例如，一副扑克牌中的四个花色可能是名为 CLUB、DIAMOND、HEART、SPADE 的四个枚举数，属于一个名为 suit 的枚举类型。如果变量 V 被声明为具有花色作为它的数据类型，可以为它分配这四个值中的任何一个。一些实现允许程序员为枚举值分配整数值，甚至将它们视为与整数类型等效的。&lt;/p>
&lt;h1 id="composite-types复合类型">Composite Types(复合类型)&lt;a class="td-heading-self-link" href="#composite-types%e5%a4%8d%e5%90%88%e7%b1%bb%e5%9e%8b" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data%20Type/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md">复合数据类型&lt;/a> 派生自多个原始类型。这可以通过多种方式完成。它们组合的方式称为&lt;a href="https://en.wikipedia.org/wiki/Data_structure">数据结构&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data%20Type/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Array.md">Array&lt;/a>(数组)&lt;/strong> # 也称为 &lt;strong>Vector(向量)&lt;/strong>、&lt;a href="https://en.wikipedia.org/wiki/List_(abstract_data_type)">&lt;strong>List(列表)&lt;/strong>&lt;/a>、&lt;strong>Sequence(序列)&lt;/strong>。Array 存储多个 &lt;strong>elements(元素)&lt;/strong>，并提供对各个 elements 的随机访问。数组的元素通常（但并非在所有情况中）要求具有相同类型。数组可以是固定长度的或可扩展的。数组的索引通常要求是来自特定范围的整数（如果不是，可以参考 &lt;a href="https://en.wikipedia.org/wiki/Associative_array">Associative array(关联数组)&lt;/a>）（如果不是该范围内的所有索引都对应于元素，则它可能是 &lt;a href="https://en.wikipedia.org/wiki/Sparse_array">Sparse array(稀疏数组)&lt;/a>）。&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://en.wikipedia.org/wiki/Record_(computer_science)">Record&lt;/a>(记录)&lt;/strong> # 也称为 也称为 &lt;strong>Tuple(元组)&lt;/strong> 或 &lt;strong>Struct(结构体)&lt;/strong>。Record 是最简单的&lt;a href="https://en.wikipedia.org/wiki/Data_structure">数据结构&lt;/a>之一。Record 是包含其他值的值，通常采用固定数量和顺序，通常按 1 名称索引。记录的元素通常称为 &lt;strong>Fields(字段)&lt;/strong> 或 &lt;strong>Members(成员)&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://en.wikipedia.org/wiki/Object_(computer_science)">Object(对象)&lt;/a>&lt;/strong> 包含许多数据字段，如 Record，以及许多用于访问或修改它们的子程序，称为 &lt;a href="https://en.wikipedia.org/wiki/Method_(computer_programming)">Methods(方法)&lt;/a>。&lt;/li>
&lt;/ul>
&lt;h1 id="abstract-data-types抽象数据类型">Abstract Data Types(抽象数据类型)&lt;a class="td-heading-self-link" href="#abstract-data-types%e6%8a%bd%e8%b1%a1%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data%20Type/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md">抽象数据类型&lt;/a>是不指定数据具体表示的数据类型。相反，使用基于数据类型操作的正式规范来描述它。规范的任何实现都必须满足给定的规则。例如，&lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Heap%20and%20Stack.md">Heap and Stack&lt;/a> 具有遵循后进先出规则的入栈/出栈操作，并且可以使用 list 或 array 来具体实现。抽象数据类型用于形式语义和程序验证，以及不太严格的设计中。&lt;/p>
&lt;h1 id="其他类型">其他类型&lt;a class="td-heading-self-link" href="#%e5%85%b6%e4%bb%96%e7%b1%bb%e5%9e%8b" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>类型可以基于或派生自上述基本类型。在某些语言（例如 C）中，&lt;a href="https://en.wikipedia.org/wiki/Function_(computer_science)">函数&lt;/a>具有从其&lt;a href="https://en.wikipedia.org/wiki/Return_value">返回值&lt;/a>的类型派生的类型。&lt;/p>
&lt;h2 id="string字符串-和-text文本-类型">String(字符串) 和 Text(文本) 类型&lt;a class="td-heading-self-link" href="#string%e5%ad%97%e7%ac%a6%e4%b8%b2-%e5%92%8c-text%e6%96%87%e6%9c%ac-%e7%b1%bb%e5%9e%8b" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>一个&lt;a href="https://en.wikipedia.org/wiki/Character_(computing)">字符&lt;/a>，可能是某个&lt;a href="https://en.wikipedia.org/wiki/Alphabet">字母表&lt;/a>中的一个&lt;a href="https://en.wikipedia.org/wiki/Alphabet">字母&lt;/a>、一个数字、一个空格、一个标点符号等。&lt;/li>
&lt;li>一个&lt;a href="https://en.wikipedia.org/wiki/String_(computer_science)">字符串&lt;/a>，它是一个字符序列。字符串通常用于表示单词和文本，尽管除了最琐碎的情况外，所有文本都不仅仅涉及字符序列。&lt;/li>
&lt;/ul>
&lt;p>字符和字符串类型可以存储字符集（例如 &lt;a href="https://en.wikipedia.org/wiki/ASCII">ASCII&lt;/a> 中的字符序列。由于大多数字符集都包含&lt;a href="https://en.wikipedia.org/wiki/Numerical_digit">数字&lt;/a>，因此可以使用数字字符串，例如&amp;quot;1234&amp;quot;. 但是，许多语言将它们视为属于与数值不同的类型 1234。&lt;/p>
&lt;p>根据所需的字符“宽度”，字符和字符串类型可以有不同的子类型。最初的 7 位宽 ASCII 被发现是有限的，并被 8 位和 16 位集取代，它们可以编码各种各样的非拉丁字母（如&lt;a href="https://en.wikipedia.org/wiki/Hebrew">希伯来语&lt;/a>和&lt;a href="https://en.wikipedia.org/wiki/Chinese_language">中文&lt;/a>）和其他符号。字符串可以是适合拉伸的，也可以是固定大小的，即使是在相同的编程语言中。它们也可以按其最大大小进行子类型化。&lt;/p>
&lt;p>注意：字符串不是所有语言中的原始数据类型。例如，在 &lt;a href="https://en.wikipedia.org/wiki/C_(programming_language)">C 语言&lt;/a> 中，它们由字符数组组成。&lt;/p>
&lt;h2 id="pointer指针-和-reference引用-类型">Pointer(指针) 和 Reference(引用) 类型&lt;a class="td-heading-self-link" href="#pointer%e6%8c%87%e9%92%88-%e5%92%8c-reference%e5%bc%95%e7%94%a8-%e7%b1%bb%e5%9e%8b" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>主要的非复合派生类型是&lt;a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">指针&lt;/a>，这是一种数据类型，其值直接引用（或“指向”）使用其&lt;a href="https://en.wikipedia.org/wiki/Memory_address">地址&lt;/a>存储在&lt;a href="https://en.wikipedia.org/wiki/Computer_memory">计算机内存中&lt;/a>其他位置的另一个值。它是一种原始的&lt;a href="https://en.wikipedia.org/wiki/Reference_(computer_science)">参考&lt;/a>。（在日常生活中，一本书的页码可以被认为是引用另一本书的一段数据）。指针通常以类似于整数的格式存储；但是，尝试取消引用或“查找”其值永远不是有效内存地址的指针会导致程序崩溃。为了改善这个潜在问题，指针被认为是指向它们指向的数据类型的单独类型，即使底层表示相同。&lt;/p>
&lt;h2 id="function函数-类型">Function(函数) 类型&lt;a class="td-heading-self-link" href="#function%e5%87%bd%e6%95%b0-%e7%b1%bb%e5%9e%8b" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>虽然也可以为函数分配类型，但在本文的设置中，它们的类型不被视为数据类型。在这里，数据被视为不同于&lt;a href="https://en.wikipedia.org/wiki/Algorithm">算法&lt;/a>。在编程中，函数与后者密切相关。但是，因为&lt;a href="https://en.wikipedia.org/wiki/Universal_Turing_machine">通用数据处理的&lt;/a>一个中心原则是算法可以&lt;a href="https://en.wikipedia.org/wiki/G%C3%B6del_numbering#Generalizations">表示为数据&lt;/a>，例如文本描述和二进制程序，数据和函数之间的对比是有限的。其实函数不仅可以用数据来表示，函数也可以用来&lt;a href="https://en.wikipedia.org/wiki/Lambda_calculus#Encoding_datatypes">对数据&lt;/a>进行&lt;a href="https://en.wikipedia.org/wiki/Lambda_calculus#Encoding_datatypes">编码&lt;/a>。许多当代&lt;a href="https://en.wikipedia.org/wiki/Type_systems">类型系统&lt;/a>强烈关注函数类型，许多现代语言允许函数作为&lt;a href="https://en.wikipedia.org/wiki/First-class_citizen">一等公民运行&lt;/a>。
将函数从被视为数据类型的对象中排除在相关领域中并不少见。[&lt;a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">需要引用&lt;/a>] 例如，&lt;a href="https://en.wikipedia.org/wiki/Predicate_logic">谓词逻辑&lt;/a>不允许在函数或谓词名称上应用&lt;a href="https://en.wikipedia.org/wiki/Quantifier_(logic)">量词&lt;/a>。&lt;/p>
&lt;h2 id="meta元-类型">Meta(元) 类型&lt;a class="td-heading-self-link" href="#meta%e5%85%83-%e7%b1%bb%e5%9e%8b" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>一些编程语言将类型信息表示为数据，从而实现&lt;a href="https://en.wikipedia.org/wiki/Type_introspection">类型自省&lt;/a>和&lt;a href="https://en.wikipedia.org/wiki/Reflection_(computer_programming)">反射&lt;/a>。相比之下，&lt;a href="https://en.wikipedia.org/wiki/Type_constructor">高阶&lt;/a> &lt;a href="https://en.wikipedia.org/wiki/Type_systems">类型系统&lt;/a>虽然允许从其他类型构造类型并作为值传递给函数，但通常避免基于它们进行&lt;a href="https://en.wikipedia.org/wiki/Computational">计算&lt;/a>决策。[&lt;a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">需要引用&lt;/a>]&lt;/p>
&lt;h2 id="utility实用程序-类型">Utility(实用程序) 类型&lt;a class="td-heading-self-link" href="#utility%e5%ae%9e%e7%94%a8%e7%a8%8b%e5%ba%8f-%e7%b1%bb%e5%9e%8b" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>为方便起见，高级语言可能提供现成的“现实世界”数据类型，例如时间、日期、货币值和内存，即使该语言允许从原始类型构建它们。&lt;/p></description></item><item><title>Docs: 进制表示法</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-type/%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data-type/%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.51cto.com/ciyorecord/1930808">https://blog.51cto.com/ciyorecord/1930808&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://qastack.cn/programming/2670639/why-are-hexadecimal-numbers-prefixed-with-0x">https://qastack.cn/programming/2670639/why-are-hexadecimal-numbers-prefixed-with-0x&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>对于整数，有四种表示方式：
  二进制：0,1 ，满 2 进 1.以 0b 或 0B 开头。
  十进制：0-9 ，满 10 进 1.
  八进制：0-7 ，满 8 进 1. 以数字 0 开头表示。
  十六进制：0-9 及 A-F，满 16 进 1. 以 0x 或 0X 开头表示。此处的 A-F 不区分大小写。
    如：0x21AF +1= 0X21B0&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>0&lt;/strong>&lt;/th>
&lt;th>&lt;strong>1&lt;/strong>&lt;/th>
&lt;th>&lt;strong>2&lt;/strong>&lt;/th>
&lt;th>&lt;strong>3&lt;/strong>&lt;/th>
&lt;th>&lt;strong>4&lt;/strong>&lt;/th>
&lt;th>&lt;strong>5&lt;/strong>&lt;/th>
&lt;th>&lt;strong>6&lt;/strong>&lt;/th>
&lt;th>&lt;strong>7&lt;/strong>&lt;/th>
&lt;th>&lt;strong>8&lt;/strong>&lt;/th>
&lt;th>&lt;strong>9&lt;/strong>&lt;/th>
&lt;th>&lt;strong>10&lt;/strong>&lt;/th>
&lt;th>&lt;strong>11&lt;/strong>&lt;/th>
&lt;th>&lt;strong>12&lt;/strong>&lt;/th>
&lt;th>&lt;strong>13&lt;/strong>&lt;/th>
&lt;th>&lt;strong>14&lt;/strong>&lt;/th>
&lt;th>&lt;strong>15&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>2&lt;/td>
&lt;td>3&lt;/td>
&lt;td>4&lt;/td>
&lt;td>5&lt;/td>
&lt;td>6&lt;/td>
&lt;td>7&lt;/td>
&lt;td>8&lt;/td>
&lt;td>9&lt;/td>
&lt;td>A&lt;/td>
&lt;td>B&lt;/td>
&lt;td>C&lt;/td>
&lt;td>D&lt;/td>
&lt;td>E&lt;/td>
&lt;td>F&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>1.原码、反码、补码&lt;/strong>&lt;/p>
&lt;p>所有数字在计算机底层都以二进制形式存在。&lt;/p>
&lt;p>计算机以补码的形式保存所有的整数。&lt;/p>
&lt;p>正数的原码、反码、补码都相同&lt;/p>
&lt;p>负数的补码是其反码加 1。&lt;/p>
&lt;p>原码：直接将一个数值换成二进制数。&lt;/p>
&lt;p>反码：是对原码按位取反，只是最高位（符号位）确定为 1。&lt;/p>
&lt;p>Java 整数常量默认是 int 类型，当用二进制定义整数时，其第 32 位是符号位；当是 long 类型时，二进制默认占 64 位，第 64 位是符号位&lt;/p>
&lt;p>&lt;strong>2.进制间转化&lt;/strong>
  十进制二进制互转
    二进制转成十进制   乘以 2 的幂数
    十进制转成二进制   除以 2 取余数
&lt;a href="https://s4.51cto.com/wyfs02/M01/97/60/wKioL1kuH3TTJrKTAABE1kplv-c085.png">&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ig4gf2/1626622220260-99ef3660-4e55-4e28-96ba-dba25b480ffa.png" alt="">&lt;/a>
二进制八进制互转
二进制十六进制互转
&lt;a href="https://s4.51cto.com/wyfs02/M01/97/5F/wKiom1kuIGfSNqR_AABAaZfqVew465.png">&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ig4gf2/1626622220293-cfa1863d-b8cc-4314-8281-fe15ee80dce4.png" alt="">&lt;/a>
&lt;a href="https://s4.51cto.com/wyfs02/M01/97/5F/wKiom1kuIGfSNqR_AABAaZfqVew465.png">十进制八进制互转&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://s4.51cto.com/wyfs02/M01/97/5F/wKiom1kuIGfSNqR_AABAaZfqVew465.png">十进制十六进制互转&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ig4gf2/1626622220096-39546f45-2018-4396-bbf6-7afd0158ca41.png" alt="">&lt;/p>
&lt;h1 id="为什么十六进制数字以-0x-开头">为什么十六进制数字以 0x 开头？&lt;a class="td-heading-self-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e5%8d%81%e5%85%ad%e8%bf%9b%e5%88%b6%e6%95%b0%e5%ad%97%e4%bb%a5-0x-%e5%bc%80%e5%a4%b4" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;a href="https://qastack.cn/programming/2670639/why-are-hexadecimal-numbers-prefixed-with-0x">https://qastack.cn/programming/2670639/why-are-hexadecimal-numbers-prefixed-with-0x&lt;/a>&lt;/p>
&lt;p>为什么十六进制数字以前缀&lt;code>0x&lt;/code>？我了解前缀的用法，但不了解&lt;code>0x&lt;/code>选择为什么的意义。&lt;/p>
&lt;p>现在，我意识到标题和文本提出了两个完全不同的问题。大多数答复都集中在标题中的问题上。文本中问题的答案很简单：“它没有任何意义，它只是一个前缀，告诉编译器整数以十六进制表示”。— &lt;a href="https://stackoverflow.comhttps//stackoverflow.com/users/282848/andreas-rejbrand">Andreas Rejbrand&lt;/a>&lt;/p>
&lt;p>为了学究，可能还会以两种不同的方式解释标题中的问题：1）“为什么十六进制数字以 0x 为前缀，而不是其他任何前缀或指示符？” 2）“为什么在输入十六进制数字时需要使用前缀？即使没有前缀，编译器肯定会识别 58A 为十六进制数字吗？” 对问题的第二种解释的答案很简单。“ 123”也是十六进制数。— &lt;a href="https://stackoverflow.comhttps//stackoverflow.com/users/282848/andreas-rejbrand">Andreas Rejbrand&lt;/a>&lt;/p>
&lt;h2 id="answers">Answers&lt;a class="td-heading-self-link" href="#answers" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>简单地说&lt;/strong>：在&lt;code>0&lt;/code>告诉它在处理一个恒定的（而不是一个标识符/保留字）的解析器。仍然需要指定数字基数：&lt;code>x&lt;/code>是任意选择。&lt;/p>
&lt;p>&lt;strong>长话短说&lt;/strong>：在 60 年代，流行的编程数字系统是十进制和_八进制_ -大型机每字节有 12、24 或 36 位，可以很好地将其除以 3 = log2（8）。&lt;/p>
&lt;p>BCPL 语言将语法&lt;code>8 1234&lt;/code>用于八进制数字。当 Ken Thompson 从 BCPL 创建 B 时，他改用了&lt;code>0&lt;/code>前缀。这很好，因为&lt;/p>
&lt;ol>
&lt;li>现在，整数常量始终由单个标记组成，&lt;/li>
&lt;li>解析器仍然可以立即告诉它有一个常数，&lt;/li>
&lt;li>解析器可以立即告诉基准（&lt;code>0&lt;/code>两个基准都相同），&lt;/li>
&lt;li>从数学上讲是理智的（&lt;code>00005 == 05&lt;/code>），&lt;/li>
&lt;li>不需要珍贵的特殊字符（如中的&lt;code>#123&lt;/code>）。&lt;/li>
&lt;/ol>
&lt;p>从 B 创建 C 时，就需要使用十六进制数字（PDP-11 具有 16 位字），并且以上所有点仍然有效。由于其他机器仍需要八进制数，&lt;code>0x&lt;/code>因此可以任意选择八进制数（&lt;code>00&lt;/code>可能被排除在尴尬之外）。&lt;/p>
&lt;p>C＃是 C 的后代，因此它继承了语法。
— &lt;a href="https://stackoverflow.com/users/398996/%c5%98r%c5%99ola">Řrřola&lt;/a>
&lt;a href="https://stackoverflow.com/programming/2670639/why-are-hexadecimal-numbers-prefixed-with-0x/4581351#4581351">source&lt;/a>&lt;/p>
&lt;hr>
&lt;p>我不认为&lt;code>0x&lt;/code>在&lt;code>00&lt;/code>为偏好/尴尬。&lt;code>00&lt;/code>会破坏现有代码。&lt;code>0010&lt;/code>如八进制一样&lt;code>8&lt;/code>，而&lt;code>0010&lt;/code>如十六进制一样&lt;code>16&lt;/code>。他们不能使用任何数字作为第二位数字指示符（&lt;code>8&lt;/code>或除外&lt;code>9&lt;/code>，也不具有与十六进制有关的任何意义），因此必须输入字母。剩下的就是&lt;code>0h&lt;/code>或&lt;code>0x&lt;/code>（&lt;strong>H&lt;/strong> e &lt;strong>X&lt;/strong>十进制）。从这一点来看，似乎真的回到了偏好。
— &lt;a href="https://stackoverflow.comhttps//stackoverflow.com/users/87234/gmannickg">GManNickG 2013 年&lt;/a>&lt;/p>
&lt;hr>
&lt;p>相关：&lt;a href="http://stackoverflow.com/questions/18987911/bcpl-octal-numerical-constants">stackoverflow.com/questions/18987911/&amp;hellip;&lt;/a>和&lt;a href="http://stackoverflow.com/questions/11483216/why-are-leading-zeroes-used-to-represent-octal-numbers">stackoverflow.com/questions/11483216/&amp;hellip;&lt;/a>
— &lt;a href="https://stackoverflow.comhttps//stackoverflow.com/users/398996/%c5%98r%c5%99ola">Řrřola&lt;/a>&lt;/p>
&lt;hr>
&lt;p>&lt;code>0&lt;/code>多年来，为八进制使用前缀已经引起了很多问题。尤其是在像英国这样的国家中，电话号码以开头&lt;code>0&lt;/code>。Javascript 和许多其他语言会将它们解析为八进制，在存储之前先处理数字。为了助兴，一个流行的数据库产品将_悄无声息_，如果数字包含在切换回十进制解析&lt;code>8&lt;/code>或&lt;code>9&lt;/code>。
— &lt;a href="https://stackoverflow.comhttps//stackoverflow.com/users/156755/basic">2015 年&lt;/a>&lt;/p>
&lt;hr>
&lt;p>12、24 和 36 也可以被 4 整除，那么为什么他们不想到十六进制呢？
— &lt;a href="https://stackoverflow.comhttps//stackoverflow.com/users/995714/phuclv">phuclv&lt;/a>&lt;/p>
&lt;hr>
&lt;p>@LưuVĩnhPhúc 可能是因为十六进制不是很重要。大多数时间的硬件，软件和文档都更适合八进制。BCPL 首先在&lt;a href="https://en.wikipedia.org/wiki/IBM_7090#IBM_7094">36 位 IBM 7094 上实现&lt;/a>，其指令格式分为两个 3 位部分和 2 个 15 位部分；6 位字符；和八进制文档。B 的早期实现是在 PDP-7（18 位）和 Honeywell GE-945（36 位，但具有 18 位寻址，并支持 6 和 9 位字节）上实现的。16 位 PDP-11 在 B 之后问世，因此对 B 的设计影响不大。
— &lt;a href="https://stackoverflow.comhttps//stackoverflow.com/users/3342206/8bittree">8bittree &amp;lsquo;17&lt;/a>&lt;/p>
&lt;hr>
&lt;p>&lt;em>注意：我不知道正确的答案，但以下只是我个人的猜测！&lt;/em>
如前所述，数字前的 0 表示它是八进制的：&lt;/p>
&lt;pre>&lt;code>04524 // octal, leading 0
&lt;/code>&lt;/pre>
&lt;p>想象一下，需要提出一个表示十六进制数字的系统，并注意我们正在 C 风格的环境中工作。以 h 结尾像汇编怎么样？不幸的是，您不能-它会允许您制作作为有效标识符的令牌（例如，您可以将变量命名为同一名称），这会带来一些令人讨厌的歧义。&lt;/p>
&lt;pre>&lt;code>8000h // hex
FF00h // oops - valid identifier! Hex or a variable or type named FF00h?
&lt;/code>&lt;/pre>
&lt;p>出于相同的原因，您不能以字符开头：&lt;/p>
&lt;pre>&lt;code>xFF00 // also valid identifier
&lt;/code>&lt;/pre>
&lt;p>使用散列可能被抛弃了，因为它与预处理器冲突：&lt;/p>
&lt;pre>&lt;code>#define ...
#FF00 // invalid preprocessor token?
&lt;/code>&lt;/pre>
&lt;p>最后，无论出于何种原因，他们决定将 x 放在前导 0 后面以表示十六进制。它是明确的，因为它仍以数字字符开头，因此不能成为有效的标识符，并且可能基于前导 0 的八进制约定。&lt;/p>
&lt;pre>&lt;code>0xFF00 // definitely not an identifier!
&lt;/code>&lt;/pre>
&lt;p>— &lt;a href="https://stackoverflow.com/users/177222/ashleysbrain">阿什莉·布莱恩&lt;/a>
&lt;a href="https://stackoverflow.com/programming/2670639/why-are-hexadecimal-numbers-prefixed-with-0x/2670983#2670983">source&lt;/a>&lt;/p>
&lt;hr>
&lt;p>有趣。我想他们可以使用前导 0 和后跟 h 表示十六进制。尾随的 h 可能已与类型说明符后缀混淆，例如 0xFF00l 与 0FF00hl
— &lt;a href="https://stackoverflow.comhttps//stackoverflow.com/users/4304/zdan">zdan 2010 年&lt;/a>&lt;/p>
&lt;hr>
&lt;p>该论点暗示使用前导零表示八进制数早于使用十六进制“ 0x”前缀。这是真的？
— &lt;a href="https://stackoverflow.comhttps//stackoverflow.com/users/282848/andreas-rejbrand">Andreas Rejbrand&lt;/a>&lt;/p>
&lt;hr>
&lt;p>它们不是同时被发明的吗？为什么会有一个而不是另一个呢？
— &lt;a href="https://stackoverflow.comhttps//stackoverflow.com/users/177222/ashleysbrain">AshleysBrain，2010 年&lt;/a>&lt;/p>
&lt;hr>
&lt;p>AshleysBrain 看到@Řrřola 的回答，说明为什么同时可能存在八进制而不是十六进制。
— &lt;a href="https://stackoverflow.comhttps//stackoverflow.com/users/428381/jv42">2012 年&lt;/a>&lt;/p>
&lt;hr>
&lt;p>@zdan 他们很久以前就使用过它。在 x86 Intel 汇编中，如果十六进制文字以字符开头，则必须始终以 0 为前缀。例如&lt;code>0xFFAB1234&lt;/code>必须写为&lt;code>0FFAB1234h&lt;/code>。我还记得我年轻时在 Pascal 的嵌入式 asm 中获得的代码 &lt;a href="http://stackoverflow.com/q/11733731/995714">stackoverflow.com/q/11733731/995714&lt;/a>&lt;/p>
&lt;p>— &lt;a href="https://stackoverflow.comhttps//stackoverflow.com/users/995714/phuclv">phuclv 2015 年&lt;/a>&lt;/p>
&lt;hr>
&lt;p>它是一个前缀，表示数字以十六进制表示，而不是以其他基数表示。C 编程语言使用它来告诉编译器。&lt;/p>
&lt;p>&lt;strong>例：&lt;/strong>&lt;/p>
&lt;p>&lt;code>0x6400&lt;/code>转换为 &lt;code>6*16^3 + 4*16^2 + 0*16^1 +0*16^0 = 25600.&lt;/code> 编译器读取时&lt;code>0x6400&lt;/code>，它借助&lt;strong>0x&lt;/strong> 术语了解数字为十六进制。通常我们可以通过（6400）16 或（6400）8 来理解或其他任何东西。&lt;/p>
&lt;p>对于&lt;strong>二进制文件&lt;/strong>，它将是：&lt;code>0b00000001&lt;/code>&lt;/p>
&lt;p>— &lt;a href="https://stackoverflow.com/users/2771859/loyola">洛伊拉&lt;/a>
&lt;a href="https://stackoverflow.com/programming/2670639/why-are-hexadecimal-numbers-prefixed-with-0x/30659240#30659240">source&lt;/a>&lt;/p>
&lt;hr>
&lt;p>从 C ++ 14 开始，二进制文字仅在 C ++中受支持，而在 C 中则完全不支持。
— &lt;a href="https://stackoverflow.comhttps//stackoverflow.com/users/673852/ruslan">Ruslan&lt;/a>&lt;/p>
&lt;hr>
&lt;p>这不能解释_原因_。特别是为什么您不能将第一个示例编写为&lt;code>x6400&lt;/code>？将&lt;code>x&lt;/code>仍然可以用来推断十六进制。
— &lt;a href="https://stackoverflow.comhttps//stackoverflow.com/users/4441547/aaron-franke">亚伦·弗兰克&lt;/a>&lt;/p>
&lt;hr>
&lt;p>前面的 0 表示以 2、8 或 16 为基数的数字。
在我看来，选择 0x 表示十六进制是因为&amp;rsquo;x&amp;rsquo;听起来像十六进制。
只是我的意见，但我认为这是有道理的。
美好的一天！
— &lt;a href="https://stackoverflow.com/users/7928450/johnny-low">约翰尼·洛&lt;/a>
&lt;a href="https://stackoverflow.com/programming/2670639/why-are-hexadecimal-numbers-prefixed-with-0x/43646862#43646862">source&lt;/a>&lt;/p></description></item></channel></rss>