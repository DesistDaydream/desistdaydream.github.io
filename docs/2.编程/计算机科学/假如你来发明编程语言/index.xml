<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>假如你来发明编程语言 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</link><description>Recent content in 假如你来发明编程语言 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/index.xml" rel="self" type="application/rss+xml"/><item><title>假如你来发明编程语言</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</guid><description>原文链接: 公众号 - 码农的荒岛求生, 假如你来发明编程语言
聪明的人类发现把简单的开关组合起来可以表达复杂的bool逻辑，在此基础之上构建了 CPU ，因此 CPU 只能简单的理解开关，用数字表达就是0和1。
创世纪：聪明的笨蛋
CPU 相当原始，就像单细胞生物一样，只能把数据从一个地方搬到另一个地方、简单的加一下，没有任何高难度动作，这些操作虽然看上去很简单很笨，但 CPU 有一个无与伦比的优势，那就是一个字：快，这是人类比不了了的，CPU 出现后人类开始拥有第二个大脑。
就是这样原始的一个物种开始支配起另一个叫做程序员的物种。
干活的是大爷 一般来说两个不同的物种要想交流，比如人和鸟，就会有两种方式：要不就是鸟说人话，让人听懂；要不就是人说鸟语，让鸟听懂；就看谁厉害了。
最开始 CPU 胜出，程序员开始说鸟语并认真感受 CPU 的支配地位，好让 CPU 大爷可以工作，感受一下最开始的程序员是怎么说鸟语的：
程序员按照 CPU 的旨意直接用0和1编写指令，你没有看错，这破玩意就是代码了，就是这么原生态，然后放到打孔纸带上输入给CPU，CPU 开始工作，这时的程序可真的是看得见摸得着，就是有点浪费纸。
这时程序员必须站在 CPU 的角度来写代码，画风是这样的：
`1101101010011010``1001001100101001``1100100011011110``1011101101010010` 乍一看你知道这是什么意思吗？你不知道，心想：“这是什么破玩意？”，但 CPU 知道，心想“这就简直就是世界上最美的语言”。
天降大任 终于有一天程序员受够了说鸟语，好歹也是灵长类，叽叽喳喳说鸟语太没面子，你被委以重任：让程序员说人话。
你没有苦其心志劳其筋骨，而是仔细研究了一下 CPU，发现 CPU 执行的指令集来来回回就那么几个指令，比如加法指令、跳转指令等等，因此你把机器指令和对应的具体操作做了一个简单的映射，把机器指令映射到人类能看懂的单词，这样上面的01串就变成了：
sub $8, %rsp mov $.LC0, %edi call puts mov $0, %eax 这样，程序员不必生硬的记住1011&amp;hellip;..，而是记住人类可以认识的ADD SUB MUL DIV等这样的单词即可。
汇编语言就这样诞生了，编程语言中首次出现了人类可以认识的东西。
这时程序员终于不用再“叽叽喳喳。。”，而是升级为“阿巴阿巴。。”，虽然人类认知“阿巴阿巴”这几个字，但这和人类的语言在形式上差别还是有点大。
细节 VS 抽象 尽管汇编语言已经有人类可以认识的单词，但汇编语言和机器语言一样都属于低级语言。
所谓低级语言是说你需要关心所有细节。
关心什么细节呢？我们说过，CPU 是非常原始的东西，只知道把数据从一个地方搬到另一个地方，简单的操作一下再从一个地方搬到另一地方。
因此，如果你想用低级语言来编程的话，你需要使用多个“把数据从一个地方搬到另一个地方，简单的操作一下再从一个地方搬到另一地方”这样的简单指令来实现诸如排序这样复杂的问题。
有的同学可能对此感触不深，这就好比，本来你想表达“去给我端杯水过来”：
如果你用汇编这种低级语言就得这样实现：</description></item><item><title>Generic</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Generic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Generic/</guid><description>概述 参考：
Wiki, Generic proramming(泛型编程) Generic(泛型) 编程是一种计算机编程的风格，在这种风格中，程序中的数据类型是不固定的（i.e. 广泛的类型），若想让这种不固定的类型固定下来，需要为其提供 类型参数 以便固定成具体的类型。这种编程风格由 1973 年的 ML 编程语言首创，允许编写通用函数或类型，这些函数或类型在使用时仅在操作的类型集上有所不同，从而减少了重复代码。
Generic 也可以看做是以一种特殊的数据类型，就像 string、int 等等数据类型一样，除了具备 Data type 的能力，还多了变化的能力。
假如现在有如下函数：
func g&amp;lt;T any&amp;gt;(i T){ print(typeof(i)) } 其中函数多了 &amp;lt;T any&amp;gt; 这部分，这就表明，这个函数中使用了泛型，这个广泛的类型标识符为 T（就像字符串的标识符为 string 之类的一样），可以让自己变成 any(任意) 的类型。
有的语言，比如 Go 语言，不是使用 [ ] 符号而不是 &amp;lt; &amp;gt; 来标识泛型语法。
此时我们调用 g 函数
g&amp;lt;int&amp;gt;(1) g&amp;lt;string&amp;gt;(&amp;#34;1&amp;#34;) g&amp;lt;int&amp;gt;(1) 输出的结果为 int，g&amp;lt;string&amp;gt;(&amp;quot;string&amp;quot;) 输出的结果为 string。此时，调用是使用的 &amp;lt; &amp;gt; 可以理解为约束，就是让 g 函数中的 T 变为指定的类型。
比如使用 g&amp;lt;int&amp;gt;(1) 调用 g 函数时，这个函数相当于变成了 func g(i int){ print(typeof(i)) }。</description></item><item><title>锁</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E9%94%81/</guid><description>概述 参考：
公众号-小林coding，面试官：你说说互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景 互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景 前言 生活中用到的锁，用途都比较简单粗暴，上锁基本是为了防止外人进来、电动车被偷等等。
但生活中也不是没有 BUG 的，比如加锁的电动车在「广西 - 窃·格瓦拉」面前，锁就是形同虚设，只要他愿意，他就可以轻轻松松地把你电动车给「顺走」，不然打工怎么会是他这辈子不可能的事情呢？牛逼之人，必有牛逼之处。
那在编程世界里，「锁」更是五花八门，多种多样，每种锁的加锁开销以及应用场景也可能会不同。
如何用好锁，也是程序员的基本素养之一了。
高并发的场景下，如果选对了合适的锁，则会大大提高系统的性能，否则性能会降低。
所以，知道各种锁的开销，以及应用场景是很有必要的。
接下来，就谈一谈常见的这几种锁：
正文 多线程访问共享资源的时候，避免不了资源竞争而导致数据错乱的问题，所以我们通常为了解决这一问题，都会在访问共享资源之前加锁。
最常用的就是互斥锁，当然还有很多种不同的锁，比如自旋锁、读写锁、乐观锁等，不同种类的锁自然适用于不同的场景。
如果选择了错误的锁，那么在一些高并发的场景下，可能会降低系统的性能，这样用户体验就会非常差了。
所以，为了选择合适的锁，我们不仅需要清楚知道加锁的成本开销有多大，还需要分析业务场景中访问的共享资源的方式，再来还要考虑并发访问共享资源时的冲突概率。
对症下药，才能减少锁对高并发性能的影响。
那接下来，针对不同的应用场景，谈一谈「互斥锁、自旋锁、读写锁、乐观锁、悲观锁」的选择和使用。
互斥锁与自旋锁：谁更轻松自如？ 最底层的两种就是会「互斥锁和自旋锁」，有很多高级的锁都是基于它们实现的，你可以认为它们是各种锁的地基，所以我们必须清楚它俩之间的区别和应用。
加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。
当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：
互斥锁加锁失败后，线程会释放 CPU ，给其他线程； 自旋锁加锁失败后，线程会忙等待，直到它拿到锁； 互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞。
对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。如下图：
所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。
那这个开销成本是什么呢？会有两次线程上下文切换的成本：
当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行； 接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。 线程的上下文切换的是什么？当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。
上下切换的耗时有大佬统计过，大概在几十纳秒到几微秒之间，如果你锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长。
所以，如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。
自旋锁是通过 CPU 提供的 CAS 函数（Compare And Swap），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。
一般加锁的过程，包含两个步骤：
第一步，查看锁的状态，如果锁是空闲的，则执行第二步； 第二步，将锁设置为当前线程持有； CAS 函数就把这两个步骤合并成一条硬件级指令，形成原子指令，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。</description></item><item><title>Coroutine(协程)</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Coroutine%E5%8D%8F%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Coroutine%E5%8D%8F%E7%A8%8B/</guid><description>概述 参考：
Wiki, Coroutine 协程，被我玩会了！ Coroutine(协程) 是计算机程序组件，通过允许暂停和恢复执行来概括非抢占式多任务处理的子程序。协程非常适合实现熟悉的程序组件，例如协作任务、异常、事件循环、迭代器、无限列表和管道。
协程，被我玩会了 前言
大家好，我的朋友们！
干了这么年后端，写过C/C++、Python、Go，每次说到协程的时候，脑海里就只能浮现一些关键字yeild、async、go等等。
但是对于协程这个知识点，我理解的一直比较模糊，于是决定搞清楚。
全文阅读预计耗时10分钟，少刷几个小视频的时间，多学点知识，想想就很划算噻！
协程概念的诞生 先抛一个粗浅的结论：协程从广义来说是一种设计理念，我们常说的只是具体的实现。
理解好思想，技术点就很简单了，关于协程道与术的区别：
上古神器COBOL 协程概念的出现比线程更早，甚至可以追溯到20世纪50年代，提协程就必须要说到一门生命力极强的最早的高级编程语言COBOL。
最开始我以为COBOL这门语言早就消失在历史长河中，但是我错了。
COBOL语言，是一种面向过程的高级程序设计语言，主要用于数据处理，是国际上应用最广泛的一种高级语言。COBOL是英文Common Business-Oriented Language的缩写，原意是面向商业的通用语言。
截止到今年在全球范围内大约有1w台大型机中有3.8w+遗留系统中约2000亿行代码是由COBOL写的，占比高达65%，同时在美国很多政府和企业机构都是基于COBOL打造的，影响力巨大。
时间拉回1958年，美国计算机科学家梅尔文·康威(Melvin Conway)就开始钻研基于磁带存储的COBOL的编译器优化问题，这在当时是个非常热门的话题，不少青年才俊都扑进去了，包括图灵奖得主唐纳德·尔文·克努斯教授(Donald Ervin Knuth)也写了一个优化后的编译器。
看看这两位的简介，我沉默了：
梅尔文·康威(Melvin Conway)也是一位超级大佬，著名的康威定律提出者。
唐纳德·尔文·克努斯是算法和程序设计技术的先驱者，1974年的图灵奖得主，计算机排版系统TeX和字型设计系统METAFONT的发明者，他因这些成就和大量创造性的影响深远的著作而誉满全球，《计算机程序设计的艺术》被《美国科学家》杂志列为20世纪最重要的12本物理科学类专著之一。
那究竟是什么问题让这群天才们投入这么大的精力呢？快来看看！
COBOL编译器的技术难题 我们都是知道高级编程语言需要借助编译器来生成二进制可执行文件，编译器的基本步骤包括：读取字符流、词法分析、语法分析、语义分析、代码生成器、代码优化器等。
这种管道式的流程，上一步的输出作为下一步的输入，将中间结果存储在内存即可，这在现代计算机上毫无压力，但是受限于软硬件水平，在几十年前的COBOL语言却是很难的。
在1958年的时候，当时的存储还不发达，磁带作为存储器是1951年在计算机中得到应用的，所以那个时代的COBOL很依赖于磁带。
其实，我在网上找了很多资料去看当时的编译器有什么问题，只找到了一条：编译器无法做到读一次磁带就可以完成整个编译过程，也就是所谓的one-pass编译器还没有产生。
当时的COBOL程序被写在一个磁带上，而磁带不支持随机读写，只能顺序读，而当时的内存又不可能把整个磁带的内容都装进去，所以一次读取没编译完就要再从头读。
于是，我脑补了COBOL编译器和磁带之间可能的两种multi-pass形式的交互情况：
可能情况一 对于COBOL的编译器来说，要完成词法分析、语法分析就要从磁带上读取程序的源代码，在之前的编译器中词法分析和语法分析是相互独立的，这就意味着： 词法分析时需要将磁带从头到尾过一遍 语法分析时需要将磁带从头到尾过一遍 可能情况二 听过磁带的朋友们一定知道磁带的两个基本操作：倒带和快进。 在完成编译器的词法分析和语法分析两件事情时，需要磁带反复的倒带和快进去寻找两类分析所需的部分，类似于磁盘的寻道，磁头需要反复移动横跳，并且当时的磁带不一定支持随机读写。
从一些资料可以看到，COBOL当时编译器各个环节相互独立的，这种软硬件的综合限制导致无法实现one-pass编译。
协同式解决方案 在梅尔文·康威的编译器设计中将词法分析和语法分析合作运行，而不再像其他编译器那样相互独立，两个模块交织运行，编译器的控制流在词法分析和语法分析之间来回切换：
当词法分析模块基于词素产生足够多的词法单元Token时就控制流转给语法分析 当语法分析模块处理完所有的词法单元Token时将控制流转给词法分析模块 词法分析和语法分析各自维护自身的运行状态，并且具备主动让出和恢复的能力 可以看到这个方案的核心思想在于：
梅尔文·康威构建的这种协同工作机制，需要参与者让出（yield）控制流时，记住自身状态，以便在控制流返回时能从上次让出的位置恢复（resume）执行。简言之，协程的全部精神就在于控制流的主动让出和恢复。
这种协作式的任务流和计算机中断非常像，在当时条件的限制下，由梅尔文·康威提出的这种让出/恢复模式的协作程序被认为是最早的协程概念，并且基于这种思想可以打造新的COBOL编译器。
在1963年，梅尔文·康威也发表了一篇论文来说明自己的这种思想，虽然半个多世纪过去了，有幸我还是找到了这篇论文：
https://melconway.com/Home/pdf/compiler.pdf
说实话这paper真是有点难，时间过于久远，很难有共鸣，最后我放弃了，要不然我或许能搞明白之前编译器的具体问题了。
怀才不遇的协程 虽然协程概念出现的时间比线程还要早，但是协程一直都没有正是登上舞台，真是有点怀才不遇的赶脚。
我们上学的时候，老师就讲过一些软件设计思想，其中主流语言崇尚自顶向下top-down的编程思想:
对要完成的任务进行分解，先对最高层次中的问题进行定义、设计、编程和测试，而将其中未解决的问题作为一个子任务放到下一层次中去解决。
这样逐层、逐个地进行定义、设计、编程和测试，直到所有层次上的问题均由实用程序来解决，就能设计出具有层次结构的程序。
C语言就是典型的top-down思想的代表，在main函数作为入口，各个模块依次形成层次化的调用关系，同时各个模块还有下级的子模块，同样有层次调用关系。
但是协程这种相互协作调度的思想和top-down是不合的，在协程中各个模块之间存在很大的耦合关系，并不符合高内聚低耦合的编程思想，相比之下top-down使程序结构清晰、层次调度明确，代码可读性和维护性都很不错。
与线程相比，协作式任务系统让调用者自己来决定什么时候让出，比操作系统的抢占式调度所需要的时间代价要小很多，后者为了能恢复现场会在切换线程时保存相当多的状态，并且会非常频繁地进行切换，资源消耗更大。
综合来说，协程完全是用户态的行为，由程序员自己决定什么时候让出控制权，保存现场和切换恢复使用的资源也非常少，同时对提高处理器效率来说也是完全符合的。
那么不禁要问：协程看着不错，为啥没成为主流呢？
协程的思想和当时的主流不符合 抢占式的线程可以解决大部分的问题，让使用者感受的痛点不足 换句话说：协程能干的线程干得也不错，线程干的不好的地方，使用者暂时也不太需要，所以协程就这样怀才不遇了。</description></item><item><title>FIFO与FILO</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/FIFO%E4%B8%8EFILO/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/FIFO%E4%B8%8EFILO/</guid><description>概述 参考：
Wiki, FIFO(先进先出) Wiki, Heap(堆) Wiki, LIFO(后进先出) 与 Wiki,Stack(栈) 两个概念被 Wiki 合并了 知乎，https://www.zhihu.com/question/438782731 first in,first out(先进先出，简称 FIFO) 与 last in,firtst out(后进先出，简称 LIFO) 在计算机科学中，是两种有组织得操作结构化数据的方法。很多时候，FIFO 也称为 Stack(栈)，LIFO 也称为 Queue(队列)。
注意：也可以说是是两种抽象的数据类型。但是这里的抽象数据类型，并不是指编程语言中的抽象数据类型。而是一种设计理念、设计思路。
FIFO
考虑火车票购票系统，我们假设系统同时只能处理 40 个买票请求。那么当系统在处理 40 个请求时，来了第 41 个请求，系统就需要把这个请求缓存起来。同样，在这一过程中如果来了第 42、第 43、……第 1000 个请求，系统也需要把这些请求缓存起来。 当系统处理完毕一个请求后，有 39 个请求尚在处理，系统能够处理一个新的请求。于是系统就需要从自己的缓存里挑一个请求来处理。而此时缓存里有第 41 至第 1000 个请求，系统应该挑选哪一个请求来处理呢？按照先到先得的朴素排队的想法，系统理应挑选并处理第 41 个请求。 在这种情况下，如果将系统的缓存设计为 FIFO，就能够很方便地实现上述调度策略。 LIFO
就好像你拿了十页论文，看完一页放桌子上一页，最后一页自然的就在最上面，也就是说你从桌子上拿到的第一张就是最后放在桌子上的一页。 也可以用叠牌子类比，把盘子叠一摞，那么当需要拿盘子的时候，最后叠上去的盘子是被先拿到的。</description></item><item><title>如何掌握所有的程序语言</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%A6%82%E4%BD%95%E6%8E%8C%E6%8F%A1%E6%89%80%E6%9C%89%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%A6%82%E4%BD%95%E6%8E%8C%E6%8F%A1%E6%89%80%E6%9C%89%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/</guid><description>原文链接：王垠，如何掌握所有的程序语言
对的，我这里要讲的不是如何掌握一种程序语言，而是所有的……
很多编程初学者至今还在给我写信请教，问我该学习什么程序语言，怎么学习。由于我知道如何掌握“所有”的程序语言，总是感觉这种该学“一种”什么语言的问题比较低级，所以一直没来得及回复他们 :P 可是逐渐的，我发现原来不只是小白们有这个问题，就连美国大公司的很多资深工程师，其实也没搞明白。
今天我有动力了，想来统一回答一下这个搁置已久的“初级问题”。类似的话题貌似曾经写过，然而现在我想把它重新写一遍。因为在跟很多人交流之后，我对自己头脑中的（未转化为语言的）想法，有了更精准的表达。
如果你存在以下的种种困惑，那么这篇文章也许会对你有所帮助：
你是编程初学者，不知道该选择什么程序语言来入门。 你是资深的程序员或者团队领导，对新出现的种种语言感到困惑，不知道该“投资”哪种语言。 你的团队为使用哪种程序语言争论不休，发生各种宗教斗争。 你追逐潮流采用了某种时髦的语言，结果两个月之后发现深陷泥潭，痛苦不堪…… 虽然我已经不再过问这些世事，然而无可置疑的现实是，程序语言仍然是很重要的话题，这个情况短时间内不会改变。程序员的岗位往往会要求熟悉某些语言，甚至某些奇葩的公司要求你“深入理解 OOP 或者 FP 设计模式”。对于在职的程序员，程序语言至今仍然是可以争得面红耳赤的宗教话题。它的宗教性之强，以至于我在批评和调侃某些语言（比如 Go 语言）的时候，有些人会本能地以为我是另外一种语言（比如 Java）的粉丝。
显然我不可能是任何一种语言的粉丝，我甚至不是 Yin 语言的粉丝 ;) 对于任何从没见过的语言，我都是直接拿起来就用，而不需要经过学习的过程。看了这篇文章，也许你会明白我为什么可以达到这个效果。理解了这里面的东西，每个程序员都应该可以做到这一点。嗯，但愿吧。
重视语言特性，而不是语言 很多人在乎自己或者别人是否“会”某种语言，对“发明”了某种语言的人倍加崇拜，为各种语言的孰优孰劣争得面红耳赤。这些问题对于我来说都是不存在的。虽然我写文章批评过不少语言的缺陷，在实际工作中我却很少跟人争论这些。如果有其它人在我身边争论，我甚至会戴上耳机，都懒得听他们说什么 ;) 为什么呢？我发现归根结底的原因，是因为我重视的是“语言特性”，而不是整个的“语言”。我能用任何语言写出不错的代码，就算再糟糕的语言也差不了多少。
任何一种“语言”，都是各种“语言特性”的组合。打个比方吧，一个程序语言就像一台电脑。它的牌子可能叫“联想”，或者“IBM”，或者“Dell”，或者“苹果”。那么，你可以说苹果一定比 IBM 好吗？你不能。你得看看它里面装的是什么型号的处理器，有多少个核，主频多少，有多少 L1 cache，L2 cache……，有多少内存和硬盘，显示器分辨率有多大，显卡是什么 GPU，网卡速度，等等各种“配置”。有时候你还得看各个组件之间的兼容性。
这些配置对应到程序语言里面，就是所谓“语言特性”。举一些语言特性的例子：
变量定义 算术运算 for 循环语句，while 循环语句 函数定义，函数调用 递归 静态类型系统 类型推导 lambda 函数 面向对象 垃圾回收 指针算术 goto 语句 这些语言特性，就像你在选择一台电脑的时候，看它里面是什么配置。选电脑的时候，没有人会说 Dell 一定是最好的，他们只会说这个型号里面装的是 Intel 的 i7 处理器，这个比 i5 的好，DDR3 的内存 比 DDR2 的快这么多，SSD 比磁盘快很多，ATI 的显卡是垃圾…… 如此等等。
程序语言也是一样的道理。对于初学者来说，其实没必要纠结到底要先学哪一种语言，再学哪一种。曾经有人给我发信问这种问题，纠结了好几个星期，结果一个语言都还没开始学。有这纠结的时间，其实都可以把他纠结过的语言全部掌握了。
初学者往往不理解，每一种语言里面必然有一套“通用”的特性。比如变量，函数，整数和浮点数运算，等等。这些是每个通用程序语言里面都必须有的，一个都不能少。你只要通过“某种语言”学会了这些特性，掌握这些特性的根本概念，就能随时把这些知识应用到任何其它语言。你为此投入的时间基本不会浪费。所以初学者纠结要“先学哪种语言”，这种时间花的很不值得，还不如随便挑一个语言，跳进去。</description></item></channel></rss>