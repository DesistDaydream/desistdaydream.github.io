<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦的站点 – 假如你来发明编程语言</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</link><description>Recent content in 假如你来发明编程语言 on 断念梦的站点</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 假如你来发明编程语言</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</guid><description>
&lt;p>原文链接: &lt;a href="https://mp.weixin.qq.com/s/jkvda7_orKdOwDPqx9W80w">公众号 - 码农的荒岛求生, 假如你来发明编程语言&lt;/a>&lt;/p>
&lt;p>聪明的人类发现把简单的开关组合起来可以表达复杂的bool逻辑，在此基础之上构建了 CPU ，因此 CPU 只能简单的理解开关，用数字表达就是0和1。&lt;/p>
&lt;p>&lt;strong>创世纪：聪明的笨蛋&lt;/strong>&lt;/p>
&lt;p>CPU 相当原始，就像单细胞生物一样，只能把数据从一个地方搬到另一个地方、简单的加一下，没有任何高难度动作，这些操作虽然看上去很简单很笨，但 CPU 有一个无与伦比的优势，那就是一个字：快，这是人类比不了了的，&lt;strong>CPU 出现后人类开始拥有第二个大脑&lt;/strong>。&lt;/p>
&lt;p>就是这样原始的一个物种开始支配起另一个叫做程序员的物种。&lt;/p>
&lt;h5 id="干活的是大爷">&lt;strong>干活的是大爷&lt;/strong>&lt;a class="td-heading-self-link" href="#%e5%b9%b2%e6%b4%bb%e7%9a%84%e6%98%af%e5%a4%a7%e7%88%b7" aria-label="Heading self-link">&lt;/a>&lt;/h5>
&lt;p>一般来说两个不同的物种要想交流，比如人和鸟，就会有两种方式：要不就是鸟说人话，让人听懂；要不就是人说鸟语，让鸟听懂；就看谁厉害了。&lt;/p>
&lt;p>最开始 CPU 胜出，程序员开始说鸟语并认真感受 CPU 的支配地位，好让 CPU 大爷可以工作，感受一下最开始的程序员是怎么说鸟语的：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/8g3rwJPmya3Viao5wgMmb6iacSNMUUJZoXPnvCk7C0aJ4ibsuyZ87DicJicPRCgRRum5Eer2YHAVatlP6OHxuz9vnAA/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>程序员按照 CPU 的旨意直接用0和1编写指令，你没有看错，这破玩意就是代码了，就是这么原生态，然后放到打孔纸带上输入给CPU，CPU 开始工作，这时的程序可真的是看得见摸得着，就是有点浪费纸。&lt;/p>
&lt;p>这时程序员必须站在 CPU 的角度来写代码，画风是这样的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>`1101101010011010``1001001100101001``1100100011011110``1011101101010010`
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>乍一看你知道这是什么意思吗？你不知道，心想：“这是什么破玩意？”，但 CPU 知道，心想“这就简直就是世界上最美的语言”。&lt;/p>
&lt;h5 id="天降大任">&lt;strong>天降大任&lt;/strong>&lt;a class="td-heading-self-link" href="#%e5%a4%a9%e9%99%8d%e5%a4%a7%e4%bb%bb" aria-label="Heading self-link">&lt;/a>&lt;/h5>
&lt;p>终于有一天程序员受够了说鸟语，好歹也是灵长类，叽叽喳喳说鸟语太没面子，你被委以重任：让程序员说人话。&lt;/p>
&lt;p>你没有苦其心志劳其筋骨，而是仔细研究了一下 CPU，发现 CPU 执行的指令集来来回回就那么几个指令，比如加法指令、跳转指令等等，因此你把机器指令和对应的具体操作做了一个简单的映射，&lt;strong>把机器指令映射到人类能看懂的单词&lt;/strong>，这样上面的01串就变成了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a40000">sub $8, %rsp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">mov&lt;/span> &lt;span style="color:#4e9a06">$.LC0, %edi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">call&lt;/span> &lt;span style="color:#4e9a06">puts&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a40000">mov $0, %eax&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样，程序员不必生硬的记住1011&amp;hellip;..，而是记住人类可以认识的ADD SUB MUL DIV等这样的单词即可。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya3Viao5wgMmb6iacSNMUUJZoXtFosSBGHBTnMv5YibnuPXWWA6S7p0mkgpicS1LjSzuRMRCxkib47GqaGg/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>汇编语言就这样诞生了，&lt;strong>编程语言中首次出现了人类可以认识的东西&lt;/strong>。&lt;/p>
&lt;p>这时程序员终于不用再“叽叽喳喳。。”，而是升级为“阿巴阿巴。。”，虽然人类认知“阿巴阿巴”这几个字，但这和人类的语言&lt;strong>在形式上&lt;/strong>差别还是有点大。&lt;/p>
&lt;h5 id="细节-vs-抽象">&lt;strong>细节 VS 抽象&lt;/strong>&lt;a class="td-heading-self-link" href="#%e7%bb%86%e8%8a%82-vs-%e6%8a%bd%e8%b1%a1" aria-label="Heading self-link">&lt;/a>&lt;/h5>
&lt;p>尽管汇编语言已经有人类可以认识的单词，但汇编语言和机器语言一样都属于低级语言。&lt;/p>
&lt;p>所谓低级语言是说你需要&lt;strong>关心所有细节&lt;/strong>。&lt;/p>
&lt;p>关心什么细节呢？我们说过，CPU 是非常原始的东西，只知道把数据从一个地方搬到另一个地方，简单的操作一下再从一个地方搬到另一地方。&lt;/p>
&lt;p>因此，如果你想用低级语言来编程的话，&lt;strong>你需要使用多个“把数据从一个地方搬到另一个地方，简单的操作一下再从一个地方搬到另一地方”这样的简单指令来实现诸如排序这样复杂的问题&lt;/strong>。&lt;/p>
&lt;p>有的同学可能对此感触不深，这就好比，本来你想表达“去给我端杯水过来”：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya3Viao5wgMmb6iacSNMUUJZoX3wdraL6AEZ8Ged2V1pGSibKSH1aqtfUloslEdkFuR3ia0icYHiaqMxxcTA/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>如果你用汇编这种低级语言就得这样实现：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya3Viao5wgMmb6iacSNMUUJZoX31MuN6ibKNhHQ7XpmCVdPj46TKACyJafnhrr5OJoffUDBzsVvEJJf8w/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>我想你已经 Get 到了。&lt;/p>
&lt;h5 id="弥补差异">&lt;strong>弥补差异&lt;/strong>&lt;a class="td-heading-self-link" href="#%e5%bc%a5%e8%a1%a5%e5%b7%ae%e5%bc%82" aria-label="Heading self-link">&lt;/a>&lt;/h5>
&lt;p>CPU 实在太简单了，简单到不能了理解任何稍微抽象一点诸如“给我端杯水”这样的东西，但人类天生习惯抽象化的表达，人类和机器的差距有办法来弥补吗？&lt;/p>
&lt;p>换句话说就是&lt;strong>有没有一种办法可以自动把人类抽象的表达转为 CPU 可以理解的具体实现&lt;/strong>，这显然可以极大增强程序员的生产力，现在，这个问题需要你来解决。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya3Viao5wgMmb6iacSNMUUJZoXZGt78ViaaUpFYWofUqL5ZuRgMkqcYDSdBlYV4srR2OhHcS6GJfic6GSg/640?wx_fmt=png" alt="">&lt;/p>
&lt;h5 id="套路都是套路">&lt;strong>套路，都是套路&lt;/strong>&lt;a class="td-heading-self-link" href="#%e5%a5%97%e8%b7%af%e9%83%bd%e6%98%af%e5%a5%97%e8%b7%af" aria-label="Heading self-link">&lt;/a>&lt;/h5>
&lt;p>思来想去你都不知道该怎么把人类的抽象自动转为 CPU 能理解的具体实现，就在要放弃的时候你又看了一眼 CPU 可以理解的一堆细节：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya3Viao5wgMmb6iacSNMUUJZoXcJ6ApyNumibjglzDGOpbjicFOLFGj99ePp6vFb9y9wlOgrYic2JA2XeBw/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>&lt;strong>电光火石之间灵光乍现，你发现了满满的套路，或者说模式&lt;/strong>。&lt;/p>
&lt;p>大部分情况下 CPU 执行的指令平铺直叙的，就像这样：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya3Viao5wgMmb6iacSNMUUJZoXDNTeCRdzfQmC1feibVUhmXibFCGjD4TQLNibRKjILmphPCgvH2ic9Ro2wA/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>这些都是告诉 CPU 完成某个特定动作，你给这些平铺直叙的指令起了个名字，姑且就叫陈述句吧，statement。&lt;/p>
&lt;p>除此之外，你还发现了这样的套路，那就是需要根据某种特定状态决定走哪段指令，这个套路在人看来就是“如果。。。就。。。否则。。就。。。”：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">***&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">blablabla&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">else&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">***&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>  &lt;span style="color:#000">blablabla&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在某些情况下还需要不断重复一些指令，这个套路看起来就是原地打转：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">while&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">***&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>  &lt;span style="color:#000">blablabla&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后就是这里有很多看起来差不多的指令，就像这里：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya3Viao5wgMmb6iacSNMUUJZoXyDicBxcMQt5oZLztXYED715IibZLT8QibHBGyKcqxjzsRR6q8XmpzMdWA/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>这些指令是重复的，只是个别细节有所差异，把这些差异提取出来，剩下的指令打包到一起，用一个代号来指定这些指令就好了，这要有个名字，就叫函数吧：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">func&lt;/span> &lt;span style="color:#f57900">abc&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>  &lt;span style="color:#000">blablabla&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在你发现了所有套路：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// 条件转移
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">***&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">blablabla&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">else&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">***&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">blablabla&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// 循环
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">while&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">***&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">blablabla&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// 函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000">func&lt;/span> &lt;span style="color:#f57900">abc&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>  &lt;span style="color:#000">blablabla&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>这些相比汇编语言已经有了质的飞跃，因为这已经和人类的语言非常接近了&lt;/strong>。&lt;/p>
&lt;p>接下来你发现自己面临两个问题：&lt;/p>
&lt;ol>
&lt;li>这里的blablabla该是什么呢？&lt;/li>
&lt;li>该怎样把上面的人类可以认识的字符串转换为 CPU 可以认识的机器指令&lt;/li>
&lt;/ol>
&lt;h5 id="盗梦空间">&lt;strong>盗梦空间&lt;/strong>&lt;a class="td-heading-self-link" href="#%e7%9b%97%e6%a2%a6%e7%a9%ba%e9%97%b4" aria-label="Heading self-link">&lt;/a>&lt;/h5>
&lt;p>你想起来了，上文说过大部分代码都是平铺直叙的陈述句，statement，这里的blablabla 仅仅就是一堆陈述句吗？&lt;/p>
&lt;p>显然不是，blablabla 可以是陈述句，当然也可以是条件转移if else，也可以是循环while，也可以是调用函数，这样才合理。&lt;/p>
&lt;p>虽然这样合理，很快你就发现了另一个严重的问题：&lt;/p>
&lt;p>blabalbla中可以包含 if else 等语句，&lt;strong>而 if else 等语句中又可以包含 blablabla，blablabla 中反过来又双可能会包含 if else 等语句，if else 等语句又双叒有可能会包含 blablabla，blablabla 又双叒叕可能会包含 if else 等语句。。。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya3Viao5wgMmb6iacSNMUUJZoXcI5CaicOBcgucsw7ylTXcYahzy8BAIwqZfIVIITVzepSZdpzWJ9PdJA/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>就像盗梦空间一样，一层梦中还有一层梦，梦中之梦，梦中之梦中之梦。。。一层嵌套一层，子子孙孙无穷匮也。。。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/8g3rwJPmya3Viao5wgMmb6iacSNMUUJZoXFCQNM7o8Be0z88cOglPqLfiaaiaAC4XAK1HIH0JxNHO8rRaHaO5vyKpw/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>此时你已经明显感觉脑细胞不够用了，这也太复杂了吧，绝望开始吞噬你，上帝以及老天爷啊，谁来救救我！&lt;/p>
&lt;p>此时你的高中老师过来拍了拍你的肩膀，递给了你一本高中数学课本，你恼羞成怒，给我这破玩意干什么，我现在想的问题这么高深，岂是一本破高中数学能解决的了的，抓过来一把扔在了地上。&lt;/p>
&lt;p>此时一阵妖风吹过，教材停留在了这样一页，上面有这样一个数列表达：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a40000">`&lt;/span>&lt;span style="color:#000">f&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">x&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">f&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">x&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">-&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span> &lt;span style="color:#000">f&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">x&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">-&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>&lt;span style="color:#a40000">`&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个递归公式在表达什么呢？f(x) 的值依赖 f(x-1)，f(x-1) 的值又依赖 f(x-2)，f(x-2) 的值又依赖。。。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya3Viao5wgMmb6iacSNMUUJZoXibffjInE0k2XPJcUgajA4M752wqWPuCOH5iaMDlOLmiauUM3ef1ACqE5Q/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>一层嵌套一层，梦中之梦，if 中嵌套 statement，statement 又可以嵌套 if。。。&lt;/p>
&lt;p>等一下，这不就是递归嘛，&lt;strong>上面看似无穷无尽的嵌套也可以用递归表达啊&lt;/strong>！&lt;/p>
&lt;p>你的数学老师仰天大笑，too young too simple，留下羞愧的你佛手而去，看似高科技的东西竟然用高中数学就解决了，一时震惊的目瞪狗带不知所措无地自容。&lt;/p>
&lt;p>有了递归这个概念加持，聪明的智商又开始占领高地了。&lt;/p>
&lt;h5 id="递归代码的本质">&lt;strong>递归：代码的本质&lt;/strong>&lt;a class="td-heading-self-link" href="#%e9%80%92%e5%bd%92%e4%bb%a3%e7%a0%81%e7%9a%84%e6%9c%ac%e8%b4%a8" aria-label="Heading self-link">&lt;/a>&lt;/h5>
&lt;p>不就是嵌套嘛，一层套一层嘛，递归天生就是来表达这玩意的 (&lt;strong>提示：这里的表达并不完备，真实的编程语言不会这么简单&lt;/strong>)：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#204a87;font-weight:bold">bool&lt;/span> &lt;span style="color:#000">statement&lt;/span> &lt;span style="color:#204a87;font-weight:bold">else&lt;/span> &lt;span style="color:#000">statement&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">for&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">while&lt;/span> &lt;span style="color:#204a87;font-weight:bold">bool&lt;/span> &lt;span style="color:#000">statement&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">statement&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000;font-weight:bold">|&lt;/span> &lt;span style="color:#204a87;font-weight:bold">for&lt;/span> &lt;span style="color:#000;font-weight:bold">|&lt;/span> &lt;span style="color:#000">statement&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面一层嵌套一层的盗梦空间原来可以这么简洁的几句表达出来啊，你给这几句表达起了高端的名字，&lt;strong>语法&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>数学，就是可以让一切都变得这么优雅&lt;/strong>。&lt;/p>
&lt;p>世界上所有的代码，不管有多么复杂最终都可以归结到语法上，原因也很简单，所有的代码都是按照语法的形式写出来的嘛。&lt;/p>
&lt;p>至此，你发明了真正的人类可以认识的编程语言。&lt;/p>
&lt;p>之前提到的第一个问题解决了，但仅仅有语言还是不够的。&lt;/p>
&lt;h5 id="让计算机理解递归">&lt;strong>让计算机理解递归&lt;/strong>&lt;a class="td-heading-self-link" href="#%e8%ae%a9%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%90%86%e8%a7%a3%e9%80%92%e5%bd%92" aria-label="Heading self-link">&lt;/a>&lt;/h5>
&lt;p>现在还差一个问题，怎样才能把这语言最终转化为 CPU 可以认识的机器指令呢？&lt;/p>
&lt;p>人类可以按照语法写出代码，这些代码其实就是一串字符，怎么让计算机也能认识用递归语法表达的一串字符呢？&lt;/p>
&lt;p>这是一项事关人类命运的事情，你不禁感到责任重大，但这最后一步又看似困难重重，你不禁仰天长叹，计算机可太难了。&lt;/p>
&lt;p>此时你的初中老师过来拍了拍你的肩膀，递给了你一本初中植物学课本，你恼羞成怒，给我这破玩意干什么，我现在想的问题这么高深，岂是一本破初中教科书能解决的了的，抓过来一把扔在了地上。&lt;/p>
&lt;p>此时又一阵妖风挂过，书被翻到了介绍树的一章，你望着这一页不禁发起呆来：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya3Viao5wgMmb6iacSNMUUJZoXdxoVZ3wqGwtiaMMkq7icQ15SmdeiaiaKmO3TQicYuMiaQ2wUDmPoKiaNh1nQA/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>树干下面是树枝，树枝下是树叶，树枝下也可以是树枝，树枝下还可以是树枝、吃葡萄不吐葡萄皮，不吃葡萄倒吐葡萄皮，哎？这句不对，回到上面这句，树干生树枝，树枝还可以生树枝，一层套一层、梦中之梦、子子孙孙无穷匮、高中数学老师，等一下，这也是递归啊！！！&lt;strong>我们可以把根据递归语法写出来的的代码用树来表示啊&lt;/strong>！&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya3Viao5wgMmb6iacSNMUUJZoXf8X6OdpiaLOYMicjeKdyaIhIvq6ibqdVPlnrUjuYSDAQnqviaib2ZPxPiafw/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>你的初中老师仰天大笑，图样图森破，看似高科技的东西竟然靠初中知识就解决了。&lt;/p>
&lt;h5 id="优秀的翻译官">&lt;strong>优秀的翻译官&lt;/strong>&lt;a class="td-heading-self-link" href="#%e4%bc%98%e7%a7%80%e7%9a%84%e7%bf%bb%e8%af%91%e5%ae%98" aria-label="Heading self-link">&lt;/a>&lt;/h5>
&lt;p>计算机处理编程语言时可以按照递归定义把代码用树的形式组织起来，由于这棵树是按照语法生成的，姑且就叫&lt;strong>语法树&lt;/strong>吧。&lt;/p>
&lt;p>现在代码被表示成了树的形式，你仔细观察后发现，其实叶子节点的表达是非常简单的，可以很简单的翻译成对应的机器指令，只要叶子节点翻译成了机器指令，&lt;strong>你就可以把此结果应用到叶子节点的父节点，父节点又可以把翻译结果引用到父节点的父节点，一层层向上传递，最终整颗树都可以翻译成具体的机器指令&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya3Viao5wgMmb6iacSNMUUJZoXvwNiasgnp2Q8nicJgqaXlnx51c9pal856WafuAicA9jFOxHoib2XydOJ9A/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>完成这个工作的程序也要有个名字，根据“&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247484768&amp;amp;idx=1&amp;amp;sn=049db350af9e5eea5cf3523ceb83f447&amp;amp;chksm=fcb9823ecbce0b28ca28d021e68c78138cde4a1b86ea7209c0c667d3d544d223d8b2aecbccec&amp;amp;scene=21#wechat_redirect">弄不懂原则&lt;/a>”，你给这个类似翻译的程序起了个不怎么响亮的名字，编译器，compiler。&lt;/p>
&lt;p>&lt;strong>现在你还觉得二叉树之类的数据结构没啥用吗&lt;/strong>？&lt;/p>
&lt;p>至此，你完成了一项了不起的发明创造，程序员可以用人类认识的东西来写代码，你编写的一个叫做编译器的程序负责将其翻译成 CPU 可以认识的机器指令。&lt;/p>
&lt;p>后人根据你的思想构建出了C/C++、以及后续的Java、Python，这些语言现在还有一帮人在用呢。&lt;/p>
&lt;h5 id="总结">&lt;strong>总结&lt;/strong>&lt;a class="td-heading-self-link" href="#%e6%80%bb%e7%bb%93" aria-label="Heading self-link">&lt;/a>&lt;/h5>
&lt;p>世界上所有的编程语言都是遵照特定语法来编写的，编译器根据该语言的语法将代码解析成语法树，遍历语法树生成机器指令(C/C++)或者字节码等(Java)，然后交给 CPU(或者虚拟机)来执行。&lt;/p>
&lt;p>也因此，高级语言的抽象表达能力很强，代价都是牺牲了对底层的控制能力，这就是为什么操作系统的一部分需要使用汇编语言编写，汇编语言对底层细节的强大控制力是高级语言替代不了的。&lt;/p>
&lt;p>&lt;strong>最后请注意&lt;/strong>，本文为通俗易懂讲解编程语言牺牲了严谨性，这里的语法没有体现函数、表达式等等，真实语言的语法远远比这里的复杂，此外关于编译器也不会直接把语法树翻译成机器语言，而是生成一种类似机器指令的中间语言，经过一系列复杂的优化后最终生成真正的机器指令，真实的编译器远比这里复杂。&lt;/p>
&lt;p>希望本文对大家理解编程语言有所帮助。&lt;/p>
&lt;h5 id="参考资料">参考资料&lt;a class="td-heading-self-link" href="#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99" aria-label="Heading self-link">&lt;/a>&lt;/h5>
&lt;ol>
&lt;li>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247483736&amp;amp;idx=1&amp;amp;sn=4da1eec64e42567a0fdf4ae6d4e9344e&amp;amp;chksm=fcb98606cbce0f10090d950ec468b0a1e28087cd158a850bc7dc4c262fd2612a319851987220&amp;amp;scene=21#wechat_redirect">&lt;strong>什么是程序？&lt;/strong>&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247484495&amp;amp;idx=1&amp;amp;sn=9dcccd7ba90c95ca967360a6aa15f396&amp;amp;chksm=fcb98311cbce0a076aa2844770b0e14a0c6b3c3ceeb5567fc288f84fec75bbe1962dee6fe531&amp;amp;scene=21#wechat_redirect">&lt;strong>编译器是如何工作的？&lt;/strong>&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247484528&amp;amp;idx=1&amp;amp;sn=e18146d87e23e8364ee9522367a4a4f1&amp;amp;chksm=fcb9832ecbce0a38fec44d3447f54ee70ae31147fb914df651a1e68696545ea452880915cec0&amp;amp;scene=21#wechat_redirect">&lt;strong>程序员应如何理解抽象？&lt;/strong>&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Docs: Generic</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Generic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Generic/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Generic_programming">Wiki，Generic proramming&lt;/a>(泛型编程)&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Generic(泛型)&lt;/strong> 编程是一种计算机编程的风格，在这种风格中，程序中的数据类型是不固定的（i.e. 广泛的类型），若想让这种不固定的类型固定下来，需要为其提供 &lt;strong>类型参数&lt;/strong> 以便固定成具体的类型。这种编程风格由 1973 年的 ML 编程语言首创，允许编写通用函数或类型，这些函数或类型在使用时仅在操作的类型集上有所不同，从而减少了重复代码。&lt;/p>
&lt;p>Generic 也可以看做是以一种特殊的数据类型，就像 string、int 等等数据类型一样，除了具备 &lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Data%20type/Data%20type.md">Data type&lt;/a> 的能力，还多了变化的能力。&lt;/p>
&lt;p>假如现在有如下函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>func g&amp;lt;T any&amp;gt;(i T){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(typeof(i))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中函数多了 &lt;code>&amp;lt;T any&amp;gt;&lt;/code> 这部分，这就表明，这个函数中使用了泛型，这个广泛的类型标识符为 T（就像字符串的标识符为 string 之类的一样），可以让自己变成 any(任意) 的类型。&lt;/p>
&lt;blockquote>
&lt;p>有的语言，比如 Go 语言，不是使用 &lt;code>[ ]&lt;/code> 符号而不是 &lt;code>&amp;lt; &amp;gt;&lt;/code> 来标识泛型语法。&lt;/p>
&lt;/blockquote>
&lt;p>此时我们调用 g 函数&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>g&amp;lt;int&amp;gt;(1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>g&amp;lt;string&amp;gt;(&amp;#34;1&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>g&amp;lt;int&amp;gt;(1)&lt;/code> 输出的结果为 int，&lt;code>g&amp;lt;string&amp;gt;(&amp;quot;string&amp;quot;)&lt;/code> 输出的结果为 string。此时，调用是使用的 &lt;code>&amp;lt; &amp;gt;&lt;/code> 可以理解为约束，就是让 g 函数中的 T 变为指定的类型。&lt;/p>
&lt;p>比如使用 &lt;code>g&amp;lt;int&amp;gt;(1)&lt;/code> 调用 g 函数时，这个函数相当于变成了 &lt;code>func g(i int){ print(typeof(i)) }&lt;/code>。&lt;/p>
&lt;h1 id="什么时候应该用泛型">什么时候应该用泛型？&lt;a class="td-heading-self-link" href="#%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e5%ba%94%e8%af%a5%e7%94%a8%e6%b3%9b%e5%9e%8b" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>Ian 给出了简要的泛型使用方针，当开发者发现自己多次编写完全相同的代码，而这些副本之间的唯一区别仅在于使用了不同类型，这时候便可以考虑使用类型参数。换句话说，即开发者应避免使用类型参数，直到发现自己要多次编写完全相同的代码。&lt;/p>
&lt;p>减少重复的代码&lt;/p>
&lt;ul>
&lt;li>重复代码可能造成的问题：
&lt;ul>
&lt;li>安全隐患。当多块相同的代码其中一块逻辑修改时，其他相同的逻辑都要修改才能保证整体逻辑一致，但是重复代码过多时，忘记修改某块代码是很难避免的&lt;/li>
&lt;li>不利于扩展。当有更多类型需要使用相同逻辑时，每次都要重新写一遍，不利于代码的可读性和可维护性。加重安全隐患。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: 锁</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E9%94%81/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/CqIXHowIDT1kxyBOO0x7TQ">公众号-小林coding，面试官：你说说互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="互斥锁自旋锁读写锁悲观锁乐观锁的应用场景">互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景&lt;a class="td-heading-self-link" href="#%e4%ba%92%e6%96%a5%e9%94%81%e8%87%aa%e6%97%8b%e9%94%81%e8%af%bb%e5%86%99%e9%94%81%e6%82%b2%e8%a7%82%e9%94%81%e4%b9%90%e8%a7%82%e9%94%81%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;h2 id="前言">前言&lt;a class="td-heading-self-link" href="#%e5%89%8d%e8%a8%80" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>生活中用到的锁，用途都比较简单粗暴，上锁基本是为了防止外人进来、电动车被偷等等。&lt;/p>
&lt;p>但生活中也不是没有 BUG 的，比如加锁的电动车在「广西 - 窃·格瓦拉」面前，锁就是形同虚设，只要他愿意，他就可以轻轻松松地把你电动车给「顺走」，不然打工怎么会是他这辈子不可能的事情呢？牛逼之人，必有牛逼之处。&lt;/p>
&lt;p>那在编程世界里，「锁」更是五花八门，多种多样，每种锁的加锁开销以及应用场景也可能会不同。&lt;/p>
&lt;p>如何用好锁，也是程序员的基本素养之一了。&lt;/p>
&lt;p>高并发的场景下，如果选对了合适的锁，则会大大提高系统的性能，否则性能会降低。&lt;/p>
&lt;p>所以，知道各种锁的开销，以及应用场景是很有必要的。&lt;/p>
&lt;p>接下来，就谈一谈常见的这几种锁：&lt;/p>
&lt;hr>
&lt;h2 id="正文">正文&lt;a class="td-heading-self-link" href="#%e6%ad%a3%e6%96%87" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>多线程访问共享资源的时候，避免不了资源竞争而导致数据错乱的问题，所以我们通常为了解决这一问题，都会在访问共享资源之前加锁。&lt;/p>
&lt;p>最常用的就是互斥锁，当然还有很多种不同的锁，比如自旋锁、读写锁、乐观锁等，不同种类的锁自然适用于不同的场景。&lt;/p>
&lt;p>如果选择了错误的锁，那么在一些高并发的场景下，可能会降低系统的性能，这样用户体验就会非常差了。&lt;/p>
&lt;p>所以，为了选择合适的锁，我们不仅需要清楚知道加锁的成本开销有多大，还需要分析业务场景中访问的共享资源的方式，再来还要考虑并发访问共享资源时的冲突概率。&lt;/p>
&lt;p>对症下药，才能减少锁对高并发性能的影响。&lt;/p>
&lt;p>那接下来，针对不同的应用场景，谈一谈「&lt;strong>互斥锁、自旋锁、读写锁、乐观锁、悲观锁&lt;/strong>」的选择和使用。&lt;/p>
&lt;h3 id="互斥锁与自旋锁谁更轻松自如">互斥锁与自旋锁：谁更轻松自如？&lt;a class="td-heading-self-link" href="#%e4%ba%92%e6%96%a5%e9%94%81%e4%b8%8e%e8%87%aa%e6%97%8b%e9%94%81%e8%b0%81%e6%9b%b4%e8%bd%bb%e6%9d%be%e8%87%aa%e5%a6%82" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>最底层的两种就是会「互斥锁和自旋锁」，有很多高级的锁都是基于它们实现的，你可以认为它们是各种锁的地基，所以我们必须清楚它俩之间的区别和应用。&lt;/p>
&lt;p>加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。&lt;/p>
&lt;p>当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>互斥锁&lt;/strong>加锁失败后，线程会&lt;strong>释放 CPU&lt;/strong> ，给其他线程；&lt;/li>
&lt;li>&lt;strong>自旋锁&lt;/strong>加锁失败后，线程会&lt;strong>忙等待&lt;/strong>，直到它拿到锁；&lt;/li>
&lt;/ul>
&lt;p>互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，&lt;strong>既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的&lt;/strong>。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lhfv25/1616161589122-9df29f82-6dbb-42b1-a184-1856f479de00.png" alt="">&lt;/p>
&lt;p>所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。&lt;/p>
&lt;p>那这个开销成本是什么呢？会有&lt;strong>两次线程上下文切换的成本&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；&lt;/li>
&lt;li>接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。&lt;/li>
&lt;/ul>
&lt;p>线程的上下文切换的是什么？当两个线程是属于同一个进程，&lt;strong>因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。&lt;/strong>&lt;/p>
&lt;p>上下切换的耗时有大佬统计过，大概在几十纳秒到几微秒之间，如果你锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长。&lt;/p>
&lt;p>所以，&lt;strong>如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。&lt;/strong>&lt;/p>
&lt;p>自旋锁是通过 CPU 提供的 &lt;code>CAS&lt;/code> 函数（&lt;em>Compare And Swap&lt;/em>），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。&lt;/p>
&lt;p>一般加锁的过程，包含两个步骤：&lt;/p>
&lt;ul>
&lt;li>第一步，查看锁的状态，如果锁是空闲的，则执行第二步；&lt;/li>
&lt;li>第二步，将锁设置为当前线程持有；&lt;/li>
&lt;/ul>
&lt;p>CAS 函数就把这两个步骤合并成一条硬件级指令，形成&lt;strong>原子指令&lt;/strong>，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。&lt;/p>
&lt;p>使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 &lt;code>while&lt;/code> 循环等待实现，不过最好是使用 CPU 提供的 &lt;code>PAUSE&lt;/code> 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。&lt;/p>
&lt;p>自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。&lt;strong>需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。&lt;/strong>&lt;/p>
&lt;p>自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式，但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系，我们需要清楚的知道这一点。&lt;/p>
&lt;p>自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：&lt;strong>当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对&lt;/strong>。&lt;/p>
&lt;p>它俩是锁的最基本处理方式，更高级的锁都会选择其中一个来实现，比如读写锁既可以选择互斥锁实现，也可以基于自旋锁实现。&lt;/p>
&lt;hr>
&lt;h3 id="读写锁读和写还有优先级区分">读写锁：读和写还有优先级区分？&lt;a class="td-heading-self-link" href="#%e8%af%bb%e5%86%99%e9%94%81%e8%af%bb%e5%92%8c%e5%86%99%e8%bf%98%e6%9c%89%e4%bc%98%e5%85%88%e7%ba%a7%e5%8c%ba%e5%88%86" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>读写锁从字面意思我们也可以知道，它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。&lt;/p>
&lt;p>所以，&lt;strong>读写锁适用于能明确区分读操作和写操作的场景&lt;/strong>。&lt;/p>
&lt;p>读写锁的工作原理是：&lt;/p>
&lt;ul>
&lt;li>当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。&lt;/li>
&lt;li>但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。&lt;/li>
&lt;/ul>
&lt;p>所以说，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是共享锁，因为读锁可以被多个线程同时持有。&lt;/p>
&lt;p>知道了读写锁的工作原理后，我们可以发现，&lt;strong>读写锁在读多写少的场景，能发挥出优势&lt;/strong>。&lt;/p>
&lt;p>另外，根据实现的不同，读写锁可以分为「读优先锁」和「写优先锁」。&lt;/p>
&lt;p>读优先锁期望的是，读锁能被更多的线程持有，以便提高读线程的并发性，它的工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取写锁。如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lhfv25/1616161589150-a51670e3-254a-4c16-ad7e-57f7a7091d33.png" alt="">&lt;/p>
&lt;p>而写优先锁是优先服务写线程，其工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取读锁。如下图：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lhfv25/1616161589175-0b5eb87b-8bc4-4611-a2bd-d8e3c7bca821.png" alt="">&lt;/p>
&lt;p>读优先锁对于读线程并发性更好，但也不是没有问题。我们试想一下，如果一直有读线程获取读锁，那么写线程将永远获取不到写锁，这就造成了写线程「饥饿」的现象。&lt;/p>
&lt;p>写优先锁可以保证写线程不会饿死，但是如果一直有写线程获取写锁，读线程也会被「饿死」。&lt;/p>
&lt;p>既然不管优先读锁还是写锁，对方可能会出现饿死问题，那么我们就不偏袒任何一方，搞个「公平读写锁」。&lt;/p>
&lt;p>&lt;strong>公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。&lt;/strong>&lt;/p>
&lt;p>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。&lt;/p>
&lt;hr>
&lt;h3 id="乐观锁与悲观锁做事的心态有何不同">乐观锁与悲观锁：做事的心态有何不同？&lt;a class="td-heading-self-link" href="#%e4%b9%90%e8%a7%82%e9%94%81%e4%b8%8e%e6%82%b2%e8%a7%82%e9%94%81%e5%81%9a%e4%ba%8b%e7%9a%84%e5%bf%83%e6%80%81%e6%9c%89%e4%bd%95%e4%b8%8d%e5%90%8c" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。&lt;/p>
&lt;p>悲观锁做事比较悲观，它认为&lt;strong>多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁&lt;/strong>。&lt;/p>
&lt;p>那相反的，如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁。&lt;/p>
&lt;p>乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：&lt;strong>先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作&lt;/strong>。&lt;/p>
&lt;p>放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。&lt;/p>
&lt;p>可见，乐观锁的心态是，不管三七二十一，先改了资源再说。另外，你会发现&lt;strong>乐观锁全程并没有加锁，所以它也叫无锁编程&lt;/strong>。&lt;/p>
&lt;p>这里举一个场景例子：在线文档。&lt;/p>
&lt;p>我们都知道在线文档可以同时多人编辑的，如果使用了悲观锁，那么只要有一个用户正在编辑文档，此时其他用户就无法打开相同的文档了，这用户体验当然不好了。&lt;/p>
&lt;p>那实现多人同时编辑，实际上是用了乐观锁，它允许多个用户打开同一个文档进行编辑，编辑完提交之后才验证修改的内容是否有冲突。&lt;/p>
&lt;p>怎么样才算发生冲突？这里举个例子，比如用户 A 先在浏览器编辑文档，之后用户 B 在浏览器也打开了相同的文档进行编辑，但是用户 B 比用户 A 提交改动，这一过程用户 A 是不知道的，当 A 提交修改完的内容时，那么 A 和 B 之间并行修改的地方就会发生冲突。&lt;/p>
&lt;p>服务端要怎么验证是否冲突了呢？通常方案如下：&lt;/p>
&lt;ul>
&lt;li>由于发生冲突的概率比较低，所以先让用户编辑文档，但是浏览器在下载文档时会记录下服务端返回的文档版本号；&lt;/li>
&lt;li>当用户提交修改时，发给服务端的请求会带上原始文档版本号，服务器收到后将它与当前版本号进行比较，如果版本号一致则修改成功，否则提交失败。&lt;/li>
&lt;/ul>
&lt;p>实际上，我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。&lt;/p>
&lt;p>乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以&lt;strong>只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。&lt;/strong>&lt;/p>
&lt;hr>
&lt;h3 id="总结">总结&lt;a class="td-heading-self-link" href="#%e6%80%bb%e7%bb%93" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>开发过程中，最常见的就是互斥锁的了，互斥锁加锁失败时，会用「线程切换」来应对，当加锁失败的线程再次加锁成功后的这一过程，会有两次线程上下文切换的成本，性能损耗比较大。&lt;/p>
&lt;p>如果我们明确知道被锁住的代码的执行时间很短，那我们应该选择开销比较小的自旋锁，因为自旋锁加锁失败时，并不会主动产生线程切换，而是一直忙等待，直到获取到锁，那么如果被锁住的代码执行时间很短，那这个忙等待的时间相对应也很短。&lt;/p>
&lt;p>如果能区分读操作和写操作的场景，那读写锁就更合适了，它允许多个读线程可以同时持有读锁，提高了读的并发性。根据偏袒读方还是写方，可以分为读优先锁和写优先锁，读优先锁并发性很强，但是写线程会被饿死，而写优先锁会优先服务写线程，读线程也可能会被饿死，那为了避免饥饿的问题，于是就有了公平读写锁，它是用队列把请求锁的线程排队，并保证先入先出的原则来对线程加锁，这样便保证了某种线程不会被饿死，通用性也更好点。&lt;/p>
&lt;p>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。&lt;/p>
&lt;p>另外，互斥锁、自旋锁、读写锁都属于悲观锁，悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。&lt;/p>
&lt;p>相反的，如果并发访问共享资源时，冲突概率非常低的话，就可以使用乐观锁，它的工作方式是，在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。&lt;/p>
&lt;p>但是，一旦冲突概率上升，就不适合使用乐观锁了，因为它解决冲突的重试成本非常高。&lt;/p>
&lt;p>不管使用的哪种锁，我们的加锁的代码范围应该尽可能的小，也就是加锁的粒度要小，这样执行速度会比较快。再来，使用上了合适的锁，就会快上加快了。&lt;/p></description></item><item><title>Docs: Coroutine(协程)</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Coroutine%E5%8D%8F%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Coroutine%E5%8D%8F%E7%A8%8B/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Coroutine">Wiki，Coroutine&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/xGe51EVn2qw2Gojh7cZqUg">协程，被我玩会了！&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Coroutine(协程)&lt;/strong> 是计算机程序组件，通过允许暂停和恢复执行来概括非抢占式多任务处理的子程序。协程非常适合实现熟悉的程序组件，例如协作任务、异常、事件循环、迭代器、无限列表和管道。&lt;/p>
&lt;h1 id="协程被我玩会了">协程，被我玩会了&lt;a class="td-heading-self-link" href="#%e5%8d%8f%e7%a8%8b%e8%a2%ab%e6%88%91%e7%8e%a9%e4%bc%9a%e4%ba%86" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>前言&lt;/p>
&lt;p>大家好，我的朋友们！&lt;/p>
&lt;p>干了这么年后端，写过C/C++、Python、Go，每次说到协程的时候，脑海里就只能浮现一些关键字yeild、async、go等等。&lt;/p>
&lt;p>但是对于协程这个知识点，我理解的一直比较模糊，于是决定搞清楚。&lt;/p>
&lt;p>全文阅读预计耗时10分钟，少刷几个小视频的时间，多学点知识，想想就很划算噻！&lt;/p>
&lt;h2 id="协程概念的诞生">协程概念的诞生&lt;a class="td-heading-self-link" href="#%e5%8d%8f%e7%a8%8b%e6%a6%82%e5%bf%b5%e7%9a%84%e8%af%9e%e7%94%9f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>先抛一个粗浅的结论：&lt;strong>协程从广义来说是一种设计理念，我们常说的只是具体的实现&lt;/strong>。&lt;/p>
&lt;p>理解好思想，技术点就很简单了，关于协程道与术的区别：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaCDLNh7OoicyuQorqTdwUyGiauLRgqsjk2Btqn2GLm9LjLHtQtJOt8ICdH0HqnNerWMTTeGFOerdMQ/640?wx_fmt=png" alt="">&lt;/p>
&lt;h3 id="上古神器cobol">上古神器COBOL&lt;a class="td-heading-self-link" href="#%e4%b8%8a%e5%8f%a4%e7%a5%9e%e5%99%a8cobol" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>协程概念的出现比线程更早，甚至可以追溯到20世纪50年代，提协程就必须要说到一门生命力极强的最早的高级编程语言COBOL。&lt;/p>
&lt;p>最开始我以为COBOL这门语言早就消失在历史长河中，但是我错了。&lt;/p>
&lt;blockquote>
&lt;p>COBOL语言，是一种面向过程的高级程序设计语言，主要用于数据处理，是国际上应用最广泛的一种高级语言。COBOL是英文Common Business-Oriented Language的缩写，原意是面向商业的通用语言。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>截止到今年在全球范围内大约有1w台大型机中有3.8w+遗留系统中约2000亿行代码是由COBOL写的，占比高达65%，同时在美国很多政府和企业机构都是基于COBOL打造的，影响力巨大。&lt;/p>
&lt;/blockquote>
&lt;p>时间拉回1958年，美国计算机科学家梅尔文·康威(Melvin Conway)就开始钻研&lt;strong>基于磁带存储的COBOL的编译器优化问题&lt;/strong>，这在当时是个非常热门的话题，不少青年才俊都扑进去了，包括图灵奖得主唐纳德·尔文·克努斯教授(Donald Ervin Knuth)也写了一个优化后的编译器。&lt;/p>
&lt;p>看看这两位的简介，我沉默了：&lt;/p>
&lt;blockquote>
&lt;p>梅尔文·康威(Melvin Conway)也是一位超级大佬，著名的康威定律提出者。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaCDLNh7OoicyuQorqTdwUyGCQkspSX2ayibGUgaL5xfTuhiabwlL8UQIIVFDOLQLRib8ceRKW2KUFe9w/640?wx_fmt=png" alt="">&lt;/p>
&lt;blockquote>
&lt;p>唐纳德·尔文·克努斯是算法和程序设计技术的先驱者，1974年的图灵奖得主，计算机排版系统TeX和字型设计系统METAFONT的发明者，他因这些成就和大量创造性的影响深远的著作而誉满全球，《计算机程序设计的艺术》被《美国科学家》杂志列为20世纪最重要的12本物理科学类专著之一。&lt;/p>
&lt;/blockquote>
&lt;p>那究竟是什么问题让这群天才们投入这么大的精力呢？快来看看！&lt;/p>
&lt;h3 id="cobol编译器的技术难题">COBOL编译器的技术难题&lt;a class="td-heading-self-link" href="#cobol%e7%bc%96%e8%af%91%e5%99%a8%e7%9a%84%e6%8a%80%e6%9c%af%e9%9a%be%e9%a2%98" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>我们都是知道高级编程语言需要借助编译器来生成二进制可执行文件，编译器的基本步骤包括：&lt;strong>读取字符流、词法分析、语法分析、语义分析、代码生成器、代码优化器等&lt;/strong>。&lt;/p>
&lt;p>这种管道式的流程，上一步的输出作为下一步的输入，将中间结果存储在内存即可，这在现代计算机上毫无压力，但是受限于软硬件水平，在几十年前的COBOL语言却是很难的。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaCDLNh7OoicyuQorqTdwUyGcp9ib9TqFxv6AKLdNdGhGx25LiaaIKVoFE0P6aILlllKEI7L82ibkpfmg/640?wx_fmt=png" alt="">
在1958年的时候，当时的存储还不发达，磁带作为存储器是1951年在计算机中得到应用的，所以那个时代的COBOL很依赖于磁带。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaCDLNh7OoicyuQorqTdwUyGqjv4H2nvk4ibvc15tZ4wNjHvcnibyn13DdBibbcibv6tVDfp3cictsXyicMw/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>其实，我在网上找了很多资料去看当时的编译器有什么问题，只找到了一条：编译器无法做到读一次磁带就可以完成整个编译过程，也就是所谓的one-pass编译器还没有产生。&lt;/p>
&lt;blockquote>
&lt;p>当时的COBOL程序被写在一个磁带上，而磁带不支持随机读写，只能顺序读，而当时的内存又不可能把整个磁带的内容都装进去，所以一次读取没编译完就要再从头读。&lt;/p>
&lt;/blockquote>
&lt;p>于是，我脑补了COBOL编译器和磁带之间可能的两种multi-pass形式的交互情况：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>可能情况一&lt;/strong>&lt;br>
对于COBOL的编译器来说，要完成词法分析、语法分析就要从磁带上读取程序的源代码，在之前的编译器中词法分析和语法分析是相互独立的，这就意味着：
&lt;ul>
&lt;li>词法分析时需要将磁带从头到尾过一遍&lt;/li>
&lt;li>语法分析时需要将磁带从头到尾过一遍&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaCDLNh7OoicyuQorqTdwUyGRHpHibJs3xODVA6HmicuiagZK9Q0yJ0HQhAySjuLkakuxkhxicpfAqkXcQ/640?wx_fmt=png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>可能情况二&lt;/strong>&lt;br>
听过磁带的朋友们一定知道磁带的两个基本操作：倒带和快进。&lt;/li>
&lt;/ul>
&lt;p>在完成编译器的词法分析和语法分析两件事情时，需要磁带反复的倒带和快进去寻找两类分析所需的部分，类似于磁盘的寻道，磁头需要反复移动横跳，并且当时的磁带不一定支持随机读写。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaCDLNh7OoicyuQorqTdwUyGqXFmxghSTM3CuKia8ndCJUFYy9FvpH3hcrXGRhxMMOM9jf9CkNBCdBQ/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>从一些资料可以看到，COBOL当时编译器各个环节相互独立的，这种软硬件的综合限制导致无法实现one-pass编译。&lt;/p>
&lt;h3 id="协同式解决方案">协同式解决方案&lt;a class="td-heading-self-link" href="#%e5%8d%8f%e5%90%8c%e5%bc%8f%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>在梅尔文·康威的编译器设计中&lt;strong>将词法分析和语法分析合作运行，而不再像其他编译器那样相互独立，两个模块交织运行，编译器的控制流在词法分析和语法分析之间来回切换&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>当词法分析模块基于词素产生足够多的词法单元Token时就控制流转给语法分析&lt;/li>
&lt;li>当语法分析模块处理完所有的词法单元Token时将控制流转给词法分析模块&lt;/li>
&lt;li>词法分析和语法分析各自维护自身的运行状态，并且具备主动让出和恢复的能力&lt;/li>
&lt;/ul>
&lt;p>可以看到这个方案的核心思想在于：&lt;/p>
&lt;blockquote>
&lt;p>梅尔文·康威构建的这种协同工作机制，需要参与者让出（yield）控制流时，记住自身状态，以便在控制流返回时能从上次让出的位置恢复（resume）执行。简言之，&lt;code>协程的全部精神就在于控制流的主动让出和恢复&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaCDLNh7OoicyuQorqTdwUyGVSic9ndCE6uGGouj8HdadLbDVrKAU1pdzoDJ9k3DIz4Evz7fLQqkBRw/640?wx_fmt=png" alt="">
这种协作式的任务流和计算机中断非常像，在当时条件的限制下，由梅尔文·康威提出的这种让出/恢复模式的协作程序被认为是最早的协程概念，并且基于这种思想可以打造新的COBOL编译器。&lt;/p>
&lt;p>在1963年，梅尔文·康威也发表了一篇论文来说明自己的这种思想，虽然半个多世纪过去了，有幸我还是找到了这篇论文：&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://melconway.com/Home/pdf/compiler.pdf">https://melconway.com/Home/pdf/compiler.pdf&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaCDLNh7OoicyuQorqTdwUyGcEe2LhR59icibhXx7QXhaS7EeG2S9EQ6xchJw83wNq8T4aLad7SpUjcQ/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>说实话这paper真是有点难，时间过于久远，很难有共鸣，最后我放弃了，要不然我或许能搞明白之前编译器的具体问题了。&lt;/p>
&lt;h2 id="怀才不遇的协程">怀才不遇的协程&lt;a class="td-heading-self-link" href="#%e6%80%80%e6%89%8d%e4%b8%8d%e9%81%87%e7%9a%84%e5%8d%8f%e7%a8%8b" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>虽然协程概念出现的时间比线程还要早，但是协程一直都没有正是登上舞台，真是有点怀才不遇的赶脚。&lt;/p>
&lt;p>我们上学的时候，老师就讲过一些软件设计思想，其中主流语言崇尚自顶向下top-down的编程思想:&lt;/p>
&lt;blockquote>
&lt;p>对要完成的任务进行分解，先对最高层次中的问题进行定义、设计、编程和测试，而将其中未解决的问题作为一个子任务放到下一层次中去解决。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>这样逐层、逐个地进行定义、设计、编程和测试，直到所有层次上的问题均由实用程序来解决，就能设计出具有层次结构的程序。&lt;/p>
&lt;/blockquote>
&lt;p>C语言就是典型的top-down思想的代表，在main函数作为入口，各个模块依次形成层次化的调用关系，同时各个模块还有下级的子模块，同样有层次调用关系。&lt;/p>
&lt;p>但是&lt;strong>协程这种相互协作调度的思想和top-down是不合的，在协程中各个模块之间存在很大的耦合关系，并不符合高内聚低耦合的编程思想&lt;/strong>，相比之下top-down使程序结构清晰、层次调度明确，代码可读性和维护性都很不错。&lt;/p>
&lt;p>与线程相比，协作式任务系统让调用者自己来决定什么时候让出，比操作系统的抢占式调度所需要的时间代价要小很多，后者为了能恢复现场会在切换线程时保存相当多的状态，并且会非常频繁地进行切换，资源消耗更大。&lt;/p>
&lt;p>综合来说，&lt;strong>协程完全是用户态的行为，由程序员自己决定什么时候让出控制权，保存现场和切换恢复使用的资源也非常少，同时对提高处理器效率来说也是完全符合的&lt;/strong>。&lt;/p>
&lt;p>那么不禁要问：协程看着不错，为啥没成为主流呢？&lt;/p>
&lt;ul>
&lt;li>&lt;strong>协程的思想和当时的主流不符合&lt;/strong>&lt;/li>
&lt;li>&lt;strong>抢占式的线程可以解决大部分的问题，让使用者感受的痛点不足&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>换句话说：协程能干的线程干得也不错，线程干的不好的地方，使用者暂时也不太需要，所以协程就这样怀才不遇了。&lt;/p>
&lt;blockquote>
&lt;p>其实，协程虽然在x86架构上没有折腾出大风浪，由于抢占式任务系统依赖于CPU硬件的支持，对硬件要求比较高，对于一些嵌入式设备来说，协同调度再合适不过了，所以协程在另外一个领域也施展了拳脚。&lt;/p>
&lt;/blockquote>
&lt;h2 id="协程的雄起">协程的雄起&lt;a class="td-heading-self-link" href="#%e5%8d%8f%e7%a8%8b%e7%9a%84%e9%9b%84%e8%b5%b7" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>我们对于CPU的压榨从未停止。&lt;/strong>&lt;/p>
&lt;p>对于CPU来说，任务分为两大类：&lt;strong>计算密集型和IO密集型&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaCDLNh7OoicyuQorqTdwUyGPxCDuXCpCfVckpWDWrlOC4uMWzKhHXQKbHZLm2NDyyic3oM9hlcicia0g/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>计算密集型已经可以最大程度发挥CPU的作用，但是IO密集型一直是提高CPU利用率的难点。&lt;/p>
&lt;h3 id="io密集型任务之痛">IO密集型任务之痛&lt;a class="td-heading-self-link" href="#io%e5%af%86%e9%9b%86%e5%9e%8b%e4%bb%bb%e5%8a%a1%e4%b9%8b%e7%97%9b" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>对于IO密集型任务，在抢占式调度中也有对应的解决方案：&lt;strong>异步+回调&lt;/strong>。&lt;/p>
&lt;p>也就是遇到IO阻塞，比如下载图片时会立即返回，等待下载完成将结果进行回调处理，交付给发起者。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaCDLNh7OoicyuQorqTdwUyGDO9MJJ9mOH06j3ZsOwSu3iaRL5DgyjrrhrPiaib4SlicIgsdic2bLIqibeTA/640?wx_fmt=png" alt="">&lt;/p>
&lt;blockquote>
&lt;p>就像你常去早餐店，油条还没好，你和老板很熟悉就先交了钱去座位玩手机了，等你的油条好了，服务员就端过去了，这就是典型的异步+回调。&lt;/p>
&lt;/blockquote>
&lt;p>虽然异步+回调在现实生活中看着也很简单，但是在程序设计上却很让人头痛，在某些场景下会让整个程序的可读性非常差，而且也不好写，相反同步IO虽然效率低，但是很好写，&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaCDLNh7OoicyuQorqTdwUyGg7HWCBB2j543osFjTOKwFiceV0O26oHeZ4ZPFaZ1fw9MiaJXibIoIU99A/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>还是以为异步图片下载为例，图片服务中台提供了异步接口，发起者请求之后立即返回，图片服务此时给了发起者一个唯一标识ID，等图片服务完成下载后把结果放到一个消息队列，此时需要发起者不断消费这个MQ才能拿到下载结果。&lt;/p>
&lt;p>整个过程相比同步IO来说，&lt;strong>原来整体的逻辑被拆分为好几个部分，各个子部分有状态的迁移，对大部分程序员来说维护状态简直就是噩梦，日后必然是bug的高发地&lt;/strong>。&lt;/p>
&lt;h3 id="用户态协同调度">用户态协同调度&lt;a class="td-heading-self-link" href="#%e7%94%a8%e6%88%b7%e6%80%81%e5%8d%8f%e5%90%8c%e8%b0%83%e5%ba%a6" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>随着网络技术的发展和高并发要求，对于抢占式调度对IO型任务处理的低效逐渐受到重视，终于协程的机会来了。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaCDLNh7OoicyuQorqTdwUyGzExbg8HUogsIvHvZibuktYF0WkS7Aaefb0SAzibBpazHtUWX3EkNtJicA/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>协程将IO的处理权交给了程序员，遇到IO被阻塞时就交出控制权给其他协程，等其他协程处理完再把控制权交回来。&lt;/p>
&lt;p>&lt;strong>通过yield方式转移执行权的多个协程之间并非调用者和被调用者的关系，而是彼此平等、对称、合作的关系。&lt;/strong>&lt;/p>
&lt;p>协程一直没有占上风的原因，除了设计思想的矛盾，还有一些其他原因，毕竟协程也不是银弹，来看看协程有什么问题：&lt;/p>
&lt;ul>
&lt;li>协程无法利用多核，需要配合进程来使用才可以在多CPU上发挥作用&lt;/li>
&lt;li>线程的回调机制仍然有巨大生命力，协程无法全部替代&lt;/li>
&lt;li>控制权需要转移可能造成某些协程的饥饿，抢占式更加公平&lt;/li>
&lt;li>协程的控制权由用户态决定可能转移给某些恶意的代码，抢占式由操作系统来调度更加安全&lt;/li>
&lt;/ul>
&lt;p>综上来说，&lt;strong>协程和线程并非矛盾，协程的威力在于IO的处理，恰好这部分是线程的软肋，由对立转换为合作才能开辟新局面&lt;/strong>。&lt;/p>
&lt;h2 id="拥抱协程的编程语言">拥抱协程的编程语言&lt;a class="td-heading-self-link" href="#%e6%8b%a5%e6%8a%b1%e5%8d%8f%e7%a8%8b%e7%9a%84%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>网络操作、文件操作、数据库操作、消息队列操作等重IO操作，是任何高级编程语言无法避开的问题，也是提高程序效率的关键。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaCDLNh7OoicyuQorqTdwUyGBibic1h9zr0UphNrBzGEqLtIBVedyJs1StTwR2lmfwv58Fa8sAlnYPyw/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>像Java、C/C++、Python这些老牌语言也陆续开始借助于第三方包来支持协程，来解决自身语言的不足。&lt;/p>
&lt;p>像Golang这种新生选手，在语言层面原生支持了协程，可以说是彻底拥抱协程，这也造就了Go的高并发能力。&lt;/p>
&lt;p>我们来分别看看它们是怎么实现协程的，以及实现协程的关键点是什么。&lt;/p>
&lt;h3 id="python">Python&lt;a class="td-heading-self-link" href="#python" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>Python对协程的支持也经历了多个版本，从部分支持到完善支持一直在演进：&lt;/p>
&lt;ul>
&lt;li>Python2.x对协程的支持比较有限，生成器yield实现了一部分但不完全&lt;/li>
&lt;li>第三方库gevent对协程的实现有比较好，但不是官方的&lt;/li>
&lt;li>Python3.4加入了asyncio模块&lt;/li>
&lt;li>在Python3.5中又提供了async/await语法层面的支持&lt;/li>
&lt;li>Python3.6中asyncio模块更加完善和稳&lt;/li>
&lt;li>Python3.7开始async/await成为保留关键字&lt;/li>
&lt;/ul>
&lt;p>我们以最新的async/await来说明Python的协程是如何使用的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">import&lt;/span> &lt;span style="color:#000">asyncio&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">from&lt;/span> &lt;span style="color:#000">pathlib&lt;/span> &lt;span style="color:#204a87;font-weight:bold">import&lt;/span> &lt;span style="color:#000">Path&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">import&lt;/span> &lt;span style="color:#000">logging&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">from&lt;/span> &lt;span style="color:#000">urllib.request&lt;/span> &lt;span style="color:#204a87;font-weight:bold">import&lt;/span> &lt;span style="color:#000">urlopen&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">Request&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">import&lt;/span> &lt;span style="color:#000">os&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">from&lt;/span> &lt;span style="color:#000">time&lt;/span> &lt;span style="color:#204a87;font-weight:bold">import&lt;/span> &lt;span style="color:#000">time&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">import&lt;/span> &lt;span style="color:#000">aiohttp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">logging&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#000">basicConfig&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">level&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#000">logging&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#000">INFO&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87">format&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#39;&lt;/span>&lt;span style="color:#4e9a06">%(asctime)s&lt;/span>&lt;span style="color:#4e9a06"> - &lt;/span>&lt;span style="color:#4e9a06">%(name)s&lt;/span>&lt;span style="color:#4e9a06"> - &lt;/span>&lt;span style="color:#4e9a06">%(levelname)s&lt;/span>&lt;span style="color:#4e9a06"> - &lt;/span>&lt;span style="color:#4e9a06">%(message)s&lt;/span>&lt;span style="color:#4e9a06">&amp;#39;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">logger&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">logging&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#000">getLogger&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">__name__&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">CODEFLEX_IMAGES_URLS&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#4e9a06">&amp;#39;https://codeflex.co/wp-content/uploads/2021/01/pandas-dataframe-python-1024x512.png&amp;#39;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>                        &lt;span style="color:#4e9a06">&amp;#39;https://codeflex.co/wp-content/uploads/2021/02/github-actions-deployment-to-eks-with-kustomize-1024x536.jpg&amp;#39;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>                        &lt;span style="color:#4e9a06">&amp;#39;https://codeflex.co/wp-content/uploads/2021/02/boto3-s3-multipart-upload-1024x536.jpg&amp;#39;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>                        &lt;span style="color:#4e9a06">&amp;#39;https://codeflex.co/wp-content/uploads/2018/02/kafka-cluster-architecture.jpg&amp;#39;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>                        &lt;span style="color:#4e9a06">&amp;#39;https://codeflex.co/wp-content/uploads/2016/09/redis-cluster-topology.png&amp;#39;&lt;/span>&lt;span style="color:#000;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">async&lt;/span> &lt;span style="color:#204a87;font-weight:bold">def&lt;/span> &lt;span style="color:#000">download_image_async&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">session&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87">dir&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">img_url&lt;/span>&lt;span style="color:#000;font-weight:bold">):&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &lt;span style="color:#000">download_path&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#204a87">dir&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">/&lt;/span> &lt;span style="color:#000">os&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#000">path&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#000">basename&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">img_url&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &lt;span style="color:#204a87;font-weight:bold">async&lt;/span> &lt;span style="color:#204a87;font-weight:bold">with&lt;/span> &lt;span style="color:#000">session&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#000">get&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">img_url&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">as&lt;/span> &lt;span style="color:#000">response&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        &lt;span style="color:#204a87;font-weight:bold">with&lt;/span> &lt;span style="color:#000">download_path&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#000">open&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#39;wb&amp;#39;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">as&lt;/span> &lt;span style="color:#000">f&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>            &lt;span style="color:#204a87;font-weight:bold">while&lt;/span> &lt;span style="color:#204a87;font-weight:bold">True&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>                &lt;span style="color:#000">chunk&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">await&lt;/span> &lt;span style="color:#000">response&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#000">content&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#000">read&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">512&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>                &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#204a87;font-weight:bold">not&lt;/span> &lt;span style="color:#000">chunk&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>                    &lt;span style="color:#204a87;font-weight:bold">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>                &lt;span style="color:#000">f&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#000">write&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">chunk&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &lt;span style="color:#000">logger&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#000">info&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#39;Downloaded: &amp;#39;&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span> &lt;span style="color:#000">img_url&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">async&lt;/span> &lt;span style="color:#204a87;font-weight:bold">def&lt;/span> &lt;span style="color:#000">main&lt;/span>&lt;span style="color:#000;font-weight:bold">():&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &lt;span style="color:#000">images_dir&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">Path&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;codeflex_images&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &lt;span style="color:#000">Path&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;codeflex_images&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#000">mkdir&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">parents&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">False&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">exist_ok&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">True&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &lt;span style="color:#204a87;font-weight:bold">async&lt;/span> &lt;span style="color:#204a87;font-weight:bold">with&lt;/span> &lt;span style="color:#000">aiohttp&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#000">ClientSession&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#204a87;font-weight:bold">as&lt;/span> &lt;span style="color:#000">session&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        &lt;span style="color:#000">tasks&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000;font-weight:bold">[(&lt;/span>&lt;span style="color:#000">download_image_async&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">session&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">images_dir&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">img_url&lt;/span>&lt;span style="color:#000;font-weight:bold">))&lt;/span> &lt;span style="color:#204a87;font-weight:bold">for&lt;/span> &lt;span style="color:#000">img_url&lt;/span> &lt;span style="color:#204a87;font-weight:bold">in&lt;/span> &lt;span style="color:#000">CODEFLEX_IMAGES_URLS&lt;/span>&lt;span style="color:#000;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        &lt;span style="color:#204a87;font-weight:bold">await&lt;/span> &lt;span style="color:#000">asyncio&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#000">gather&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">tasks&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">return_exceptions&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">True&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">__name__&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">==&lt;/span> &lt;span style="color:#4e9a06">&amp;#39;__main__&amp;#39;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &lt;span style="color:#000">start&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">time&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>     
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &lt;span style="color:#000">event_loop&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">asyncio&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#000">get_event_loop&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &lt;span style="color:#204a87;font-weight:bold">try&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        &lt;span style="color:#000">event_loop&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#000">run_until_complete&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">main&lt;/span>&lt;span style="color:#000;font-weight:bold">())&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &lt;span style="color:#204a87;font-weight:bold">finally&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        &lt;span style="color:#000">event_loop&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#000">close&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &lt;span style="color:#000">logger&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#000">info&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#39;Download time: &lt;/span>&lt;span style="color:#4e9a06">%s&lt;/span>&lt;span style="color:#4e9a06"> seconds&amp;#39;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">time&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&lt;/span> &lt;span style="color:#000">start&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段代码展示了如何使用async/await来实现图片的并发下载功能。&lt;/p>
&lt;ul>
&lt;li>在普通的函数def前面加async关键字就变成异步/协程函数，调用该函数并不会运行，而是返回一个协程对象，后续在event_loop中执行&lt;/li>
&lt;li>await表示等待task执行完成，也就是yeild让出控制权，同时asyncio使用事件循环event_loop来实现整个过程，await需要在async标注的函数中使用&lt;/li>
&lt;li>event_loop事件循环充当管理者的角色，将控制权在几个协程函数之间切换&lt;/li>
&lt;/ul>
&lt;h3 id="c">C++&lt;a class="td-heading-self-link" href="#c" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>在C++20引入协程框架，但是很不成熟，换句话说是给写协程库的大佬用的最底层的东西，用起来就很复杂门槛比较高。&lt;/p>
&lt;p>C++作为高性能服务器开发语言的无冕之王，各大公司也做了很多尝试来使用协程功能，比如&lt;strong>boost.coroutine、微信的libco、libgo、云风用C实现的协程库&lt;/strong>等。&lt;/p>
&lt;p>说实话，C++协程相关的东西有点复杂，后面专门写一下，在此不展开了。&lt;/p>
&lt;h3 id="go">Go&lt;a class="td-heading-self-link" href="#go" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>go中的协程被称为goroutine，被认为是用户态更轻量级的线程，协程对操作系统而言是透明的，也就是操作系统无法直接调度协程，因此必须有个中间层来接管goroutine。&lt;/p>
&lt;p>goroutine仍然是基于线程来实现的，因为线程才是CPU调度的基本单位，在go语言内部维护了一组数据结构和N个线程，协程的代码被放进队列中来由线程来实现调度执行，这就是著名的GMP模型。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>G:Goroutine&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>每个Gotoutine对应一个G结构体，G存储Goroutine的运行堆栈，状态，以及任务函数，可重用函数实体G需要保存到P的队列或者全局队列才能被调度执行。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>M:machine&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>M是线程的抽象，代表真正执行计算的资源，在绑定有效的P后，进入调度执行循环，M会从P的本地队列来执行，&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>P:Processor&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>P是一个抽象的概念，不是物理上的CPU而是表示逻辑处理器。当一个P有任务，需要创建或者唤醒一个系统线程M去处理它队列中的任务。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>P决定同时执行的任务的数量，GOMAXPROCS限制系统线程执行用户层面的任务的数量。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>对M来说，P提供了相关的执行环境，入内存分配状态，任务队列等。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaCDLNh7OoicyuQorqTdwUyGR7hJicsy0COfOcvUMjR6HnN0pQIAwCicxpVBGUR2ZTwyqhmMqibdO7XTg/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>&lt;strong>GMP模型运行的基本过程&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>首先创建一个G对象，然后G被保存在P的本地队列或者全局队列&lt;/li>
&lt;li>这时P会唤醒一个M，M寻找一个空闲的P将G移动到它自己，然后M执行一个调度循环：调用G对象-&amp;gt;执行-&amp;gt;清理线程-&amp;gt;继续寻找Goroutine。&lt;/li>
&lt;li>在M的执行过程中，上下文切换随时发生。当切换发生，任务的执行现场需要被保护，这样在下一次调度执行可以进行现场恢复。&lt;/li>
&lt;li>M的栈保存在G对象，只有现场恢复需要的寄存器(SP,PC等)，需要被保存到G对象。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaCDLNh7OoicyuQorqTdwUyGTQlwhiazsx4UFgMficIvWacmkI2LD0CFnf8Evl3hIleT9kibBia2cK8ggA/640?wx_fmt=png" alt="">&lt;/p>
&lt;h2 id="总结">总结&lt;a class="td-heading-self-link" href="#%e6%80%bb%e7%bb%93" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>本文通过1960年对COBOL语言编译器的one-pass问题的介绍，让大家看到了协同式程序的最早背景以及主动让出/恢复的重要理念。&lt;/p>
&lt;p>紧接着介绍了主流的自顶向下的软件设计思想和协程思想的矛盾所在，并且抢占式程序调度的蓬勃发展，以及存在的问题。&lt;/p>
&lt;p>继续介绍了关于IO密集型任务对于提升CPU效率的阻碍，抢占式调度对于IO密集型问题的异步+回调的解决方案，以及协程的处理，展示了协程在IO密集型任务上处理的重大优势。&lt;/p>
&lt;p>最后说明了当前抢占式调度+协程IO密集型处理的方案，包括Python、C++和go的语言层面对于协程的支持和实现。&lt;/p>
&lt;p>本文特别具体的内容并不多，旨在介绍协程思想及其优势所在，对于各个语言的协程实现细节并未展开。&lt;/p>
&lt;p>最后依然是感谢大家的耐心阅读，我们下期见！&lt;/p></description></item><item><title>Docs: FIFO与FILO</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/FIFO%E4%B8%8EFILO/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/FIFO%E4%B8%8EFILO/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)">Wiki，FIFO&lt;/a>(先进先出)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">Wiki，Heap(堆)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">Wiki，LIFO(后进先出) 与 Wiki,Stack(栈)&lt;/a> 两个概念被 Wiki 合并了&lt;/li>
&lt;li>知乎，&lt;a href="https://www.zhihu.com/question/438782731">https://www.zhihu.com/question/438782731&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>first in,first out(先进先出，简称 FIFO)&lt;/strong> 与 &lt;strong>last in,firtst out(后进先出，简称 LIFO)&lt;/strong> 在计算机科学中，是两种有组织得操作结构化数据的方法。很多时候，&lt;strong>FIFO 也称为 Stack(栈)&lt;/strong>，&lt;strong>LIFO 也称为 Queue(队列)&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>注意：也可以说是是两种抽象的数据类型。但是这里的抽象数据类型，并不是指编程语言中的抽象数据类型。而是一种设计理念、设计思路。&lt;/p>
&lt;/blockquote>
&lt;p>FIFO&lt;/p>
&lt;ul>
&lt;li>考虑火车票购票系统，我们假设系统同时只能处理 40 个买票请求。那么当系统在处理 40 个请求时，来了第 41 个请求，系统就需要把这个请求缓存起来。同样，在这一过程中如果来了第 42、第 43、……第 1000 个请求，系统也需要把这些请求缓存起来。&lt;/li>
&lt;li>当系统处理完毕一个请求后，有 39 个请求尚在处理，系统能够处理一个新的请求。于是系统就需要从自己的缓存里挑一个请求来处理。而此时缓存里有第 41 至第 1000 个请求，系统应该挑选哪一个请求来处理呢？按照&lt;strong>先到先得的朴素排队的想法&lt;/strong>，系统理应挑选并处理第 41 个请求。&lt;/li>
&lt;li>在这种情况下，如果将系统的缓存设计为 FIFO，就能够很方便地实现上述调度策略。&lt;/li>
&lt;/ul>
&lt;p>LIFO&lt;/p>
&lt;ul>
&lt;li>就好像你拿了十页论文，看完一页放桌子上一页，最后一页自然的就在最上面，也就是说你从桌子上拿到的第一张就是最后放在桌子上的一页。&lt;/li>
&lt;li>也可以用叠牌子类比，把盘子叠一摞，那么当需要拿盘子的时候，最后叠上去的盘子是被先拿到的。&lt;/li>
&lt;/ul></description></item><item><title>Docs: 如何掌握所有的程序语言</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%A6%82%E4%BD%95%E6%8E%8C%E6%8F%A1%E6%89%80%E6%9C%89%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%81%87%E5%A6%82%E4%BD%A0%E6%9D%A5%E5%8F%91%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%A6%82%E4%BD%95%E6%8E%8C%E6%8F%A1%E6%89%80%E6%9C%89%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/</guid><description>
&lt;p>原文链接：&lt;a href="http://www.yinwang.org/blog-cn/2017/07/06/master-pl">王垠，如何掌握所有的程序语言&lt;/a>&lt;/p>
&lt;p>对的，我这里要讲的不是如何掌握一种程序语言，而是所有的……&lt;/p>
&lt;p>很多编程初学者至今还在给我写信请教，问我该学习什么程序语言，怎么学习。由于我知道如何掌握“所有”的程序语言，总是感觉这种该学“一种”什么语言的问题比较低级，所以一直没来得及回复他们 :P 可是逐渐的，我发现原来不只是小白们有这个问题，就连美国大公司的很多资深工程师，其实也没搞明白。&lt;/p>
&lt;p>今天我有动力了，想来统一回答一下这个搁置已久的“初级问题”。类似的话题貌似曾经写过，然而现在我想把它重新写一遍。因为在跟很多人交流之后，我对自己头脑中的（未转化为语言的）想法，有了更精准的表达。&lt;/p>
&lt;p>如果你存在以下的种种困惑，那么这篇文章也许会对你有所帮助：&lt;/p>
&lt;ol>
&lt;li>你是编程初学者，不知道该选择什么程序语言来入门。&lt;/li>
&lt;li>你是资深的程序员或者团队领导，对新出现的种种语言感到困惑，不知道该“投资”哪种语言。&lt;/li>
&lt;li>你的团队为使用哪种程序语言争论不休，发生各种宗教斗争。&lt;/li>
&lt;li>你追逐潮流采用了某种时髦的语言，结果两个月之后发现深陷泥潭，痛苦不堪……&lt;/li>
&lt;/ol>
&lt;p>虽然我已经不再过问这些世事，然而无可置疑的现实是，程序语言仍然是很重要的话题，这个情况短时间内不会改变。程序员的岗位往往会要求熟悉某些语言，甚至某些奇葩的公司要求你“深入理解 OOP 或者 FP 设计模式”。对于在职的程序员，程序语言至今仍然是可以争得面红耳赤的宗教话题。它的宗教性之强，以至于我在批评和调侃某些语言（比如 Go 语言）的时候，有些人会本能地以为我是另外一种语言（比如 Java）的粉丝。&lt;/p>
&lt;p>显然我不可能是任何一种语言的粉丝，我甚至不是 Yin 语言的粉丝 ;) 对于任何从没见过的语言，我都是直接拿起来就用，而不需要经过学习的过程。看了这篇文章，也许你会明白我为什么可以达到这个效果。理解了这里面的东西，每个程序员都应该可以做到这一点。嗯，但愿吧。&lt;/p>
&lt;h3 id="重视语言特性而不是语言">重视语言特性，而不是语言&lt;a class="td-heading-self-link" href="#%e9%87%8d%e8%a7%86%e8%af%ad%e8%a8%80%e7%89%b9%e6%80%a7%e8%80%8c%e4%b8%8d%e6%98%af%e8%af%ad%e8%a8%80" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>很多人在乎自己或者别人是否“会”某种语言，对“发明”了某种语言的人倍加崇拜，为各种语言的孰优孰劣争得面红耳赤。这些问题对于我来说都是不存在的。虽然我写文章批评过不少语言的缺陷，在实际工作中我却很少跟人争论这些。如果有其它人在我身边争论，我甚至会戴上耳机，都懒得听他们说什么 ;) 为什么呢？我发现归根结底的原因，是因为我重视的是“语言特性”，而不是整个的“语言”。我能用任何语言写出不错的代码，就算再糟糕的语言也差不了多少。&lt;/p>
&lt;p>任何一种“语言”，都是各种“语言特性”的组合。打个比方吧，一个程序语言就像一台电脑。它的牌子可能叫“联想”，或者“IBM”，或者“Dell”，或者“苹果”。那么，你可以说苹果一定比 IBM 好吗？你不能。你得看看它里面装的是什么型号的处理器，有多少个核，主频多少，有多少 L1 cache，L2 cache……，有多少内存和硬盘，显示器分辨率有多大，显卡是什么 GPU，网卡速度，等等各种“配置”。有时候你还得看各个组件之间的兼容性。&lt;/p>
&lt;p>这些配置对应到程序语言里面，就是所谓“语言特性”。举一些语言特性的例子：&lt;/p>
&lt;ul>
&lt;li>变量定义&lt;/li>
&lt;li>算术运算&lt;/li>
&lt;li>for 循环语句，while 循环语句&lt;/li>
&lt;li>函数定义，函数调用&lt;/li>
&lt;li>递归&lt;/li>
&lt;li>静态类型系统&lt;/li>
&lt;li>类型推导&lt;/li>
&lt;li>lambda 函数&lt;/li>
&lt;li>面向对象&lt;/li>
&lt;li>垃圾回收&lt;/li>
&lt;li>指针算术&lt;/li>
&lt;li>goto 语句&lt;/li>
&lt;/ul>
&lt;p>这些语言特性，就像你在选择一台电脑的时候，看它里面是什么配置。选电脑的时候，没有人会说 Dell 一定是最好的，他们只会说这个型号里面装的是 Intel 的 i7 处理器，这个比 i5 的好，DDR3 的内存 比 DDR2 的快这么多，SSD 比磁盘快很多，ATI 的显卡是垃圾…… 如此等等。&lt;/p>
&lt;p>程序语言也是一样的道理。对于初学者来说，其实没必要纠结到底要先学哪一种语言，再学哪一种。曾经有人给我发信问这种问题，纠结了好几个星期，结果一个语言都还没开始学。有这纠结的时间，其实都可以把他纠结过的语言全部掌握了。&lt;/p>
&lt;p>初学者往往不理解，每一种语言里面必然有一套“通用”的特性。比如变量，函数，整数和浮点数运算，等等。这些是每个通用程序语言里面都必须有的，一个都不能少。你只要通过“某种语言”学会了这些特性，掌握这些特性的根本概念，就能随时把这些知识应用到任何其它语言。你为此投入的时间基本不会浪费。所以初学者纠结要“先学哪种语言”，这种时间花的很不值得，还不如随便挑一个语言，跳进去。&lt;/p>
&lt;p>如果你不能用一种语言里面的基本特性写出好的代码，那你换成另外一种语言也无济于事。你会写出一样差的代码。我经常看到有些人 Java 代码写得相当乱，相当糟糕，却骂 Java 不好，雄心勃勃要换用 Go 语言。这些人没有明白，是否能写出好的代码在于人，而不在于语言。如果你的心中没有清晰简单的思维模型，你用任何语言表述出来都是一堆乱麻。如果你 Java 代码写得很糟糕，那么你写 Go 语言代码也会一样糟糕，甚至更差。&lt;/p>
&lt;p>很多初学者不了解，一个高明的程序员如果开始用一种新的程序语言，他往往不是去看这个语言的大部头手册或者书籍，而是先有一个需要解决的问题。手头有了问题，他可以用两分钟浏览一下这语言的手册，看看这语言大概长什么样。然后，他直接拿起一段例子代码来开始修改捣鼓，想法把这代码改成自己正想解决的问题。在这个简短的过程中，他很快的掌握了这个语言，并用它表达出心里的想法。&lt;/p>
&lt;p>在这个过程中，随着需求的出现，他可能会问这样的问题：&lt;/p>
&lt;ul>
&lt;li>这个语言的“变量定义”是什么语法，需要“声明类型”吗，还是可以用“类型推导”？&lt;/li>
&lt;li>它的“类型”是什么语法？是否支持“泛型”？泛型的 “variance” 如何表达？&lt;/li>
&lt;li>这个语言的“函数”是什么语法，“函数调用”是什么语法，可否使用“缺省参数”？&lt;/li>
&lt;li>……&lt;/li>
&lt;/ul>
&lt;p>注意到了吗？上面每一个引号里面的内容，都是一种语言特性（或者叫概念）。这些概念可以存在于任何的语言里面，虽然语法可能不一样，它们的本质都是一样的。比如，有些语言的参数类型写在变量前面，有些写在后面，有些中间隔了一个冒号，有些没有。&lt;/p>
&lt;p>这些实际问题都是随着写实际的代码，解决手头的问题，自然而然带出来的，而不是一开头就抱着语言手册看得仔仔细细。因为掌握了语言特性的人都知道，自己需要的特性，在任何语言里面一定有对应的表达方式。如果没有直接的方式表达，那么一定有某种“绕过方式”。如果有直接的表达方式，那么它只是语法稍微有所不同而已。所以，他是带着问题找特性，就像查字典一样，而不是被淹没于大部头的手册里面，昏昏欲睡一个月才开始写代码。&lt;/p>
&lt;p>掌握了通用的语言特性，剩下的就只剩某些语言“特有”的特性了。研究语言的人都知道，要设计出新的，好的，无害的特性，是非常困难的。所以一般说来，一种好的语言，它所特有的新特性，终究不会超过一两种。如果有个语言号称自己有超过 5 种新特性，那你就得小心了，因为它们带来的和可能不是优势，而是灾难！&lt;/p>
&lt;p>同样的道理，最好的语言研究者，往往不是某种语言的设计者，而是某种关键语言特性的设计者（或者支持者）。举个例子，著名的计算机科学家 Dijkstra 就是“递归”的强烈支持者。现在的语言里面都有递归，然而你可能不知道，早期的程序语言是不支持递归的。直到 Dijkstra 强烈要求 Algol 60 委员会加入对递归的支持，这个局面才改变了。Tony Hoare 也是语言特性设计者。他设计了几个重要的语言特性，却没有设计过任何语言。另外大家不要忘了，有个语言专家叫王垠，他是早期 union type 的支持者和实现者，也是 checked exception 特性的支持者，他在自己的博文里指出了 checked exception 和 union type 之间的关系 :P&lt;/p>
&lt;p>很多人盲目的崇拜语言设计者，只要听到有人设计（或者美其民曰“发明”）了一个语言，就热血沸腾，佩服的五体投地。他们却没有理解，其实所有的程序语言，不过是像 Dell，联想一样的“组装机”。语言特性的设计者，才是像 Intel，AMD，ARM，Qualcomm 那样核心技术的创造者。&lt;/p>
&lt;h3 id="合理的入门语言">合理的入门语言&lt;a class="td-heading-self-link" href="#%e5%90%88%e7%90%86%e7%9a%84%e5%85%a5%e9%97%a8%e8%af%ad%e8%a8%80" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>所以初学者要想事半功倍，就应该从一种“合理”的，没有明显严重问题的语言出发，掌握最关键的语言特性，然后由此把这些概念应用到其它语言。哪些是合理的入门语言呢？我个人觉得这些语言都可以用来入门：&lt;/p>
&lt;ul>
&lt;li>Scheme&lt;/li>
&lt;li>C&lt;/li>
&lt;li>Java&lt;/li>
&lt;li>Python&lt;/li>
&lt;li>JavaScript&lt;/li>
&lt;/ul>
&lt;p>那么相比之下，我不推荐用哪些语言入门呢？&lt;/p>
&lt;ul>
&lt;li>Shel&lt;/li>
&lt;li>PowerShell&lt;/li>
&lt;li>AWK&lt;/li>
&lt;li>Perl&lt;/li>
&lt;li>PHP&lt;/li>
&lt;li>Basic&lt;/li>
&lt;li>Go&lt;/li>
&lt;li>Rust&lt;/li>
&lt;/ul>
&lt;p>总的说来，你不应该使用所谓“脚本语言”作为入门语言，特别是那些源于早期 Unix 系统的脚本语言工具。PowerShell 虽然比 Unix 的 Shell 有所进步，然而它仍然没有摆脱脚本语言的根本问题——他们的设计者不知道他们自己在干什么 :P&lt;/p>
&lt;p>采用脚本语言学编程，一个很严重的问题就是使得学习者抓不住关键。脚本语言往往把一些系统工具性质的东西（比如正则表达式，Web 概念）加入到语法里面，导致初学者为它们浪费太多时间，却没有理解编程最关键的概念：变量，函数，递归，类型……&lt;/p>
&lt;p>不推荐 Go 语言的原因类似，虽然 Go 语言不算脚本语言，然而他的设计者显然不明白自己在干什么。所以使用 Go 语言来学编程，你不能专注于最关键，最好的语言特性。关于 Go 语言的各种毛病，你可以参考这篇文章。&lt;/p>
&lt;p>同样的，我不觉得 Rust 适合作为入门语言。Rust 花了太大精力来夸耀它的“新特性”，而这些新特性不但不是最关键的部分，而且很多是有问题的。初学者过早的关注这些特性，不仅学不会最关键的编程思想，而且可能误入歧途。关于 Rust 的一些问题，你可以参考这篇文章。&lt;/p>
&lt;h3 id="掌握关键语言特性忽略次要特性">掌握关键语言特性，忽略次要特性&lt;a class="td-heading-self-link" href="#%e6%8e%8c%e6%8f%a1%e5%85%b3%e9%94%ae%e8%af%ad%e8%a8%80%e7%89%b9%e6%80%a7%e5%bf%bd%e7%95%a5%e6%ac%a1%e8%a6%81%e7%89%b9%e6%80%a7" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>为了达到我之前提到的融会贯通，一通百通的效果，初学者应该专注于语言里面最关键的特性，而不是被次要的特性分心。&lt;/p>
&lt;p>举个夸张点的例子。我发现很多编程培训班和野鸡大学的编程入门课，往往一来就教学生如何使用 printf 打印“Hello World！”，进而要他们记忆 printf 的各种“格式字符”的意义，要他们实现各种复杂格式的打印输出，甚至要求打印到文本文件里，然后再读出来……&lt;/p>
&lt;p>可是殊不知，这种输出输入操作其实根本不算是语言的一部分，而且对于掌握编程的核心概念来说，都是次要的。有些人的 Java 课程进行了好几个星期，居然还在布置各种 printf 的作业。学生写出几百行的 printf，却不理解变量和函数是什么，甚至连算术语句和循环语句都不知道怎么用！这就是为什么很多初学者感觉编程很难，我连 &lt;code>%d&lt;/code>，&lt;code>%f&lt;/code>，&lt;code>%.2f&lt;/code> 的含义都记不住，还怎么学编程！&lt;/p>
&lt;p>然而这些野鸡大学的“教授”头衔是如此的洗脑，以至于被他们教过的学生（比如我女朋友）到我这里请教，居然骂我净教一些没用的东西，学了连 printf 的作业都没法完成 :P 你别跟我讲 for 循环，函数什么的了…… 可不可以等几个月，等我背熟了 printf 的用法再学那些啊？&lt;/p>
&lt;p>所以你就发现一旦被差劲的老师教过，这个程序员基本就毁了。就算遇到好的老师，他们也很难纠正过来。&lt;/p>
&lt;p>当然这是一个夸张的例子，因为 printf 根本不算是语言特性，但这个例子从同样的角度说明了次要肤浅的语言特性带来的问题。&lt;/p>
&lt;p>这里举一些次要语言特性的例子：&lt;/p>
&lt;ul>
&lt;li>C 语言的语句块，如果里面只有一条语句，可以不打花括号。&lt;/li>
&lt;li>Go 语言的函数参数类型如果一样可以合并在一起写，比如 &lt;code>func foo(s string, x, y, z int, c bool) { ... }&lt;/code>&lt;/li>
&lt;li>Perl 把正则表达式作为语言的一种特殊语法&lt;/li>
&lt;li>JavaScript 语句可以在某些时候省略句尾的分号&lt;/li>
&lt;li>Haskell 和 ML 等语言的 currying&lt;/li>
&lt;/ul>
&lt;h3 id="自己动手实现语言特性">自己动手实现语言特性&lt;a class="td-heading-self-link" href="#%e8%87%aa%e5%b7%b1%e5%8a%a8%e6%89%8b%e5%ae%9e%e7%8e%b0%e8%af%ad%e8%a8%80%e7%89%b9%e6%80%a7" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>在基本学会了各种语言特性，能用它们来写代码之后，下一步的进阶就是去实现它们。只有实现了各种语言特性，你才能完全地拥有它们，成为它们的主人。否则你就只是它们的使用者，你会被语言的设计者牵着鼻子走。&lt;/p>
&lt;p>有个大师说得好，完全理解一种语言最好的方法就是自己动手实现它，也就是自己写一个解释器来实现它的语义。但我觉得这句话应该稍微修改一下：完全理解一种“语言特性”最好的方法就是自己亲自实现它。&lt;/p>
&lt;p>注意我在这里把“语言”改为了“语言特性”。你并不需要实现整个语言来达到这个目的，因为我们最终使用的是语言特性。只要你自己实现了一种语言特性，你就能理解这个特性在任何语言里的实现方式和用法。&lt;/p>
&lt;p>举个例子，学习 SICP 的时候，大家都会亲自用 Scheme 实现一个面向对象系统。用 Scheme 实现的面向对象系统，跟 Java，C++，Python 之类的语言语法相去甚远，然而它却能帮助你理解任何这些 OOP 语言里面的“面向对象”这一概念，它甚至能帮助你理解各种面向对象实现的差异。&lt;/p>
&lt;p>这种效果是你直接学习 OOP 语言得不到的，因为在学习 Java，C++，Python 之类语言的时候，你只是一个用户，而用 Scheme 自己动手实现了 OO 系统之后，你成为了一个创造者。&lt;/p>
&lt;p>类似的特性还包括类型推导，类型检查，惰性求值，如此等等。我实现过几乎所有的语言特性，所以任何语言在我的面前，都是可以被任意拆卸组装的玩具，而不再是凌驾于我之上的神圣。&lt;/p>
&lt;h3 id="总结">总结&lt;a class="td-heading-self-link" href="#%e6%80%bb%e7%bb%93" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>写了这么多，重要的话重复三遍：语言特性，语言特性，语言特性，语言特性！不管是初学者还是资深程序员，应该专注于语言特性，而不是纠结于整个的“语言品牌”。只有这样才能达到融会贯通，拿起任何语言几乎立即就会用，并且写出高质量的代码。&lt;/p></description></item></channel></rss>