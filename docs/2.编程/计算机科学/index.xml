<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>计算机科学 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/</link><description>Recent content in 计算机科学 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/index.xml" rel="self" type="application/rss+xml"/><item><title>计算机科学</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/</guid><description>概述 参考：
王垠博客，解谜计算机科学 Wiki 分类，Computer science(计算机科学) Wiki 分类，Computer programming(计算机编程) Wiki 分类，Programming language concepts(编程语言概念) Wiki 分类，Programming constructs(编程结构) Wiki 分类，Programming languages(编程语言) Wiki, Identifier(标识符) Wiki, Symbol(符号) Wiki, DataType(数据类型) Wiki, Variables(变量) Wiki, Assignment(赋值) Wiki, Declaration(声明) 与 Definition(定义) 要掌握一个学科的精髓，不能从细枝末节开始。人脑的能力很大程度上受限于信念。一个人不相信自己的时候，他就做不到本来可能的事。信心是很重要的，信心却容易被挫败。如果只见树木不见森林，人会失去信心，以为要到猴年马月才能掌握一个学科。
所以我们不从 “树木” 开始，而是引导读者一起来探索这背后的“森林”，把计算机科学最根本的概念用浅显的例子解释，让读者领会到它们的本质。把这些概念稍作发展，你就得到逐渐完整的把握。你一开头就掌握着整个学科，而且一直掌握着它，只不过增添更多细节而已。这就像画画，先勾勒出轮廓，一遍遍的增加细节，日臻完善，却不失去对大局的把握。
一般计算机专业的学生学了很多课程，可是直到毕业都没能回答一个基础问题：什么是计算？这一章会引导你去发现这个问题的答案。不要小看这基础的问题，它经常是解决现实问题的重要线索。世界上有太多不理解它的人，他们走了很多的弯路，掉进很多的坑，制造出过度复杂或者有漏洞的理论和技术。
接下来，我们就来理解几个关键的概念，由此接触到计算的本质。
手指算术 每个人都做过计算，只是大部分人都没有理解自己在做什么。回想一下幼儿园（大概四岁）的时候，妈妈问你：“帮我算一下，4+3 等于几？” 你掰了一会手指，回答：7。当你掰手指的时候，你自己就是一台简单的计算机。
不要小看了这手指算术，它蕴含着深刻的原理。计算机科学植根于这类非常简单的过程，而不是复杂的高等数学。
现在我们来回忆一下这个过程。这里应该有一段动画，但现阶段还没有。请你对每一步发挥一下想象力，增加点 “画面感”。
当妈妈问你 “4+3 等于几” 的时候，她是一个程序员，你是一台计算机。计算机得到程序员的输入：4，+，3。 听到妈妈的问题之后，你拿出两只手，左手伸出四个指头，右手伸出三个指头。 接着你开始自己的计算过程。一根根地数那些竖起来的手指，每数一根你就把它弯下去，表示它已经被数过了。你念道：“1，2，3，4，5，6，7。” 现在已经没有手指伸着，所以你把最后数到的那个数作为答案：7！整个计算过程就结束了。 Identifier(标识符) 和 Model(模型) 这里的幼儿园手指算术包含着深刻的哲学问题，现在我们来初步体会一下这个问题。
当妈妈说 “帮我算 4+3” 的时候，4，+，3，三个字符传到你耳朵里，它们都是 Identifier(标识符)，有的时候也称为 symbol(符号)。符号是 “表面” 的东西：光是盯着 “4” 和“3”这两个阿拉伯数字的曲线，一个像旗子，一个像耳朵，你是不能做什么的。你需要先用脑子把它们转换成对应的“模型”（model）。这就是为什么你伸出两只手，一只手表示 4，另一只表示 3。
这两只手的手势是 “可操作” 的。比如，你把左手再多弯曲一个手指，它就变成 “3”。你再伸开一根手指，它就变成“5”。所以手指是一个相当好的机械模型，它是可以动，可操作的。把符号“4” 和“3”转换成手指模型之后，你就可以开始计算了。</description></item><item><title>Literal</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Literal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Literal/</guid><description>概述 参考：
Wiki, Literal(字面量) 在计算机科学中，Literal(字面量) 是表示源代码中固定值的 snotation(表示法)。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如：整数、浮点数以及字符串；而有很多也对布尔类型和字符类型的值也支持字面量表示；还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值也支持字面量表示法。
// b 为常量，10为字面量,数据类型为整数 const int b = 10 // str 为变量，hello world！为字面量，数据类型为字符串 string str = &amp;#34;hello world！&amp;#34;</description></item><item><title>Operator</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Operator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Operator/</guid><description>概述 参考：
Wiki, Operator(运算符) 喜马拉雅，番外篇06：布尔代数 编程中通过 Operator(运算符) 实现多种 Operation(运算)。
在编程领域中
真 可以用 true 或者 1 来表示 假 可以用 false 或者 0 来表示 常见的简单示例包括算术（例如用 + 加法）、比较（例如“大于”用 &amp;gt;）和逻辑运算（例如 AND，在某些语言中也写成 &amp;amp;&amp;amp;）。更多涉及的示例包括赋值（通常为 = 或 :=）、记录或访问对象中的字段（通常为 .）和范围解析运算符（通常为 :: 或 .）。语言通常会定义一组内置的运算符，并且在某些情况下允许用户为现有运算符添加新的含义甚至定义全新的运算符。
Arithmetic Operators(算数运算) # 最后的运算结果必然是数学概念上的整数、小数等。e.g.1+2=3、2*3=6 等 Boolean Operators(逻辑运算) # 之所以被称为逻辑运算符是因为它们的运算结果总是为布尔值 bool，不是 true 就是 false。e.g.1 是否等于 2、语句是否执行成功、是否有返回值、条件一成立且条件二失败结果四 true 还是 false 布尔代数 由于白马非马这种典故，语言是不可靠的。所以要创建一种符号。
算术运算 下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：
运算符 说明 举例 - 减法 $a - $b 结果为 -10。 * 乘法 $a * $b 结果为 200。 / 除法 $b / $a 结果为 2。 % 取余 $b % $a 结果为 0。 比较运算 运算符 说明 举例 == 是否等于 !</description></item><item><title>Variable</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Variable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Variable/</guid><description>概述 参考：
Wiki, Variable_(computer_science) 在计算机编程中，Variable(编程) 是一个抽象的存储位置，与一个相关的符号名称配对，变量中包含一些称为 Value(值) 的已知或未知数量的信息。或者可以说，变量是一个有名字的容器，用于存放特定 Data Type(数据类型) 的数据。
变量是一个可以改变内容的固定规定，比如我定义“这台电脑的名字”叫“XXX”，“这台电脑的名字”就是不变的内容，“XXX”就是可以改变的内容，给不变的内容定义不同的内容
比如 X=1，X=2，X=3 等等，X 就是不变的，1，2，3 等等都是可变的，X 就是一个变量，可以被赋予某些内容 环境变量就是在当前环境下所定义的内容，比如 linux 启动了一个 shell，在 shell 这个环境下，有一些规定被定义了，这些规定就是环境变量；不在这个 shell 下变量就不生效 比如：LANG 是一个语言的规定，你赋予他一个内容，就相当于定义了这个 shell 环境下所显示的语言，比如 LANG=US，LANG=CN 等等。LANG 这叫定义语言，这是不变的，可变的是后面的自定义内容，语言(不变)=英语、汉语、日语(可变)。</description></item><item><title>Control structure</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Control-structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Control-structure/</guid><description>概述 参考：
Wiki, Control_flow Control structure(控制结构) 有的时候也称为 Control flow(控制流)，在计算机科学中是指，执行或评估命令时程序的各个语句、指令、函数的调用顺序。对显式控制流的强调将命令式编程与声明式编程区分开来。
选择 if else
switch case
循环 Loop(循环)
Recurise(递归)
Iterative(迭代)
Traversal(遍历)
结构化的非局部控制流 异常处理 延续 异步 协程 Coroutines(协程)</description></item><item><title>Algorithm</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Algorithm/</guid><description>概述 参考：
Wiki, Algorithm Algorithm(算法)
Complexity 参考：
Wiki, Computational complexity Wiki, Time complexity B 站，常见的大O表示法有哪些？时间复杂度是什么？ Complexity(复杂度) 指运行某算法所需的资源量。通常不会精确计算，而是用一种表示法来表示一个数值的范围。
特别关注的是计算时间和存储空间。问题的复杂度则是指解决该问题的最佳算法所具有的复杂度。
常用 O() 表示。如下图时间复杂度所示，越靠左上角的复杂度越糟糕。
时间复杂度通常指一个函数运行完成需要执行某些行代码的次数。比如：
恒定时间的复杂度是 $O(1)$ for 循环复杂度是 $O(n)$，i.e. 循环 n 次。查找 嵌套 for 循环复杂度通常是 $O(n^2)$ 二分查找的复杂度是 $O(\log_{}n)$ etc. [!Note]
复杂度的计算并不是一个精确的计算，而是一种在宏观上通过表示法来表示某种无法确定传入参数的算法所需要消耗的资源
比如，上面的嵌套循环 2 次方只是方便描述，是一种抽象的表示法，并不是真的只循环 2 次并且每次都一样，只是用来表示一种宏观上需要消耗的时间。
如果 n 也确定了，2 也确定了，比如 1000 个元素遍历 2 遍，那这种情况的时间复杂度应该用 $O(1)$ 表示，因为传入参数是固定的，没有复杂度。</description></item><item><title>Heap and Stack</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Heap-and-Stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Heap-and-Stack/</guid><description>概述 参考：
StackOverflow Heap(堆) 与 Stack(栈)
汇编语言 这里有一些 堆栈 的通俗解释，非常好理解
内存模型：Heap 寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。
程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从0x1000到0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址。
程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用malloc命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到 10 个字节内存，那么从起始地址0x1000开始给他分配，一直分配到地址0x100A，如果再要求得到 22 个字节，那么就分配到0x1020。
这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。
内存模型：Stack 除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。
请看下面的例子。
int main() { int a = 2; int b = 3; } 上面代码中，系统开始执行main函数时，会为它在内存里面建立一个帧（frame），所有main的内部变量（比如a和b）都保存在这个帧里面。main函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。
如果函数内部调用了其他函数，会发生什么情况？
int main() { int a = 2; int b = 3; return add_a_and_b(a, b); } 上面代码中，main函数内部调用了add_a_and_b函数。执行到这一行的时候，系统也会为add_a_and_b新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：main和add_a_and_b。一般来说，调用栈有多少层，就有多少帧。
等到add_a_and_b运行结束，它的帧就会被回收，系统会回到函数main刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。
所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做 &amp;ldquo;入栈&amp;rdquo;，英文是 push；栈的回收叫做 &amp;ldquo;出栈&amp;rdquo;，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做 &amp;ldquo;后进先出&amp;rdquo; 的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。</description></item><item><title>I/O 模型</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/I_O-%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/I_O-%E6%A8%A1%E5%9E%8B/</guid><description>概述 参考：
Wiki, Asynchronous_I/O 编程中的 I_O
同步/异步：关注的是消息通信机制，被调用者在收到调用请求后，是否立即返回，还是得到最终结果后才返回,立即返回为异步，等待结果再返回为同步，异步不会影响调用者处理后续
同步和异步通常用来形容一次方法调用。
同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。
异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。举个例子
你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下&amp;quot;，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。 而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。 阻塞/非阻塞：关注的是程序在等待调用结果（消息，返回值）时的状态.，调用者发起调用请求后，在收到响应结果之前是否会被挂起，被挂起为阻塞，不被挂起为非阻塞。举个例子
同步阻塞： 老张在厨房用普通水壶烧水，一直在厨房等着（阻塞），盯到水烧开（同步）； 异步阻塞： 老张在厨房用响水壶烧水，一直在厨房中等着（阻塞），直到水壶发出响声（异步），老张知道水烧开了； 同步非阻塞： 老张在厨房用普通水壶烧水，在烧水过程中，就到客厅去看电视（非阻塞），然后时不时去厨房看看水烧开了没（轮询检查同步结果）； 异步非阻塞： 老张在厨房用响水壶烧水，在烧水过程中，就到客厅去看电视（非阻塞），当水壶发出响声（异步），老张就知道水烧开了。 所谓同步异步，只是对于水壶而言。 普通水壶，同步；响水壶，异步。 虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。 同步只能让调用者去轮询自己（情况 2 中），造成老张效率的低下。 所谓阻塞非阻塞，仅仅对于老张而言。 立等的老张，阻塞；看电视的老张，非阻塞。 情况 1 和情况 3 中老张就是阻塞的，媳妇喊他都不知道。虽然 3 中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</description></item></channel></rss>