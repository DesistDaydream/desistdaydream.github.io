<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>无法分类的语言 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/</link><description>Recent content in 无法分类的语言 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/index.xml" rel="self" type="application/rss+xml"/><item><title>TOML</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/TOML/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/TOML/</guid><description>概述 参考：
GitHub 项目，toml-lang/toml 官方文档 Wiki, TOML 知乎 格式对比 Tom&amp;rsquo;s Obvious, Minimal Language(简称 TOML) 是一种配置语言，旨在称为一种最小的配置文件结构，并且易于阅读、具有显而易见的语义。
TOML 规范 TOML 大小写敏感 TOML 必须是有效的 UTF-8 编码的 Unicode 文档 空白表示 Tab(0x09) 或 空格(0x20) 换行表示 LF(0x0a) 或 CRLF(0x0D 0x0A) TOML 特点 TOML 的原子单位也是 Key/Value pair(键值对)。多个 Key/Value pair 组成一个 Table(表)。
所以，一个 TOML 格式的配置文件，本质上是 Table(表) 的集合。
TOML 放弃了括号或缩进的底层原理，而是以 . 符号来表示层级关系(实现类似缩进的效果)
TOML 基本示例 # This is a TOML document. title = &amp;#34;TOML Example&amp;#34; [owner] name = &amp;#34;Tom Preston-Werner&amp;#34; dob = 1979-05-27T07:32:00-08:00 # First class dates [database] server = &amp;#34;192.</description></item><item><title>YAML</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/YAML/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/YAML/</guid><description>概述 参考：
官方文档，规范 v1.2.2 Wiki, YAML 编程免不了要写配置文件，怎么写配置也是一门学问。
YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便
YAML Ain&amp;rsquo;t Markup Language(简称 YAML) 是一种数据序列化语言。设计目标就是方便人类读写，并且可以在日常工作中与现代编程语言很好的配合。它实质上是一种通用的数据串行化格式。
YAML 与 JSON 的关系 JSON 和 YAML 都旨在成为人类可读的数据交换格式。但是，JSON 和 YAML 具有不同的优先级。 JSON 的首要设计目标是简单性和通用性。因此，JSON 的生成和解析非常简单，但代价是人类可读性降低。它还使用最低公分母信息模型，以确保所有现代编程环境都可以轻松处理任何 JSON 数据。
相反，YAML 的首要设计目标是人类可读性并支持序列化任意本机数据结构。因此，YAML 允许可读性极强的文件，但生成和解析起来更复杂。此外，YAML 的业务范围超越了最低公分母数据类型，因此在不同的编程环境之间进行转换时，需要进行更复杂的处理。
因此，YAML 可以看作是 JSON 的自然超集，可以提高人类可读性和更完整的信息模型。实际上也是这种情况；每个 JSON 文件也是一个有效的 YAML 文件，JSON 与 YAML 格式可以轻松得互相转换
并且，YAML 格式也可以转换为别的格式
YAML 基本语法规则 大小写敏感 使用缩进表示层级关系 缩进时不允许使用 Tab 键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 # 表示注释，从这个字符一直到行尾，都会被解析器忽略 Data Structures(数据结构) YAML 由多个 Node(节点) 组成，每个 Node 都可以是三种 Native Data Structures(原生数据结构) 其中之一：</description></item><item><title>ASN.1</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/ASN.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/ASN.1/</guid><description>概述 参考：
ITU 官网, ITU-T-ASN.1 项目 Wiki, ASN.1 Wiki, X.690-DER_encoding http://www.txrzx.com/i4477.html http://threelambda.com/2020/11/08/asn-1/ https://lapo.it/asn1js 《抽象语法记法 asn.1 原理与应用》 Abstract Syntax Notation One (ASN.1) 是一种标准的 interface description language(接口描述语言)，用于定义以跨平台方式序列化和反序列化的数据结构。 它广泛用于电信和计算机网络，尤其是在密码学中。
Abstract Syntax Notation One(抽象语法表示法，简称 ASN.1) 是一个形式化的标准，用于定义抽象数据类型的规范。它广泛用于计算机网络中，用于描述 telecommunications protocols(电信协议) 传输数据时所使用的 formal notation(正式表示法)。
通信设备需要相互传输数据，但是设备可能是由不同厂家生产的，其硬件体系结构、程序语言的语法定义和程序功能实现一般是不相同的。例如，在一台设备中，整形数据类型是 16 位表示，而在另一台则可能用 32 位表示。这些差异导致了同一数据对象在不同的设备上被表示为不同的符号串。为了解决以上问题，ISO 组织推出了 ASN.1。ASN.1 通过定义若干简单类型和复合类型，使得各个设备对其间交换消息的数据类型有了一致的认识。系统的消息发送方采用编码规则（BER、PER）将 ASN.1 描述的消息编码成二进制字节流；消息接受方对收到的字节流进行解码，再转化为符合其自身语法的消息格式。这样，经过 ASN.1 处理的消息独立于应用环境，就不会因为系统终端的区别而产生歧义。基于 H.323 协议的视频会议系统的信令消息就是采用 ASN.1 来表示的。
80 年代初，当时的国际电报电话咨询委员会（CCITT）将应用于 E-mail MHS 协议的基本记法和解码格式进行了标准化，形成了 X.409 方案，这是 ASN.1 的前身。该标准后来被 ISO 组织采用并将其分为抽象语法记法和传输语法，形成了 ISO/IEC 8824 和 ISO/IEC 8825 两个系列标准，且版本在不断更新之中（目前是 2015 年版本）。CCITT 于 1989 年相应地发布了 X.</description></item><item><title>EBNF</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/EBNF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/EBNF/</guid><description>概述 参考：
Wiki, EBNF Wiki, Metasyntax Extended Backus-Naur Form(扩展的 Backus-Naur 格式，简称 EBNF) 是一组 Metasyntax(元语法) 表示法。EBNF 用于对计算机编程语言等形式语言进行形式化描述。EBNF 是基于 BNF 的扩展。
EBNF 是一种表达形式语言语法的代码。EBNF 由两部分组成
Terminal Symbols(终结符号) non-terminal production rules(非终结表达式规则) # 其实就相当于一个表达式 这两部分组合起来，其实就是一句话，最后跟一个句号~~~一行内容就是一个 EBNF 表示法，比如：
digit excluding zero = &amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | &amp;quot;3&amp;quot; | &amp;quot;4&amp;quot; | &amp;quot;5&amp;quot; | &amp;quot;6&amp;quot; | &amp;quot;7&amp;quot; | &amp;quot;8&amp;quot; | &amp;quot;9&amp;quot; ; digit = &amp;quot;0&amp;quot; | digit excluding zero ; Symbols(符号) 下面定义的符号意义中，... 仅仅用来表示符号中可以是任意内容，不属于被定义的符号的一部分。 = # Definition(定义) , # Concatenation(串接) ; # Termination(终止) | # Alternation(交替)，就是“或者”的意思。 [.</description></item><item><title>INI</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/INI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/INI/</guid><description>概述 参考：
Wiki, INI INI 格式规范 ; 分号表示注释 INI 原语 Key/Value pair(键/值对) INI 格式的文件主要结构是 Key/Value pair(键/值对) 格式。Key 与 Value 以 = 符号分割。有的地方也称为 Properties(属性)。
Sections(部分) Selections(部分) 是 键/值对 的集合，也称为 Hash Tables(哈希表) 或 Dictionaries(字典)，以 [] 符号表示。从 Table 的 [] 符号开始到下一个 [] 符号为止，所有键值对都属于该 Sections。
人们日常生活中描述的 第一部分、第二部分、我这部分 等等，这就是 部分的意思，表示一个整体的其中一部分。一个 INI 有很多部分，比如可以说：有 main 部分、logging 部分 等等。
Sections 也有章节的意思，但是不如 Chapter 这个词用来表示章节更合适。</description></item><item><title>JSON</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/JSON/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/JSON/</guid><description>概述 参考：
官方文档 Wiki, JSON RFC 8259 JavaScript Object Notation(JS 对象表示法，简称 JSON) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。 它基于 JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999 的一个子集。 JSON 采用完全独立于语言的文本格式，但是也使用了类似于 C 语言家族的习惯（包括 C, C++, C#, Java, JavaScript, Perl, Python 等）。 这些特性使 JSON 成为理想的数据交换语言。
JavaScript Object Notation(简称 JSON) 是一种简单的数据交换格式。从句法上讲，它类似于 JavaScript 的对象和列表。它最常用于Web后端与浏览器中运行的 JavaScript 程序之间的通信，但它也用于许多其他地方。它的主页 json.org 提供了一个清晰，简洁的标准定义。
JSON 建构于两种结构：
“名称/值”对的集合（A collection of name/value pairs） # 不同的语言中，它被理解为对象（object），映射（mapping），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。 值的有序列表（An ordered list of values） # 在大部分语言中，它被理解为数组（array）。 JSON 具有以下这些形式：</description></item><item><title>Protobuf</title><link>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/Protobuf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E5%88%86%E7%B1%BB%E7%9A%84%E8%AF%AD%E8%A8%80/Protobuf/</guid><description>概述 参考：
Wiki, Protocol Buffers 公众号 - 码农的荒岛求生，神奇的 Google 二进制编解码技术：Protobuf 计算机网络编程中一个非常基本的问题：该怎样表示client与server之间交互的数据，在往下看之前先想一想这个问题。
共识与协议 这个问题可不像看上去的那样简单，因为client进程和server进程运行在不同的机器上，这些机器可能运行在不同的处理器平台、可能运行在不同的操作系统、可能是由不同的编程语言编写的，server要怎样才能识别出client发送的是什么数据呢？就像这样： client给server发送了一段数据：
0101000100100001 server怎么能知道该怎样“解读”这段数据呢？
显然，client和server在发送数据之前必须首先达成某种关于怎样解读数据的共识，这就是所谓的协议。
这里的协议可以是这样的：“将每8个比特为一个单位解释为无符号数字”，如果协议是这样的，那么server接收到这串二进制后就会将其解析为81(01010001)与33(00100001)。
当然，这里的协议也可以是这样的：“将每8个比特为一个单位解释为ASCII字符”，那么server接收到这串二进制后就将其解析为“Q!”。
可见，同样一串二进制在不同的“上下文/协议”下有完全不一样的解读，这也是为什么计算机明明只认知0和1但是却能处理非常复杂任务的根本原因，因为一切都可以编码为0和1，同样的我们也可以从0和1中解析出我们想要的信息，这就是所谓的编解码技术。
实际上不止0和1，我们也可以将信息编码为摩斯密码(Morse code)等，只不过计算机擅长处理0和1而已。
扯远了，回到本文的主题。
远程过程调用：RPC 作为程序员我们知道，client以及server之间不会简单传递一串数字以及字符这样简单，尤其在互联网大厂后端服务这种场景下。
当我们在电商App搜索商品、打车App呼叫出租车以及刷短视频时，每一次请求的背后在后端都涉及大量服务之间的交互，就像这样：
完成一次客户端请求gateway这个服务要调用N多个下游服务，所谓调用是说A服务向B服务发送一段数据（请求），B服务接收到这段数据后执行相应的函数，并将结果返回给A服务。
只不过对于服务A来说并不想关心网络传输这样的底层细节，如果能像调用本地函数一样调用远程服务就好了，这就是所谓的RPC，经典的实现方式是这样的：
RPC对上层提供和普通函数一样的接口，只不过在实现上封装了底层复杂的网络通信，RPC框架是当前互联网后端的基石之一，很多所谓互联网后端的职位无非就是在此基础之上堆业务逻辑。
本文我们不关心其中的细节，这里我们只关心在网络层client是怎样对请求参数进行编码、server怎样对请求参数进行解码的，也就是本文开头提出的问题。
信息的编解码 在思考怎样进行编解码之前我们必须意识到：
client和server可能是用不同语言编写的，你的编解码方案必须通用且不能和语言绑定 编解码方法的性能问题，尤其是对时间要求苛刻的服务 首先，我们最应该能想到的就是以纯文本的形式来表示。
纯文本从来都是一种非常有友好的信息载体，为什么？很简单，因为人类(我们)可以直接看懂，就像这段：
{ &amp;#34;widget&amp;#34;: { &amp;#34;window&amp;#34;: { &amp;#34;title&amp;#34;: &amp;#34;Sample Konfabulator Widget&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;main_window&amp;#34;, &amp;#34;width&amp;#34;: 500, &amp;#34;height&amp;#34;: 500 }, &amp;#34;image&amp;#34;: { &amp;#34;src&amp;#34;: &amp;#34;Images/Sun.png&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;sun1&amp;#34;, &amp;#34;hOffset&amp;#34;: 250, &amp;#34;vOffset&amp;#34;: 250, }, }} 是不是很清晰，一目了然，只要我们实现约定好文本的结构(也就是语法)，那么client和server就能利用这种文本进行信息的编码以及解码，不管client和server是运行在x86还是Arm、是32位的还是64位的、运行在Linux上还是windows上、是大端还是小端，都可以无障碍交流。
因此在这里，文本的语法就是一种协议。 顺便说一句，你都规定好了文本的语法，实际上就相当于发明了一种语言。
这里用来举例用的语言就是所谓的Json，只不过json这种语言不是用来表示逻辑(代码)而是用来存储数据的。
Json就是这个老头提出来的：
除了Json，另一种利用文本存储数据的表示方法是XML，来一段感受下：</description></item></channel></rss>