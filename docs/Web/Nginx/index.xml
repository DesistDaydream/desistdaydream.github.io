<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Nginx on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/Web/Nginx/</link><description>Recent content in Nginx on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/Web/Nginx/index.xml" rel="self" type="application/rss+xml"/><item><title>Nginx</title><link>https://desistdaydream.github.io/docs/Web/Nginx/Nginx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/Web/Nginx/Nginx/</guid><description>概述 参考：
GitHub 项目，nginx/nginx 原始代码：https://hg.nginx.org/nginx/ org 官方网站 官方网站 官方网站,动态模块列表 Nginx 称为 Engine X，可以做为 Web 服务器、代理服务器、缓存服务器、负载均衡器 等来使用。
传统上基于进程或线程模型架构的 web 服务通过每进程或每线程处理并发连接请求，这势必会在网络和 I/O 操作时产生阻塞，其另一个必然结果则是对内存或 CPU 的利用率低下。生成一个新的进程/线程需要事先备好其运行时环境，这包括为其分配堆内存和栈内存，以及为其创建新的执行上下文等。这些操作都需要占用 CPU，而且过多的进程/线程还会带来线程抖动或频繁的上下文切换，系统性能也会由此进一步下降。
在设计的最初阶段，nginx 的主要着眼点就是其高性能以及对物理计算资源的高密度利用，因此其采用了不同的架构模型。受启发于多种操作系统设计中基于“事件”的高级处理机制，nginx 采用了模块化、事件驱动、异步、单线程及非阻塞的架构，并大量采用了多路复用及事件通知机制。在 nginx 中，连接请求由为数不多的几个仅包含一个线程的进程 worker 以高效的回环(run-loop)机制进行处理，而每个 worker 可以并行处理数千个的并发连接及请求。
Nginx 会按需同时运行多个进程：一个主进程(master)和几个工作进程(worker)，配置了缓存时还会有缓存加载器进程(cache loader)和缓存管理器进程(cache manager)等。所有进程均是仅含有一个线程，并主要通过“共享内存”的机制实现进程间通信。主进程以 root 用户身份运行，而 worker、cache loader 和 cache manager 均应以非特权用户身份运行。
Nginx 特性：
模块化设计，较好的扩展性，所有配置均有指定的模块进行处理。 高可靠 master &amp;ndash;&amp;gt; worker，主控进程不接收和响应用户请求，主控进程负责解析配置文件并生成多个工作进程，工作进程来响应用户请求 主控进程读取并验证配置，创建或绑定套接字，启动及终止和维护 worker 进程的个数，无须重启进程让新配置的配置文件进行加载，以及完成平滑版本升级等等 工作进程，负责缓存加载的(反向代理时候用)，负责响应用户请求，cache manager 缓存管理 低内存消耗，10000 个 keep-alive 模式下的 connection，仅需 2.5MB 内存 支持热部署，不停机而更新配置文件，日志文件滚动，升级程序版本 支持事件驱动、AIO、mmap 基本功能：
静态资源的 web 服务器，能缓存打开的文件描述符 http、SMTP、pop3 协议的反向代理服务器 缓存加速、负载均衡 支持 FastCGI(fpm，LNMP)，uWSGI(Python)等 模块化(非 DSO 机制)、过滤器 zip、SSI 及图像的大小调整 支持 SSL(https) 扩展功能</description></item><item><title>Nginx 处理 HTTP 请求的流程</title><link>https://desistdaydream.github.io/docs/Web/Nginx/Nginx-%E5%A4%84%E7%90%86-HTTP-%E8%AF%B7%E6%B1%82%E7%9A%84%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/Web/Nginx/Nginx-%E5%A4%84%E7%90%86-HTTP-%E8%AF%B7%E6%B1%82%E7%9A%84%E6%B5%81%E7%A8%8B/</guid><description>概述 参考：
原文：Nginx 处理 HTTP 请求的 11 个阶段 博客园对该文章的排版更好 前面给大家讲了 Nginx 是如何处理 HTTP请求头部的，接下来就到了真正处理 HTTP 请求的阶段了。先看下面这张图，这张图是 Nginx 处理 HTTP 请求的示意图，虽然简单，但是却很好的说明了整个过程。
Read Request Headers：解析请求头。 Identify Configuration Block：识别由哪一个 location 进行处理，匹配 URL。 Apply Rate Limits：判断是否限速。例如可能这个请求并发的连接数太多超过了限制，或者 QPS 太高。 Perform Authentication：连接控制，验证请求。例如可能根据 Referrer 头部做一些防盗链的设置，或者验证用户的权限。 Generate Content：生成返回给用户的响应。为了生成这个响应，做反向代理的时候可能会和上游服务（Upstream Services）进行通信，然后这个过程中还可能会有些子请求或者重定向，那么还会走一下这个过程（Internal redirects and subrequests）。 Response Filters：过滤返回给用户的响应。比如压缩响应，或者对图片进行处理。 Log：记录日志。 以上这七个步骤从整体上介绍了一下处理流程，下面还会再说一下实际的处理过程。
Nginx 处理 HTTP 请求的 11 个阶段 下面介绍一下详细的 11 个阶段，每个阶段都可能对应着一个甚至多个 HTTP 模块，通过这样一个模块对比，我们也能够很好的理解这些模块具体是怎么样发挥作用的。
可以在 Nginx 源码 src/http/ngx_http_core_module.h 找到这 11 个阶段的定义
typedef enum { NGX_HTTP_POST_READ_PHASE = 0, NGX_HTTP_SERVER_REWRITE_PHASE, NGX_HTTP_FIND_CONFIG_PHASE, NGX_HTTP_REWRITE_PHASE, NGX_HTTP_POST_REWRITE_PHASE, NGX_HTTP_PREACCESS_PHASE, NGX_HTTP_ACCESS_PHASE, NGX_HTTP_POST_ACCESS_PHASE, NGX_HTTP_PRECONTENT_PHASE, NGX_HTTP_CONTENT_PHASE, NGX_HTTP_LOG_PHASE } ngx_http_phases; POST_READ：在 read 完请求的头部之后，在没有对头部做任何处理之前，想要获取到一些原始的值，就应该在这个阶段进行处理。这里面会涉及到一个 realip 模块。 SERVER_REWRITE：和下面的 REWRITE 阶段一样，都只有一个模块叫 rewrite 模块，一般没有第三方模块会处理这个阶段。 FIND_CONFIG：做 location 的匹配，暂时没有模块会用到。 REWRITE：对 URL 做一些处理。 POST_WRITE：处于 REWRITE 之后，也是暂时没有模块会在这个阶段出现。 接下来是确认用户访问权限的三个模块：</description></item><item><title>Nginx 源码解析</title><link>https://desistdaydream.github.io/docs/Web/Nginx/Nginx-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/Web/Nginx/Nginx-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>概述 参考：
GitHub 项目，nginx/nginx Nginx 的架构设计是高度模块化的，从 Nginx 的源码目录与 Nginx 模块化及其功能的划分是紧密结合的。
# tree -d . ├── auto ├── conf ├── contrib ├── docs ├── misc └── src ├── core ├── event │ └── modules ├── http │ ├── modules │ │ └── perl │ └── v2 ├── mail ├── misc ├── os │ ├── unix │ └── win32 └── stream 每个模块必须要具备 ngx_module_t 这个数据结构，比如 src/core/nginx.c 文件中，在 ngx_module_t 数据结构中，定义了 ngx_core_module 模块
ngx_module_t ngx_core_module = { // 定义模块名称为 ngx_core_module NGX_MODULE_V1, &amp;amp;ngx_core_module_ctx, /* module context */ // ngx_core_commands 是该模块的指令，这里一般会定义一个数组，数组中每个元素就是一个指令 ngx_core_commands, /* module directives */ // NGX_CORE_MODULE 是该模块的类型 NGX_CORE_MODULE, /* module type */ NULL, /* init master */ NULL, /* init module */ NULL, /* init process */ NULL, /* init thread */ NULL, /* exit thread */ NULL, /* exit process */ NULL, /* exit master */ NGX_MODULE_V1_PADDING }; 再看 src/http/ngx_http.</description></item><item><title>Nginx 优化</title><link>https://desistdaydream.github.io/docs/Web/Nginx/Nginx-%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/Web/Nginx/Nginx-%E4%BC%98%E5%8C%96/</guid><description>性能优化的相关配置 work_processes NUM; # 常用，指定 work 线程个数，通常应该少于 cpu 物理核心数，设为 auto 为自动判断 work_cpu_affinity CpuMask; # 常用，设定 cpu 掩码，用于绑定给 nginx 专用的 cpu 数 timer_resolution Num; # 计时器解析度，降低此值，可提高性能 worker_priority NUM; # 设定优先级，即 worker 线程的 nice 值 事件相关配置 worker_connections NUM; # 常用，指定每个 worker 线程所能处理的最大并发连接数 accept_mutex on|off; # 调度用户请求至 worker 线程时使用的负载均衡锁。on 是让多个 worker 轮流的，序列化地响应新请求 lock_file /PATH/FILE; # 指定 accept_mutex 开启后用到的锁文件路径 用于调试、定位问题的配置 daemon on|off； # 是否以守护进程方式运行 nginx，调试时设置为 off master_process on|off； # 是否以 master/worker 模式来运行 ngins，调试时可以设置为 off 优化 Nginx 数据包头缓存 1）优化前，使用脚本测试长头部请求是否能获得响应</description></item></channel></rss>