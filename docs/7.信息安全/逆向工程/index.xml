<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 逆向工程</title><link>https://desistdaydream.github.io/docs/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</link><description>Recent content in 逆向工程 on 断念梦</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 逆向工程</title><link>https://desistdaydream.github.io/docs/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Reverse_engineering">Wiki，Reverse_engineering&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Software_cracking">Wiki，Software_cracking&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Reverse engineering(逆向工程)&lt;/strong>&lt;/p>
&lt;p>逆向工程的其他目的包括安全审核、消除复制保护（“破解”）、规避消费电子产品中常见的访问限制、定制嵌入式系统（例如引擎管理系统）、内部维修或改造、低成本“残缺”硬件（例如某些显卡芯片组）上的附加功能，甚至只是满足好奇心。&lt;/p>
&lt;p>&lt;strong>Software cracking(软件破解)&lt;/strong>&lt;/p>
&lt;h1 id="学习">学习&lt;/h1>
&lt;p>&lt;a href="https://www.52pojie.cn/">吾爱破解&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/97o3fX9AN_kl2GCLhHAfig">吾爱破解安卓逆向入门教程《安卓逆向这档事》十五、是时候学习一下Frida一把梭了(下)&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="http://www.lxspider.com/?p=194">lamda安卓逆向辅助框架&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.tulingpyton.cn/">图灵 Python&lt;/a> 何老师相关课程&lt;/p>
&lt;p>&lt;a href="https://github.com/lixi5338619/lxSpider">https://github.com/lixi5338619/lxSpider&lt;/a>&lt;/p>
&lt;h1 id="待整理">待整理&lt;/h1>
&lt;p>逆向算法&lt;/p>
&lt;p>逆向混淆&lt;/p>
&lt;p>验证码技术&lt;/p>
&lt;ul>
&lt;li>腾讯防水墙&lt;/li>
&lt;li>阿里无感 v3&lt;/li>
&lt;li>极验4代点选&lt;/li>
&lt;li>小红书 数美验证&lt;/li>
&lt;li>百度旋转验证&lt;/li>
&lt;li>易盾&lt;/li>
&lt;li>顶象&lt;/li>
&lt;li>瑞数&lt;/li>
&lt;/ul>
&lt;p>JSVMP 加密&lt;/p>
&lt;h1 id="小程序逆向">小程序逆向&lt;/h1>
&lt;p>&lt;a href="https://www.bilibili.com/video/BV1ew411K7nB?p=40">https://www.bilibili.com/video/BV1ew411K7nB?p=40&lt;/a>&lt;/p>
&lt;p>微信小程序目录位置&lt;/p>
&lt;ul>
&lt;li>PC
&lt;ul>
&lt;li>&lt;code>WeChat Files\Applet\&lt;/code> # 该目录为小程序所在文件夹。每个小程序文件都是一个独立的文件夹，以 wx 开头，像 &lt;code>wx64479c83c7630409&lt;/code> 这样&lt;/li>
&lt;li>想要找到对应的小程序，可以把所有 wx 开头的文件夹都删除，然后打开小程序，就会生成一个信息的 wx 开头的文件夹。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>UnpackMiniApp # 解密 &lt;code>*.wxapkg&lt;/code> 文件获得 &lt;code>*.wxapkg&lt;/code> 文件。TODO: 为什么要先解密？这是加的什么密？&lt;/p>
&lt;ul>
&lt;li>找不到官方下载渠道&lt;/li>
&lt;/ul>
&lt;p>Unveilr # 反编译解密后的 &lt;code>*.wxapkg&lt;/code> 文件得到源码。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/r3x5ur/unveilr">https://github.com/r3x5ur/unveilr&lt;/a> # 好像是原始源码，但是 2.0 之后的版本作者收费了
&lt;ul>
&lt;li>只有个下载地址和 TG 号 &lt;a href="https://t.me/Qobg3fbwQM1hNTY1">https://t.me/Qobg3fbwQM1hNTY1&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://u.openal.lat/">https://u.openal.lat/&lt;/a> 提供下载和花钱买 token&lt;/li>
&lt;li>下面是一些 2.0.2 版本源码的备份
&lt;ul>
&lt;li>&lt;a href="https://github.com/AnkioTomas/unveilr">https://github.com/AnkioTomas/unveilr&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/CoderYiXin/unveilr">https://github.com/CoderYiXin/unveilr&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>使用微信开发者工具打开项目&lt;/p>
&lt;p>其他反编译小程序的项目&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/wux1an/wxapkg">https://github.com/wux1an/wxapkg&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/zgqwork/wxapkg-unpacker">https://github.com/zgqwork/wxapkg-unpacker&lt;/a>
&lt;ul>
&lt;li>基于 &lt;a href="https://github.com/qwerty472123/wxappUnpacker">https://github.com/qwerty472123/wxappUnpacker&lt;/a>, 该项目已于 2021 年删库归档&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="web-逆向">Web 逆向&lt;/h1>
&lt;p>从 &lt;a href="docs/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Cryptography/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.md">加密解密的最佳实践&lt;/a> 中可以看到常见的加密/解密方式。&lt;/p>
&lt;p>很多时候我们无法用其他语言实现找到的 js 代码，但是又想要使用 Python 怎么办呢，可以使用一些第三方库，以便让 Python 可以执行 JS 代码（e.g. pyexecjs、js2py）&lt;/p>
&lt;p>在 &lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF.md">编程技术&lt;/a> 可以知道网站的数据有动态和静态两种。&lt;/p>
&lt;ul>
&lt;li>若是静态的数据，在 “&lt;a href="https://desistdaydream.github.io/docs/Web/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7.md">开发者工具&lt;/a> - 网络 - 文档” 中查看数据资源
&lt;ul>
&lt;li>静态数据通常是直接返回 HTML 页面，此时我们可以直接使用各种语言的 DOM 树管理库，通过 XPath 等方式定位元素，以获取其中的数据&lt;/li>
&lt;li>这类网站有的时候有个特点，一个页面有需要两次请求，第一次返回一段 js 代码，然后生成 cookie，第二次带着 cookie 发起请求再获取到静态 HTML 数据。
&lt;ul>
&lt;li>这两次请求需要在 开发者工具 - 网络 中打开 “保留日志” 功能才可以看到第一次。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1ew411K7nB?p=19">https://www.bilibili.com/video/BV1ew411K7nB?p=19&lt;/a> 这里有介绍。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>若是动态的数据，在 “&lt;a href="https://desistdaydream.github.io/docs/Web/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7.md">开发者工具&lt;/a> - 网络 - Fetch/XHR” 中查看数据资源&lt;/li>
&lt;/ul>
&lt;p>扣 js 代码。主要是找到加密/解密相关的 JS 代码，找到后大段大段得放到本地，给定已加密的数据，可以正常解密就算成功。绝大部分都是扣的函数，然后传密文（密文响应体能直接看到）进去返回明文。而 JS 代码又可以被 Python 执行。&lt;/p>
&lt;ul>
&lt;li>第一步扣下来的代码通常都缺少函数、变量等，一步一步寻找并扣到缺失的函数或变量，形成完整的解密代码。&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1ew411K7nB?t=221.2&amp;amp;p=15">https://www.bilibili.com/video/BV1ew411K7nB?t=221.2&amp;amp;p=15&lt;/a>&lt;/li>
&lt;li>控制台输入内容的返回值若是函数，双击函数可以跳转到代码位置。&lt;/li>
&lt;li>使用 &lt;code>函数名.toString()&lt;/code> 的方式可以直接在控制台输出函数。此时从控制台直接拷贝即可。&lt;/li>
&lt;li>在源代码页面把鼠标放到函数上，可以看到 &lt;code>FunctionLacation&lt;/code> 标志，右侧有个连接，点击即可跳转到该函数。&lt;/li>
&lt;li>通过控制台的代码段重写 &lt;code>JSON.stringify&lt;/code>、&lt;code>JSON.parse&lt;/code> 等常见方法的逻辑，添加 debugger 关键字，以便在代码无法找到时，虽慢但准得找到解密相关代码。
&lt;ul>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1Cz4y1w78y">https://www.bilibili.com/video/BV1Cz4y1w78y&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>补环境。有的代码，可能会获取浏览器特定的一些属性，比如 &lt;a href="https://desistdaydream.github.io/docs/Web/WebAPI/WebAPI.md">WebAPI&lt;/a> 中 document、window 等对象中的数据。此时如果使用代码编译器运行代码的场合是没有办法获取到这些信息的，需要在代码中手动造一些浏览器信息。&lt;/p>
&lt;h2 id="js-逆向的调试方法">JS 逆向的调试方法&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1ew411K7nB/?p=3">JS 逆向的调试方法&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ul>
&lt;li>使用 &lt;code>Ctrl + Shift + C&lt;/code> 定位感兴趣的元素。&lt;/li>
&lt;li>在网络中使用 &lt;code>Ctrl + f&lt;/code> 打开搜索，并搜索关键字，找到被选中的请求&lt;/li>
&lt;li>从网络标签中找到被选中（深灰色北京）的请求，点击该请求的 &lt;code>启动器&lt;/code> 进入到代码位置&lt;/li>
&lt;li>使用左下角的 &lt;em>美观输出&lt;/em>，随后在代码中寻找感兴趣的内容。比如 sign 之类的关键字，找到 sign 的生成逻辑。&lt;/li>
&lt;/ul>
&lt;h2 id="已加密的数据如何处理">已加密的数据如何处理&lt;/h2>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1ew411K7nB/?p=4">遇到数据加密如何处理（一）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1ew411K7nB?p=6">遇到数据加密如何处理（二）&lt;/a>&lt;/li>
&lt;li>视频已上传到网盘&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>已加密的数据在上文调试方法中是搜索不到的。这种通常都是使用 &lt;a href="https://desistdaydream.github.io/docs/2.%E7%BC%96%E7%A8%8B/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ECMAScript/ECMAScript%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/AJAX.md">AJAX&lt;/a> 获取的数据，也就是对响应体中的 json 加密，由客户端解密才能看到。&lt;/p>
&lt;p>此时通过保存加密数据的键（常见的为 key、encrypt 等等），找到代码位置，打上断点后，进行 &lt;em>单步调试&lt;/em> 直到找到生成逻辑。&lt;/p>
&lt;h2 id="js-混淆如何处理">JS 混淆如何处理&lt;/h2>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1ew411K7nB/?p=7">关于数据加密js混淆的处理方式&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 Fetch/XHR 的请求中，从开发者工具查看该请求的启动器，如果函数名、变量名都是 &lt;code>_0x5601f0&lt;/code> 这类以 &lt;code>_0x&lt;/code> 开头的，说明代码是经过混淆的&lt;/p>
&lt;h2 id="请求参数中的-sign-如何处理">请求参数中的 sign 如何处理&lt;/h2>
&lt;blockquote>
&lt;p>&lt;a href="https://www.bilibili.com/video/BV1ew411K7nB/?p=9">请求参数sign逆向&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="hook-代码段">Hook 代码段&lt;/h2>
&lt;p>有些混淆代码无法查找，通过编写代码段后调试，可以快速定位。&lt;/p>
&lt;p>比如下面这个，可以通过 &lt;code>JSON.stringify = function (params) {}&lt;/code> 重新定义 &lt;code>JSON.stringify&lt;/code> 方法的逻辑，在其中加入文本输出和 debug 暂停能力。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">function&lt;/span> () {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">my_stringify&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">JSON&lt;/span>.&lt;span style="color:#a6e22e">stringify&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">JSON&lt;/span>.&lt;span style="color:#a6e22e">stringify&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">params&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hook 字符串化&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">params&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">debugger&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">my_stringify&lt;/span>(&lt;span style="color:#a6e22e">params&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">my_parse&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">JSON&lt;/span>.&lt;span style="color:#a6e22e">parse&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">JSON&lt;/span>.&lt;span style="color:#a6e22e">parse&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">params&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hook 解析&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">params&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">debugger&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">my_parse&lt;/span>(&lt;span style="color:#a6e22e">params&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这时，凡是页面的 JS 代码中调用了 JSON.stringify 和 JSON.parse 这俩方法的地方，都会输出参数，并被 debugger 关键字暂停以进行断点检查。然后可以在右侧 &lt;em>调用堆栈&lt;/em> 中点击直接跳转到网页的代码中，对应的位置（堆栈是顺序执行的，查看下面几个即可）。&lt;/p>
&lt;p>若是想拦截 cookie 设置，那就重新定义 &lt;code>Cookie.set&lt;/code> 方法。&lt;/p>
&lt;h2 id="cookie-处理">Cookie 处理&lt;/h2>
&lt;p>动态生成 cookie、时效性 cookie、需要登录网站&lt;/p>
&lt;p>&lt;a href="https://www.bilibili.com/video/BV1ew411K7nB/?p=17">https://www.bilibili.com/video/BV1ew411K7nB/?p=17&lt;/a> 及后面几 P&lt;/p></description></item></channel></rss>