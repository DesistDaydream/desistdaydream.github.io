<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦的站点 – 证书 与 PKI</title><link>https://desistdaydream.github.io/docs/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Cryptography/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/%E8%AF%81%E4%B9%A6-%E4%B8%8E-PKI/</link><description>Recent content in 证书 与 PKI on 断念梦的站点</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Cryptography/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/%E8%AF%81%E4%B9%A6-%E4%B8%8E-PKI/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: X.509</title><link>https://desistdaydream.github.io/docs/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Cryptography/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/%E8%AF%81%E4%B9%A6-%E4%B8%8E-PKI/X.509/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Cryptography/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/%E8%AF%81%E4%B9%A6-%E4%B8%8E-PKI/X.509/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/X.509">Wiki，X.509&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc5280">RFC，5280&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://arthurchiao.art/blog/everything-about-pki-zh/">Arthurchiao 博客，[译] 写给工程师：关于证书（certificate）和公钥基础设施（PKI）的一切（SmallStep, 2018）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc5280">RFC 5280，Internet X.509 PKI 证书和 CRL 配置文件&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>X.509 是 &lt;a href="https://desistdaydream.github.io/docs/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Cryptography/Cryptography.md">Cryptography&lt;/a> 里定义公钥证书格式的&lt;strong>标准&lt;/strong>。X.509 格式的证书已应用在包括 TSL/SSL 在内的众多网络协议里，它是 HTTPS 的基础。&lt;/p>
&lt;p>在大部分时候，人们提到证书而没有加额外的限定词时，通常都是指 X.509 v3 证书。&lt;/p>
&lt;ul>
&lt;li>更准确的说，是 RFC 5280 中描述、 CA/Browser Forum &lt;a href="https://cabforum.org/baseline-requirements-documents/">Baseline Requirements&lt;/a>中进一步完善的 PKIX 变种。&lt;/li>
&lt;li>也可以说，指的是浏览器理解并用来做 HTTPS 的那些证书。&lt;/li>
&lt;li>也是那些具有通过 HTTP + TLS 协议交互的程序们所使用的证书&lt;/li>
&lt;/ul>
&lt;p>当然，全世界并不是只有 X.509 这一种格式，SSH 和 PGP 都有其各自的格式。&lt;/p>
&lt;p>X.509 在 1988 年作为 ITU(国际电信联盟) X.500 项目的一部分首次标准化。 这是 telecom(通信) 领域的标准，想通过它构建一个 global telephone book(全球电话簿)。 虽然这个项目没有成功，但却留下了一些遗产，X.509 就是其中之一。如果查看 X.509 的证书，会看到其中包含了 locality、state、country 等信息， 之前可能会有疑问为什么为 web 设计的证书会有这些东西，现在应该明白了，因为 X.509 并不是为 web 设计的。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/puor14/1635944301557-e8774c02-d1c8-4e0f-9f7a-a2c3a7180ce0.png" alt="image.png">&lt;/p>
&lt;p>图片补充：可以说 Subject 其实就是符合 &lt;a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol#Directory_structure">Distinguished Name(专有名称，简称 DN)&lt;/a> 的规范，只不过 Subject 只是包含了 DN 中的部分字段罢了。也可以说，&lt;strong>Subject 是符合 X.509 标准的 DN。&lt;/strong>&lt;/p>
&lt;h1 id="x509-证书的格式">X.509 证书的格式&lt;a class="td-heading-self-link" href="#x509-%e8%af%81%e4%b9%a6%e7%9a%84%e6%a0%bc%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/puor14/1635931450920-fd8cad72-9ee7-476a-96ef-5e6ed60cc52b.png" alt="image.png|800">&lt;/p>
&lt;p>&lt;strong>Certificate(OBJECT)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Data(OBJECT)&lt;/strong># 证书的数据
&lt;ul>
&lt;li>&lt;strong>Version: STRING&lt;/strong> # 版本号&lt;/li>
&lt;li>&lt;strong>Serial Number: STRING&lt;/strong># 序列号&lt;/li>
&lt;li>&lt;strong>Signature Algorithm: STRING&lt;/strong> # 签名算法&lt;/li>
&lt;li>&lt;strong>Issuer: STRING&lt;/strong> # 发行人名称，也就是这个证书的签发者。&lt;/li>
&lt;li>&lt;strong>Validity(OBJECT)&lt;/strong># 有效期
&lt;ul>
&lt;li>&lt;strong>Not Before: STRING&lt;/strong># 不能早于该日期。即证书从本日期开始生效&lt;/li>
&lt;li>&lt;strong>Not After: STRING&lt;/strong># 不能晚于该日期。即证书到本日期为止失效&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Subject: STRING&lt;/strong># 主体信息。如何 X.509 规范的 Distinguished Name。
&lt;ul>
&lt;li>对于 CA 证书来说， Subject 与 Issuer 的值相同。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Subject Public Key Info:&lt;/strong># 主体的公钥信息
&lt;ul>
&lt;li>&lt;strong>Public Key Algorithm: STRING&lt;/strong># 公钥算法&lt;/li>
&lt;li>&lt;strong>主体的公钥&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Issuer Unique Identifier:&lt;/strong> # 颁发者唯一身份信息（可选项）&lt;/li>
&lt;li>&lt;strong>Subject Unique Identifier:&lt;/strong> # 主体唯一身份信息（可选项）&lt;/li>
&lt;li>&lt;strong>Extensions(OBJECT)&lt;/strong> # 扩展信息（可选项）
&lt;ul>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;li>&lt;strong>X509v3 Subject Alternative Name:&lt;/strong> # SAN 信息。常用来作为该证书的名称。&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Signature Algorithm: STRING&lt;/strong># 证书签名算法&lt;/li>
&lt;li>证书签名&lt;/li>
&lt;/ul>
&lt;p>证书的 Issuer 和证书的 Subject 用 X.509 DN 表示，DN 是由 RDN 构成的序列。RDN 用“属性类型=属性值”的形式表示。常用的属性类型名称以及简写如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性类型名称&lt;/th>
&lt;th>含义&lt;/th>
&lt;th>简写&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Common Name&lt;/td>
&lt;td>通用名称&lt;/td>
&lt;td>CN&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Organizational Unit name&lt;/td>
&lt;td>机构单元名称&lt;/td>
&lt;td>OU&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Organization name&lt;/td>
&lt;td>机构名&lt;/td>
&lt;td>O&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Locality&lt;/td>
&lt;td>地理位置&lt;/td>
&lt;td>L&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>State or province name&lt;/td>
&lt;td>州/省名&lt;/td>
&lt;td>S&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Country&lt;/td>
&lt;td>国名&lt;/td>
&lt;td>C&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="dn-与-san-命名的历史包袱">DN 与 SAN 命名的历史包袱&lt;a class="td-heading-self-link" href="#dn-%e4%b8%8e-san-%e5%91%bd%e5%90%8d%e7%9a%84%e5%8e%86%e5%8f%b2%e5%8c%85%e8%a2%b1" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="dn-distinguished-names">DN (distinguished names)&lt;a class="td-heading-self-link" href="#dn-distinguished-names" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>历史上，X.509 使用 X.500 distinguished names (DN) 来命名证书的使用者（name the subject of a certificate），即 subscriber。 一个 DN 包含了一个 common name （对作者我来说，就是 “Mike Malone”），此外还可以包含 locality、country、organization、organizational unit 及其他一些东西（数字电话簿相关）。&lt;/p>
&lt;ul>
&lt;li>没人理解 DN，它在互联网上也没什么意义。&lt;/li>
&lt;li>应该避免使用 DN。如果真的要用，也要尽量保持简单。&lt;/li>
&lt;li>无需使用全部字段，实际上，也不应该使用全部字段。&lt;/li>
&lt;li>common name 可能就是需要用到的全部字段了，如果你是一个 thrill seeker ，可以在用上一个 organization name。&lt;/li>
&lt;/ul>
&lt;p>PKIX 规定一个网站的 DNS hostname 应该关联到 DN common name。最近，CAB Forum 已 经废弃了这个规定，使整个 DN 字段变成可选的（Baseline Requirements, sections 7.1.4.2）。&lt;/p>
&lt;h3 id="san-subject-alternative-name">SAN (subject alternative name)&lt;a class="td-heading-self-link" href="#san-subject-alternative-name" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>在 &lt;a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.6">RFC 5280 的 4.2.1.6 部分&lt;/a>中，推荐的现代最佳实践是使用 &lt;strong>证书扩展中的 subject alternative name(SAN)&lt;/strong> 来绑定证书中的 name。&lt;/p>
&lt;p>常用的 SAN 有四种类型，绑定的都是广泛使用的名字：&lt;/p>
&lt;ul>
&lt;li>domain names (DNS)&lt;/li>
&lt;li>email addresse&lt;/li>
&lt;li>IP addresse&lt;/li>
&lt;li>URI&lt;/li>
&lt;/ul>
&lt;p>在我们讨论的上下文中，这些都是唯一的，而且它们能很好地映射到我们想识别的东西：&lt;/p>
&lt;ul>
&lt;li>email addresses for people&lt;/li>
&lt;li>domain names and IP addresses for machines and code,&lt;/li>
&lt;li>URIs if you want to get fancy&lt;/li>
&lt;/ul>
&lt;p>应该使用 SAN。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/puor14/1638258551706-2b7a5b62-a093-4b12-8b34-7c6b9eefe49b.png" alt="image.png|800">&lt;/p>
&lt;p>注意，Web PKI 允许在一个证书内 bind 多个 name，name 也允许通配符。也就是说，&lt;/p>
&lt;ul>
&lt;li>一个证书可以有多个 SNA，也可以有类似 *.smallstep.com 这样的 SAN。&lt;/li>
&lt;li>这对有多个域名的的网站来说很有用。&lt;/li>
&lt;/ul>
&lt;h1 id="证书扩展名与编码">证书扩展名与编码&lt;a class="td-heading-self-link" href="#%e8%af%81%e4%b9%a6%e6%89%a9%e5%b1%95%e5%90%8d%e4%b8%8e%e7%bc%96%e7%a0%81" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>通常，为了便于传输，需要为证书进行编码。就好比传输 JSON 数据时，也需要对其进行编码，收到后再解码。&lt;/p>
&lt;p>一般情况下，X.509 格式证书的原始数据，会使用 ASN.1 的 DER 进行编码，将编码后的二进制数据再使用根据 PEM 格式使用 Base64 编码，然后就会生成 PEM 格式的证书数据，实际上，所谓的 X.509 格式的文件，其实就是具有 CERTIFICATE 标志的 PEM 格式文件。&lt;/p>
&lt;ul>
&lt;li>可以将 ASN.1 理解成 X.509 的 JSON&lt;/li>
&lt;li>但是实际上，更像是 protobuf、thrift 或 SQL DDL。说白了就是通过一种算法，将人类可读的明文的证书编码成另一种便于传输的格式。&lt;/li>
&lt;/ul>
&lt;h2 id="oid">OID&lt;a class="td-heading-self-link" href="#oid" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>ASN.1 除了有常见的数据类型，如整形、字符串、集合、列表等， 还有一个&lt;strong>不常见但很重要的类型：OID&lt;/strong>（object identifier，&lt;strong>对象标识符&lt;/strong>）。&lt;/p>
&lt;ul>
&lt;li>OID &lt;strong>与 URI 有些像&lt;/strong>，但比 URI 要怪。&lt;/li>
&lt;li>OID （在设计上）是&lt;strong>全球唯一标识符&lt;/strong>。&lt;/li>
&lt;li>在结构上，OID 是在一个 hierarchical namespace 中的一个整数序列（例如 2.5.4.3）。&lt;/li>
&lt;/ul>
&lt;p>可以用 OID 来 tag 一段数据的类型。例如，一个 string 本来只是一个 string，但可 以 tag 一个 OID 2.5.4.3，然后就&lt;strong>变成了一个特殊 string&lt;/strong>：这是 &lt;strong>X.509 的通用名字（common name）&lt;/strong> 字段。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/puor14/1638343160689-8e109cf9-cb84-4a14-94fb-99421dab444c.png" alt="oids.png">&lt;/p>
&lt;h2 id="证书的扩展名">证书的扩展名&lt;a class="td-heading-self-link" href="#%e8%af%81%e4%b9%a6%e7%9a%84%e6%89%a9%e5%b1%95%e5%90%8d" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>X.509 有多种常用的扩展名。不过其中的一些还用于其它用途，就是说具有这个扩展名的文件可能并不是证书，比如说可能只是保存了私钥。&lt;/p>
&lt;ul>
&lt;li>.pem # 将使用 DER 格式编码的内容，再通过 PEM 进行 Base64 编码，得出来的数据存放在&amp;quot;&amp;mdash;&amp;ndash;BEGIN CERTIFICATE&amp;mdash;&amp;ndash;&amp;ldquo;和&amp;rdquo;&amp;mdash;&amp;ndash;END CERTIFICATE&amp;mdash;&amp;ndash;&amp;ldquo;之中&lt;/li>
&lt;li>.cer, .crt, .der – 通常是 DER 二进制格式的，但 Base64 编码后也很常见。&lt;/li>
&lt;li>.p7b, .p7c – PKCS#7 SignedData structure without data, just certificate(s) or CRL(s)&lt;/li>
&lt;li>.p12 – PKCS#12 格式，包含证书的同时可能还有带密码保护的私钥&lt;/li>
&lt;li>.pfx – PFX，PKCS#12 之前的格式（通常用 PKCS#12 格式，比如那些由 IIS 产生的 PFX 文件）&lt;/li>
&lt;/ul>
&lt;p>更多的编码信息见：&lt;a href="https://desistdaydream.github.io/docs/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Cryptography(%E5%AF%86%E7%A0%81%E5%AD%A6)/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/%E5%AF%86%E9%92%A5_%E8%AF%81%E4%B9%A6%20%E7%9A%84%E7%BC%96%E7%A0%81.md">密钥/证书 的编码&lt;/a>&lt;/p>
&lt;h1 id="证书示例">证书示例&lt;a class="td-heading-self-link" href="#%e8%af%81%e4%b9%a6%e7%a4%ba%e4%be%8b" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;h2 id="终端实体证书">终端实体证书&lt;a class="td-heading-self-link" href="#%e7%bb%88%e7%ab%af%e5%ae%9e%e4%bd%93%e8%af%81%e4%b9%a6" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>这是 wikipedia.org 和其他几个维基百科网站使用的解码 X.509 证书的示例。它由 &lt;a href="https://en.wikipedia.org/wiki/GlobalSign">GlobalSign&lt;/a> 颁发，如 &lt;code>Issuer&lt;/code> 字段中所述。它的 &lt;code>Subject&lt;/code> 字段将维基百科描述为一个组织，它的 &lt;code>Subject Alternative Name&lt;/code> 字段描述了可以使用它的域名。主题公钥信息字段包含一个&lt;a href="https://en.wikipedia.org/wiki/ECDSA">ECDSA&lt;/a>公钥，而底部的签名是由 GlobalSign 的&lt;a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA&lt;/a>私钥生成的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Certificate:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Data:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># 证书版本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Version: &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>0x2&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># 序列号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Serial Number:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 10:e6:fc:62:b7:41:8a:d5:00:5e:45:b6
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># 证书的签名算法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Signature Algorithm: sha256WithRSAEncryption
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># 证书的颁发者信息。CA 证书的 Issuer 与 Subject 相同&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Issuer: &lt;span style="color:#000">C&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>BE, &lt;span style="color:#000">O&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>GlobalSign nv-sa, &lt;span style="color:#000">CN&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>GlobalSign Organization Validation CA - SHA256 - G2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># 证书有效期&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Validity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Not Before: Nov &lt;span style="color:#0000cf;font-weight:bold">21&lt;/span> 08:00:00 &lt;span style="color:#0000cf;font-weight:bold">2016&lt;/span> GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Not After : Nov &lt;span style="color:#0000cf;font-weight:bold">22&lt;/span> 07:59:59 &lt;span style="color:#0000cf;font-weight:bold">2017&lt;/span> GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># 证书主体信息。i.e.该证书颁发给谁&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Subject: &lt;span style="color:#000">C&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>US, &lt;span style="color:#000">ST&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>California, &lt;span style="color:#000">L&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>San Francisco, &lt;span style="color:#000">O&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>Wikimedia Foundation, Inc., &lt;span style="color:#000">CN&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>*.wikipedia.org
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># 证书公钥信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Subject Public Key Info:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># 证书主体的公钥算法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Public Key Algorithm: id-ecPublicKey
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Public-Key: &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">256&lt;/span> bit&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pub:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 00:c9:22:69:31:8a:d6:6c:ea:da:c3:7f:2c:ac:a5:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> af:c0:02:ea:81:cb:65:b9:fd:0c:6d:46:5b:c9:1e:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 9d:3b:ef
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ASN1 OID: prime256v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NIST CURVE: P-256
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># X509 v3版本的扩展信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 extensions:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># 密钥用法：critical级别。包括数字签名、密钥加密&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Key Usage: critical
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Digital Signature, Key Agreement
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Authority Information Access:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CA Issuers - URI:http://secure.globalsign.com/cacert/gsorganizationvalsha2g2r1.crt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OCSP - URI:http://ocsp2.globalsign.com/gsorganizationvalsha2g2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Certificate Policies:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Policy: 1.3.6.1.4.1.4146.1.20
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CPS: https://www.globalsign.com/repository/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Policy: 2.23.140.1.2.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Basic Constraints:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CA:FALSE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 CRL Distribution Points:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Full Name:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URI:http://crl.globalsign.com/gs/gsorganizationvalsha2g2.crl
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># 证书主体名称的替代名称。i.e.别名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Subject Alternative Name:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DNS:*.wikipedia.org, DNS:*.m.mediawiki.org, DNS:*.m.wikibooks.org, DNS:*.m.wikidata.org, DNS:*.m.wikimedia.org, DNS:*.m.wikimediafoundation.org, DNS:*.m.wikinews.org, DNS:*.m.wikipedia.org, DNS:*.m.wikiquote.org, DNS:*.m.wikisource.org, DNS:*.m.wikiversity.org, DNS:*.m.wikivoyage.org, DNS:*.m.wiktionary.org, DNS:*.mediawiki.org, DNS:*.planet.wikimedia.org, DNS:*.wikibooks.org, DNS:*.wikidata.org, DNS:*.wikimedia.org, DNS:*.wikimediafoundation.org, DNS:*.wikinews.org, DNS:*.wikiquote.org, DNS:*.wikisource.org, DNS:*.wikiversity.org, DNS:*.wikivoyage.org, DNS:*.wiktionary.org, DNS:*.wmfusercontent.org, DNS:*.zero.wikipedia.org, DNS:mediawiki.org, DNS:w.wiki, DNS:wikibooks.org, DNS:wikidata.org, DNS:wikimedia.org, DNS:wikimediafoundation.org, DNS:wikinews.org, DNS:wikiquote.org, DNS:wikisource.org, DNS:wikiversity.org, DNS:wikivoyage.org, DNS:wiktionary.org, DNS:wmfusercontent.org, DNS:wikipedia.org
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># 扩展密钥用法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Extended Key Usage:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TLS Web Server Authentication, TLS Web Client Authentication
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Subject Key Identifier:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 28:2A:26:2A:57:8B:3B:CE:B4:D6:AB:54:EF:D7:38:21:2C:49:5C:36
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Authority Key Identifier:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> keyid:96:DE:61:F1:BD:1C:16:29:53:1C:C0:CC:7D:3B:83:00:40:E6:1A:7C
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic"># 证书的签名算法及其标识符&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Signature Algorithm: sha256WithRSAEncryption
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 8b:c3:ed:d1:9d:39:6f:af:40:72:bd:1e:18:5e:30:54:23:35:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="中级证书">中级证书&lt;a class="td-heading-self-link" href="#%e4%b8%ad%e7%ba%a7%e8%af%81%e4%b9%a6" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Certificate:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Data:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Version: &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>0x2&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Serial Number:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 04:00:00:00:00:01:44:4e:f0:42:47
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Signature Algorithm: sha256WithRSAEncryption
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Issuer: &lt;span style="color:#000">C&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>BE, &lt;span style="color:#000">O&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>GlobalSign nv-sa, &lt;span style="color:#000">OU&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>Root CA, &lt;span style="color:#000">CN&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>GlobalSign Root CA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Validity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Not Before: Feb &lt;span style="color:#0000cf;font-weight:bold">20&lt;/span> 10:00:00 &lt;span style="color:#0000cf;font-weight:bold">2014&lt;/span> GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Not After : Feb &lt;span style="color:#0000cf;font-weight:bold">20&lt;/span> 10:00:00 &lt;span style="color:#0000cf;font-weight:bold">2024&lt;/span> GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Subject: &lt;span style="color:#000">C&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>BE, &lt;span style="color:#000">O&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>GlobalSign nv-sa, &lt;span style="color:#000">CN&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>GlobalSign Organization Validation CA - SHA256 - G2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Subject Public Key Info:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Public Key Algorithm: rsaEncryption
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Public-Key: &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2048&lt;/span> bit&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Modulus:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 00:c7:0e:6c:3f:23:93:7f:cc:70:a5:9d:20:c3:0e:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Exponent: &lt;span style="color:#0000cf;font-weight:bold">65537&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>0x10001&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 extensions:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Key Usage: critical
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Certificate Sign, CRL Sign
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Basic Constraints: critical
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CA:TRUE, pathlen:0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Subject Key Identifier:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 96:DE:61:F1:BD:1C:16:29:53:1C:C0:CC:7D:3B:83:00:40:E6:1A:7C
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Certificate Policies:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Policy: X509v3 Any Policy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CPS: https://www.globalsign.com/repository/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 CRL Distribution Points:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Full Name:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URI:http://crl.globalsign.net/root.crl
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Authority Information Access:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OCSP - URI:http://ocsp.globalsign.com/rootr1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Authority Key Identifier:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> keyid:60:7B:66:1A:45:0D:97:CA:89:50:2F:7D:04:CD:34:A8:FF:FC:FD:4B
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Signature Algorithm: sha256WithRSAEncryption
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 46:2a:ee:5e:bd:ae:01:60:37:31:11:86:71:74:b6:46:49:c8:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="根证书">根证书&lt;a class="td-heading-self-link" href="#%e6%a0%b9%e8%af%81%e4%b9%a6" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Certificate:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Data:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Version: &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>0x2&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Serial Number:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 04:00:00:00:00:01:15:4b:5a:c3:94
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Signature Algorithm: sha1WithRSAEncryption
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Issuer: &lt;span style="color:#000">C&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>BE, &lt;span style="color:#000">O&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>GlobalSign nv-sa, &lt;span style="color:#000">OU&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>Root CA, &lt;span style="color:#000">CN&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>GlobalSign Root CA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Validity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Not Before: Sep &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> 12:00:00 &lt;span style="color:#0000cf;font-weight:bold">1998&lt;/span> GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Not After : Jan &lt;span style="color:#0000cf;font-weight:bold">28&lt;/span> 12:00:00 &lt;span style="color:#0000cf;font-weight:bold">2028&lt;/span> GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Subject: &lt;span style="color:#000">C&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>BE, &lt;span style="color:#000">O&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>GlobalSign nv-sa, &lt;span style="color:#000">OU&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>Root CA, &lt;span style="color:#000">CN&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>GlobalSign Root CA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Subject Public Key Info:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Public Key Algorithm: rsaEncryption
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Public-Key: &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2048&lt;/span> bit&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Modulus:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 00:da:0e:e6:99:8d:ce:a3:e3:4f:8a:7e:fb:f1:8b:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Exponent: &lt;span style="color:#0000cf;font-weight:bold">65537&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>0x10001&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 extensions:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Key Usage: critical
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Certificate Sign, CRL Sign
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Basic Constraints: critical
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CA:TRUE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Subject Key Identifier:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 60:7B:66:1A:45:0D:97:CA:89:50:2F:7D:04:CD:34:A8:FF:FC:FD:4B
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Signature Algorithm: sha1WithRSAEncryption
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> d6:73:e7:7c:4f:76:d0:8d:bf:ec:ba:a2:be:34:c5:28:32:b5:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="x509-格式证书数据示例">X.509 格式证书数据示例&lt;a class="td-heading-self-link" href="#x509-%e6%a0%bc%e5%bc%8f%e8%af%81%e4%b9%a6%e6%95%b0%e6%8d%ae%e7%a4%ba%e4%be%8b" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;h2 id="pem-格式数据">PEM 格式数据&lt;a class="td-heading-self-link" href="#pem-%e6%a0%bc%e5%bc%8f%e6%95%b0%e6%8d%ae" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>从 &lt;code>-----BEGIN CERTIFICATE-----&lt;/code> 开始到 &lt;code>-----END CERTIFICATE-----&lt;/code> 为止是证书的明文格式经过 ASN.1 编码再经过 Base64 编码得到的。&lt;/p>
&lt;p>对于私钥文件，真正的私钥是包含在字符串 &lt;code>-----BEGIN PRIVATE KEY-----&lt;/code> 和字符串 &lt;code>-----END PRIVATE KEY-----&lt;/code> 之间。&lt;/p>
&lt;h2 id="原始数据">原始数据&lt;a class="td-heading-self-link" href="#%e5%8e%9f%e5%a7%8b%e6%95%b0%e6%8d%ae" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># openssl x509 -text -noout -in apiserver.crt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Certificate:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Data:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Version: &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>0x2&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> &lt;span style="color:#8f5902;font-style:italic"># 证书版本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Serial Number: &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>0x0&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> &lt;span style="color:#8f5902;font-style:italic"># 序列号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Signature Algorithm: sha256WithRSAEncryption &lt;span style="color:#8f5902;font-style:italic"># 证书的签名算法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Issuer: &lt;span style="color:#000">CN&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>kubernetes &lt;span style="color:#8f5902;font-style:italic"># 证书的颁发者信息。CA证书的Issuer与Subject相同&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Validity &lt;span style="color:#8f5902;font-style:italic"># 证书有效期&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Not Before: Nov &lt;span style="color:#0000cf;font-weight:bold">20&lt;/span> 08:45:23 &lt;span style="color:#0000cf;font-weight:bold">2019&lt;/span> GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Not After : Nov &lt;span style="color:#0000cf;font-weight:bold">17&lt;/span> 08:45:23 &lt;span style="color:#0000cf;font-weight:bold">2029&lt;/span> GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Subject: &lt;span style="color:#000">CN&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>kube-apiserver &lt;span style="color:#8f5902;font-style:italic"># 证书主体信息。i.e.该证书颁发给谁&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Subject Public Key Info: &lt;span style="color:#8f5902;font-style:italic"># 证书公钥信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Public Key Algorithm: rsaEncryption &lt;span style="color:#8f5902;font-style:italic"># 证书主体的公钥算法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Public-Key: &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2048&lt;/span> bit&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Modulus:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 00:c7:2e:02:61:db:b0:24:db:22:aa:46:94:de:7e:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Exponent: &lt;span style="color:#0000cf;font-weight:bold">65537&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>0x10001&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 extensions: &lt;span style="color:#8f5902;font-style:italic"># X509 v3版本的扩展信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Key Usage: critical &lt;span style="color:#8f5902;font-style:italic"># 密钥用法：critical级别。包括数字签名、密钥加密&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Digital Signature, Key Encipherment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Extended Key Usage: &lt;span style="color:#8f5902;font-style:italic"># 扩展密钥用法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TLS Web Server Authentication
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Subject Alternative Name: &lt;span style="color:#8f5902;font-style:italic"># 证书主体名称的替代名称。i.e.别名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DNS:master-1.k8s.cloud.tjiptv.net, DNS:kubernetes, DNS:kubernetes.default, DNS:kubernetes.default.svc, DNS:kubernetes.default.svc.cluster.local, IP Address:10.96.0.1, IP Address:10.10.9.51, IP Address:10.10.9.54
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Signature Algorithm: sha256WithRSAEncryption &lt;span style="color:#8f5902;font-style:italic"># 证书的签名算法及其标识符&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 47:38:42:cf:02:85:71:49:ac:19:9c:ba:3a:f3:74:c3:4b:09:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .....
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: SSL/TLS Pinning</title><link>https://desistdaydream.github.io/docs/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Cryptography/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/%E8%AF%81%E4%B9%A6-%E4%B8%8E-PKI/SSL_TLS-Pinning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Cryptography/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/%E8%AF%81%E4%B9%A6-%E4%B8%8E-PKI/SSL_TLS-Pinning/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/HTTP_Public_Key_Pinning">Wiki，HTTP_Public_Key_Pinning&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://owasp.org/www-community/controls/Certificate_and_Public_Key_Pinning">OWASP，Certificate and Public Key Pinning&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/58204817">知乎，证书锁定SSL Pinning简介及用途&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>SSL/TLS Pinning&lt;/strong> 也可以称为 &lt;strong>Public Key Pinning&lt;/strong>、&lt;strong>Certificate Pinning&lt;/strong>。顾名思义，将服务器提供的 SSL/TLS 证书内置到移动端开发的 APP 客户端中，当客户端发起请求时，通过比对内置的证书和服务器端证书的内容，以确定这个连接的合法性。&lt;/p>
&lt;p>在公共网络中通知我们使用安全的 SSL/TLS 通信协议来进行通信，并且使用数字证书来提供加密和认证，在《&lt;a href="https://link.zhihu.com/?target=https%3A//www.infinisign.com/faq/ssl-hello-process">HTTPS入门, 图解SSL从回车到握手&lt;/a>》过程中我们知道握手环节仍然面临（MIM中间人）攻击的可能性，因为CA证书签发机构也存在被黑客入侵的可能性，同时移动设备也面临内置证书被篡改的风险。&lt;/p>
&lt;h1 id="ssltls-pinning-原理">SSL/TLS Pinning 原理&lt;a class="td-heading-self-link" href="#ssltls-pinning-%e5%8e%9f%e7%90%86" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>证书锁定（SSL/TLS Pinning）提供了两种锁定方式： &lt;strong>Certificate Pinning&lt;/strong> 和 &lt;strong>Public Key Pinning&lt;/strong>，文头和概述描述的实际上是 Certificate Pinning（证书锁定）。&lt;/p>
&lt;p>HTTP Public Key Pinning(简称 HPKP) 在 RFC 7469 中标准化。扩展了 Certificate Pinning，Certificate Pinning 对 Web 浏览器和应用程序中的知名网站或服务的公钥哈希进行硬编码。&lt;/p>
&lt;h2 id="证书锁定">证书锁定&lt;a class="td-heading-self-link" href="#%e8%af%81%e4%b9%a6%e9%94%81%e5%ae%9a" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>我们需要将APP代码内置仅接受指定域名的证书，而不接受操作系统或浏览器内置的CA根证书对应的任何证书，通过这种授权方式，保障了APP与服务端通信的唯一性和安全性，因此我们移动端APP与服务端（例如API网关）之间的通信是可以保证绝对安全。但是CA签发证书都存在有效期问题，所以缺点是在证书续期后需要将证书重新内置到APP中。&lt;/p>
&lt;h2 id="公钥锁定">公钥锁定&lt;a class="td-heading-self-link" href="#%e5%85%ac%e9%92%a5%e9%94%81%e5%ae%9a" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>公钥锁定则是提取证书中的公钥并内置到移动端APP中，通过与服务器对比公钥值来验证连接的合法性，我们在制作证书密钥时，公钥在证书的续期前后都可以保持不变（即密钥对不变），所以可以避免证书有效期问题。&lt;/p>
&lt;h1 id="证书锁定指纹hash">证书锁定指纹(Hash)&lt;a class="td-heading-self-link" href="#%e8%af%81%e4%b9%a6%e9%94%81%e5%ae%9a%e6%8c%87%e7%ba%b9hash" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;h2 id="获取移动端所需证书">获取移动端所需证书&lt;a class="td-heading-self-link" href="#%e8%8e%b7%e5%8f%96%e7%a7%bb%e5%8a%a8%e7%ab%af%e6%89%80%e9%9c%80%e8%af%81%e4%b9%a6" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>如果采用证书锁定方式，则获取证书的摘要hash，以 &lt;a href="https://link.zhihu.com/?target=https%3A//www.infinisign.com/infinisign.com">infinisign.com&lt;/a> 为例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>## 在线读取服务器端.cer格式证书
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl s_client -connect infinisign.com:443 -showcerts &amp;lt; /dev/null | openssl x509 -outform DER &amp;gt; infinisign.der
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>## 提取证书的摘要hash并查看base64格式
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl dgst -sha256 -binary infinisign.der | openssl enc -base64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wLgBEAGmLltnXbK6pzpvPMeOCTKZ0QwrWGem6DkNf6o=
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以其中的&lt;code>wLgBEAGmLltnXbK6pzpvPMeOCTKZ0QwrWGem6DkNf6o=&lt;/code>就是我们将要进行证书锁定的指纹(Hash)信息。&lt;/p>
&lt;h2 id="获取移动端所需公钥">获取移动端所需公钥&lt;a class="td-heading-self-link" href="#%e8%8e%b7%e5%8f%96%e7%a7%bb%e5%8a%a8%e7%ab%af%e6%89%80%e9%9c%80%e5%85%ac%e9%92%a5" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>如果采用公钥锁定方式，则获取证书公钥的摘要hash，以&lt;a href="https://link.zhihu.com/?target=https%3A//www.infinisign.com/infinisign.com">infinisign.com&lt;/a>为例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">## 在线读取服务器端证书的公钥&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl x509 -pubkey -noout -in infinisign.der -inform DER &lt;span style="color:#000;font-weight:bold">|&lt;/span> openssl rsa -outform DER -pubin -in /dev/stdin 2&amp;gt;/dev/null &amp;gt; infinisign.pubkey
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">## 提取证书的摘要hash并查看base64格式&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl dgst -sha256 -binary infinisign.pubkey &lt;span style="color:#000;font-weight:bold">|&lt;/span> openssl enc -base64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">bAExy9pPp0EnzjAlYn1bsSEGvqYi1shl1OOshfH3XDA&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以其中的&lt;code>bAExy9pPp0EnzjAlYn1bsSEGvqYi1shl1OOshfH3XDA=&lt;/code>就是我们将要进行证书锁定的指纹(Hash)信息。&lt;/p>
&lt;h1 id="总结">总结&lt;a class="td-heading-self-link" href="#%e6%80%bb%e7%bb%93" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>证书锁定旨在解决移动端APP与服务端通信的唯一性，实际通信过程中，如果锁定过程失败，那么客户端APP将拒绝针对服务器的所有 SSL/TLS 请求，FaceBook/Twitter则通过证书锁定以防止Charles/Fiddler等抓包工具中间人攻击，关于如何在Android、IOS的各类开发工具中设置证书锁定，请参照《&lt;a href="https://link.zhihu.com/?target=https%3A//www.infinisign.com/faq/what-is-ssl-pinning%23">Android SSL证书锁定(SSL/TLS Pinning)&lt;/a>》、《&lt;a href="https://link.zhihu.com/?target=https%3A//www.infinisign.com/faq/ios-ssl-pinning-three-method">IOS SSL证书锁定(SSL/TLS Pinning)&lt;/a>》。&lt;/p></description></item><item><title>Docs: 证书 与 PKI</title><link>https://desistdaydream.github.io/docs/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Cryptography/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/%E8%AF%81%E4%B9%A6-%E4%B8%8E-PKI/%E8%AF%81%E4%B9%A6-%E4%B8%8E-PKI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Cryptography/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/%E8%AF%81%E4%B9%A6-%E4%B8%8E-PKI/%E8%AF%81%E4%B9%A6-%E4%B8%8E-PKI/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Public_key_certificate">Wiki，Public Key Certificate&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Public_key_infrastructure">Wiki，PKI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Certificate_signing_request">Wiki，CSR&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Certificate_authority">Wiki，CA&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Root_certificate">Wiki，Root Certificate&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc5280">RFC,5280&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/E-aU-lbieGLokDKbjdGc3g">公众号,云原生生态圈-白话文说 CA 原理&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://arthurchiao.art/blog/everything-about-pki-zh/">Arthurchiao 博客,[译] 写给工程师：关于证书（certificate）和公钥基础设施（PKI）的一切（SmallStep, 2018）&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/li3ZjfNgX5nh7AKjyyzt5A">公众号-云原生实验室，搬运了上面的文章&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Certificate 与 PKI 的目标很简单：Bind names to Public Keys(将名字关联到公钥)。这是关于 Certificate 与 PKI 的最高抽象，其他都是属于实现细节&lt;/p>
&lt;h1 id="certificate">Certificate&lt;a class="td-heading-self-link" href="#certificate" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;strong>Certificate(证书)&lt;/strong> 在密码学中，是指 &lt;a href="https://desistdaydream.github.io/docs/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Cryptography/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86.md">公开密钥加密&lt;/a> 中完善其签名&lt;a href="https://desistdaydream.github.io/docs/7.%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Cryptography/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86.md#%E7%BC%BA%E7%82%B9">缺点&lt;/a>的 &lt;strong>Public Key Certificate(公钥证书)&lt;/strong>。在公开密钥加密的介绍中，我们看到了公钥加密的特点，并且也发现了缺点，公钥容易被劫持。那么为了解决这个问题，就需要一个东西可以&lt;strong>验证公钥的真实性&lt;/strong>。公钥证书也就由此而来。&lt;/p>
&lt;p>&lt;strong>Public Key Certificate(公钥证书，简称 PKC)&lt;/strong> 也称为 &lt;strong>Digital Certifacte(数字证书)&lt;/strong> 或 &lt;strong>Identity Certificate(身份证书)&lt;/strong>，是一种用于证明公钥的所有权的电子文档。&lt;/p>
&lt;p>假设有这么一种场景：公钥加密系统使我们能知道和谁在通信，但这个事情的前提是：我们必须要有对方的公钥&lt;/p>
&lt;p>那么，如果我们不知道对方的公钥，那么该怎么办呢？这时候 Certificate 就出现了。&lt;/p>
&lt;ul>
&lt;li>首先，我需要从对方手里拿到公钥和其拥有者的信息&lt;/li>
&lt;li>那么我如何相信我拿到的信息是真实有效的呢？~可以请一个双方都信任的权威机构，对我拿到的信息做出证明
&lt;ul>
&lt;li>而这个权威机构用来证明信息有效的东西，就是 Certificate&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>公钥证书通常应该包含如下内容：&lt;/p>
&lt;ul>
&lt;li>密钥的信息&lt;/li>
&lt;li>有关其所有者的身份信息，称为 Subject(主体)&lt;/li>
&lt;li>验证证书内容的实体的数字签名，这个实体称为 Issuer(发行人)&lt;/li>
&lt;li>权威机构对证书的签名，签名的大概意思就是：&lt;code>Public key XXX 关联到了 name XXX&lt;/code>，这就对应了文章开头的那句话：Certificate 与 PKI 的目标很简单：Bind names to Public Keys(将名字关联到公钥)
&lt;ul>
&lt;li>对证书的签名的实体称为 &lt;strong>Certificate Authority(简称 CA)&lt;/strong>，也可以称为 &lt;strong>Issuer(签发者)&lt;/strong>。&lt;/li>
&lt;li>被签名的实体称为 &lt;strong>Subject(主体)&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>举个例子，如果某个 Issuer 为 Bob 签发了一张证书，其中的内容就可以解读如下：&lt;/p>
&lt;p>&lt;em>Some Issuer&lt;/em> says &lt;em>Bob&lt;/em>’s public key is 01:23:42…&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wlyw54/1634110798410-4fe856d6-2d02-43a9-b233-229b8d48fa51.png" alt="image.png|800">&lt;/p>
&lt;p>证书是权威机构颁发的身份证明，并没有什么神奇之处&lt;/p>
&lt;p>其中 &lt;code>Some Issuer&lt;/code> 是证书的签发者(CA)，证书是为了证明这是 Bob 的公钥， Some Issuer 也是这个声明的签字方。&lt;/p>
&lt;p>如果签名有效，并且检查证书的软件信任发行者，那么它可以使用该密钥与证书的主题安全地通信。在电子邮件加密，代码签名和电子签名系统中，证书的主体通常是一个人或组织。然而，在传输层安全性（TLS）中，证书的主体通常是计算机或其他设备，但除了在识别设备中的核心作用之外，TLS 证书还可以识别组织或个人。 TLS 有时被其旧的名称安全套接字层（SSL）调用，对于 HTTPS 的一部分是值得注意的，该协议是安全浏览 Web 的协议。&lt;/p>
&lt;p>公钥证书最常用的格式是 X.509 标准。&lt;/p>
&lt;h2 id="证书的类型">证书的类型&lt;a class="td-heading-self-link" href="#%e8%af%81%e4%b9%a6%e7%9a%84%e7%b1%bb%e5%9e%8b" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;ol>
&lt;li>自签名证书：一般都是 CA 机构使用 CA 自己的的公钥签署的证书，这样别人拿到该证书后，才可以去找 CA 验证这个证书是不是可信的。&lt;/li>
&lt;li>根证书：根证书是标识根证书颁发机构(CA)的公钥证书。根证书是自签名的，并构成基于 X.509 的公钥基础结构（PKI）的基础。&lt;/li>
&lt;li>TLS / SSL 服务器证书&lt;/li>
&lt;li>TLS / SSL 客户端证书&lt;/li>
&lt;li>电子邮件证书&lt;/li>
&lt;li>代码签名证书&lt;/li>
&lt;li>合格证书&lt;/li>
&lt;li>中级证书&lt;/li>
&lt;li>终端实体或叶子证书&lt;/li>
&lt;/ol>
&lt;h1 id="public-key-infrastructure">Public Key Infrastructure&lt;a class="td-heading-self-link" href="#public-key-infrastructure" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;strong>Public Key Infrastructure(公钥基础设施)&lt;/strong> 是用来管理数字证书和管理公钥加密所需的一组 Entity(实体，包括但不限于 角色、策略、硬件、软件、程序 等等)。PKI 的目的是为了促进一系列网络活动的安全传输，例如电子商务、网上银行、敏感电子邮件。&lt;/p>
&lt;p>PKI 是通用的，与厂商无关的概念，适用于任何地方，因此及时系统分布在世界各地，彼此之间也能安全地通信；如果我们使用 TLS everywhere 模型，甚至连 VPN 都不需要。&lt;/p>
&lt;p>PKI 的标准由 RFC 5280 定义，然后 &lt;a href="https://cabforum.org/">CA/Browser Forum&lt;/a> (a.k.a., CA/B or CAB Forum) 对其进行了进一步完善。PKI 的标准称为 &lt;strong>Public-Key Infrastructure(X.509)(公要基础设施(X.509)，简称 PKIX)&lt;/strong>，由于 PKIX 是围绕 X.509 证书标准定义的 PKI 标准，所以 PKI 后面就加了一个 X~~~~~o(╯□╰)o ~~~从 RFC 5280 也可以看到每页文档的页眉写的是 &lt;code>PKIX Certificate and CRL Profile&lt;/code>。并且 IETF 与 1995 年秋季成了了 &lt;a href="https://datatracker.ietf.org/wg/pkix/about/">PKIX 工作组&lt;/a>。&lt;/p>
&lt;h2 id="certificate-authority证书权威">Certificate Authority(证书权威)&lt;a class="td-heading-self-link" href="#certificate-authority%e8%af%81%e4%b9%a6%e6%9d%83%e5%a8%81" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;strong>Certificate Authority(证书权威，简称 CA)&lt;/strong> 是拥有公信力的颁发数字证书的实体，通常称为&lt;strong>证书颁发机构&lt;/strong>。&lt;/p>
&lt;p>CA 自身的证书，通常称为 &lt;strong>Root Certificate(根证书)&lt;/strong>，根证书是使用 CA 的私钥 &lt;strong>Self-signed(自签名的)&lt;/strong>，且是 CA 的唯一标识。&lt;/p>
&lt;p>&lt;strong>CA 使用自己的私钥为其他实体签名并颁发证书&lt;/strong>。就像文章开头提到的一样，Bind names to Public Keys，CA 为公钥和名字之间的绑定关系做担保。&lt;/p>
&lt;h3 id="trust-stores信任仓库即操作系统浏览器等保存证书的地方">Trust Stores(信任仓库)，即操作系统、浏览器等保存证书的地方&lt;a class="td-heading-self-link" href="#trust-stores%e4%bf%a1%e4%bb%bb%e4%bb%93%e5%ba%93%e5%8d%b3%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%b5%8f%e8%a7%88%e5%99%a8%e7%ad%89%e4%bf%9d%e5%ad%98%e8%af%81%e4%b9%a6%e7%9a%84%e5%9c%b0%e6%96%b9" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>那么，当我们访问一个网站时，是如何验证其证书的真实性呢?~其实，通常都会有一个 CA 仓库，用来保存一些预配置的可信的根证书。凭借这些预配置的根证书，当我们访问互联网上绝大部分网站时，就可以验证其身份。&lt;/p>
&lt;p>这个信任仓库又是如何来的呢？&lt;/p>
&lt;ul>
&lt;li>浏览器 # 浏览器默认使用的信任仓库以及其他任何使用 TLS 的东西，都是由 4 个组织维护的
&lt;ul>
&lt;li>&lt;a href="http://www.apple.com/certificateauthority/ca_program.html">Apple’s root certificate&lt;/a>：iOS/macOS 程序&lt;/li>
&lt;li>&lt;a href="https://social.technet.microsoft.com/wiki/contents/articles/31633.microsoft-trusted-root-program-requirements.aspx">Microsoft’s root certificate program&lt;/a>：Windows 使用&lt;/li>
&lt;li>&lt;a href="https://www.mozilla.org/en-US/about/governance/policies/security-group/certs/">Mozilla’s root certificate program&lt;/a>： Mozilla 产品使用，由于其开放和透明，也作为其他一些信任仓库从基础 (e.g., for many Linux distributions)&lt;/li>
&lt;li>Google &lt;a href="https://www.chromium.org/Home/chromium-security/root-ca-policy">未维护 root certificate program&lt;/a> （Chrome 通常使用所在计算的操作系统的信任仓库），但 &lt;a href="https://chromium.googlesource.com/chromium/src/+/master/net/data/ssl/blacklist/README.md">维护了自己的黑名单&lt;/a>， 列出了自己不信任的根证书或特定证书。 (&lt;a href="https://chromium.googlesource.com/chromiumos/docs/+/master/ca_certs.md">ChromeOS builds off of Mozilla’s certificate program&lt;/a>)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>操作系统 # 操作系统中的信任仓库通常是各自发行版自带的。不同的发行版，保存路径不同，保存方式也不同：
&lt;ul>
&lt;li>CentOS 发行版
&lt;ul>
&lt;li>/etc/pki/ca-trust/extracted/openssl/ca-bundle.trust.crt # 包含所有证书，每个证书前有注释&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Ubuntu 发行版
&lt;ul>
&lt;li>/etc/ssl/certs/* # 该目录中一个证书一个文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Windows，证书位置如图
&lt;ul>
&lt;li>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wlyw54/1662898111701-e46d8a99-c518-48fa-8eb2-9a37448d3df3.png" alt="image.png">&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>信任仓库中通常包含了超过 100 个由这些程序维护的常见 CA。比如：&lt;/p>
&lt;ul>
&lt;li>Let’s Encrypt&lt;/li>
&lt;li>Symantec&lt;/li>
&lt;li>DigiCert&lt;/li>
&lt;li>Entrust&lt;/li>
&lt;/ul>
&lt;h4 id="示例">示例&lt;a class="td-heading-self-link" href="#%e7%a4%ba%e4%be%8b" aria-label="Heading self-link">&lt;/a>&lt;/h4>
&lt;p>比如在 Linux 各种发行版中上述目录中有一个名为 GlobalSign_Root_CA 的根证书，百度就是使用这个证书签名的。&lt;/p>
&lt;p>这是通过浏览器访问 &lt;a href="http://www.baidu.com">http://www.baidu.com&lt;/a> 获取到的证书信息&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wlyw54/1638255619893-aaa4aaf0-0b19-4aab-94c7-ea6d52c40e8b.png" alt="image.png">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wlyw54/1638255970307-44dc01bc-7d7d-4adb-94c7-bb7ec2ce1636.png" alt="image.png">&lt;/p>
&lt;p>这是从服务器的 CA 仓库中获取的 GlobalSign_Root_CA 这个 CA 的证书信息&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wlyw54/1638255663132-94adcb92-b634-4f45-936b-8f51245f7558.png" alt="image.png">&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>root@hw-cloud-xngy-jump-server-linux-2 ~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>&lt;span style="color:#8f5902;font-style:italic"># openssl x509 -text -noout -in /etc/ssl/certs/GlobalSign_Root_CA.pem&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Certificate:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Data:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Version: &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>0x2&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Serial Number:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 04:00:00:00:00:01:15:4b:5a:c3:94
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Signature Algorithm: sha1WithRSAEncryption
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Issuer: &lt;span style="color:#000">C&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> BE, &lt;span style="color:#000">O&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> GlobalSign nv-sa, &lt;span style="color:#000">OU&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> Root CA, &lt;span style="color:#000">CN&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> GlobalSign Root CA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Validity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Not Before: Sep &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> 12:00:00 &lt;span style="color:#0000cf;font-weight:bold">1998&lt;/span> GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Not After : Jan &lt;span style="color:#0000cf;font-weight:bold">28&lt;/span> 12:00:00 &lt;span style="color:#0000cf;font-weight:bold">2028&lt;/span> GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Subject: &lt;span style="color:#000">C&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> BE, &lt;span style="color:#000">O&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> GlobalSign nv-sa, &lt;span style="color:#000">OU&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> Root CA, &lt;span style="color:#000">CN&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> GlobalSign Root CA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，两个证书的信息是一样的，时间不一致是由于时区设置的问题，浏览器直接打开证书变成了东八区。所以是 20:00:00；如果从窗口导出证书成文件，再使用 openssl 命令查看，就可以发现，两个证书是一模一样的。&lt;/p>
&lt;h3 id="chain-of-trust信任链">Chain of trust(信任链)&lt;a class="td-heading-self-link" href="#chain-of-trust%e4%bf%a1%e4%bb%bb%e9%93%be" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wlyw54/1638252283465-124564d9-4f52-4812-9cfb-484fb54b599b.png" alt="image.png">
CA 使用自己的私钥签一个根证书，然后再为下级 Issuer 签署证书，下级 Issuer 还可以为其自身的下级 Issuer 签署证书。这么层层签署，可以形成一个树形结构的信任链。&lt;/p>
&lt;p>现在假如 A 是 CA，签署证书给 B，C 想访问 B 提供的服务，C 在访问时，如何确保 B 就是 B 呢？~这就是 TLS/SSL 协议所要做的事情。总结一下就是 C 首先要获取 A 的证书，这是访问 B 时，就可以使用 A 的证书验证 B 的证书。并且，由于 A 的证书是用其私钥签名的，只要 A 签证书的私钥(即 CA 的私钥)不泄露，整个信任链就是可信的。&lt;/p>
&lt;h3 id="保证-ca-私钥的安全">保证 CA 私钥的安全&lt;a class="td-heading-self-link" href="#%e4%bf%9d%e8%af%81-ca-%e7%a7%81%e9%92%a5%e7%9a%84%e5%ae%89%e5%85%a8" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>CAB Forum Baseline Requirements 4.3.1 明确规定：一个 Web PKI CA 的 root private key 只能通过 issue a direct command 来签发证书。&lt;/p>
&lt;ul>
&lt;li>换句话说，Web PKI root CA 不能自动化证书签名（certificate signing）过程。&lt;/li>
&lt;li>对于任何大的 CA operation 来说，无法在线完成都是一个问题。 不可能每次签发一个证书时，都人工敲一个命令。&lt;/li>
&lt;/ul>
&lt;p>这样规定是出于安全考虑。&lt;/p>
&lt;ul>
&lt;li>Web PKI root certificates 广泛存在于信任仓库中，很难被撤回。截获一个 root CA private key 理论上将影响几十亿的人和设备。&lt;/li>
&lt;li>因此，最佳实践就是，确保 root private keys 是离线的（offline），理想情况下在一些 &lt;a href="https://en.wikipedia.org/wiki/Hardware_security_module">专用硬件&lt;/a> 上，连接到某些物理空间隔离的设备上，有很好的物理安全性，有严格的使用流程。&lt;/li>
&lt;/ul>
&lt;p>一些 internal PKI 也遵循类似的实践，但实际上并没有这个必要。&lt;/p>
&lt;ul>
&lt;li>如果能自动化 root certificate rotation （例如，通过配置管理或编排工具，更新信任仓库）， 你就能轻松地 rotate 一个 compromised root key。&lt;/li>
&lt;li>由于人们如此沉迷于 internal PKI 的根秘钥管理，导致 internal PKI 的部署效率大大 降低。你的 AWS root account credentials 至少也是机密信息，你又是如何管理它的呢？&lt;/li>
&lt;/ul>
&lt;h3 id="其他">其他&lt;a class="td-heading-self-link" href="#%e5%85%b6%e4%bb%96" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>可以通过工具来创建私有 CA 证书(即自己创造一个 CA 所用的证书，等于是自己的其中一台设备当做 CA 来给自己所用的其余设备颁发证书)(自签名的)以便让个人或公司内部使用。比如 openssl 工具就可以实现。openssl 即可创建私有 CA 证书。&lt;/p>
&lt;h2 id="certificate-signing-request证书签名请求">Certificate Signing Request(证书签名请求)&lt;a class="td-heading-self-link" href="#certificate-signing-request%e8%af%81%e4%b9%a6%e7%ad%be%e5%90%8d%e8%af%b7%e6%b1%82" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>在 PKI 系统中，&lt;strong>Certificate Signing Request(证书签名请求，简称 CSR)&lt;/strong> 是申请人发送到 PKI 的注册机构，用来申请&lt;strong>公钥证书&lt;/strong>的一种消息。&lt;/p>
&lt;p>CSR 最常见的格式是 &lt;a href="https://en.wikipedia.org/wiki/PKCS">PKCS&lt;/a>＃10 规范；另一个是某些&lt;a href="https://en.wikipedia.org/wiki/Web_browser">浏览器&lt;/a>生成的签名公钥和质询 &lt;a href="https://en.wikipedia.org/wiki/SPKAC">SPKAC&lt;/a> 格式。&lt;/p>
&lt;p>在创建 CSR 之前，申请人首先需要生成一个密钥对，并将私钥保密。实际上，CSR 也可以称为证书，想要创建一个 CSR，则需要使用申请人的密钥中的私钥进行签名。&lt;/p>
&lt;p>CSR 中应包含&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>名字&lt;/strong> # 申请人的识别信息(比如 X.509 规范中的 Subject 字段)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>公钥&lt;/strong> # 从申请人密钥中提取出的公钥&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>签名&lt;/strong> #&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>其他信息&lt;/strong> #&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="证书的验证过程">证书的验证过程&lt;a class="td-heading-self-link" href="#%e8%af%81%e4%b9%a6%e7%9a%84%e9%aa%8c%e8%af%81%e8%bf%87%e7%a8%8b" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>CA 收到一个 CSR 并验证签名之后，接下来需要确认证书中绑定的 name 是否真的 是这个 subscriber 的 name。这项工作很棘手。 证书的核心功能是&lt;strong>能让 RP 对 subscriber 进行认证&lt;/strong>。因此， 如果一个&lt;strong>证书都还没有颁发，CA 如何对这个 subscriber 进行认证呢&lt;/strong>？
答案是：分情况。&lt;/p>
&lt;h2 id="web-pki-证明身份过程">Web PKI 证明身份过程&lt;a class="td-heading-self-link" href="#web-pki-%e8%af%81%e6%98%8e%e8%ba%ab%e4%bb%bd%e8%bf%87%e7%a8%8b" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>Web PKI 有三种类型的证书，它们&lt;strong>最大的区别就是如何识别 subscriber&lt;/strong>， 以及它们所用到的 &lt;strong>identity proofing 机制&lt;/strong>。
这三种证书是：&lt;/p>
&lt;ol>
&lt;li>domain validation (DV，域验证)DV 证书绑定的是 &lt;strong>DNS name&lt;/strong>，CA 在颁发时需要验证的这个 domain name 确实是由该 subscriber 控制的。证明过程通常是通过一个简单的流程，例如
&lt;ol>
&lt;li>给 WHOIS 记录中该 domain name 的管理员发送一封确认邮件。&lt;/li>
&lt;li>&lt;a href="https://ietf-wg-acme.github.io/acme/draft-ietf-acme-acme.html">ACME protocol&lt;/a> （最初由 Let’s Encrypt 开发和使用）改进了这种方式，更加自动化：不再用邮件验证 ，而是由 ACME CA 提出一个 challenge，该 subscriber 通过完成这个问题来证明它拥有 这个域名。challenge 部分属于 ACME 规范的扩展部门，常见的包括：
&lt;ul>
&lt;li>在指定的 URL 上提供一个随机数（HTTP challenge）&lt;/li>
&lt;li>在 DNS TXT 记录中放置一个随机数（DNS challenge）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>organization validation (OV，组织验证)
&lt;ul>
&lt;li>OV 和下面将介绍的 EV 证书构建在 DV 证书之上，它们包括了 name 和域名 &lt;strong>所属组织的位置信息（location）&lt;/strong>。&lt;/li>
&lt;li>OV 和 EV 证书不仅仅将证书关联到域名，还关联到控制这个域名的法律实体（legal entity）。&lt;/li>
&lt;li>OV 证书的验证过程，不同的 CA 并不统一。为解决这个问题，CAB Forum 引入了 EV 证书。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>extended validation&lt;/strong> (EV，扩展验证)这些完成之后，当相应网站时，&lt;strong>某些浏览器会在 URL 栏中显示该组织的名称&lt;/strong>。例如：&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/wlyw54/1638261597799-3bbc2a87-727d-4c25-8492-f993a2e94ead.png" alt="image.png">但除了这个场景之外，EV certificates 并未得到广泛使用，Web PKI RP 也未强依赖它。
&lt;ul>
&lt;li>EV 证书包含的基本信息与 OV 是一样的，但强制要求严格验证（identity proofing）。&lt;/li>
&lt;li>EV 过程需要几天或几个星期，其中可能包括公网记录搜索（public records searches）和公司人员（用笔）签署的（纸质）证词。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>本质上来说，每个 Web PKI RP 只需要 DV 级别的 assurance&lt;/strong> 就行了， 也就是确保域名是被该 subscriber 控制的。重要的是能理解一个 DV 证书在设计上的意思和在实际上做了什么：&lt;/p>
&lt;ul>
&lt;li>在设计上，希望通过它证明：请求这个证书的 entity 拥有对应的域名；&lt;/li>
&lt;li>在实际上，真正完成的操作是：在某个时间，请求这个证书的 entity 能读一封邮件，或配置一条 DNS 记录，或能通过 HTTP serve 一个指定随机数等等。&lt;/li>
&lt;/ul>
&lt;p>但话说回来，DNS、电子邮件和 BGP 这些底层基础设施本身的安全性也并没有做到足够好， 针对这些基础设施的攻击还是 &lt;a href="https://doublepulsar.com/hijack-of-amazons-internet-domain-service-used-to-reroute-web-traffic-for-two-hours-unnoticed-3a6f0dda6a6f">时有发生&lt;/a>， 目的之一就是获取证书。&lt;/p>
&lt;h2 id="internal-pki-证明身份过程">Internal PKI 证明身份过程&lt;a class="td-heading-self-link" href="#internal-pki-%e8%af%81%e6%98%8e%e8%ba%ab%e4%bb%bd%e8%bf%87%e7%a8%8b" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>上面是 Web PKI 的身份证明过程，再来看 internal PKI 的身份证明过程。
实际上，用户可以使用&lt;strong>任何方式&lt;/strong>来做 internal PKI 的 identity proofing， 并且效果可能比 Web PKI 依赖 DNS 或邮件方式的效果更好。
乍听起来好像很难，但其实不难，因为可以&lt;strong>利用已有的受信基础设施&lt;/strong>： 用来搭建基础设施的工具，也能用来为这些基础设施之上的服务创建和证明安全身份。&lt;/p>
&lt;ul>
&lt;li>如果用户已经信任 Chef/Puppet/Ansible/Kubernetes，允许它们将代码放到服务器上， 那也应该信任它们能完成 identity attestations&lt;/li>
&lt;li>如果在 AWS 上，可以用 &lt;a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html">instance identity documents&lt;/a>&lt;/li>
&lt;li>如果在 GCP：&lt;a href="https://cloud.google.com/compute/docs/instances/verifying-instance-identity">GCP&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/how-to-use-vm-token">Azure&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>provisioning infrastructure 必须理解 identity 的概念，这样才能将正确的代码放到正确的位置。 此外，用户必须信任这套机制。基于这些知识和信任，才能配置 RP 信任仓库、将 subscribers 纳入你的 internal PKI 管理范围。 而完成这些功能全部所需做的就是：设计和实现某种方式，能让 provisioning infrastructure 在每个服务启动时，能将它们的 identity 告诉你的 CA。 顺便说一句，这正是 &lt;a href="https://smallstep.com/certificates/">step certificates&lt;/a> 解决的事情。&lt;/p>
&lt;h1 id="证书的生命周期">证书的生命周期&lt;a class="td-heading-self-link" href="#%e8%af%81%e4%b9%a6%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;h2 id="expiration过期">Expiration（过期）&lt;a class="td-heading-self-link" href="#expiration%e8%bf%87%e6%9c%9f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>证书通常都会过期。虽然这不是强制规定，但一般都这么做。设置一个过期时间非常重要，&lt;/p>
&lt;ul>
&lt;li>&lt;strong>证书都是分散在各处的&lt;/strong>：通常 RP 在验证一个证书时，并没有某个中心式权威能感知到（这个操作）。&lt;/li>
&lt;li>如果没有过期时间，证书将永久有效。&lt;/li>
&lt;li>安全领域的一条经验就是：&lt;strong>时间过的越久，凭证被泄露的概率就越接近 100%&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>因此，设置过期时间非常重要。具体来说，X.509 证书中包含一个有效时间范围：&lt;/p>
&lt;ol>
&lt;li>&lt;em>issued at&lt;/em>&lt;/li>
&lt;li>&lt;em>not before&lt;/em>&lt;/li>
&lt;li>&lt;em>not after&lt;/em>：过了这个时间，证书就过期了。&lt;/li>
&lt;/ol>
&lt;p>这个机制看起来设计良好，但实际上也是有一些不足的：&lt;/p>
&lt;ul>
&lt;li>首先，&lt;strong>没有什么能阻止 RP&lt;/strong> 错误地（或因为糟糕的设计）&lt;strong>接受一个过期证书&lt;/strong>；&lt;/li>
&lt;li>其次，证书是分散的。验证证书是否过期是每个 RP 的责任，而有时它们会出乱子。例如，&lt;strong>RP 依赖的系统时钟不对&lt;/strong>时。 &lt;strong>最坏的情况就是系统时钟被重置为了 unix epoch&lt;/strong>（1970.1.1），此时它无法信任任何证书。&lt;/li>
&lt;/ul>
&lt;p>在 subscriber 侧，证书过期后，私钥要处理得当：&lt;/p>
&lt;ul>
&lt;li>如果一个密钥对之前是&lt;strong>用来签名/认证&lt;/strong>的（例如，基于 TLS），
&lt;ul>
&lt;li>应该在不需要这个密钥对之后，&lt;strong>立即删除私钥&lt;/strong>。&lt;/li>
&lt;li>保留已经失效的签名秘钥（signing key）会导致不必要的风险：对谁都已经没有用处，反而会被拿去仿冒签名。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果密钥对是&lt;strong>用来加密的&lt;/strong>，情况就不同了。
&lt;ul>
&lt;li>只要还有数据是用这个加密过的，就需要&lt;strong>留着这个私钥&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>这就是为什么很多人会说，&lt;strong>不要用同一组秘钥来同时做签名和加密&lt;/strong>（signing and encryption）。 因为当一个用于签名的私钥过期时，&lt;strong>无法实现秘钥生命周期的最佳管理&lt;/strong>： 最终不得不保留着这个私钥，因为解密还要用它。&lt;/p>
&lt;h2 id="renewal续期">Renewal（续期）&lt;a class="td-heading-self-link" href="#renewal%e7%bb%ad%e6%9c%9f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>证书快过期时，如果还想继续使用，就需要续期。&lt;/p>
&lt;h3 id="web-pki-证书续期">Web PKI 证书续期&lt;a class="td-heading-self-link" href="#web-pki-%e8%af%81%e4%b9%a6%e7%bb%ad%e6%9c%9f" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>Web PKI 实际上并&lt;strong>没有标准的续期过期&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>没有一个标准方式来延长证书的合法时间，&lt;/li>
&lt;li>一般是&lt;strong>直接用一个新证书替换过期的&lt;/strong>。&lt;/li>
&lt;li>因此续期过程和 issuance 过程是一样的：&lt;strong>生成并提交一个 CSR&lt;/strong>，然后完成 identity proofing。&lt;/li>
&lt;/ul>
&lt;h3 id="internal-pki-证书续期">Internal PKI 证书续期&lt;a class="td-heading-self-link" href="#internal-pki-%e8%af%81%e4%b9%a6%e7%bb%ad%e6%9c%9f" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>对于 internal PKI 我们能做的更好。
最简单的方式是：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>用 mTLS 之类的协议对老证书续期&lt;/strong>。&lt;/li>
&lt;li>CA 能对 subscriber 提供的客户端证书进行认证（authenticate），&lt;strong>重签一个更长的时间&lt;/strong>，然后返回这个证书。&lt;/li>
&lt;li>这使得续期过程&lt;strong>很容易自动化&lt;/strong>，而且强制 subscriber 定期与中心权威保持沟通。&lt;/li>
&lt;li>基于这种机制能轻松&lt;strong>构建一个证书的监控和撤销基础设施&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h3 id="小结">小结&lt;a class="td-heading-self-link" href="#%e5%b0%8f%e7%bb%93" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>证书的续期过程其实并不是太难，&lt;strong>最难的是记得续期这件事&lt;/strong>。
几乎每个管理过公网证书的人，都经历过证书过期导致的生产事故，&lt;a href="https://expired.badssl.com/">例如这个&lt;/a>。 我的建议是：&lt;/p>
&lt;ol>
&lt;li>发现问题之后，一定要全面排查，解决能发现的所有此类问题。&lt;/li>
&lt;li>另外，使用生命周期比较短的证书。这会反过来逼迫你们优化和自动化整个流程。&lt;/li>
&lt;/ol>
&lt;p>Let’s Encrypt 使自动化非常容易，它签发 90 天有效期的证书，因此对 Web PKI 来说非常合适。 对于 internal PKI，建议有效期签的更短：24 小时或更短。有一些实现上的挑战 —— &lt;a href="https://diogomonica.com/2017/01/11/hitless-tls-certificate-rotation-in-go/">hitless certificate rotation&lt;/a> 可能比较棘手 —— 但这些工作是值得的。&lt;/p>
&lt;p>用 step 检查证书过期时间：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>step certificate inspect cert.pem --format json &lt;span style="color:#000;font-weight:bold">|&lt;/span> jq .validity.end
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>step certificate inspect https://smallstep.com --format json &lt;span style="color:#000;font-weight:bold">|&lt;/span> jq .validity.end
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将这种命令行封装到监控采集脚本，就可以实现某种程度的监控和自动化。&lt;/p>
&lt;h2 id="revocation撤销">Revocation（撤销）&lt;a class="td-heading-self-link" href="#revocation%e6%92%a4%e9%94%80" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>如果一个私钥泄露了，或者一个证书已经不再用了，就需要撤销它。即希望：&lt;/p>
&lt;ol>
&lt;li>明确地将其标记为非法的，&lt;/li>
&lt;li>所有 RP 都不再信任这个证书了，即使它还未过期。&lt;/li>
&lt;/ol>
&lt;p>但实际上，&lt;strong>撤销证书过程也是一团糟&lt;/strong>。&lt;/p>
&lt;h3 id="主动撤销的困难">主动撤销的困难&lt;a class="td-heading-self-link" href="#%e4%b8%bb%e5%8a%a8%e6%92%a4%e9%94%80%e7%9a%84%e5%9b%b0%e9%9a%be" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>与过期类似，&lt;strong>执行撤回的职责在 RP&lt;/strong>。&lt;/li>
&lt;li>与过期不同的是，&lt;strong>撤销状态无法编码在证书中&lt;/strong>。RP 只能依靠某些带外过程（out-of-band process） 来判断证书的撤销状态。&lt;/li>
&lt;/ul>
&lt;p>除非显式配置，否则大部分 Web PKI TLS RP 并不关注撤销状态。换句话说，默认情况下， 大部分 TLS 实现都乐于接受已经撤销的证书。&lt;/p>
&lt;h3 id="internal-pki被动撤销机制">Internal PKI：被动撤销机制&lt;a class="td-heading-self-link" href="#internal-pki%e8%a2%ab%e5%8a%a8%e6%92%a4%e9%94%80%e6%9c%ba%e5%88%b6" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>Internal PKI 的趋势是接受这个现实，然后试图通过&lt;strong>被动撤销&lt;/strong>（passive revocation）机制来弥补， 具体来说就是&lt;strong>签发生命周期很短的证书&lt;/strong>，这样就使撤销过程变得不再那么重要了。 想撤销一个证书时，直接不给它续期就行了，过一段时间就会自动过期。
可以看到，&lt;strong>这个机制有效的前提&lt;/strong>就是使用生命周期很短的证书。具体有多短？&lt;/p>
&lt;ol>
&lt;li>取决于你的威胁模型（安全专家说了算）。&lt;/li>
&lt;li>24 小时是很常见的，但也有短到 5 分钟的。&lt;/li>
&lt;li>如果生命周期太短，显然也会给可扩展性和可用性带来挑战：&lt;strong>每次续期都需要与 online CA 交互&lt;/strong>， 因此 CA 有性能压力。&lt;/li>
&lt;li>如果缩短了证书的生命周期，记得&lt;strong>确保你的时钟是同步的&lt;/strong>，否则就有罪受了。&lt;/li>
&lt;/ol>
&lt;p>对于 web 和其他的被动撤销不适合的场景，如果认真思考之后发现&lt;strong>真的&lt;/strong> 需要撤销功能，那有两个选择：&lt;/p>
&lt;ol>
&lt;li>CRL（，&lt;strong>证书撤销列表&lt;/strong>，RFC 5280）&lt;/li>
&lt;li>OCSP（Online Certificate Signing Protocol，&lt;strong>在线证书签名协议&lt;/strong>，RFC 2560）&lt;/li>
&lt;/ol>
&lt;h3 id="主动检查机制crl">主动检查机制：CRL&lt;a class="td-heading-self-link" href="#%e4%b8%bb%e5%8a%a8%e6%a3%80%e6%9f%a5%e6%9c%ba%e5%88%b6crl" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>&lt;strong>Certificate Revocation Lists(证书吊销列表，简称 CRL)&lt;/strong> 定义在 RFC 5280 中，这是一个相当庞杂的 RFC，还定义了很多其他东西。 简单来是，CRL 是一个&lt;strong>有符号整数序列，用来识别已撤销的证书&lt;/strong>。
这个维护在一个 &lt;strong>CRL distribution point&lt;/strong> 服务中，每个证书中都包含指向这个服务的 URL。 工作流程：每个 RP 下载这个列表并缓存到本地，在对证书进行验证时，从本地缓存查询撤销状态。 但这里也有一些明显的问题：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>CRL 可能很大&lt;/strong>，&lt;/li>
&lt;li>distribution point 也可能失效。&lt;/li>
&lt;li>RP 的 CRL 缓存同步经常是天级的，因此如果一个证书撤销了，可能要几天之后才能同步到这个状态。&lt;/li>
&lt;li>此外，RP &lt;em>fail open&lt;/em> 也很常见 —— CRL distribution point 挂了之后，就接受这个证书。 这显然是一个安全问题：只要对 CRL distribution point 发起 DDoS 攻击，就能让 RP 接受一个已经撤销的证书。&lt;/li>
&lt;/ol>
&lt;p>因此，即使已经在用 CRL，也应该考虑使用短时证书来保持 CRL size 比较小。 CRL 只需要包含&lt;strong>已撤销但还未过期的证书&lt;/strong>的 serial numbers，因此 证书生命周期越短，CRL 越短。&lt;/p>
&lt;h3 id="主动检查机制ocsp">主动检查机制：OCSP&lt;a class="td-heading-self-link" href="#%e4%b8%bb%e5%8a%a8%e6%a3%80%e6%9f%a5%e6%9c%ba%e5%88%b6ocsp" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>主动检查机制除了 CRL 之外，另一个选择是 &lt;strong>Online Certificate Signing Protocol(简称 OCSP)&lt;/strong>，它允许 RP 实时查询一个 &lt;em>OCSP responder&lt;/em>： 指定证书的 serial number 来获取这个证书的撤销状态。
与 CRL distribution point 类似，OCSP responder URL 也包含在证书中。 这样看，OCSP 似乎更加友好，但实际上它也有自己的问题。对于 Web PKI，它引入了验证的隐私问题：&lt;/p>
&lt;ol>
&lt;li>每次查询 OCSP responder，使得它能看到我正在访问哪个网站。&lt;/li>
&lt;li>此外，它还增加了每个 TLS 连接的开销：需要一个额外请求来检查证实的撤销状态。&lt;/li>
&lt;li>与 CRL 一样，很多 RPs (including browsers) 会在 OCSP responder 失效时直接认为证书有效（未撤销）。&lt;/li>
&lt;/ol>
&lt;h3 id="主动检查机制ocsp-stapling合订绑定">主动检查机制：OCSP stapling（合订，绑定）&lt;a class="td-heading-self-link" href="#%e4%b8%bb%e5%8a%a8%e6%a3%80%e6%9f%a5%e6%9c%ba%e5%88%b6ocsp-stapling%e5%90%88%e8%ae%a2%e7%bb%91%e5%ae%9a" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>OCSP stapling 是 OCSP 的一个变种，目的是解决以上提到的那些问题。&lt;/p>
&lt;p>相比于让 RP 每次都去查询 OCSP responder，OCSP stapling 中让证书的 subscriber 来做这件事情。 OCSP response 是一个经过签名的、时间较短的证词（signed attestation），证明这个证书未被撤销。&lt;/p>
&lt;p>attestation 包含在 subscriber 和 RP 的 TLS handshake (“stapled to” the certificate) 中。 这给 RP 提供了相对比较及时的撤销状态，而不用每次都去查询 OCSP responder。 subscriber 可以在 signed OCSP response 过期之前多次使用它。这减少了 OCSP 的负担，也解决了 OCSP 的隐私问题。&lt;/p>
&lt;p>但是，所有这些东西其实最终都像是一个 &lt;strong>鲁布·戈德堡装置（Rube Goldberg Device）&lt;/strong>，&lt;/p>
&lt;blockquote>
&lt;p>鲁布·戈德堡机械（Rube Goldberg machine）是一种被设计得过度复杂的机械组合，以 迂回曲折的方法去完成一些其实是非常简单的工作，例如倒一杯茶，或打一只蛋等等。 设计者必须计算精确，令机械的每个部件都能够准确发挥功用，因为任何一个环节出错 ，都极有可能令原定的任务不能达成。
解释来自 &lt;a href="https://www.zhihu.com/topic/20017497/intro">知乎&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>如果让 subscribers 去 CA 获取一些生命周期很短的证词（signed attestation）来证明对应的证书并没有过期， 为什么不直接干掉中间环节，直接使用生命周期很短的证书呢？&lt;/p>
&lt;h1 id="证书申请及签署步骤">证书申请及签署步骤&lt;a class="td-heading-self-link" href="#%e8%af%81%e4%b9%a6%e7%94%b3%e8%af%b7%e5%8f%8a%e7%ad%be%e7%bd%b2%e6%ad%a5%e9%aa%a4" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;ol>
&lt;li>生成申请请求&lt;/li>
&lt;li>RA 核验你的申请信息&lt;/li>
&lt;li>CA 签署&lt;/li>
&lt;li>获取证书(从证书存取库)&lt;/li>
&lt;/ol>
&lt;p>私有 CA 的创建以及签发证书步骤，详细命令详见 2.0.OpenSSL.note 命令说明&lt;/p>
&lt;ol>
&lt;li>(可选)配置需要使用 CA 功能服务器的 CA 配置文件&lt;/li>
&lt;li>在 CA 功能服务器上创建自签证书以便给其余设备签证&lt;/li>
&lt;li>在需要签证的设备上创建密钥以及证书签署请求，并把请求文件发送给 CA 服务器&lt;/li>
&lt;li>CA 服务器给该请求签证后，把生成的证书文件发还给需要签证的设备。&lt;/li>
&lt;/ol>
&lt;p>吊销证书&lt;/p>
&lt;ol>
&lt;li>获取证书的 serial&lt;/li>
&lt;li>根据用户提交的 serial 与 subject 信息，对比验证是否与 index.txt 文件中的信息一致，使用吊销命令吊销/etc/pki/CA/newcerts/目录下对应的证书文件&lt;/li>
&lt;li>生成吊销证书的编号&lt;/li>
&lt;li>echo 01 &amp;gt; /etc/pki/CA/crl/NUM&lt;/li>
&lt;li>更新证书吊销列表&lt;/li>
&lt;/ol>
&lt;p>证书文件格式：&lt;/p>
&lt;ol>
&lt;li>XXX.pem # 证书相关文件标准格式&lt;/li>
&lt;li>XXX.key # 明确指明这是一个密钥文件&lt;/li>
&lt;li>XXX.csr # Certificate signing request。证书签署请求文件&lt;/li>
&lt;li>XXX.crt # 明确指明这是一个证书文件&lt;/li>
&lt;/ol></description></item></channel></rss>