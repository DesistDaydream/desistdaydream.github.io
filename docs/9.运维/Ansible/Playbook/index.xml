<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Playbook on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/</link><description>Recent content in Playbook on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/index.xml" rel="self" type="application/rss+xml"/><item><title>Playbook</title><link>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/Playbook/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/Playbook/</guid><description>概述 参考：
官方文档，Playbook指南 - Playbook 介绍 官方文档，Playbook 指南 - 使用 Playbook Ansible Galaxy 类似于 playbook 仓库的地方 公众号，任务中心之Ansible进阶篇 与通过命令行来执行 Ansbile 任务模式相比，Playbook 是 Ansible 执行任务的另一种方式，而且功能非常强大。
playbook 可以通过定义一个或多个文件，然后让 ansible 使用这些文件来完成一系列复杂的任务。如果说通过命令行是对多台设备执行一个任务，那么 Playbook 则是可以对多台设备按顺序执行不同任务。
playbook 称为&amp;quot;剧本&amp;quot;。每个 playbook 都包含一个或多个 plays(戏剧)。拿拍电影举例，一部电影会有一部“剧本 playbook”来描述电影情节，而整部电影都是由一场一场的“戏剧 play”拼凑起来的。每一场戏剧又需要执行多种“任务 task”(比如亲嘴、打架、聊天、上床~~~)
首先，下面是一个 playbook 的样例。这个 playbook 中包含两个 play，一个叫 webservers，另一个叫 databases。其中 webservers 中包含两个 tasks，一个要使用 yum 模块执行动作，另一个要使用 template 模块，向文件中写入内容
- hosts: webservers remote_user: root tasks: - name: ensure apache is at the latest version yum: name: httpd state: latest - name: write the apache config file template: src: /srv/httpd.</description></item><item><title>Playbook Role(角色)</title><link>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/Playbook-Role%E8%A7%92%E8%89%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/Playbook-Role%E8%A7%92%E8%89%B2/</guid><description>概述 参考：
官方文档，Playbook 指南 - Roles Ansible 中文权威指南，Playbooks-Playbook 角色和 Incluede 语句 刚开始学习运用 playbook 时，可能会把 playbook 写成一个内容很多的文件，这种情况不利于扩展和复用。这时候可以使用一种方式，将这个复杂的 playbook 模块化，即拆分一个复杂的 playbook 文件成多个零散的小文件，将其组合成一个一个具有不同功能的 playbook。
这时候就需要用到 ansible playbook 的 roles 概念了。roles 实际上是对 playbook 进行逻辑上的划分，主要依赖于目录的命名和摆放，一个 Role 就是一个目录，Role 名与目录名相同。
当我们开始思考这些概念：tasks, handlers, variables 等等，是否可以将它们抽象为一个更大的概念呢。我们考虑的不再是”将这些 tasks，handlers，variables 等等应用到这些 hosts 中”，而是有了更抽象的概念，比如：”这些 hosts 是 dbservers” 或者 “那些 hosts 是 webservers”（注：dbserver，webservers 即是”角色”）。这种思考方式在编程中被称为”封装”，将其中具体的功能封装了起来。举个例子，你会开车但并不需要知道引擎的工作原理（注：同样的道理，我们只需要知道”这些 hosts 是 dbservers”，而不需要知道其中有哪些 task，handlers 等）。
roles 目录结构 下面是一个最基本的 roles 目录结构。在这个目录结构里，有两个 roles，一个名为 common，另一个名为 webservers
site.yml webservers.yml fooservers.yml roles/ common/ tasks/ handlers/ files/ templates/ vars/ defaults/ meta/ webservers/ tasks/ defaults/ meta/ 每个目录的作用如下</description></item><item><title>Variables(变量)</title><link>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/Variables%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/Variables%E5%8F%98%E9%87%8F/</guid><description>概述 参考：
官方文档，用户指南 - 目录 - 使用变量 变量基本的定义与引用方式 变量名应为字母、数字、下划线。并且始终应该以字母开头。
基础的定义方式是在一个 play 中使用 vars 关键字定义变量，示例如下
- host: webservers vars: http_port: 80 # 定义一个名为http_port的变量，值为80 tasks: - debug Note: vars 关键字可以用在 host 环境中，也可以用在 tasks 环境中，用在 tasks 环境时，则变量仅对当前任务生效
下面是一个在角色中定义字典类型变量的样例：
~]# cat roles/test/defaults/main.yml docker: version: 18.06.2 dataDir: /var/lib/docker registryMirrors: - https://ac1rmo5p.mirror.aliyuncs.com execOpts: - &amp;#39;native.cgroupdriver=systemd&amp;#39; insecureRegistries: - 100.64.2.52:9999 - 100.64.1.31:9999 变量的引用方式 一般情况使用 {{ VarName }} 来引用变量，特殊情况不用加 {{ }} 而可以直接引用，比如在某些控制结构(比如 when)的语句中。
变量可以通过两种方式引用字典内特定字段的变量
使用方括号 [] 进行引用 docker['registryMirrors'] 变量的值为 https://ac1rmo5p.</description></item><item><title>Templates 模板(Jinja2)</title><link>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/Templates-%E6%A8%A1%E6%9D%BFJinja2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/Templates-%E6%A8%A1%E6%9D%BFJinja2/</guid><description>概述 参考：
官方文档，用户指南 - 传统目录 - 使用剧本 - 模板(Jinja2) 朱双印博客,jinja2 模板 https://www.zsythink.net/archives/2999 https://www.zsythink.net/archives/3021 https://www.zsythink.net/archives/3037 https://www.zsythink.net/archives/3051 骏马金龙，9. 如虎添翼的力量：解锁强大的 Jinja2 模板 Jinja2 的内容较多，但对于学习 Ansible 来说，只需要学习其中和 template 相关的一部分 (其它的都和开发有关或 Ansible 中用不上) 以及 Ansible 对 Jinja2 的扩展功能即可。
详见 Python 编程语言部分的 《Jinja》章节
尽管在编写 Playbook 时可以不用在意是否要用 Jinja2，但 Ansible 的运行离不开 Jinja2，当 Ansible 开始执行 playbook 或任务时，总是会先使用 Jinja2 去解析所有指令的值，然后再执行任务。另一方面，在编写任务的过程中也会经常用到 Jinja2 来实现一些需求。所以，Jinja2 可以重要到成为 Ansible 的命脉。
严格地说，playbook 中所有地方都使用了 Jinja2，包括几乎所有指令的值、template 模板文件、copy 模块的 content 指令的值、lookup 的 template 插件、等等。它们会先经过 Jinja2 渲染，然后再执行相关任务。
例如，下面的 playbook 中分别使用了三种 Jinja2 特殊符号。</description></item><item><title>Conditionals(条件判断)</title><link>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/Conditionals%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/Conditionals%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/</guid><description>概述 参考：
官方文档，用户指南 - 传统目录 - 条件 通常，play 的结果可能取决于 variable，fact（有关远程系统的知识）或先前的任务结果。在某些情况下，变量的值可能取决于其他变量。可以基于主机是否符合其他条件来创建其他组来管理主机。
Ansible 在条件中使用 Jinja 的 测试 和 过滤器来实现条件判断。详见 Ansible Template 文章中《Ansible 扩展测试函数》章节
基于变量的条件 https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_conditionals.html#conditionals-based-on-variables
您还可以根据剧本或库存中定义的变量创建条件。由于条件需要布尔值输入（必须评估测试以触发条件），因此您必须应用| Bool过滤到非树状变量，例如带有“是”，“ ON”，“ 1”或“ TRUE”的内容的字符串变量。您可以定义这样的变量：
vars: epic: true monumental: &amp;#34;yes&amp;#34; 对于上面的变量，Ansible将运行其中一个任务并跳过另一个任务：
tasks: - name: Run the command if &amp;#34;epic&amp;#34; or &amp;#34;monumental&amp;#34; is true ansible.builtin.shell: echo &amp;#34;This certainly is epic!&amp;#34; when: epic or monumental | bool - name: Run the command if &amp;#34;epic&amp;#34; is false ansible.builtin.shell: echo &amp;#34;This certainly isn&amp;#39;t epic!</description></item><item><title>loop(循环)</title><link>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/loop%E5%BE%AA%E7%8E%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/loop%E5%BE%AA%E7%8E%AF/</guid><description>概述 参考：
官方文档，用户指南 - 传统目录 - Loops 有时需要重复执行多次任务。在计算机编程中，这称为循环。常见的 Ansible 循环包括使用文件模块更改多个文件和/或目录的所有权，使用用户模块创建多个用户以及重复轮询步骤直到达到特定结果。Ansible 提供了两个用于创建循环的关键字：loop 和 with_XX
with_XX 关键字依赖于 Lookup Plugins(Lookup 插件)。其中 根据插件的不同功能，使用不同的字符串。e.g.with_items 也是 Lookup 插件。 插件的介绍详见：Ansible Plugins loop 关键字与 with_list 等效，是简单循环的最佳选择 循环的简单样例 下面展示了循环的基本功能：通过 loop 或者 with_*来对一个列表中的值逐一操作
- name: 添加几个用户。循环的基本使用方式 user: name: &amp;#34;{{ item }}&amp;#34; state: present loop: - testuser1 - testuser2 等同于
- name: 添加几个用户。先赋值给一个变量，然后在loop关键字中引用变量。 vars: users: [testuser1, testuser2] user: name: &amp;#34;{{ item }}&amp;#34; state: present loop: &amp;#34;{{ users}}&amp;#34; 上述示例与下面的任务相同。这就相当于将两个任务模块相同但是操作内容不同的任务合并成为一个任务
- name: 添加testuser1用户 user: name: &amp;#34;testuser1&amp;#34; state: present - name: 添加testuser2用户 user: name: &amp;#34;testuser2&amp;#34; state: present 从示例可以看出，循环是使用两个部分来组成整个循环的功能</description></item><item><title>错误处理</title><link>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid><description>概述 参考：
官方文档，用户指南 - 在 playbook 中的错误处理 忽略失败的任务(ignore_errors) 默认情况下，当任意目标机器上的任务结果失败时，Ansible 都会停止继续执行，我们可以通过 ignore_errors 关键字忽略错误，以便继续执行后续任务。 ignore_errors 指令仅在任务能够运行并返回“失败”值时起作用。它不会让 Ansible 忽略未定义的变量错误、连接失败、执行问题（例如，缺少包）或语法错误。
改变任务状态(failed_when 与 changed_when) Ansible 可以通过特定条件定义任务的执行状态，通过对 failed_when、changed_when 关键字指定的条件进行判断，用以定义 failed、changed、ok 等任务执行状态意味着什么。 failed_when
若结果为真，则任务执行结果变为 fatal 若结果为假，则任务执行结果变为 changed changed_when
若结果为真，则任务执行结果变为 changed 若结果为假，则任务执行结果变为 ok 比如，我们常用 shell 模块执行一些命令，而 shell 模块的任务状态总是 changed 的~~如果一个 shell 命令执行后，没有变化，我们想让他将任务状态设为 ok，就可以通过 changed_when 功能，比如现在有如下两个任务
- name: Changed_when 判断的结果为真时，任务状态为 changed shell: cmd: &amp;#34;docker start changed_when&amp;#34; register: is_started changed_when: &amp;#34;&amp;#39;changed_when&amp;#39; in is_started[&amp;#39;stdout&amp;#39;]&amp;#34; ignore_errors: true - name: Changed_when 判断的结果为假时，任务状态为 ok shell: cmd: &amp;#34;docker start changed_when&amp;#34; register: is_started changed_when: &amp;#34;&amp;#39;changed_when&amp;#39; in is_started[&amp;#39;stderr&amp;#39;]&amp;#34; ignore_errors: true - name: Failed_when 判断的结果为真时，任务状态为 failed shell: cmd: &amp;#34;docker start failed_when&amp;#34; register: is_started failed_when: &amp;#34;&amp;#39;failed_when&amp;#39; in is_started[&amp;#39;stdout&amp;#39;]&amp;#34; ignore_errors: true - name: Failed_when 判断的结果为假时，任务状态为 changed shell: cmd: &amp;#34;docker start failed_when&amp;#34; register: is_started failed_when: &amp;#34;&amp;#39;failed_when&amp;#39; in is_started[&amp;#39;stderr&amp;#39;]&amp;#34; ignore_errors: true 假设目标机器上已经有一个已经停止的，名为 test 的容器，则执行结果如下</description></item><item><title>Debugger</title><link>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/Debugger/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/Debugger/</guid><description>概述 参考：
官方文档，用户指南 - Debugging 任务 Ansible 提供了一个任务调试器，因此您可以在执行过程中修复错误，而不是编辑 playbook 并再次运行它以查看更改是否有效。您可以在任务上下文中访问调试器的所有功能。您可以检查或设置变量的值，更新模块参数，并使用新的变量和参数重新运行任务。调试器可让您解决故障原因并继续执行 playbook。
Enabling the debugger with thedebuggerkeyword You can use the debugger keyword to enable (or disable) the debugger for a specific play, role, block, or task. This option is especially useful when developing or extending playbooks, plays, and roles. You can enable the debugger on new or updated tasks. If they fail, you can fix the errors efficiently. The debugger keyword accepts five values:</description></item><item><title>Playbook 命令行工具</title><link>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/Playbook-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/Playbook-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid><description>概述 参考：
官方文档，用户指南 - 传统目录 - 使用命令行工具 - ansible-playbook ansible-playbook 用来运行运行 Ansible playbook，以便在目标主机上执行定义的任务。
ansible-playbook 运行 Ansible playbooks，并在目标主机上执行剧本中定义的任务
Syntax(语法) ansible-playbook [OPTIONS] PLAYBOOK
OPTIONS &amp;ndash;ask-vault-pass # ask for vault password &amp;ndash;become-method # privilege escalation method to use (default=%(default)s), use ansible-doc -t become -l to list valid choices. &amp;ndash;become-user # run operations as this user (default=root) -C, &amp;ndash;check # 不在目标主机上执行任务，仅检查任务是否可以完成 -c, &amp;ndash;connection &amp;lt;CONNECTION&amp;gt; # 要使用的连接插件。默认值：smart 可以设置为 local 以便让 playbook 在本地执行而不用去远程机器上运行 &amp;ndash;flush-cache # clear the fact cache for every host in inventory &amp;ndash;force-handlers # run handlers even if a task fails -i, &amp;ndash;inventory, &amp;ndash;inventory-file # 指定 inventory 文件路径或者以逗号分隔的主机列表。(不推荐使用该选项) -l , &amp;ndash;limit &amp;lt;SUBSET&amp;gt; # 限定执行的主机范围。可以对一批主机的其中一台执行操作，但是依然可以使用其他主机的变量。further limit selected hosts to an additional pattern &amp;ndash;list-hosts # 列出执行该剧本所能匹配到的主机，但并不会执行 &amp;ndash;list-tags # 列出所有可用的 tags &amp;ndash;list-tasks # 列出所有即将被执行的任务 &amp;ndash;private-key , &amp;ndash;key-file # use this file to authenticate the connection &amp;ndash;scp-extra-args # specify extra arguments to pass to scp only (e.</description></item><item><title>Tags</title><link>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/Tags/</link><pubDate>Mon, 06 Jan 2025 22:09:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/Tags/</guid><description>概述 参考：
官方文档，执行 Playbooks - 标签 如果您有一个很大的剧本，则仅运行其中的特定部分而不是运行整个剧本可能会很有用。您可以使用 Ansible 标签来做到这一点。使用标签执行或跳过选定的任务是一个两步过程：
将标签添加到您的任务中，可以单独添加标签，也可以使用继承自 block、play、role 或 import 的标签 运行 playbook 时选择或跳过标签 继承 Tags https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_tags.html#tag-inheritance-for-includes-blocks-and-the-apply-keyword</description></item><item><title>最佳实践</title><link>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/9.%E8%BF%90%E7%BB%B4/Ansible/Playbook/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid><description>概述 参考：
使用 Inventory 变量 一、指定多个 inventory，并使用 &amp;ndash;limit 限定主机
ansible-playbook -i inventory/fj-server.yaml -i inventory/fj-client.yaml deploy-monitoring.yaml --limit FJ-BS101-JMR-Monitor 模板使用方式（直接使用 groups, hostvars 这两个遍历啊那个）
{% for target in groups[&amp;#39;intf&amp;#39;] %} {{ hostvars[target][&amp;#39;ansible_host&amp;#39;] }} {% endfor %} 二、使用 include_vars 加载
deploy-test.yaml
- hosts: fj-server gather_facts: no pre_tasks: - name: &amp;#34;加载 client inventory&amp;#34; ansible.builtin.include_vars: file: inventory/fj-client.yaml # 读取该文件，将其中内容作为变量使用 name: client_inventory # 这些变量的父级字段名称 roles: - test tasts/main.yaml
- name: &amp;#34;检查变量&amp;#34; ansible.builtin.debug: msg: &amp;#34;{{ item[&amp;#39;ansible_host&amp;#39;] }}&amp;#34; with_items: # 要使用 valuse() 函数 - &amp;#34;{{ client_inventory[&amp;#39;intf&amp;#39;].</description></item></channel></rss>