<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Logs on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Logs/</link><description>Recent content in Logs on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Logs/index.xml" rel="self" type="application/rss+xml"/><item><title>日志系统</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Logs/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Logs/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</guid><description>概述 参考:
Wiki, Syslog RFC 5424 - The Syslog Protocol 背景 在系统上，不管是系统本身还是外部程序，在开始、运行、结束的一整套过程中，都会产生信息，这些信息包括：何时、何地(e.g. 来源 IP)、何物(e.g. 什么程序)、发生了什么事情等。i.e. 记录系统在什么时候由哪个程序做了什么样的行为时，发生了何种事件等等。而发生的事情又有等级的区别，哪些信息是危险的，哪些信息是标准可以不用关注的等。这些信息就统称为 Log(日志)。
随着时代发展，操作系统、程序、硬件设备等等都会产生日志，如此众多的日志需要一个标准来进行定义，这个日志标准就是 Syslog Protocol，由 IETF 给定的 RFC 5424 规范来执行。而在 IT 行业，一般也把各个事务所生成的日志称为 syslog。
日志的生成 操作系统、进程和应用程序的编写者完全清楚他们将生成的事件。在某些情况下，生成消息用来说明状态。可以是一段时间一次，也可以由其他方式触发，例如在程序退出时。在其他情况下，消息是由遇到的条件产生的。在这些情况下，不管是状态消息或者包含一些类型的警告都可能被产生。操作系统、进程和应用程序的编写者可能会在详单中确定消息的数量。这些详单中通常包括发出消息的设备，同时包含消息的严重级别。这样，操作员可以有选择地筛选消息，可以更快的定位更加重要的和有处理时间限制的消息，同时可以将状态或消息信息放在文件中，将来阅读他们。其他显示和保存信息的方式也可以存在。
必须在设备中配置一些规则，这些规则可以告诉设备显示还是转发事件消息。这些规则是十分灵活的。管理员可能希望所有的信息都保存在本地，同时所有高优先级的消息都会转发到另一台设备中。他们可能发现，将某些设备的信息发送到一些或所有用户的设备中，同时显示在系统控制台上是很合适的。然而，管理员决定将事件信息发送到 syslog 采集器中，在采集器中包含了组成设备的信息以及发送的严重级别，同时定义了远程接收器。例如，系统管理员可能想让所有由邮件设备发出的消息被转发到一个特定的事件信息采集器中。管理员还可以让所有内核生成的事件信息被发送到另一台 syslog 接收器中，同时，将内核产生的 critical 严重级别的消息发送到第三台设备中。同时，将显示在系统控制台中的信息 email 给部分用户，同时将他们保存在设备本地磁盘的文件中。反之，可以将本地进程产生的消息显示在控制台中，但不保存也不转发。所有事件的规则都在设备中生成。因为管理员知道 collector 会收集到哪种类型的事件，他们会在 syslog 服务器中配置相应的规则。
消息的内容因创建者而异。建议将消息按照一定格式编写，这样人们就可以阅读他们。在消息中加入时间戳和发出消息的设备以及进程的标识符是一个很好的建议。但他们都不是必须的。
假设任何进程和设备都有可能产生事件消息。可能包含没有任何本地存储空间的设备，例如打印机、路由器、集线器、交换机以及无盘工作站。在这种情况下，将事件消息传送到 collector 可能是必要的，以便操作者可以记录并希望看到它们。
日志的收集 日志收集起来，才能方便管理人员进行查看并进行故障排除。如此众多事物的日志如果想要统一管理，就需要一套程序来对所有事物的日志进行收集、处理、保存、过滤、分析等，可以实现该功能的程序有以下几个：
sysLog 程序与 syslog 标准重名，是早期的 Linux 用于处理系统上所有事物日志的程序 RsysLog 是 sysLog 的升级版 ELK/EFK 是很重量级，功能很全的 3 款程序的统称 Eleasticsearch 是一个存储系统和搜索引擎 logstash、Fluentd 日志收集 kibana 日志的前端展示 日志的生成与收集的通用流程 当一个程序生成日志后，一般调用一个 output() 函数，把生成的日志输出到某处，e.</description></item><item><title>LogRotate(日志轮替)</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Logs/LogRotate%E6%97%A5%E5%BF%97%E8%BD%AE%E6%9B%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Logs/LogRotate%E6%97%A5%E5%BF%97%E8%BD%AE%E6%9B%BF/</guid><description>概述 参考：
Wiki, Log_rotation 公众号-马哥 Linux 运维，[译] 理解 logrotate 实用工具 为了防止日志文件持续被写入文件导致过于庞大，那么就需要对日志进行拆分，每隔一段时间就把日志文件保存(打包压缩)起来，然后再创建一个新的空文件继续接收日志，来回循环该过程直到通过配置规定的保留日期，来清除存在过久的日志。通过这种方式来进行日志的归档，分类，清理。这就是 LogRotate 所做的事情。是否进行轮替会有一系列的配置，比如文件的大小达到 N 会轮替一次，每隔多少天轮替一次等等。
logrotate 只是一个命令行工具，不以守护进程的方式运行在后台，默认情况下，logrotate 命令作为放在 /etc/cron.daily 中的 cron 任务，每天运行一次，该任务会根据设置的策略进行日志文件的检查，其中达到设置中满足轮替配置的日志文件将被轮替。
关联文件与配置 /etc/logrotate.conf # logrotate 基本配置文件
/etc/logrotate.d/ # 对基本文件的扩展，该目录下的文件的配置会被包含在基本配置文件中。该目录下一般是一个程序一个文件，每个程序都有自己的日志轮替配置。
/etc/cron.daily/logrotate # 该文件定义了 cron 定时任务执行日志轮替工作的时间
/var/lib/logrotate.status # logrotate 的执行历史
logrotate.conf 配置文件详解 /PATH/TO/FILES {&amp;hellip;} # 指定想要轮替的日志文件，可以通过 * 通配指定多个文件名 copytruncate # 把正在输出的日志拷(copy)一份出来，再清空(trucate)原来的日志。 compress # 压缩日志文件的所有非当前版本 dateext # 切换后的日志文件会附加上一个短横线和 YYYYMMDD 格式的日期, daily # 日志文件将每天轮替一次。其它可用值为 monthly(每月)，weekly(每周)、yearly(每年) delaycompress # 在轮替任务完成后，已轮替的归档将使用 gzip 进行压缩 errors &amp;lt;EMAIL&amp;gt; # 给指定邮箱发送错误通知 missingok # 如果日志文件丢失，不要显示错误 notifempty # 如果日志文件为空，则不轮换日志文件 olddir &amp;lt;DIR&amp;gt; # 指定日志文件的旧版本放在 “DIR”目录 中 postrotate 和 endscript # 在所有其它指令完成后，postrotate 和 endscript 里面指定的命令将被执行。在这种情况下，rsyslogd 进程将立即再次读取其配置并继续运行。 rotate N # 共存储 N 个轮替后日志。当产生第 N+1 个轮替后的日志，时间最久的日志将被删除 sharedscripts # 有多个日志需要轮替时，只执行一次脚本 size &amp;lt;LogSize&amp;gt; # 在日志文件大小大于 LogSize（例如 100K，4M）时进行轮替 配置样例</description></item><item><title>Journal</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Logs/Journal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Logs/Journal/</guid><description>概述 参考：
Manual, systemd-journald.service(8) 相关服务说明
systemd-Journald.service # 日志功能通过该 Unit 来实现，是一个用于收集和存储日志数据的系统服务，是系统启动前要启动的第一个进程，Journald 会把所有收集到的信息保存在内存中。 rsyslog.service # 另一种日志数据持久化，Journald 会把日志信息转发给 rsyslog.service 进行处理和保存，如果没有 Journald，rsyslog 也可以自动生成日志而不用从 journald 去获取 logrotate # logrotate 会对日志文件进行轮替操作，i.e.把已经非常大的日志文件改名后，创建一个新的日志文件，新产生的日志会保存在新文件中，老文件保留一定时期后会自动清除 Journald 关联文件与配置 /etc/systemd/journal.conf
日志存放路径 /run/log/journal/${MACHINE-ID}/
/var/log/journal/${MACHINE-ID}/
默认情况下，journald 的日志保存在 /run/log/journal 中，系统重启就会清除。通过新建 /var/log/journal 目录，日志会自动记录到这个目录中，并永久存储。
路径中的 MACHINE-ID 的值，可以通过 cat /etc/machine-id 命令获取
~]# ls /run/log/journal c14766a3e9ae49a3872fb9b7e2583710 ~]# cat /etc/machine-id c14766a3e9ae49a3872fb9b7e2583710 所有 journal 程序生成的日志，都会存在 MACHIN-ID 目录下
~]# ll -h /var/log/journal/c14766a3e9ae49a3872fb9b7e2583710 total 153M drwxr-sr-x+ 2 root systemd-journal 4.0K Feb 21 23:15 .</description></item></channel></rss>