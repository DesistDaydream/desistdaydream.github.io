<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦的站点 – LogQL</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Logs/Loki/LogQL/</link><description>Recent content in LogQL on 断念梦的站点</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Logs/Loki/LogQL/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: LogQL</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Logs/Loki/LogQL/LogQL/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Logs/Loki/LogQL/LogQL/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://grafana.com/docs/loki/latest/query/">官方文档，查询&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/0dXT0fIreZk6_4ZL4S8lHg">公众号，Loki 查询语言 LogQL 使用&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Log Query Language(日志查询语言，简称 LogQL)&lt;/strong> 受 PromQL 启发，可以看作是分布式的 grep 命令，用来从汇总的日志源筛选日志。LogQL 通过 Labels(标签) 和 Operators(运算符) 进行过滤。&lt;/p>
&lt;p>LogQL 查询有两种类型：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Log Queries(日志查询)&lt;/strong> # 根据查询语句返回日志条目，每行是一条日志。&lt;/li>
&lt;li>&lt;strong>Metric Queries(指标查询)&lt;/strong> # 用于扩展日志查询并根据 Log Queries 中的日志计数计算值。通过这种查询语句，可以计算将日志数据量化成指标信息，并且，Promtail 可以通过这种查询语句将指标信息，填充到自己暴露的 Metrics 端点中。&lt;/li>
&lt;/ul>
&lt;p>注意：由于 Loki 的设计，所有 LogQL 查询都必须包含一个 Log Queries 中的 日志流选择器&lt;/p>
&lt;p>日志流选择器确定将搜索多少日志流（日志内容的唯一来源，例如文件）。然后，更细粒度的日志流选择器将搜索到的流的数量减少到可管理的数量。这意味着传递给日志流选择器的标签将影响查询执行的相对性能。然后使用过滤器表达式对来自匹配日志流的聚合日志进行分布式 grep。&lt;/p>
&lt;h1 id="log-queries日志查询">Log Queries(日志查询)&lt;a class="td-heading-self-link" href="#log-queries%e6%97%a5%e5%bf%97%e6%9f%a5%e8%af%a2" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>详见 &lt;a href="https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Logs/Loki/LogQL/Log%20Queries.md">Log Queries&lt;/a>&lt;/p>
&lt;h1 id="metric-queries指标查询">Metric Queries(指标查询)&lt;a class="td-heading-self-link" href="#metric-queries%e6%8c%87%e6%a0%87%e6%9f%a5%e8%af%a2" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>详见 &lt;a href="https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Logs/Loki/LogQL/Metric%20Queries.md">Metric Queries&lt;/a>&lt;/p></description></item><item><title>Docs: Log Queries</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Logs/Loki/LogQL/Log-Queries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Logs/Loki/LogQL/Log-Queries/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://grafana.com/docs/loki/latest/query/log_queries">官方文档，查询 - 日志查询&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>基本的日志查询由两部分组成：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Log Stream Selector(日志流选择器)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Log Pipeline(日志管道)&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;p>注意：由于 Loki 的设计原则，所有的 LogQL 查询必须包含 Log Stream Selector(日志流选择器)&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/xgx9x4/1621837564259-416660f0-81ef-4d14-9086-dbda268daf9f.png" alt="image.png">&lt;/p>
&lt;p>&lt;strong>日志流选择器&lt;/strong>决定了有多少日志流将被搜索到，一个更细粒度的日志流选择器将搜索到流的数量减少到一个可管理的数量。所以传递给日志流选择器的标签将影响查询执行的性能。&lt;/p>
&lt;p>而日志流选择器后面的&lt;strong>日志管道&lt;/strong>是可选的，日志管道是一组阶段表达式，它们被串联在一起应用于所过滤的日志流，每个表达式都可以过滤、解析和改变日志行内容以及各自的标签。&lt;/p>
&lt;p>下面的例子显示了一个完整的日志查询的操作：&lt;/p>
&lt;p>&lt;code>{container=&amp;quot;query-frontend&amp;quot;,namespace=&amp;quot;loki-dev&amp;quot;} |= &amp;quot;metrics.go&amp;quot; | logfmt | duration &amp;gt; 10s and throughput_mb &amp;lt; 500&lt;/code>&lt;/p>
&lt;p>该查询语句由以下几个部分组成：&lt;/p>
&lt;ul>
&lt;li>一个日志流选择器 &lt;code>{container=&amp;quot;query-frontend&amp;quot;,namespace=&amp;quot;loki-dev&amp;quot;}&lt;/code>，用于过滤 &lt;code>loki-dev&lt;/code> 命名空间下面的 &lt;code>query-frontend&lt;/code> 容器的日志&lt;/li>
&lt;li>然后后面跟着一个日志管道 &lt;code>|= &amp;quot;metrics.go&amp;quot; | logfmt | duration &amp;gt; 10s and throughput_mb &amp;lt; 500&lt;/code>，这管道表示将筛选出包含 &lt;code>metrics.go&lt;/code> 这个词的日志，然后解析每一行日志提取更多的表达并进行过滤&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>为了避免转义特色字符，你可以在引用字符串的时候使用单引号，而不是双引号，比如 &lt;code>\w+1&lt;/code> 与 &amp;ldquo;\w+&amp;rdquo; 是相同的。&lt;/p>
&lt;/blockquote>
&lt;h1 id="log-stream-selector日志流选择器">Log Stream Selector(日志流选择器)&lt;a class="td-heading-self-link" href="#log-stream-selector%e6%97%a5%e5%bf%97%e6%b5%81%e9%80%89%e6%8b%a9%e5%99%a8" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>Log Stream Selector 用于确定查询结果中应该包括哪些日志流。Log Stream Selector 由一个或多个Label(标签) 组成，Label 是以 &lt;code>=&lt;/code> 分割的 &lt;strong>Key/Value Paire(键/值对)&lt;/strong> 。所谓的日志流就是一行一行的日志，组合在一起，形成的一种类似数据流的感觉，从上到下哗哗流水那种感觉~日志流说白了就是日志的集合。stream(流) 的概念如果在 Prometheus 中描述，那就是 series(序列) 的概念。&lt;/p>
&lt;p>Log Stream Selector 中的键值对应包装在一对花括号中，比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#a40000">job=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">&amp;#34;kube-system/etcd&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#a40000">container=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">&amp;#34;etcd&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在上面这个例子中，所有具有 job 标签，值为 kube-system/etcd 和 container 标签，值为 etcd 的日志流将被包含在查军结果中。&lt;/p>
&lt;p>这种语法与 Prometheus 标签选择器 的语法一样。参考 PromQL,prometheus 查询语言 文章中 即时向量 章节中的匹配说明&lt;/p>
&lt;p>上面 LogQL 的执行效果如下：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/xgx9x4/1616129551117-ca616a54-c0f1-48e3-868b-9f43f2138f1a.jpeg" alt="">&lt;/p>
&lt;blockquote>
&lt;p>如果想要获取所有日志，使用这种方式: &lt;code>{job=~&amp;quot;..*&amp;quot;}&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;h1 id="log-pipeline日志管道">Log Pipeline(日志管道)&lt;a class="td-heading-self-link" href="#log-pipeline%e6%97%a5%e5%bf%97%e7%ae%a1%e9%81%93" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>Log Pipeline(日志管道) 可以通过 &lt;code>|&lt;/code> 符号附加到 Log Stream Selector(日志流选择器) 语句后面，以便对日志流进一步处理和过滤。&lt;/p>
&lt;p>Log Pipeline 通常由一个或多个 &lt;strong>Expression(表达式)&lt;/strong> 组成，多个表达式以 &lt;code>|&lt;/code> 符号分割。&lt;/p>
&lt;blockquote>
&lt;p>这用法其实跟 Linux 中使用命令并通过管道传递结果给下一个命令的用法一模一样。&lt;/p>
&lt;/blockquote>
&lt;p>可用的 Log Pipeline 有如下几种表达式&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#Line%20Filter(%E8%A1%8C%E8%BF%87%E6%BB%A4%E8%A1%A8%E8%BE%BE%E5%BC%8F)">&lt;strong>Line Filter Expression&lt;/strong>&lt;/a>&lt;strong>(行过滤表达式)&lt;/strong> # 最基本的过滤方式，通过关键字匹配每一行的日志内容&lt;/li>
&lt;li>&lt;a href="#Parser(%E8%A7%A3%E6%9E%90%E8%A1%A8%E8%BE%BE%E5%BC%8F)">&lt;strong>Parser Expression&lt;/strong>&lt;/a>&lt;strong>(解析表达式)&lt;/strong># 以指定方式解析日志内容，并将解析结果提取为标签。&lt;/li>
&lt;li>&lt;a href="#Label%20Filter(%E6%A0%87%E7%AD%BE%E8%BF%87%E6%BB%A4%E8%A1%A8%E8%BE%BE%E5%BC%8F)">&lt;strong>Label Filter Expression&lt;/strong>&lt;/a>&lt;strong>(标签过滤表达式)&lt;/strong> #&lt;/li>
&lt;li>&lt;a href="#Line%20Format(%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%A1%A8%E8%BE%BE%E5%BC%8F)">&lt;strong>Line Format Expression&lt;/strong>&lt;/a>&lt;strong>(行格式化表达式)&lt;/strong> #&lt;/li>
&lt;li>&lt;a href="#Labels%20Format(%E6%A0%87%E7%AD%BE%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%A1%A8%E8%BE%BE%E5%BC%8F)">&lt;strong>Labels Format Expression&lt;/strong>&lt;/a>&lt;strong>(标签格式化表达式)&lt;/strong> #&lt;/li>
&lt;li>&lt;a href="https://grafana.com/docs/loki/latest/query/metric_queries/#unwrapped-range-aggregations">&lt;strong>Unwrap Expression&lt;/strong>&lt;/a> #
&lt;ul>
&lt;li>这是一个特殊的表达式，只能在 &lt;a href="https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Logs/Loki/LogQL/Metric%20Queries.md">Metric Queries&lt;/a> 中使用。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>其中一些表达式可以改变日志内容和相应的标签，然后可用于进一步 过滤和处理表达式 或 指标查询。&lt;/p>
&lt;h2 id="line-filter行过滤表达式">Line Filter(行过滤表达式)&lt;a class="td-heading-self-link" href="#line-filter%e8%a1%8c%e8%bf%87%e6%bb%a4%e8%a1%a8%e8%be%be%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;a href="https://grafana.com/docs/loki/latest/query/log_queries/#line-filter-expression">https://grafana.com/docs/loki/latest/query/log_queries/#line-filter-expression&lt;/a>&lt;/p>
&lt;p>通过 日志流选择器 获取到想要的日志后，可以使用 Line Filter Expression(行过滤表达式) 对这些日志进行过滤。过滤表达式 可以只是文本或正则表达式，比如&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 过滤出日志内容中，包含 timeout 字符串的日志行。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>&lt;span style="color:#000">job&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;kube-system/etcd&amp;#34;&lt;/span>,container&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;etcd&amp;#34;&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span> &lt;span style="color:#000;font-weight:bold">|&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;timeout&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 匹配 {job=&amp;#34;nginx-promtail&amp;#34;} 日志流中所有日志行中，不包含 北京 字符串的行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>&lt;span style="color:#000">job&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;nginx-promtail&amp;#34;&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span> !&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;北京&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：过滤表达式不能单独使用，必须基于 日志流选择器 得出的结果，再进行过滤。示例 LogQL 执行效果如下&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/xgx9x4/1616129550979-719a6401-7dd8-4196-9f8a-78f7b14e80a8.jpeg" alt="">&lt;/p>
&lt;p>在上面的示例中， |= 这个符号作为 filter operators(过滤运算符)，来定义过滤行为。可用的 filter operators 有以下几种：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>|=&lt;/strong> # 匹配包含指定字符串的日志行&lt;/li>
&lt;li>&lt;strong>!=&lt;/strong> # 匹配不包含指定字符串的日志行&lt;/li>
&lt;li>&lt;strong>|~&lt;/strong> # 匹配包含正则表达式的日志行&lt;/li>
&lt;li>&lt;strong>!~&lt;/strong># 匹配不包含正则表达式的日志行&lt;/li>
&lt;/ol>
&lt;h2 id="parser解析表达式">Parser(解析表达式)&lt;a class="td-heading-self-link" href="#parser%e8%a7%a3%e6%9e%90%e8%a1%a8%e8%be%be%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;a href="https://grafana.com/docs/loki/latest/query/log_queries/#parser-expression">https://grafana.com/docs/loki/latest/query/log_queries/#parser-expression&lt;/a>&lt;/p>
&lt;p>&lt;strong>Parser(解析) 表达式&lt;/strong> 可以解析日志行内容，并将&lt;strong>提取成标签&lt;/strong>。这些被提取出来的标签，可以用在 &lt;a href="https://grafana.com/docs/loki/latest/query/log_queries/#label-filter-expression">label filter expressions&lt;/a>(标签过滤表达式) 或 &lt;a href="https://grafana.com/docs/loki/latest/query/metric_queries/">metric aggregations&lt;/a>(指标聚合)、etc. （Tip: 毕竟有了标签，那玩法就很多了）&lt;/p>
&lt;p>提取的标签键将由解析器进行自动格式化，以遵循 Prometheus 指标名称的约定（它们只能包含 ASCII 字母和数字，以及下划线和冒号，不能以数字开头）。&lt;/p>
&lt;p>例如下面的日志行，经过 &lt;code>| json&lt;/code> 表达式将产生以下 Map 数据：&lt;/p>
&lt;pre tabindex="0">&lt;code>{ &amp;#34;a.b&amp;#34;: { &amp;#34;c&amp;#34;: &amp;#34;d&amp;#34; }, &amp;#34;e&amp;#34;: &amp;#34;f&amp;#34; }
&lt;/code>&lt;/pre>&lt;p>-&amp;gt;&lt;/p>
&lt;pre tabindex="0">&lt;code>{a_b_c=&amp;#34;d&amp;#34;, e=&amp;#34;f&amp;#34;}
&lt;/code>&lt;/pre>&lt;p>在出现错误的情况下，例如，如果该行不是预期的格式，该日志行不会被过滤，而是会被添加一个新的 &lt;code>__error__&lt;/code> 标签。&lt;/p>
&lt;p>需要注意的是如果一个提取的标签键名已经存在于原始日志流中，那么提取的标签键将以 &lt;code>_extracted&lt;/code> 作为后缀，以区分两个标签，你可以使用一个标签格式化表达式来强行覆盖原始标签，但是如果一个提取的键出现了两次，那么只有最新的标签值会被保留。&lt;/p>
&lt;p>目前支持 &lt;code>json&lt;/code>、&lt;code>logfmt&lt;/code>、&lt;code>pattern&lt;/code>、&lt;code>regexp&lt;/code>、&lt;code>unpack&lt;/code> 这几种解析器。&lt;/p>
&lt;p>我们应该尽可能使用 &lt;code>json&lt;/code> 和 &lt;code>logfmt&lt;/code> 等预定义的解析器，这会更加容易，而当日志行结构异常时，可以使用 &lt;code>regexp&lt;/code>，可以在同一日志管道中使用多个解析器，这在你解析复杂日志时很有用。&lt;/p>
&lt;h3 id="json">json&lt;a class="td-heading-self-link" href="#json" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>json 解析器有两种模式运行。&lt;/p>
&lt;ul>
&lt;li>
&lt;ol>
&lt;li>没有参数。如果日志行是一个有效的 json 文档，在你的管道中添加 &lt;code>| json&lt;/code> 将提取所有 json 属性作为标签，嵌套的属性会使用 &lt;code>_&lt;/code> 分隔符被平铺到标签键中。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>注意：数组会被忽略。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>例如，使用 json 解析器从以下文件内容中提取标签。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;protocol&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;HTTP/2.0&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;servers&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;129.0.1.1&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;10.2.1.3&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">],&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;request&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;time&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;6.032&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;method&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;GET&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;host&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;foo.grafana.net&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;size&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;55&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;headers&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;Accept&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;*/*&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;User-Agent&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;curl/7.68.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">},&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;response&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;status&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">401&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;size&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;228&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;latency_seconds&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;6.031&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>可以得到如下所示的标签列表：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>&amp;#34;protocol&amp;#34; =&amp;gt; &amp;#34;HTTP/2.0&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#34;request_time&amp;#34; =&amp;gt; &amp;#34;6.032&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#34;request_method&amp;#34; =&amp;gt; &amp;#34;GET&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#34;request_host&amp;#34; =&amp;gt; &amp;#34;foo.grafana.net&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#34;request_size&amp;#34; =&amp;gt; &amp;#34;55&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#34;response_status&amp;#34; =&amp;gt; &amp;#34;401&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#34;response_size&amp;#34; =&amp;gt; &amp;#34;228&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#34;response_size&amp;#34; =&amp;gt; &amp;#34;228&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;ol start="2">
&lt;li>带有参数的。在你的管道中使用 &lt;code>|json label=&amp;quot;expression&amp;quot;, another=&amp;quot;expression&amp;quot;&lt;/code> 将只提取指定的 json 字段为标签，你可以用这种方式指定一个或多个表达式，与 &lt;code>label_format&lt;/code> 相同，所有表达式必须加引号。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>当前仅支持字段访问（&lt;code>my.field&lt;/code>, &lt;code>my[&amp;quot;field&amp;quot;]&lt;/code>）和数组访问（&lt;code>list[0]&lt;/code>），以及任何级别嵌套中的这些组合（&lt;code>my.list[0][&amp;quot;field&amp;quot;]&lt;/code>）。
例如，&lt;code>|json first_server=&amp;quot;servers[0]&amp;quot;, ua=&amp;quot;request.headers[\&amp;quot;User-Agent\&amp;quot;]&lt;/code> 将从以下日志文件中提取标签：&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;protocol&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;HTTP/2.0&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;servers&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;129.0.1.1&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;10.2.1.3&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">],&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;request&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;time&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;6.032&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;method&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;GET&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;host&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;foo.grafana.net&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;size&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;55&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;headers&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;Accept&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;*/*&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;User-Agent&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;curl/7.68.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">},&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;response&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;status&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">401&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;size&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;228&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;latency_seconds&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;6.031&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>提取的标签列表为：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>&amp;#34;first_server&amp;#34; =&amp;gt; &amp;#34;129.0.1.1&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#34;ua&amp;#34; =&amp;gt; &amp;#34;curl/7.68.0&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>如果表达式返回一个数组或对象，它将以 json 格式分配给标签。例如，&lt;code>|json server_list=&amp;quot;services&amp;quot;, headers=&amp;quot;request.headers&lt;/code> 将提取到如下标签：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>&amp;#34;server_list&amp;#34; =&amp;gt; `[&amp;#34;129.0.1.1&amp;#34;,&amp;#34;10.2.1.3&amp;#34;]`
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#34;headers&amp;#34; =&amp;gt; `{&amp;#34;Accept&amp;#34;: &amp;#34;*/*&amp;#34;, &amp;#34;User-Agent&amp;#34;: &amp;#34;curl/7.68.0&amp;#34;}`
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="logfmt">logfmt&lt;a class="td-heading-self-link" href="#logfmt" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>&lt;code>logfmt&lt;/code> 解析器可以通过使用 &lt;code>|logfmt&lt;/code> 来添加，它将从 logfmt 格式的日志行中提前所有的键和值。&lt;/p>
&lt;p>例如，下面的日志行数据：&lt;/p>
&lt;pre tabindex="0">&lt;code>at=info method=GET path=/ host=grafana.net fwd=&amp;#34;124.133.124.161&amp;#34; service=8ms status=200
&lt;/code>&lt;/pre>&lt;p>将提取得到如下所示的标签：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>&amp;#34;at&amp;#34; =&amp;gt; &amp;#34;info&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#34;method&amp;#34; =&amp;gt; &amp;#34;GET&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#34;path&amp;#34; =&amp;gt; &amp;#34;/&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#34;host&amp;#34; =&amp;gt; &amp;#34;grafana.net&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#34;fwd&amp;#34; =&amp;gt; &amp;#34;124.133.124.161&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#34;service&amp;#34; =&amp;gt; &amp;#34;8ms&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#34;status&amp;#34; =&amp;gt; &amp;#34;200&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="pattern">pattern&lt;a class="td-heading-self-link" href="#pattern" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;blockquote>
&lt;p>Tips: &lt;a href="https://grafana.com/docs/loki/latest/release-notes/v2-3/">Loki v2.3.0&lt;/a> 版本引入 &lt;a href="https://grafana.com/blog/2021/08/09/new-in-loki-2.3-logql-pattern-parser-makes-it-easier-to-extract-data-from-unstructured-logs/">pattern 表达式&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>pattern 表达式语法：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-logql" data-lang="logql">| pattern PatternExpression
&lt;/code>&lt;/pre>&lt;p>PatternExpression 由 Captures(捕获) 和 Literals(文字) 组成&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Captures(捕获)&lt;/strong> # 由 &lt;code>&amp;lt;&amp;gt;&lt;/code> 分割的字符串，&lt;code>&amp;lt;&amp;gt;&lt;/code> 中的字符将会作为一个新 Label 的键，捕获到的内容作为该 Label 的值。&lt;/li>
&lt;li>&lt;strong>Literals(文字)&lt;/strong> # 任意 UTF-8 字符序列，包括空白字符。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>PatternExpression 必须用 &lt;code>``&lt;/code> 或 &lt;code>&amp;quot;&amp;quot;&lt;/code> 符号括起来，使用反引号时会将 &lt;code>\&lt;/code> 作为字符串而不是转义符。&lt;/p>
&lt;/blockquote>
&lt;p>比如，现在有如下日志：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-log" data-lang="log">0.191.12.2 - - [10/Jun/2021:09:14:29 +0000] &amp;#34;GET /api/plugins/versioncheck HTTP/1.1&amp;#34; 200 2 &amp;#34;-&amp;#34; &amp;#34;Go-http-client/2.0&amp;#34; &amp;#34;13.76.247.102, 34.120.177.193&amp;#34; &amp;#34;TLSv1.2&amp;#34; &amp;#34;US&amp;#34; &amp;#34;&amp;#34;
&lt;/code>&lt;/pre>&lt;p>使用表达式&lt;/p>
&lt;pre tabindex="0">&lt;code>| pattern `&amp;lt;ip&amp;gt; - - &amp;lt;_&amp;gt; &amp;#34;&amp;lt;method&amp;gt; &amp;lt;uri&amp;gt; &amp;lt;_&amp;gt;&amp;#34; &amp;lt;status&amp;gt; &amp;lt;size&amp;gt; &amp;lt;_&amp;gt; &amp;#34;&amp;lt;agent&amp;gt;&amp;#34; &amp;lt;_&amp;gt;`
&lt;/code>&lt;/pre>&lt;p>将会产生如下几个标签&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>&amp;#34;ip&amp;#34; =&amp;gt; &amp;#34;0.191.12.2&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#34;method&amp;#34; =&amp;gt; &amp;#34;GET&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#34;uri&amp;#34; =&amp;gt; &amp;#34;/api/plugins/versioncheck&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#34;status&amp;#34; =&amp;gt; &amp;#34;200&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#34;size&amp;#34; =&amp;gt; &amp;#34;2&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#34;agent&amp;#34; =&amp;gt; &amp;#34;Go-http-client/2.0&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>&amp;lt;&amp;gt;&lt;/code> 关键字用以捕获字符串，捕获的是从 &lt;code>&amp;lt;&lt;/code> 的左侧字符直到 &lt;code>&amp;gt;&lt;/code> 右侧的字符中间的所有字符。除了 &lt;code>&amp;lt;&amp;gt;&lt;/code> 之外的所有字符都没有特殊含义。比如：&lt;/p>
&lt;ul>
&lt;li>&lt;code>&amp;lt;ip&amp;gt;&lt;/code> # 将会从开头捕获直到第一个空白字符（i.e. &lt;code>-&lt;/code> 前的空白字符），并生成键为 ip 的标签，将这些捕获到的字符作为标签的值&lt;/li>
&lt;li>&lt;code>&amp;lt;_&amp;gt;&lt;/code> # 也是从 &lt;code>&amp;lt;&lt;/code> 左侧捕获到 &lt;code>&amp;gt;&lt;/code> 右侧，但是并不会生成新的标签。&lt;/li>
&lt;li>&lt;code>&amp;quot;&amp;lt;method&amp;gt; &amp;lt;uri&amp;gt; &amp;lt;_&amp;gt;&amp;quot;&lt;/code> # 这里的冒号是被当作具体字符进行匹配的。这部分是要从 &lt;code>&amp;lt;ip&amp;gt; - - &amp;lt;_&amp;gt; &amp;quot;&lt;/code> 之后的字符开始，直到下一个空格之间的所有字符，作为 method 标签的值；以此类推&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>示例&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-log" data-lang="log">level=debug ts=2021-06-10T09:24:13.472094048Z caller=logging.go:66 traceID=0568b66ad2d9294c msg=&amp;#34;POST /loki/api/v1/push (204) 16.652862ms&amp;#34;
&lt;/code>&lt;/pre>&lt;p>表达式: &lt;code>&amp;lt;_&amp;gt; msg=&amp;quot;&amp;lt;method&amp;gt; &amp;lt;path&amp;gt; (&amp;lt;status&amp;gt;) &amp;lt;latency&amp;gt;&amp;quot;&lt;/code>&lt;/p>
&lt;p>日志前面的部分都会被忽略，直到遇上 &lt;code>msg=&amp;quot;&lt;/code> 字符串。POST 作为 method 标签的值；/loki/api/v1/push 作为 path 标签的值；204 作为 status 标签的值；16.652862ms 作为 latency 标签的值。&lt;/p>
&lt;h3 id="regexp">regexp&lt;a class="td-heading-self-link" href="#regexp" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>与 &lt;code>logfmt&lt;/code> 和 &lt;code>json&lt;/code>（它们隐式提取所有值且不需要参数）不同，&lt;code>regexp&lt;/code> 解析器采用单个参数 &lt;code>| regexp &amp;quot;&amp;lt;re&amp;gt;&amp;quot;&lt;/code> 的格式，其参数是使用 Golang RE2 语法的正则表达式。&lt;/p>
&lt;p>正则表达式必须包含至少一个命名的子匹配（例如&lt;code>(?P&amp;lt;name&amp;gt;re)&lt;/code>），每个子匹配项都会提取一个不同的标签。&lt;/p>
&lt;p>例如，解析器 &lt;code>| regexp &amp;quot;(?P&amp;lt;method&amp;gt;\\w+) (?P&amp;lt;path&amp;gt;[\\w|/]+) \\((?P&amp;lt;status&amp;gt;\\d+?)\\) (?P&amp;lt;duration&amp;gt;.*)&amp;quot;&lt;/code> 将从以下行中提取标签：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>POST /api/prom/api/v1/query_range (200) 1.5s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>提取的标签为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>&amp;#34;method&amp;#34; =&amp;gt; &amp;#34;POST&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#34;path&amp;#34; =&amp;gt; &amp;#34;/api/prom/api/v1/query_range&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#34;status&amp;#34; =&amp;gt; &amp;#34;200&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#34;duration&amp;#34; =&amp;gt; &amp;#34;1.5s&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="unpack">unpack&lt;a class="td-heading-self-link" href="#unpack" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>&lt;code>unpack&lt;/code> 解析器将解析 json 日志行，并通过打包阶段解开所有嵌入的标签，一个特殊的属性 &lt;code>_entry&lt;/code> 也将被用来替换原来的日志行。&lt;/p>
&lt;p>例如，使用 &lt;code>| unpack&lt;/code> 解析器，可以得到如下所示的标签：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;container&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;myapp&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;pod&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;pod-3223f&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">&amp;#34;_entry&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;original log message&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>允许提取 &lt;code>container&lt;/code> 和 &lt;code>pod&lt;/code> 标签以及原始日志信息作为新的日志行。&lt;/p>
&lt;blockquote>
&lt;p>如果原始嵌入的日志行是特定的格式，你可以将 unpack 与 json 解析器（或其他解析器）相结合使用。&lt;/p>
&lt;/blockquote>
&lt;h2 id="line-format行格式化表达式">Line Format(行格式化表达式)&lt;a class="td-heading-self-link" href="#line-format%e8%a1%8c%e6%a0%bc%e5%bc%8f%e5%8c%96%e8%a1%a8%e8%be%be%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;a href="https://grafana.com/docs/loki/latest/query/log_queries/#line-format-expression">https://grafana.com/docs/loki/latest/query/log_queries/#line-format-expression&lt;/a>&lt;/p>
&lt;p>日志行格式化表达式可以通过使用 Golang 的 &lt;code>text/template&lt;/code> 模板格式重写日志行的内容，它需要一个字符串参数&lt;/p>
&lt;p>语法：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-logql" data-lang="logql">| line_format &amp;#34;{{.LabelName}}&amp;#34;
&lt;/code>&lt;/pre>&lt;p>作为模板格式，所有的 Labels 都是注入模板的变量，可以用 &lt;code>{{.LabelName}}&lt;/code> 引用 Label 的值。&lt;/p>
&lt;p>例如，下面的表达式：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-logql" data-lang="logql">{container=&amp;#34;frontend&amp;#34;} | logfmt | line_format &amp;#34;{{.query}} {{.duration}}&amp;#34;
&lt;/code>&lt;/pre>&lt;p>将提取并重写日志行，只包含 &lt;code>query&lt;/code> 和请求的 &lt;code>duration&lt;/code>。你可以为模板使用双引号字符串或反引号 &lt;code>{{.label_name}}&lt;/code> 来避免转义特殊字符。&lt;/p>
&lt;p>此外 &lt;code>line_format&lt;/code> 也支持数学函数，例如：&lt;/p>
&lt;p>如果我们有以下标签 &lt;code>ip=1.1.1.1&lt;/code>, &lt;code>status=200&lt;/code> 和 &lt;code>duration=3000(ms)&lt;/code>, 我们可以用 &lt;code>duration&lt;/code> 除以 1000 得到以秒为单位的值：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-logql" data-lang="logql">{container=&amp;#34;frontend&amp;#34;} | logfmt | line_format &amp;#34;{{.ip}} {{.status}} {{div .duration 1000}}&amp;#34;
&lt;/code>&lt;/pre>&lt;p>上面的查询将得到的日志行内容为&lt;code>1.1.1.1 200 3&lt;/code>。&lt;/p>
&lt;h2 id="label-filter标签过滤表达式">Label Filter(标签过滤表达式)&lt;a class="td-heading-self-link" href="#label-filter%e6%a0%87%e7%ad%be%e8%bf%87%e6%bb%a4%e8%a1%a8%e8%be%be%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;a href="https://grafana.com/docs/loki/latest/query/log_queries/#label-filter-expression">https://grafana.com/docs/loki/latest/query/log_queries/#label-filter-expression&lt;/a>&lt;/p>
&lt;p>标签过滤表达式允许使用其原始和提取的标签来过滤日志行，它可以包含多个谓词。&lt;/p>
&lt;p>一个谓词包含一个标签标识符、操作符和用于比较标签的值。&lt;/p>
&lt;p>例如 &lt;code>cluster=&amp;quot;namespace&amp;quot;&lt;/code> 其中的 &lt;code>cluster&lt;/code> 是标签标识符，操作符是 &lt;code>=&lt;/code>，值是&lt;code>&amp;quot;namespace&amp;quot;&lt;/code>。&lt;/p>
&lt;p>LogQL 支持从查询输入中自动推断出的多种值类型：&lt;/p>
&lt;ul>
&lt;li>&lt;code>String（字符串）&lt;/code>用双引号或反引号引起来，例如&lt;code>&amp;quot;200&amp;quot;&lt;/code>或&lt;code>us-central1&lt;/code>。&lt;/li>
&lt;li>&lt;code>Duration（时间）&lt;/code>是一串十进制数字，每个数字都有可选的数和单位后缀，如 &lt;code>&amp;quot;300ms&amp;quot;&lt;/code>、&lt;code>&amp;quot;1.5h&amp;quot;&lt;/code> 或 &lt;code>&amp;quot;2h45m&amp;quot;&lt;/code>，有效的时间单位是 &lt;code>&amp;quot;ns&amp;quot;&lt;/code>、&lt;code>&amp;quot;us&amp;quot;&lt;/code>（或 &lt;code>&amp;quot;µs&amp;quot;&lt;/code>）、&lt;code>&amp;quot;ms&amp;quot;&lt;/code>、&lt;code>&amp;quot;s&amp;quot;&lt;/code>、&lt;code>&amp;quot;m&amp;quot;&lt;/code>、&lt;code>&amp;quot;h&amp;quot;&lt;/code>。&lt;/li>
&lt;li>&lt;code>Number（数字）&lt;/code>是浮点数（64 位），如 250、89.923。&lt;/li>
&lt;li>&lt;code>Bytes（字节）&lt;/code>是一串十进制数字，每个数字都有可选的数和单位后缀，如 &lt;code>&amp;quot;42MB&amp;quot;&lt;/code>、&lt;code>&amp;quot;1.5Kib&amp;quot;&lt;/code> 或 &lt;code>&amp;quot;20b&amp;quot;&lt;/code>，有效的字节单位是 &lt;code>&amp;quot;b&amp;quot;&lt;/code>、&lt;code>&amp;quot;kib&amp;quot;&lt;/code>、&lt;code>&amp;quot;kb&amp;quot;&lt;/code>、&lt;code>&amp;quot;mib&amp;quot;&lt;/code>、&lt;code>&amp;quot;mb&amp;quot;&lt;/code>、&lt;code>&amp;quot;gib&amp;quot;&lt;/code>、&lt;code>&amp;quot;gb&amp;quot;&lt;/code>、&lt;code>&amp;quot;tib&amp;quot;&lt;/code>、&lt;code>&amp;quot;tb&amp;quot;&lt;/code>、&lt;code>&amp;quot;pib&amp;quot;&lt;/code>、&lt;code>&amp;quot;bb&amp;quot;&lt;/code>、&lt;code>&amp;quot;eb&amp;quot;&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>字符串类型的工作方式与 Prometheus 标签匹配器在日志流选择器中使用的方式完全一样，这意味着你可以使用同样的操作符（&lt;code>=&lt;/code>、&lt;code>!=&lt;/code>、&lt;code>=~&lt;/code>、&lt;code>!~&lt;/code>）。&lt;/p>
&lt;p>使用 Duration、Number 和 Bytes 将在比较前转换标签值，并支持以下比较器。&lt;/p>
&lt;ul>
&lt;li>&lt;code>==&lt;/code> 或 &lt;code>=&lt;/code> 相等比较&lt;/li>
&lt;li>&lt;code>!=&lt;/code> 不等于比较&lt;/li>
&lt;li>&lt;code>&amp;gt;&lt;/code> 和 &lt;code>&amp;gt;=&lt;/code> 用于大于或大于等于比较&lt;/li>
&lt;li>&lt;code>&amp;lt;&lt;/code> 和 &lt;code>&amp;lt;=&lt;/code> 用于小于或小于等于比较&lt;/li>
&lt;/ul>
&lt;p>例如 &lt;code>logfmt | duration &amp;gt; 1m and bytes_consumed &amp;gt; 20MB&lt;/code> 过滤表达式。&lt;/p>
&lt;p>如果标签值的转换失败，日志行就不会被过滤，而会添加一个 &lt;code>__error__&lt;/code> 标签，要过滤这些错误，请看管道错误部分。&lt;/p>
&lt;p>你可以使用 &lt;code>and&lt;/code>和 &lt;code>or&lt;/code> 来连接多个谓词，它们分别表示&lt;strong>且&lt;/strong>和&lt;strong>或&lt;/strong>的二进制操作，&lt;code>and&lt;/code> 可以用逗号、空格或其他管道来表示，标签过滤器可以放在日志管道的任何地方。&lt;/p>
&lt;p>以下所有的表达式都是等价的:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>| duration &amp;gt;= 20ms or size == 20kb and method!~&amp;#34;2..&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| duration &amp;gt;= 20ms or size == 20kb | method!~&amp;#34;2..&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| duration &amp;gt;= 20ms or size == 20kb,method!~&amp;#34;2..&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| duration &amp;gt;= 20ms or size == 20kb method!~&amp;#34;2..&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认情况下，多个谓词的优先级是从右到左，你可以用圆括号包装谓词，强制使用从左到右的不同优先级。&lt;/p>
&lt;p>例如，以下内容是等价的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>| duration &amp;gt;= 20ms or method=&amp;#34;GET&amp;#34; and size &amp;lt;= 20KB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| ((duration &amp;gt;= 20ms or method=&amp;#34;GET&amp;#34;) and size &amp;lt;= 20KB)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>它将首先评估 &lt;code>duration&amp;gt;=20ms or method=&amp;quot;GET&amp;quot;&lt;/code>，要首先评估 &lt;code>method=&amp;quot;GET&amp;quot; and size&amp;lt;=20KB&lt;/code>，请确保使用适当的括号，如下所示。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>| duration &amp;gt;= 20ms or (method=&amp;#34;GET&amp;#34; and size &amp;lt;= 20KB)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="labels-format标签格式化表达式">Labels Format(标签格式化表达式)&lt;a class="td-heading-self-link" href="#labels-format%e6%a0%87%e7%ad%be%e6%a0%bc%e5%bc%8f%e5%8c%96%e8%a1%a8%e8%be%be%e5%bc%8f" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;a href="https://grafana.com/docs/loki/latest/query/log_queries/#labels-format-expression">https://grafana.com/docs/loki/latest/query/log_queries/#labels-format-expression&lt;/a>&lt;/p>
&lt;p>语法&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-logql" data-lang="logql">| label_format
&lt;/code>&lt;/pre>&lt;p>表达式可以重命名、修改或添加标签，它以逗号分隔的操作列表作为参数，可以同时进行多个操作。&lt;/p>
&lt;p>当两边都是标签标识符时，例如 &lt;code>dst=src&lt;/code>，该操作将把 &lt;code>src&lt;/code> 标签重命名为 &lt;code>dst&lt;/code>。&lt;/p>
&lt;p>左边也可以是一个模板字符串，例如 &lt;code>dst=&amp;quot;{{.status}} {{.query}}&amp;quot;&lt;/code>，在这种情况下，&lt;code>dst&lt;/code> 标签值会被 Golang 模板执行结果所取代，这与 &lt;code>| line_format&lt;/code> 表达式是同一个模板引擎，这意味着标签可以作为变量使用，也可以使用同样的函数列表。&lt;/p>
&lt;p>在上面两种情况下，如果目标标签不存在，那么就会创建一个新的标签。&lt;/p>
&lt;p>重命名形式 &lt;code>dst=src&lt;/code> 会在将 &lt;code>src&lt;/code> 标签重新映射到 &lt;code>dst&lt;/code> 标签后将其删除，然而，模板形式将保留引用的标签，例如 &lt;code>dst=&amp;quot;{{.src}}&amp;quot;&lt;/code> 的结果是 &lt;code>dst&lt;/code> 和 &lt;code>src&lt;/code> 都有相同的值。&lt;/p>
&lt;blockquote>
&lt;p>一个标签名称在每个表达式中只能出现一次，这意味着 &lt;code>| label_format foo=bar,foo=&amp;quot;new&amp;quot;&lt;/code> 是不允许的，但你可以使用两个表达式来达到预期效果，比如 &lt;code>| label_format foo=bar | label_format foo=&amp;quot;new&amp;quot;&lt;/code>。&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: Metric Queries</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Logs/Loki/LogQL/Metric-Queries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Logs/Loki/LogQL/Metric-Queries/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://grafana.com/docs/loki/latest/query/metric_queries/">官方文档，查询 - 指标查询&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>LogQL 还可以通过 &lt;strong>Functions(函数)&lt;/strong> 来对每个日志流进行计算以实现 &lt;strong>Metric Queries(指标查询)&lt;/strong> 。就是将日志流中的日志计数，并根据技术进行一些查询，这种查询方式与 &lt;a href="https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Metrics/Prometheus/PromQL/PromQL.md">PromQL&lt;/a> 的指标查询类似。&lt;/p>
&lt;p>指标查询可用于计算诸如 错误消息率、最近 3 个小时内日志数量最多的 N 个日志源、etc. 的信息。&lt;/p>
&lt;h2 id="范围向量聚合">范围向量聚合&lt;a class="td-heading-self-link" href="#%e8%8c%83%e5%9b%b4%e5%90%91%e9%87%8f%e8%81%9a%e5%90%88" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>LogQL 与 Prometheus 具有相同的范围向量概念，不同之处在于所选的样本范围包括每个日志&lt;/p>
&lt;p>常用函数主要是如下 4 个：&lt;/p>
&lt;ul>
&lt;li>&lt;code>rate&lt;/code>: 计算每秒的日志条目&lt;/li>
&lt;li>&lt;code>count_over_time&lt;/code>: 对指定范围内的每个日志流的条目进行计数&lt;/li>
&lt;li>&lt;code>bytes_rate&lt;/code>: 计算日志流每秒的字节数&lt;/li>
&lt;li>&lt;code>bytes_over_time&lt;/code>: 对指定范围内的每个日志流的使用的字节数&lt;/li>
&lt;/ul>
&lt;p>比如计算 nginx 的 qps：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-logql" data-lang="logql">rate({filename=&amp;#34;/var/log/nginx/access.log&amp;#34;}[5m]))
&lt;/code>&lt;/pre>&lt;p>计算 kernel 过去 5 分钟发生 oom 的次数：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-logql" data-lang="logql">count_over_time({filename=&amp;#34;/var/log/message&amp;#34;} |~ &amp;#34;oom_kill_process&amp;#34; [5m]))
&lt;/code>&lt;/pre>&lt;h2 id="聚合运算符">聚合运算符&lt;a class="td-heading-self-link" href="#%e8%81%9a%e5%90%88%e8%bf%90%e7%ae%97%e7%ac%a6" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>与 PromQL 一样，LogQL 支持内置聚合运算符的一个子集，可用于聚合单个向量的元素，从而产生一个具有更少元素但具有集合值的新向量：&lt;/p>
&lt;ul>
&lt;li>sum: Calculate sum over labels&lt;/li>
&lt;li>min: Select minimum over labels&lt;/li>
&lt;li>max: Select maximum over labels&lt;/li>
&lt;li>avg: Calculate the average over labels&lt;/li>
&lt;li>stddev: Calculate the population standard deviation over labels&lt;/li>
&lt;li>stdvar: Calculate the population standard variance over labels&lt;/li>
&lt;li>count: Count number of elements in the vector&lt;/li>
&lt;li>bottomk: Select smallest k elements by sample value&lt;/li>
&lt;li>topk: Select largest k elements by sample value&lt;/li>
&lt;li>sum：求和&lt;/li>
&lt;li>min：最小值&lt;/li>
&lt;li>max：最大值&lt;/li>
&lt;li>avg：平均值&lt;/li>
&lt;li>stddev：标准差&lt;/li>
&lt;li>stdvar：标准方差&lt;/li>
&lt;li>count：计数&lt;/li>
&lt;li>bottomk：最小的 k 个元素&lt;/li>
&lt;li>topk：最大的 k 个元素&lt;/li>
&lt;/ul>
&lt;p>聚合函数我们可以用如下表达式描述：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-logql" data-lang="logql">&amp;lt;aggr-op&amp;gt;([parameter,] &amp;lt;vector expression) [without|by (label list)]
&lt;/code>&lt;/pre>&lt;p>对于需要对标签进行分组时，我们可以用 &lt;code>without&lt;/code> 或者 &lt;code>by&lt;/code> 来区分。比如计算 nginx 的 qps，并按照 pod 来分组：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-logql" data-lang="logql">sum(rate({filename=&amp;#34;/var/log/nginx/access.log&amp;#34;}[5m])) by (pod)
&lt;/code>&lt;/pre>&lt;p>只有在使用 &lt;code>bottomk&lt;/code> 和 &lt;code>topk&lt;/code> 函数时，我们可以对函数输入相关的参数。比如计算 nginx 的 qps 最大的前 5 个，并按照 pod 来分组：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-logql" data-lang="logql">topk(5,sum(rate({filename=&amp;#34;/var/log/nginx/access.log&amp;#34;}[5m])) by (pod)))
&lt;/code>&lt;/pre>&lt;h2 id="binary-operators二元运算符">Binary Operators(二元运算符)&lt;a class="td-heading-self-link" href="#binary-operators%e4%ba%8c%e5%85%83%e8%bf%90%e7%ae%97%e7%ac%a6" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;h3 id="数学计算">数学计算&lt;a class="td-heading-self-link" href="#%e6%95%b0%e5%ad%a6%e8%ae%a1%e7%ae%97" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>Loki 存的是日志，都是文本，怎么计算呢？显然 LogQL 中的数学运算是面向区间向量操作的，LogQL 中的支持的二进制运算符如下：&lt;/p>
&lt;ul>
&lt;li>&lt;code>+&lt;/code>：加法&lt;/li>
&lt;li>&lt;code>-&lt;/code>：减法&lt;/li>
&lt;li>&lt;code>*&lt;/code>：乘法&lt;/li>
&lt;li>&lt;code>/&lt;/code>：除法&lt;/li>
&lt;li>&lt;code>%&lt;/code>：求模&lt;/li>
&lt;li>&lt;code>^&lt;/code>：求幂&lt;/li>
&lt;/ul>
&lt;p>比如我们要找到某个业务日志里面的错误率，就可以按照如下方式计算：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-logql" data-lang="logql">sum(rate({app=&amp;#34;foo&amp;#34;, level=&amp;#34;error&amp;#34;}[1m])) / sum(rate({app=&amp;#34;foo&amp;#34;}[1m]))
&lt;/code>&lt;/pre>&lt;h3 id="逻辑运算">逻辑运算&lt;a class="td-heading-self-link" href="#%e9%80%bb%e8%be%91%e8%bf%90%e7%ae%97" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>集合运算仅在区间向量范围内有效，当前支持&lt;/p>
&lt;ul>
&lt;li>&lt;code>and&lt;/code>：并且&lt;/li>
&lt;li>&lt;code>or&lt;/code>：或者&lt;/li>
&lt;li>&lt;code>unless&lt;/code>：排除&lt;/li>
&lt;/ul>
&lt;p>比如：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-logql" data-lang="logql">rate({app=~&amp;#34;foo|bar&amp;#34;}[1m]) and rate({app=&amp;#34;bar&amp;#34;}[1m])
&lt;/code>&lt;/pre>&lt;h3 id="比较运算">比较运算&lt;a class="td-heading-self-link" href="#%e6%af%94%e8%be%83%e8%bf%90%e7%ae%97" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>LogQL 支持的比较运算符和 PromQL 一样，包括：&lt;/p>
&lt;ul>
&lt;li>&lt;code>==&lt;/code>：等于&lt;/li>
&lt;li>&lt;code>!=&lt;/code>：不等于&lt;/li>
&lt;li>&lt;code>&amp;gt;&lt;/code>：大于&lt;/li>
&lt;li>&lt;code>&amp;gt;=&lt;/code>: 大于或等于&lt;/li>
&lt;li>&lt;code>&amp;lt;&lt;/code>：小于&lt;/li>
&lt;li>&lt;code>&amp;lt;=&lt;/code>: 小于或等于&lt;/li>
&lt;/ul>
&lt;p>通常我们使用区间向量计算后会做一个阈值的比较，这对应告警是非常有用的，比如统计 5 分钟内 error 级别日志条目大于 10 的情况：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-logql" data-lang="logql">count_over_time({app=&amp;#34;foo&amp;#34;, level=&amp;#34;error&amp;#34;}[5m]) &amp;gt; 10
&lt;/code>&lt;/pre>&lt;p>我们也可以通过布尔计算来表达，比如统计 5 分钟内 error 级别日志条目大于 10 为真，反正则为假：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-logql" data-lang="logql">count_over_time({app=&amp;#34;foo&amp;#34;, level=&amp;#34;error&amp;#34;}[5m]) &amp;gt; bool 10
&lt;/code>&lt;/pre>&lt;h2 id="注释">注释&lt;a class="td-heading-self-link" href="#%e6%b3%a8%e9%87%8a" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>LogQL 查询可以使用 &lt;code>#&lt;/code> 字符进行注释，例如：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-logql" data-lang="logql">{app=&amp;#34;foo&amp;#34;} # anything that comes after will not be interpreted in your query
&lt;/code>&lt;/pre>&lt;p>对于多行 LogQL 查询，可以使用 &lt;code>#&lt;/code> 排除整个或部分行：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-logql" data-lang="logql">{app=&amp;#34;foo&amp;#34;}
| json
# this line will be ignored
| bar=&amp;#34;baz&amp;#34; # this checks if bar = &amp;#34;baz&amp;#34;
&lt;/code>&lt;/pre>&lt;h2 id="pipeline-errors-管道错误">Pipeline Errors 管道错误&lt;a class="td-heading-self-link" href="#pipeline-errors-%e7%ae%a1%e9%81%93%e9%94%99%e8%af%af" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>There are multiple reasons which cause pipeline processing errors, such as:有多种原因导致流水线处理错误，例如：&lt;/p>
&lt;ul>
&lt;li>A numeric label filter may fail to turn a label value into a number 数字标签过滤器可能无法将标签值转换为数字&lt;/li>
&lt;li>A metric conversion for a label may fail.标签的度量转换可能会失败。&lt;/li>
&lt;li>A log line is not a valid json document.日志行不是有效的 JSON 文档。&lt;/li>
&lt;li>etc…等等…&lt;/li>
&lt;/ul>
&lt;p>When those failures happen, Loki won’t filter out those log lines. Instead they are passed into the next stage of the pipeline with a new system label named &lt;code>__error__&lt;/code>. The only way to filter out errors is by using a label filter expressions. The &lt;code>__error__&lt;/code> label can’t be renamed via the language.当这些故障发生时，Loki 不会过滤掉这些日志线。相反，它们通过名为__Error__的新系统标签传递到管道的下一个阶段。过滤误差的唯一方法是使用标签过滤表达式。 __Err__标签无法通过语言重命名。
For example to remove json errors:例如要删除 JSON 错误：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-logql" data-lang="logql">{cluster=&amp;#34;ops-tools1&amp;#34;,container=&amp;#34;ingress-nginx&amp;#34;}
| json
| __error__ != &amp;#34;JSONParserErr&amp;#34;
&lt;/code>&lt;/pre>&lt;p>Logql
Alternatively you can remove all error using a catch all matcher such as &lt;code>__error__ = &amp;quot;&amp;quot;&lt;/code> or even show only errors using &lt;code>__error__ != &amp;quot;&amp;quot;&lt;/code>.或者，您可以使用捕获器删除所有匹配器，例如__Error__ =“”甚至仅显示使用__Error__！=“”。
The filter should be placed after the stage that generated this error. This means if you need to remove errors from an unwrap expression it needs to be placed after the unwrap.在生成此错误的阶段后应放置过滤器。这意味着如果您需要从未包装中删除从未包装表达式中删除错误，则需要放置在未包装之后。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-logql" data-lang="logql">quantile_over_time(
0.99,
{container=&amp;#34;ingress-nginx&amp;#34;,service=&amp;#34;hosted-grafana&amp;#34;}
| json
| unwrap response_latency_seconds
| __error__=&amp;#34;&amp;#34;[1m]
) by (cluster)
&lt;/code>&lt;/pre>&lt;p>Logql&lt;/p>
&lt;blockquote>
&lt;p>Metric queries cannot contains errors, in case errors are found during execution, Loki will return an error and appropriate status code.度量标准查询不能包含错误，以便在执行期间找到错误，Loki 将返回错误和适当的状态代码。&lt;/p>
&lt;/blockquote></description></item></channel></rss>