<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Observability on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Observability/</link><description>Recent content in Observability on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Observability/index.xml" rel="self" type="application/rss+xml"/><item><title>Observability</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Observability/Observability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Observability/Observability/</guid><description>概述 参考：
CNCF 博客，What was observability again? 中文翻译：公众号，云原生技术爱好者社区-什么是可观测性 CNCF 可观测性白皮书(中文) CNCF 全景图 Wiki, Observability 宋净超-云原生资料库-OpenTelemetry 可观测性的未来 公众号，云原生社区-构建适合组织的云原生可观测性能力 Goole 文章 想象一下，在没有财务预测的情况下经营企业，甚至不知道银行剩下多少钱。您怎么知道您是在巨大的现金缓冲中游泳还是由于资金不足而需要跳过客户午餐？如果不注意自己的财务状况，根本就不可能开展健康的业务。同样，如果不观察您的计算基础架构，就不可能保持应用程序运行正常。
事实上，Observability(可观测性) 非常重要，到 2021 年 2 月，云原生计算基金会(CNCF)列出了 102 个可观察性项目。可观测性不仅重要，而且昂贵。Netflix 被戏称为一个产生大量日志的平台，同时也是一个流视频平台。可观测性之所以昂贵，有两个原因:
可观测性比被观测系统至少可靠一个数量级。否则，你将继续调试你的可观察性堆栈，而不是使用它来保持你的应用程序运行。 因为你永远不知道要观察什么，直到事件发生后，观察多于需要的东西是很常见的。一个好的汽车司机不仅要向前看，而且还要不断扫视周围以避免事故。 什么是可观测性 可观测性有许多名称，如监测、审计、遥测、仪器。忽略这些细微差别，所有这些词本质上的意思都是一样的:度量您的基础设施、平台和应用程序，以了解它是如何运行的。正如彼得·德鲁克(Peter Drucker)曾经说过的：如果你无法量化它，你就无法管理它。
如果你熟悉精益思维——即构建-度量-学习——那么可观察性就会自然而然地出现在你身上。可观测性通过测量阶段闭合反馈回路。它允许您的团队对应用程序进行快速更改，快速适应其用户基础和环境，而不会产生不必要的意外。良好的可观测性可以将凌晨 2 点被唤醒转换为日常检查。
可观测性的三大支柱 具有可观测的系统通常具有三个部分
Metrics(指标) 监控 # 随着时间推移产生的一些与监控相关的可聚合数据点 Logging(日志) 监控 # 离散式的日志或事件 Tracing(链路追踪) 监控 # 追踪程序的函数 CNCF 将 可观测性 和 数据分析 归类为一个单独的类别，且划分成 4 个子类
监控系统 # 以 Prometheus 等为代表 日志系统 # 以 Elastic Stack 和 PLG Stack 等为代表 追踪系统 # 以 Jaeger、Zipkiin、SkyWalking、Pinpoint 等为代表 可以监控两个程序之间调用时，程序内部都调用了哪些函数。类似 Linux 的 Strace 命令，只不过这些监控是实时的。 混沌工程系统 # 以 ChaosMonkey 和 ChaosBlade 等为代表 Metrics(指标) 指标 —— 也称为服务水平指标(SLI)或关键性能指标(KPI) —— 是数字值的时间序列。可以把它想象成每小时记录所有大城市的室外温度。指标使用最少的空间，提供最多的洞察力(为它们使用的空间)。它们可以记录每小时活动用户的数量、应用程序收到的请求的数量、可用磁盘空间的数量等。关注指标可以确保您的用户在使用应用程序时获得良好的体验，同时还可以降低基础设施的成本。</description></item><item><title>可观测性之数据模型</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Observability/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Observability/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</guid><description>概述 参考
原文：公众号-k8s 技术圈，聊聊可观测性之数据模型 在 201x 年，随着容器技术的出现，容器的部署方式逐渐被各大互联网公司采用，相比物理机/虚拟机，容器的好处是环境隔离、轻量、快速。
但是管理容器是一件复杂的事情，后来出现了 Kubernetes，成为了事实上的容器管理标准，目前各大公司都在使用 Kubernetes。
因为容器和 Kubernetes 降低了服务（应用）的部署和升级成本，所以催生了「微服务」的概念，服务从「单体复杂服务」向「多个简单服务」演变，在之前，需要着重考虑服务内的架构设计，单个服务对外提供尽可能多的能力，而在微服务中，会直接把单个服务拆分成多个服务，服务之间用 API 调用。
这里也可以看到，在微服务中，架构设计的重要性降低，API 设计的重要性提高。
另外，拆分出微服务后，编程的难度事实上降低了，对编程人员的要求也降低了。
这说明一个事实，随着基础设施的不断发展，会有越来越多的「编程能力」沉淀成基础设施，使编程的难度不断降低：软件开发不断向简单的方式发展。
但是，随着微服务的发展，服务变得太多了，管理负责度又上升了，比如怎么去解决服务发现的问题、怎么控制流量、服务之间怎么做隔离，服务状态怎么观测等等。这时候又出现了「服务治理」的概念，关于服务治理，有一个新的词：Service Mesh，现在事实标准是 Istio。
概述 可观测性是为了应对微服务的复杂场景下发明出来的一个词，本质上是为了衡量系统运行的状态，可观测性是服务治理的一个维度，和功能性、可测试性、可运维性一样。
一般常说可观测性包含三个度量角度：Metric、Logging、Tracing，其实还有一个：Profiling。
Metric：指标，对系统中某一类信息的聚合统计，比如 QPS、延迟、错误率等。 Logging：日志，对系统所做行为的一种记录，它是离散的，没有相关性，为了区分这种记录的重要程度，会分级别（DEBUG、INFO、WARN、ERROR、FATAL）。 Tracing：调用链，它反映的是请求经过某个组件的运行情况，经过组件的数据叫做 Span，Span 可以体现经过组件的状态、一些关键属性和事件、上下文信息。Span 之间通过 Trace ID 关联。 Profiling：一般叫做 Continuous Profiling，持续分析，它反映的是程序内部的运行状态，比如栈调用、执行时间等。可以把 Profiling 可视化成火焰图方面分析问题。 一般来说，基于这些度量处理故障的流程是：Metric → Tracing → Logging → Profiling
根据 Metric 配置的告警策略发现问题，基于 Tracing 查看是哪个组件出问题，基于 Logging 查看组件的日志，Profiling 分析组件具体的故障或性能问题。
数据模型 在 Tracing 领域，之前有两个项目，一个是 OpenTracing，它是一个规范，Jaeger 就是基于 OpenTracing 的开源实现，另一个是 OpenCensus，它是 Google 开源的度量工具。这两个项目功能高度重合，在 CNCF 主导下合并成了 OpenTelemetry，而 OpenTracing 和 OpenCensus 也不再维护。</description></item><item><title>Exemplars</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Observability/Exemplars/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Observability/Exemplars/</guid><description>概述 参考；
https://prometheus.io/docs/prometheus/latest/feature_flags/#exemplars-storage https://grafana.com/docs/grafana/latest/basics/exemplars/ 这是啥？CNCF 可观测性白皮书最后提到了这个
Trace ID 实际应用 我们讨论了在多个信号之间相互跳转的方法，但是它真的是有用的吗？让我们简单的看两个基本案例:
我们收到了一个关于超出 SLO (service level objectives) 的意外高错误率的告警。告警来源于错误的计数器值，我们看到请求暴增导致 501 errors。我们使用_exemplar_ 跳转到事例的 logs 以了解准确的可供人类阅读的错误消息中。错误似乎来自于依赖深层次的内部微服务系统，由于存在与 trace ID 匹配的 request ID，所以可以跳转到 traces。多亏了这一点，我们确切的了解到哪个 service/process 导致了这个问题，并进一步挖掘更多的信息。 我们去 debug 慢请求，我们使用 trace 采样手动触发请求并获得 trace ID。多亏了 tracing view，我们可以在请求方式的几个进程中看到，对于基本操作而说，ABC-1 请求的速度非常的慢。由于目标元数据和时间，我们选择了相关的 CPU 使用率 metrics。我们看到 CPU 使用率很高，接近了机器的限制值，表明 CPU 已经饱和。为了了解 CPU 使用率高的原因 (特别是当它是容器中仅存的进程)，我们使用相同的 目标元数据 和 time 选择跳转到 CPU profile。 总结一下，好像是通过一个 ID 可以在 Metrics、Log、Trace 数据之间相互跳转。即一个 ID 关联了一个或多个应用所有的可观测性数据</description></item></channel></rss>