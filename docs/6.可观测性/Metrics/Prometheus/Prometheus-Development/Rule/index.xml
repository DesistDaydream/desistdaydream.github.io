<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rule on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Metrics/Prometheus/Prometheus-Development/Rule/</link><description>Recent content in Rule on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Metrics/Prometheus/Prometheus-Development/Rule/index.xml" rel="self" type="application/rss+xml"/><item><title>Rule</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Metrics/Prometheus/Prometheus-Development/Rule/Rule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Metrics/Prometheus/Prometheus-Development/Rule/Rule/</guid><description>概述 参考：
GitHub 项目，prometheus/prometheus - rules 公众号 - 运维开发故事，prometheus告警规则管理 接口 代码：./rules/manager.go —— Rule{}
Rule 接口封装了一个向量表达式，在指定的时间间隔评估规则。Prometheus 将规则分为两类：Recording Rule(记录规则) 与 Alerting Rule(告警规则)，所以将处理这两种规则的方法统一成一个接口，如下两个结构体实现了该接口：
./rules/alerting.go —— AlertingRule{} ./rules/recording.go —— RecordingRule{} type Rule interface { // 直接返回规则的名称 Name() string // Labels of the rule. Labels() labels.Labels // 评估规则(规则处理逻辑中最重要的部分) Eval(context.Context, time.Time, QueryFunc, *url.URL) (promql.Vector, error) // String returns a human-readable string representation of the rule. String() string // Query returns the rule query expression. Query() parser.Expr // SetLastErr sets the current error experienced by the rule.</description></item><item><title>从配置文件入手寻找代码逻辑</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Metrics/Prometheus/Prometheus-Development/Rule/%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%85%A5%E6%89%8B%E5%AF%BB%E6%89%BE%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/Metrics/Prometheus/Prometheus-Development/Rule/%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%85%A5%E6%89%8B%E5%AF%BB%E6%89%BE%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91/</guid><description>告警通知逻辑解析 解析起因：告警在触发后，每隔一定时间，就会重新发送一次，在 rule 配置文件的 interval 字段是配置的其中一个，但是通过抓包分析，应该还有另一个参数的时间，与之相加，才是总体的告警重发送间隔
首先找到 interval 字段的配置，由于该字段的默认值是 PrometheusServer 配置文件中的 .global.evaluation_interval 字段的值，所以从此处开始找起。
配置文件及其关联的结构体 在 ./config/config.go 文件中，找到了与该配置关联的结构体
// ./config/config.go type GlobalConfig struct { // 其他结构体中的属性省略 // How frequently to evaluate rules by default. EvaluationInterval model.Duration `yaml:&amp;#34;evaluation_interval,omitempty&amp;#34;` } 通过查找引用，找到引用该属性的位置
为什么我就确定是这里呢？因为 main.go 文件中的另俩个引用是这样的：
// ./cmdg/prometheus/main.go noStepSubqueryInterval.Set(config.DefaultGlobalConfig.EvaluationInterval) // ./cmd/prometheus/main.go noStepSuqueryInterval.Set(conf.GlobalConfig.EvaluationInterval) 而该属性在 config.go 文件中的调用是用来确定该字段的值的。比如，如果配置文件没有该字段，则默认 如何如何
所以，EvaluationInterval 真正被使用的地方，应该就是 Updata() 方法中的调用
找到使用该配置的函数 接下来跳转过来，这是一个作用在 ruleManager 上的 Update() 方法，第一个参数就是评估间隔
// ./cmd/prometheus/main.go return ruleManager.Update( time.Duration(cfg.GlobalConfig.EvaluationInterval), // 评估间隔 files, cfg.GlobalConfig.ExternalLabels, ) 接下来查看 Update() 的逻辑，重点是 LoadGroups() 方法，使用到了 评估间隔 ，就是该方法的第一个参数 interval。</description></item></channel></rss>