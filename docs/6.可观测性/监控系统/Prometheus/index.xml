<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Prometheus</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/</link><description>Recent content in Prometheus on 断念梦</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Prometheus</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Prometheus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Prometheus/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/introduction/overview/">官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://yunlzheng.gitbook.io/prometheus-book/">yunlzheng 写的电子书&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/Tencent-Cloud-Native/tkedocs">GitHub 项目，Tencent-Cloud-Native/tkedocs&lt;/a>(我个人总结完绝大部分文档后发现的这个项目)&lt;/li>
&lt;li>Prometheus 纪录片
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=rT4fJNbfe14">YouTube&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1aW4y147GX">B 站翻译&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Prometheus 是由 SoundCloud 开发的 开源监控报警系统 和 时间序列数据库(TSDB) 。&lt;strong>Time Series(时间序列)&lt;/strong> 概念详见：&lt;a href="https://www.yuque.com/go/doc/33147376">Prometheus 数据模型&lt;/a>。使用 Go 语言开发，是 Google BorgMon 监控系统的开源版本。&lt;/p>
&lt;blockquote>
&lt;p>题外话：Google 的 Borg 诞生了 kuberntes、Google 的 Borgmon 诞生了 Prometheus&lt;/p>
&lt;/blockquote>
&lt;p>2016 年由 Google 发起 Linux 基金会旗下的 Cloud Native Computing Foundation(云原生计算基金会), 将 Prometheus 纳入其下第二大开源项目。Prometheus 目前在开源社区相当活跃。&lt;/p>
&lt;h2 id="prometheus-架构概述">Prometheus 架构概述&lt;/h2>
&lt;p>Prometheus 的基本原理是通过 HTTP 协议周期性抓取被监控组件的状态，任意组件只要提供对应的 HTTP 接口就可以接入监控。不需要任何 SDK 或者其他的集成过程。这样做非常适合做虚拟化环境监控系统，比如 VM、Docker、Kubernetes 等。输出被监控组件信息的 HTTP 接口被叫做 exporter 。&lt;/p>
&lt;p>下面这张图说明了 Prometheus 的整体架构，以及生态中的一些组件作用：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189523-5ca97287-5886-4ab9-a4f8-6c249117e314.jpeg" alt="">
Prometheus 生态圈中包含了多个组件，其中许多组件是可选的，多数 Prometheus 组件是 Go 语言写的，使得这些组件很容易编译和部署：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Prometheus Server&lt;/strong> # 主要负责数据抓取和存储，提供 PromQL 查询语言的支持。用于收集和存储时间序列数据。
&lt;ul>
&lt;li>定期从配置好的 Jobs 中&lt;strong>拉取&lt;/strong>Exporters 采集的&lt;strong>Metrics(指标)&lt;/strong> 数据；或者&lt;strong>接收&lt;/strong>来自 &lt;strong>Pushgateway&lt;/strong>(类似 zabbix 的 proxy) 发过来的 Metrics；或者从其他的 Prometheus Server 中拉取 Metrics。&lt;/li>
&lt;li>Prometheus Server 在本地存储收集到的 Metrics，并通过一定 &lt;strong>RecordingRule(记录规则)&lt;/strong> 进行清理和整理数据，并把得到的结果存储到新的时间序列中。还会运行已定义好的 &lt;strong>AlertingRule(告警规则)&lt;/strong>，记录新的时间序列或者向 Alertmanager 推送警报。&lt;/li>
&lt;li>由于 Metrics 都是通过 HTTP 或者 HTTPS 协议提供的，所以 Prometheus Server 在抓取 Metrics 时，也就是发起一次 HTTP 或者 HTTPS 的 GET 请求&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Instrumenting&lt;/strong> # 为 Prometheus 提供指标的工具或代码
&lt;ul>
&lt;li>&lt;strong>Exporters&lt;/strong># 导出器。Exporter 是 Prometheus 的一类数据采集组件的总称。它负责从设备上搜集数据，并将其转化为 Prometheus 支持的格式(一般情况下 exporter 是安装在需要采集数据的设备上的程序，并监听某个 port。但是如果想要收集 snmp 信息的话，则有专门的 snmp-exporter 安装在某个地方；再收集指定设备的 snmp 信息，然后 prometheus 再找 snmp-exporter 去收集数据)。与传统的数据采集组件不同的是，它并不向中央服务器发送数据，而是等待中央服务器主动前来抓取。Prometheus 提供多种类型的 Exporter 用于采集各种不同服务的运行状态。目前支持的有数据库、硬件、消息中间件、存储系统、HTTP 服务器、JMX 等。&lt;/li>
&lt;li>&lt;strong>Client Library&lt;/strong> # 客户端库(客户端 SDK)，官方提供的客户端类库有 go、java、scala、python、ruby，其他还有很多第三方开发的类库，支持 nodejs、php、erlang 等。为需要监控的服务生成相应的 Metrics 并暴露给 Prometheus server。当 Prometheus server 来 pull 时，直接返回实时状态的 Metrics。&lt;/li>
&lt;li>&lt;strong>Push Gateway&lt;/strong># 支持 Client 主动推送 Metrics 到 PushGateway，而 PrometheusServer 只是定时去 Gateway 上抓取数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Alertmanager&lt;/strong> # 警告管理器，用来进行报警。从 Prometheus server 端接收到 alerts 后，会进行去除重复数据，分组，并路由到对收的接受方式，发出报警。常见的接收方式有：电子邮件，pagerduty，OpsGenie, webhook 等。&lt;/li>
&lt;li>&lt;strong>prometheus_cli&lt;/strong> # 命令行工具。&lt;/li>
&lt;li>&lt;strong>其他辅助性工具&lt;/strong>
&lt;ul>
&lt;li>Prometheus 通过 PromQL 和其他 API 可视化地展示收集的数据。Prometheus 支持很多方式的图表可视化，例如 Grafana、自带的 PrometheusDashboard 以及自身提供的模版引擎等等。Prometheus 还提供 HTTP API 的查询方式，自定义所需要的输出。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Prometheus 适用的场景&lt;/p>
&lt;ul>
&lt;li>Prometheus 在记录纯数字时间序列方面表现非常好。它既适用于面向服务器等硬件指标的监控，也适用于高动态的面向服务架构的监控。对于现在流行的微服务，Prometheus 的多维度数据收集和数据筛选查询语言也是非常的强大。Prometheus 是为服务的可靠性而设计的，当服务出现故障时，它可以使你快速定位和诊断问题。它的搭建过程对硬件和服务没有很强的依赖关系。&lt;/li>
&lt;/ul>
&lt;p>Prometheus 不适用的场景&lt;/p>
&lt;ul>
&lt;li>Prometheus 它的价值在于可靠性，甚至在很恶劣的环境下，你都可以随时访问它和查看系统服务各种指标的统计信息。 如果你对统计数据需要 100%的精确，它并不适用，例如：它不适用于实时计费系统。&lt;/li>
&lt;/ul>
&lt;h3 id="总结prometheus-从-instrumenting-那里抓取监控数据储存完了哈哈哈哈哈">总结：prometheus 从 Instrumenting 那里抓取监控数据，储存。完了~~~~哈哈哈哈哈&lt;/h3>
&lt;h2 id="instrumenting检测仪表装置-的实现方式">Instrumenting(检测仪表装置) 的实现方式&lt;/h2>
&lt;p>Prometheus 可以通过 3 种方式从目标上 Scrape(抓取) 指标：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Exporters&lt;/strong> # 外部抓取程序&lt;/li>
&lt;li>&lt;strong>Instrumentation&lt;/strong> # 可以理解为内嵌的 Exporter，比如 Prometheus Server 的 9090 端口的 &lt;code>/metrics&lt;/code> 就属于此类。
&lt;ul>
&lt;li>说白了，就是目标自己就可以吐出符合 Prometheus 格式的指标数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Pushgateway&lt;/strong> # 针对需要推送指标的应用&lt;/li>
&lt;/ul>
&lt;h2 id="label-与-relabeling">Label 与 Relabeling&lt;/h2>
&lt;p>详见 &lt;a href="https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Target(%E7%9B%AE%E6%A0%87)%20%E4%B8%8E%20Relabeling(%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0).md">Label 与 Relabeling 章节&lt;/a>&lt;/p>
&lt;h2 id="instrumenting-的安装与使用">Instrumenting 的安装与使用&lt;/h2>
&lt;p>详见 &lt;a href="https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Instrumenting/Instrumenting.md">Instrumenting 章节&lt;/a>&lt;/p>
&lt;h1 id="prometheus-部署">Prometheus 部署&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/prometheus/latest/installation/">官方文档，Prometheus-安装&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>官方系统版本可在这里下载：&lt;a href="https://prometheus.io/download/">https://prometheus.io/download/&lt;/a>&lt;/p>
&lt;p>Prometheus 官方有多种部署方案，比如：Docker 容器、Ansible、Chef、Puppet、Saltstack 等。Prometheus 用 Golang 实现，因此具有天然可移植性(支持 Linux、Windows、macOS 和 Freebsd)。&lt;/p>
&lt;h2 id="二进制文件运行-prometheus-server">二进制文件运行 Prometheus Server&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/prometheus/prometheus/releases/">https://github.com/prometheus/prometheus/releases/&lt;/a> 在该页面下直接下载 prometheus 的进制文件 &lt;code>prometheus-版本号.linux-amd64.tar.gz&lt;/code> 并解压，其中包含 prometheus 的主程序还有 yaml 格式的配置文件以及运行所需要的依赖库&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export PromVersion&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2.25.1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://github.com/prometheus/prometheus/releases/download/v&lt;span style="color:#e6db74">${&lt;/span>PromVersion&lt;span style="color:#e6db74">}&lt;/span>/prometheus-&lt;span style="color:#e6db74">${&lt;/span>PromVersion&lt;span style="color:#e6db74">}&lt;/span>.linux-amd64.tar.gz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>创建/usr/local/prometheus 目录，并将解压的所有文件移动到该目录下&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir /usr/local/prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar -zxvf prometheus-&lt;span style="color:#e6db74">${&lt;/span>PromVersion&lt;span style="color:#e6db74">}&lt;/span>.linux-amd64.tar.gz -C /usr/local/prometheus/ --strip-components&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>创建 Systemd 服务,在 ExecStart 字段上，使用运行时标志来对 prometheus 进行基本运行配置，标志说明详见下文&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /usr/lib/systemd/system/prometheus.service &lt;span style="color:#e6db74">&amp;lt;&amp;lt; EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Unit]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Description=prometheus
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">After=network.target
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Service]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Type=simple
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">User=root
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">ExecStart=/usr/local/prometheus/prometheus \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --web.console.templates=/usr/local/prometheus/consoles \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --web.console.libraries=/usr/local/prometheus/console_libraries \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --config.file=/usr/local/prometheus/prometheus.yml \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --storage.tsdb.path=/var/lib/prometheusData \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --web.enable-lifecycle
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">Restart=on-failure
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[Install]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">WantedBy=multi-user.target
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>启动 Prometheus&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl start prometheus
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="容器运行-prometheus">容器运行 prometheus&lt;/h2>
&lt;p>获取配置文件.&lt;/p>
&lt;blockquote>
&lt;p>也可以不获取配置文件，去掉启动时的 -v /etc/monitoring/prometheus:/etc/prometheus/config_out 与 &amp;ndash;config.file=/etc/prometheus/config_out/prometheus.yml 这两行即可
获取配置文件主要是为了让后续测试可以更方便得修改文件&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir -p /opt/monitoring/prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run -d --name prometheus --rm prom/prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker cp prometheus:/etc/prometheus /opt/monitoring/prometheus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mv /opt/monitoring/prometheus/prometheus /opt/monitoring/prometheus/config
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker stop prometheus
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行 Prometheus Server&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -d --name prometheus --restart&lt;span style="color:#f92672">=&lt;/span>always &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --network host &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /etc/localtime:/etc/localtime &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /opt/monitoring/prometheus/config:/etc/prometheus/config_out &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> prom/prometheus &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --config.file&lt;span style="color:#f92672">=&lt;/span>/etc/prometheus/config_out/prometheus.yml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="prometheus-关联文件与配置">Prometheus 关联文件与配置&lt;/h1>
&lt;p>&lt;strong>/etc/prometheus/prometheus.yml&lt;/strong> # Prometheus Server 运行时的配置文件。可通过 &amp;ndash;config.file 标志指定其他文件。
&lt;strong>/etc/prometheus/rule.yml&lt;/strong> # Prometheus Rule 配置文件。该文件默认不存在，需手动创建。可以在 prometheus.yml 配置中指定其他文件。&lt;/p>
&lt;h2 id="prometheus-配置示例">Prometheus 配置示例&lt;/h2>
&lt;h3 id="默认配置文件">默认配置文件&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 全局配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">global&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scrape_interval&lt;/span>: &lt;span style="color:#ae81ff">15s&lt;/span> &lt;span style="color:#75715e"># 默认抓取间隔, 15秒向目标抓取一次数据。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">evaluation_interval&lt;/span>: &lt;span style="color:#ae81ff">15s&lt;/span> &lt;span style="color:#75715e"># 每15秒评估一次规则，默认为1分钟。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># scrape_timeout is set to the global default (10s).&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 告警报警配置，设置prometheus主程序对接alertmanager程序的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">alerting&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">alertmanagers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">static_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># - alertmanagerIP:9093&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 指定要使用的规则文件位置，并加载一次，根据全局配置中的 evaluation_interval 来定期评估&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 从所有匹配到的文件中读取配置内容。可以使用正则表达式匹配多个符合的文件。Prometheus支持两种规则&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 其一是记录规则(recording rules)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 其二是告警规则(alerting rules)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">rule_files&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># - &amp;#34;first.rules&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># - &amp;#34;second.rules&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 抓取配置，prometheus抓取exporter上的数据时的配置，一个job就是一个抓取工作，其中可以包括1个或者多个目标&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 目标指的是可以被 prometheus 采集的服务器、服务等。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 默认配置里，Prometheus Server 会抓取本地9090端口上数据。该端口上的 exporter 就是 PrometheusServer 自己的 exporter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># job_name 指定要 scrape(抓取) 的 job(工作) 名称，名称必须是唯一的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 并且在这个配置内的时间序例，每一条都会自动添加上这个{job_name:&amp;#34;prometheus&amp;#34;}的标签。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;prometheus&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 设定该job的抓取时间间隔&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scrape_interval&lt;/span>: &lt;span style="color:#ae81ff">5s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">static_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#39;localhost:9090&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="具有-node_exporter-的配置简单文件">具有 node_exporter 的配置简单文件&lt;/h3>
&lt;p>抓取部署了 node_exporter 设备的监控数据的方式及 prometheus.yml 配置文件说明
prometheus 会从 Node Exporter 所在服务器的 http://IP:9100/metrics 这个地址里的内容来获取该设备的监控数据
所以需要给 prometheus 创建一个工作(i.e.job)。一个 job 就是一个抓取监控数据的工作，其中包括要抓取目标的 ip 和 port，还可以设置标签进行分类，还能进行抓取筛选等等，下面提供一个基本的配置
修改 prometheus.yml，加入下面的监控目标，以便让 prometheus 监控这个已经安装了 node_exporter 的设备&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;linux&amp;#34;&lt;/span> &lt;span style="color:#75715e">#新增一个job，名为linux&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">static_configs&lt;/span>: &lt;span style="color:#75715e"># 使用静态配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;10.10.100.101:9100&amp;#34;&lt;/span>] &lt;span style="color:#75715e">#添加一个要抓取数据的目标，指定IP与PORT 。node_exporter所安装的设备&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">instance&lt;/span>: &lt;span style="color:#ae81ff">lchTest&lt;/span> &lt;span style="color:#75715e">#给该目标添加一个标签&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在，prometheus.yml 配置文件中中一共定义了两个监控：一个是默认自带监控 prometheus 自身服务，另一个是我们新增的 job，这个 job 就是要抓取目标是 10.10.100.101 这台服务器上的监控数据&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;prometheus&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">static_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;localhost:9090&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;linux&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 指定job名称&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">static_configs&lt;/span>: &lt;span style="color:#75715e">#设定静态配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;10.10.100.101:9100&amp;#34;&lt;/span>] &lt;span style="color:#75715e"># 指定node_exporter所安装设备的ip:port&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">instance&lt;/span>: &lt;span style="color:#ae81ff">lchTest&lt;/span> &lt;span style="color:#75715e">#给该target一个label来分类，常用于在查询语句中的筛选条件&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>访问 Prometheus Web，在 Status-&amp;gt;Targets 页面下，我们可以看到我们配置的两个 Target，它们的 State 为 UP&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189541-1dfdddd7-ee74-4f32-8df6-8821cf415a14.jpeg" alt="">&lt;/p>
&lt;h1 id="prometheus-的基本使用方式">Prometheus 的基本使用方式&lt;/h1>
&lt;p>Prometheus 运行后默认会监听在 9090 端口，可以通过访问 9090 端口来打开 Prometheus 的 web 界面&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189523-861a164c-3f79-42af-bd88-44c4baf2e349.jpeg" alt="">&lt;/p>
&lt;p>Prometheus 本身也是自带 exporter 的,我们通过请求 http://ip:9090/metrics 可以查看从 exporter 中能具体抓到哪些 metrics。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189563-4125f137-160f-48dd-b4f6-dfd6af94aed0.jpeg" alt="">&lt;/p>
&lt;p>这里以 Prometheus 本身数据为例，简单演示下在 Web 中查询指定表达式及图形化显示查询结果。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/usvgfl/1616041189526-ee545ef0-965e-499c-b80f-b6cdaf05c974.jpeg" alt="">&lt;/p></description></item><item><title>Docs: Alerting(告警)</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Alerting%E5%91%8A%E8%AD%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Alerting%E5%91%8A%E8%AD%A6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/alerting/latest/overview/">官方文档,告警-告警概述&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://prometheus.io/docs/alerting/latest/clients/">官方文档,告警-客户端&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/prometheus/alertmanager/blob/main/api/v2/openapi.yaml">OpenAPI&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Prometheus 本身不提告警的通知的功能！告警能力在 Prometheus 的架构中被划分成两个独立的部分。如下所示，通过在 Prometheus 中定义 AlertRule（告警规则），Prometheus 会周期性的对告警规则进行 &lt;strong>Evaluate(评估)&lt;/strong>，如果满足告警触发条件就会向 Alertmanager 发送告警信息。&lt;/p>
&lt;p>&lt;strong>Evaluate(评估)&lt;/strong> 就是指，Prometheus Server 会定期执行规则配置文件中的 PromQL，获得结果并与阈值进行匹配，当超过设置的阈值时，会产生告警。这个过程，就称为 **Evaluate(评估)。**在代码中，通过 Eval() 方法来评估规则。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sw6o6t/1616069590594-41190e69-d023-4ef4-87ad-fdc1a7cf8b6f.png" alt="">&lt;/p>
&lt;p>Alertmanager 处理客户端应用程序(如 Prometheus Server)发送的警报。它负责对它们进行重复数据删除，分组和路由，以及正确的接收器集成，例如 email，PagerDuty 或 OpsGenie。它还负责警报的静音和抑制。&lt;/p>
&lt;p>即：Prometheus Server 只负责根据 PromQL 语句定义的规则产生告警并发送给 Alertmanager(告警管理器)。&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>Alertmanager 是一个单独的程序，需要独立安装使用&lt;/li>
&lt;li>Alertmanager 既可以描述为一类具有处理告警功能的应用程序。也可以描述为一个 Prometheus 官方推出的名为 Alertmanager 的程序。以后的描述一般都不加区分&lt;/li>
&lt;/ul>
&lt;h2 id="关联-alertmanager-与-prometheus">关联 Alertmanager 与 Prometheus&lt;/h2>
&lt;p>由于 Alertmanager 与 Prometheus 是两个程序。所以需要修改 Prometheus Server 的配置文件，以便让自己产生的告警可以发送到正确地方，配置效果如下（Prometheus 推出的 Alertmanager 默认监听在 9093 端口上）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">alerting&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">alertmanagers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">static_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;localhost:9093&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>告警规则的配置，由于 Prometheus Server 自己产生告警，所以还需要在配置文件中指定具体根据哪个《告警规则的配置文件》来生成告警&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">rule_files&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">/etc/prometheus/rules.yml&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下文会介绍配置文件的详细用法&lt;/p>
&lt;h3 id="prometheus-推出的-alertmanager-程序简介">Prometheus 推出的 Alertmanager 程序简介&lt;/h3>
&lt;blockquote>
&lt;p>详见：&lt;a href="https://www.yuque.com/go/doc/33146169">Alertmanager 介绍&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>Prometheus 推出的 Alertmanager 作为一个独立的组件，可以实现告警管理功能，负责接收并处理来自 Prometheus Server(也可以是其它的客户端程序)的告警信息。Alertmanager 可以对这些告警信息进行进一步的处理，比如当接收到大量重复告警时能够消除重复的告警信息，同时对告警信息进行分组并且路由到正确的通知方，Alertmanager 内置了对邮件，Slack 等多种通知方式的支持。同时 AlertManager 还提供了静默和告警抑制机制来对告警通知行为进行优化。&lt;/p>
&lt;h2 id="查看告警的状态">查看告警的状态&lt;/h2>
&lt;p>在 prometheus server 的 web 页面中的 &lt;code>Alerts&lt;/code> 标签查看到所有其所配置和产生的告警信息，效果如图：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sw6o6t/1616069590604-e9eaacdf-e275-4662-b8f1-8d1739a63fc4.jpeg" alt="">&lt;/p>
&lt;p>其中每行都是一条告警规则，绿色表示没有达到设定的阈值，不会产生告警；红色的表示达到设定的阈值并已经持续了一段时间，所以产生了告警，并推送给 alermanager。在绿条或者红条中间的位置是“路径&amp;gt;组名”这里表示其下的所有告警都是这个组里的。点开一个告警，就能看到其中的配置，包括告警规则的名称、告警触发条件、等待时长等等信息&lt;/p>
&lt;h2 id="告警发送过程">告警发送过程&lt;/h2>
&lt;p>在 State 中，有两种状态，一个是 PENDING，一个是 FIRING。当告警刚刚出发时，处于 PENDING 状态，此时告警并不会推送到 Alertmanager，当该状态无法恢复且持续配置中定义一段时间后，则变为 FIRING，并向 Alertmanager 推送告警。&lt;/p>
&lt;p>当一个告警解决后，会具有一个隐藏的 Pending 状态，持续 15 分钟，在这 15 分钟之内，依然会重复发送告警，只不过发送的每个告警的结束时间，都是同一个，就是解决告警的时间。这个 15 分钟是不可变的，在代码 github.com/prometheus/prometheus/rules/alerting.go 这个里，有一个常量 &lt;code>resolvedRetention&lt;/code> 就是用来判断何时删除一个未激活告警的条件之一。&lt;/p>
&lt;h1 id="prometheus-告警规则配置">Prometheus 告警规则配置&lt;/h1>
&lt;blockquote>
&lt;p>详见：&lt;a href="https://www.yuque.com/go/doc/33147385">Prometheus Alerting Rules 配置详解&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h1 id="告警数据结构">告警数据结构&lt;/h1>
&lt;p>&lt;strong>免责声明：Prometheus 会自动负责发送由其配置的&lt;/strong>&lt;a href="https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/">警报规则&lt;/a>&lt;strong>生成的&lt;/strong>&lt;a href="https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/">警报&lt;/a>&lt;strong>。强烈建议在 Prometheus 中根据时间序列数据配置警报规则，而不是实现直接客户端。&lt;/strong>
&lt;strong>也就是说，不要自己写一个程序，频繁对 Prometheus 发起 PromQL 查询请求，来生成告警。&lt;/strong>&lt;/p>
&lt;p>Alertmanager 现阶段有两个 API，v1 和 v2，这两个 API 都是用来监听发送到自身的告警。&lt;/p>
&lt;p>Prometheus 产生告警后，会通过 POST 请求将下列 JSON 格式内容向 Alertamanger 推送告警：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>[
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;labels&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;alertname&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;lt;Prometheus Server 的规则配置文件中的 .groups.rules.alert 字段的值&amp;gt;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;&amp;lt;LabelName&amp;gt;&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;lt;LabelValue&amp;gt;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;annotations&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;&amp;lt;LabelName&amp;gt;&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;lt;LabelValue&amp;gt;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;startsAt&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;lt;RFC3339&amp;gt;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;endsAt&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;lt;RFC3339&amp;gt;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;generatorURL&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;lt;GeneratorURL&amp;gt;&amp;#34;&lt;/span> &lt;span style="color:#75715e">// 生成告警的 URL。就是可以向 Prometheus API 发送的包含 PromQL 的完整 URL
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>推送路径根据 Prometheus Server 配置文件中 &lt;code>alerting.alertmanagers.api_version&lt;/code> 和 &lt;code>alerting.alertmanagers.path_prefix&lt;/code> 这两个字段决定。&lt;/p>
&lt;p>默认推送路径为 /api/v2/alerts。如果 api_version 为 v2，path_prefix 值为 /test，最终的路径就是 /test/api/v2/alerts&lt;/p>
&lt;h2 id="labels-与-annotations-字段">labels 与 annotations 字段&lt;/h2>
&lt;p>&lt;strong>labels(标签)&lt;/strong> 是告警的唯一标识符。具有相同标签的告警，则称为重复数据，重复数据只会保留最新的一个。
&lt;strong>annotations(注释)&lt;/strong> 顾名思义，就是用来注释一个告警&lt;/p>
&lt;p>labels 包含如下内容：&lt;/p>
&lt;ul>
&lt;li>alertname 字段
&lt;ul>
&lt;li>该字段的的值就是 Prometheus Server 的 Rules 配置文件中的 .groups.rules.alert 字段的值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>告警规则配置文件中定义的标签&lt;/li>
&lt;li>产生告警的时间序列所具有的标签&lt;/li>
&lt;/ul>
&lt;h2 id="startsat-与-endsat-字段">startsAt 与 endsAt 字段&lt;/h2>
&lt;p>&lt;strong>startsAt&lt;/strong> # 告警的开始时间
&lt;strong>endsAt&lt;/strong> # 告警的结束时间&lt;/p>
&lt;ul>
&lt;li>结束时间可以这么理解：从开始时间到结束时间，如果 Alertmanager 没有再收到相同的告警，则认为告警已经处理&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>注意：对于 Prometheus 官方的 Alertmanager 来说，startsAt 和 endsAt 时间戳都是可选的。如果省略了 startAt，则由 Alertmanager 分配当前时间。 endsAt 只有在已知警报的结束时间时才会设置。否则，它将被设置为从最后一次收到警报的时间开始的一个可配置的超时时间段。&lt;/p>
&lt;/blockquote>
&lt;h2 id="示例">示例&lt;/h2>
&lt;h3 id="配置文件">配置文件&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">groups&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">rules&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">alert&lt;/span>: &lt;span style="color:#ae81ff">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">expr&lt;/span>: &lt;span style="color:#ae81ff">vector(1)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">level&lt;/span>: &lt;span style="color:#ae81ff">warning&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">annotations&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">additionalExample&lt;/span>: &lt;span style="color:#ae81ff">test&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="生成的告警数据">生成的告警数据&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>[
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;labels&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;alertname&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;test&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;level&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;warning&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;annotations&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;additionalExample&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;test&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;startsAt&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2021-02-23T03:56:42.944457098Z&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;endsAt&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2021-02-23T04:04:27.944457098Z&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;generatorURL&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;http://cs-cs-prometheus.desistdaydream.ltd/graph?g0.expr=vector%281%29\u0026g0.tab=1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>抓包内容如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/sw6o6t/1621754366379-909c188e-f854-4c8e-8a9d-e75b6e671d2c.png" alt="image.png">&lt;/p></description></item><item><title>Docs: Federate(集群联邦)</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Federate%E9%9B%86%E7%BE%A4%E8%81%94%E9%82%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Federate%E9%9B%86%E7%BE%A4%E8%81%94%E9%82%A6/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/prometheus/latest/federation/">官方文档，Prometheus-联邦&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>通过 Remote Storage 可以分离监控样本采集和数据存储，解决 Prometheus 的持久化问题。这一部分会重点讨论如何利用联邦集群特性对 Promthues 进行扩展，以适应不同监控规模的变化。&lt;/p>
&lt;p>Prometheus Federate 还可以充当代理功能，让 Prometheus Server 获取无法直接访问网段的 Metrics&lt;/p>
&lt;h1 id="使用联邦集群">使用联邦集群&lt;/h1>
&lt;p>对于大部分监控规模而言，我们只需要在每一个数据中心(例如：EC2 可用区，Kubernetes 集群)安装一个 Prometheus Server 实例，就可以在各个数据中心处理上千规模的集群。同时将 Prometheus Server 部署到不同的数据中心可以避免网络配置的复杂性。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gx0oz1/1616069518476-78bbd4f5-fc64-4a96-bde6-2309bd716812.jpeg" alt="">
如上图所示，在每个数据中心部署单独的 Prometheus Server，用于采集当前数据中心监控数据。并由一个中心的 Prometheus Server 负责聚合多个数据中心的监控数据。这一特性在 Promthues 中称为联邦集群。&lt;/p>
&lt;p>联邦集群的核心在于每一个 Prometheus Server 都包含额一个用于获取当前实例中监控样本的接口/federate(用于 web 打开 localhost:9090/federate 即可，初始是空白的，需要详细指明要匹配的内容，才可以获取 metrics)。对于中心 Prometheus Server 而言，无论是从其他的 Prometheus 实例还是 Exporter 实例中获取数据实际上并没有任何差异。其实其他的 promeheus 就相当于中心 prometheus 的一个 exporter&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;federate&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scrape_interval&lt;/span>: &lt;span style="color:#ae81ff">15s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">honor_labels&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">metrics_path&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/federate&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">params&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;match[]&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;up{job=~&amp;#34;external.*&amp;#34;}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">static_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;192.168.77.11:9090&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;192.168.77.12:9090&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置说明：&lt;/p>
&lt;ol>
&lt;li>通过 URL 中的 match[]参数指定我们可以指定需要获取的时间序列。match[]参数必须是一个瞬时向量选择器，例如 up 或者{job=&amp;ldquo;api-server&amp;rdquo;}。配置多个 match[]参数，用于获取多组时间序列的监控数据。该例中表示 job 名字开头是 external 的 metric 都抓取
&lt;ol>
&lt;li>如果只指定指标名，则获取当前 prom 中该指标名的所有样本；如果只指定标签，则获取所有符合该标签的样本。&lt;/li>
&lt;li>事例中 up{job=~&amp;ldquo;external.&lt;em>&amp;rdquo;} 表示获取 up 指标中，标签符合正则 external.&lt;/em> 的所有样本&lt;/li>
&lt;li>注意，可以使用 &amp;lsquo;{job=~&amp;quot;..*&amp;quot;}&amp;rsquo; 来匹配所有 job 的 metric，但是官方不建议这么用，防止意外情况发生&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>horbor_labels 配置 true 可以确保当采集到的监控指标冲突时，能够自动忽略冲突的监控数据。如果为 false 时，prometheus 会自动将冲突的标签替换为”exported_“的形式。&lt;/li>
&lt;li>targets 的目标选择要抓取的另一个 prometheus 运行时所监听的 IP:PORT&lt;/li>
&lt;/ol>
&lt;p>可以在 web 上进行 match 语句的测试，例如下面，如果获取到的数据和自己预期的一样，那么该配置就没问题&lt;/p>
&lt;ol>
&lt;li>&lt;a href="http://172.38.40.214:30001/federate?match%5B%5D=up%7Bjob%253D~%22external.*%22%7D">http://172.38.40.214:30001/federate?match[]=up{job%3D~&amp;ldquo;external.*&amp;rdquo;}&lt;/a>
&lt;ol>
&lt;li>使用 curl 命令：
&lt;ol>
&lt;li>curl &amp;lsquo;http://172.38.40.214:30001/federate?match[]=up{job%3D~&amp;ldquo;external.*&amp;rdquo;}&amp;rsquo;&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>url 中的规则为
&lt;ol>
&lt;li>{job=~&amp;ldquo;prometheus&amp;rdquo;}&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>功能分区
联邦集群的特性可以帮助用户根据不同的监控规模对 Promthues 部署架构进行调整。例如如下所示，可以在各个数据中心中部署多个 Prometheus Server 实例。每一个 Prometheus Server 实例只负责采集当前数据中心中的一部分任务(Job)，例如可以将不同的监控任务分离到不同的 Prometheus 实例当中，再有中心 Prometheus 实例进行聚合。&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gx0oz1/1616069518457-5ea7fc2c-1edc-4ce8-acc4-b5bd7534e556.jpeg" alt="">
功能分区，即通过联邦集群的特性在任务级别对 Prometheus 采集任务进行划分，以支持规模的扩展。&lt;/p></description></item><item><title>Docs: HTTPS 和 Authentication(认证)</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/HTTPS-%E5%92%8C-Authentication%E8%AE%A4%E8%AF%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/HTTPS-%E5%92%8C-Authentication%E8%AE%A4%E8%AF%81/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/prometheus/latest/configuration/https/">官方文档,Prometheus-配置-HTTPS 和 认证&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://prometheus.io/docs/guides/basic-auth/">官方文档,指南-基础认证&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.github.io/ingress-nginx/examples/auth/basic/">Ngxin Ingress Controller 官方文档,认证-基础认证&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jianshu.com/p/4d5aa1995de3">知乎&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>认证功能的发展：&lt;/p>
&lt;ul>
&lt;li>Prometheus 从 2.24 版本开始，才支持基本认证，截止 2021 年 8 月 25 日官方已经提供了实验性的 HTTPS 与 认证配置，详见&lt;a href="https://prometheus.io/docs/prometheus/latest/configuration/https/">此处&lt;/a>。&lt;/li>
&lt;li>截止 2021 年 8 月 25 日，Thanos 的 Sidecar 还不支持向 Prometheus 发起请求是携带认证信息，但已经有 &lt;a href="https://github.com/thanos-io/thanos/issues/3975">issue #3975&lt;/a> 提出来该问题，并将在未来 &lt;a href="https://github.com/thanos-io/thanos/pull/4104">PR #4104&lt;/a> 实现&lt;/li>
&lt;/ul>
&lt;p>现阶段在 Prometheus 前面添加代理(比如 Nginx)，只暴露 Nginx 端口，所有访问 Prometheus 的请求都经过代理，并在代理上添加认证，这样可以为 Prometheus 的 web 端添加一个基本的基于用户名和密码的认证。&lt;/p>
&lt;p>在 kubernetes 中，可以通过 ingress 来实现。其他环境可以直接配置 ngxin 来实现。&lt;/p>
&lt;h1 id="通过-ingress-controller-配置认证普通的-nginx-同理">通过 ingress controller 配置认证，普通的 nginx 同理&lt;/h1>
&lt;p>首先需要安装 htpasswd 二进制文件，通过 htpasswd 命令行工具生成保存用户名密码的文件，然后通过该文件创建一个 secret 对象，并在 ingress 引用该 secret 对象&lt;/p>
&lt;p>&lt;strong>通过 htpasswd 生成一个“auth”文件;用来存取我们创建的用户及加密之后的密码&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@lichenhao:~# htpasswd -c auth admin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>New password:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Re-type new password:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Adding password &lt;span style="color:#66d9ef">for&lt;/span> user admin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看这个文件，可以看到密码是加密之后的字符串&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@lichenhao:~# cat auth
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>admin:$apr1$8NSwCSR3$s5G25cvkaUDAoxEFtaGZ11
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 密码：ehl1234&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>创建 kubernetes secret 来存储 auth 文件中的用户名和密码&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">root@lichenhao:~# kubectl create -n monitoring secret generic basic-auth --from-file=auth&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">secret &amp;#34;basic-auth&amp;#34; created&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">root@lichenhao:~# kubectl get secrets -n monitoring basic-auth -oyaml | neat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">data&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">auth&lt;/span>: &lt;span style="color:#ae81ff">YWRtaW46JGFwcjEkOE5Td0NTUjMkczVHMjVjdmthVURBb3hFRnRhR1oxMQo=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Secret&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">annotations&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">meta.helm.sh/release-name&lt;/span>: &lt;span style="color:#ae81ff">monitor-bj-net&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">meta.helm.sh/release-namespace&lt;/span>: &lt;span style="color:#ae81ff">monitoring&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app.kubernetes.io/managed-by&lt;/span>: &lt;span style="color:#ae81ff">Helm&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">basic-auth&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">monitoring&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">Opaque&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>在 ingress 资源中添加注释&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">root@lichenhao:~# kubectl get ingress -n monitoring monitor-bj-net-k8s-prometheus -oyaml | neat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">extensions/v1beta1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Ingress&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">annotations&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">meta.helm.sh/release-name&lt;/span>: &lt;span style="color:#ae81ff">monitor-bj-net&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">meta.helm.sh/release-namespace&lt;/span>: &lt;span style="color:#ae81ff">monitoring&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 添加如下三行注释内容，&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 指定认证类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">nginx.ingress.kubernetes.io/auth-type&lt;/span>: &lt;span style="color:#ae81ff">basic&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 指定包含用户名与密码的 secret 资源的名称&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">nginx.ingress.kubernetes.io/auth-secret&lt;/span>: &lt;span style="color:#ae81ff">basic-auth&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 消息，显示一个适当的上下文，说明为什么需要身份验证。最后 admin 就是指明应该要使用的用户名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">nginx.ingress.kubernetes.io/auth-realm&lt;/span>: &lt;span style="color:#ae81ff">Authentication Required - admin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app&lt;/span>: &lt;span style="color:#ae81ff">k8s-prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app.kubernetes.io/managed-by&lt;/span>: &lt;span style="color:#ae81ff">Helm&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">chart&lt;/span>: &lt;span style="color:#ae81ff">kube-prometheus-stack-12.12.1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">heritage&lt;/span>: &lt;span style="color:#ae81ff">Helm&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">release&lt;/span>: &lt;span style="color:#ae81ff">monitor-bj-net&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">monitor-bj-net-k8s-prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">monitoring&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ingressClassName&lt;/span>: &lt;span style="color:#ae81ff">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">rules&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">host&lt;/span>: &lt;span style="color:#ae81ff">prometheus.desistdaydream.ltd&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">http&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">paths&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">backend&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">serviceName&lt;/span>: &lt;span style="color:#ae81ff">monitor-bj-net-k8s-prometheus&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">servicePort&lt;/span>: &lt;span style="color:#ae81ff">9090&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">path&lt;/span>: &lt;span style="color:#ae81ff">/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">pathType&lt;/span>: &lt;span style="color:#ae81ff">ImplementationSpecific&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="为-prometheus-添加基础认证">为 Prometheus 添加基础认证&lt;/h1>
&lt;p>Prometheus 通过 &lt;code>--web.config.file&lt;/code> 命令行标志来开启 &lt;strong>TLS&lt;/strong> 或者 &lt;strong>基本认证&lt;/strong> 功能。Prometheus 将会读取该标志指定的文件，通过该文件的配置来为 9090 端口添加 TLS 或者 基本认证。让人们在访问 9090 端口的 Web UI 或者使用 API 时，必须进行认证才可以操作。&lt;/p>
&lt;h2 id="web-config-文件详解">web-config 文件详解&lt;/h2>
&lt;p>该文件有 3 个主要字段&lt;/p>
&lt;ul>
&lt;li>tls_server_config&lt;/li>
&lt;li>http_server_config&lt;/li>
&lt;li>basic_auth_users&lt;/li>
&lt;/ul>
&lt;p>如果没有任何配置，则不开启任何 TLS 或 认证，只要配置了某个字段，就默认开启相关功能。&lt;/p>
&lt;h3 id="tls_server_config-object--为-prometheus-开启-tls">tls_server_config: &amp;lt;Object&amp;gt; # 为 Prometheus 开启 TLS&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>cert_file: &amp;lt;FileName&amp;gt;&lt;/strong> # TLS 所需的证书文件&lt;/li>
&lt;li>&lt;strong>key_file: &amp;lt;FileName&amp;gt;&lt;/strong> # TLS 所需的私钥文件&lt;/li>
&lt;/ul>
&lt;h1 id="client_auth_type-string--默认值noclientcert">Server policy for client authentication. Maps to ClientAuth Policies
# For more detail on clientAuth options:
# &lt;a href="https://golang.org/pkg/crypto/tls/#ClientAuthType">https://golang.org/pkg/crypto/tls/#ClientAuthType&lt;/a>
&lt;strong>client_auth_type: &amp;lt;STRING&amp;gt;&lt;/strong> # &lt;code>默认值：NoClientCert&lt;/code>&lt;/h1>
&lt;h1 id="-client_ca_file-filename-">CA certificate for client certificate authentication to the server
[ client_ca_file: &amp;lt;filename&amp;gt; ]&lt;/h1>
&lt;h1 id="-min_version-string--default--tls12-">Minimum TLS version that is acceptable
[ min_version: &amp;lt;string&amp;gt; | default = &amp;ldquo;TLS12&amp;rdquo; ]&lt;/h1>
&lt;h1 id="-max_version-string--default--tls13-">Maximum TLS version that is acceptable
[ max_version: &amp;lt;string&amp;gt; | default = &amp;ldquo;TLS13&amp;rdquo; ]&lt;/h1>
&lt;h1 id="---string--">List of supported cipher suites for TLS versions up to TLS 1.2. If empty
# Go default cipher suites are used. Available cipher suites are documented
# in the go documentation:
# &lt;a href="https://golang.org/pkg/crypto/tls/#pkg-constants">https://golang.org/pkg/crypto/tls/#pkg-constants&lt;/a>
[ cipher_suites:
[ - &amp;lt;string&amp;gt; ] ]&lt;/h1>
&lt;h1 id="-prefer_server_cipher_suites-bool--default--true-">prefer_server_cipher_suites controls whether the server selects the
# client&amp;rsquo;s most preferred ciphersuite, or the server&amp;rsquo;s most preferred
# ciphersuite. If true then the server&amp;rsquo;s preference, as expressed in
# the order of elements in cipher_suites, is used.
[ prefer_server_cipher_suites: &amp;lt;bool&amp;gt; | default = true ]&lt;/h1>
&lt;p>Elliptic curves that will be used in an ECDHE handshake, in preference
# order. Available curves are documented in the go documentation:
# &amp;lt;https://golang.org/pkg/crypto/tls/#CurveID&amp;gt;
[ curve_preferences:
[ - &amp;lt;string&amp;gt; ] ]&lt;/p>
&lt;p>==========================&lt;/p>
&lt;h3 id="http_server_config-object--为-prometheus-开启-http2注意http2-仅支持-tls">http_server_config: &amp;lt;Object&amp;gt; # 为 Prometheus 开启 HTTP/2。注意，HTTP/2 仅支持 TLS&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>http2: &amp;lt;BOOLEAN&amp;gt;&lt;/strong> # &lt;code>默认值：true&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>Usernames and hashed passwords that have full access to the web
# server via basic authentication. If empty, no basic authentication is
# required. Passwords are hashed with bcrypt.&lt;/p>
&lt;h3 id="basic_auth_users-mapstringstring--为-prometheus-server-开启基本认证">basic_auth_users: &amp;lt;map[STRING]STRING&amp;gt; # 为 Prometheus Server 开启基本认证&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>&amp;lt;KEY&amp;gt;: &amp;lt;VALUE&amp;gt;&lt;/strong> # KEY 是用户名，VALUE 是密码
&lt;ul>
&lt;li>注意：密码必须是经过 hash 的字符串，可以通过&lt;a href="https://bcrypt-generator.com/">这个网站&lt;/a>在线获取 hash 过的字符串&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="配置示例">配置示例&lt;/h2>
&lt;p>在&lt;a href="https://bcrypt-generator.com/">这里&lt;/a>生成密码的 hash 值，比如我使用 &lt;code>Prometheus@lichenhao&lt;/code> 这个密码，生成的 hash 为 &lt;code>$2a$12$twJp6N9kL5aEf08Ja8XRAOImHOjCTBQvb485Uuz7hJLEX1XT4iVDm&lt;/code>&lt;/p>
&lt;p>在 /etc/prometheus/config_out/ 目录中创建一个 web-config.yml 文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>basic_auth_users:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Prometheus: $2a$12$twJp6N9kL5aEf08Ja8XRAOImHOjCTBQvb485Uuz7hJLEX1XT4iVDm
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为 Promethues Server 添加命令行标志 &lt;code>--web.config.file=/etc/prometheus/config_out/web-config.yml&lt;/code>&lt;/p>
&lt;p>启动 Prometheus 后，将会需要认证信息，效果如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/bx144g/1628063307526-21ac3e4b-150d-4e77-9a7c-5069ad006369.png" alt="image.png">&lt;/p></description></item><item><title>Docs: Prometheus API</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Prometheus-API/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Prometheus-API/</guid><description/></item><item><title>Docs: Prometheus 管理</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Prometheus-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Prometheus-%E7%AE%A1%E7%90%86/</guid><description/></item><item><title>Docs: Prometheus 开发</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Prometheus-%E5%BC%80%E5%8F%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Prometheus-%E5%BC%80%E5%8F%91/</guid><description/></item><item><title>Docs: Prometheus 衍生品</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Prometheus-%E8%A1%8D%E7%94%9F%E5%93%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Prometheus-%E8%A1%8D%E7%94%9F%E5%93%81/</guid><description/></item><item><title>Docs: PromQL</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/PromQL/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/PromQL/</guid><description/></item><item><title>Docs: Rules 配置</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Rules-%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Rules-%E9%85%8D%E7%BD%AE/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;p>Prometheus 规则分为两种：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Recording Rule(记录规则)&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>Alerting Rule(告警规则)&lt;/strong> #
&lt;ol>
&lt;li>！！！！注意编写告警规则的逻辑，由于 Prometheus 会定期评估告警，所以会定期读取数据，尽相避免读取大范围的数据，以免造成性能问题&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>Prometheus 规则配置文件需要在 Prometheus 主配置文件中的 rule_files 配置环境中指定，让 Prometheus 加载指定的文件并读取其配置(这个过程称为评估 evaluation)。&lt;/p>
&lt;p>一个规则封装了一个向量表达式，该向量表达式在指定的时间间隔内进行评估并采取行动（目前要么记录，要么用于报警）。&lt;/p>
&lt;p>可以通过发送 SIGHUP 到 Prometheus 进程在运行时重新加载规则文件。仅当所有规则文件格式正确时，才会应用更改。&lt;/p>
&lt;h1 id="recording-rule记录规则">Recording Rule(记录规则)&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在我们使用 Prometheus 的过程中，随着时间的推移，存储在 Prometheus 中的监控指标数据越来越多，查询频率也在不断的增加，当我们用 Grafana 添加更多的 Dashboard 的时候，可能会慢慢的体验到 Grafana 已经无法按时渲染图表，并且偶尔还会出现超时的情况，特别是当我们在长时间汇总大量的指标数据的时候，Prometheus 查询超时的情况可能更多了，这时就需要一种能够类似于后排批处理的机制在后台完成这些复杂运算的计算，对于使用者而言只需要查询这些运算结果即可。&lt;/p>
&lt;p>当我们有频繁使用的复杂查询时，如果直接将语句写在 grafana 的 query 中，grafana 每次刷新都对 promethus 提交实时查询，会增加 prometheus 的性能消耗并且降低了响应速度。 这时候我们就可以用到 Recoding rules 了。&lt;/p>
&lt;p>记录规则允许我们预先计算经常使用或计算成本高的表达式，并将其结果保存为一组新的时间序列。因此，查询预先计算的结果通常比每次需要时执行原始表达式快得多。&lt;/p>
&lt;h2 id="配置示例">配置示例&lt;/h2>
&lt;p>这是一个简单的记录规则。使用一个表达式 &lt;code>sum by (job) (http_inprogress_requests)&lt;/code> 生成了一条新的名为 &lt;code>job:http_inprogress_requests:sum&lt;/code> 的时间序列&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">groups&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">example&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">rules&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">record&lt;/span>: &lt;span style="color:#ae81ff">job:http_inprogress_requests:sum&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">expr&lt;/span>: &lt;span style="color:#ae81ff">sum by (job) (http_inprogress_requests)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="alerting-rule告警规则">Alerting Rule(告警规则)&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Alerting Rules(告警规则)&lt;/strong> 可以让我们基于 PromQL 的表达式，定义告警的触发条件，当满足触发条件时，Prometheus Server 会将触发的告警通知发送到指定的服务。这个服务默认是 Prometheus 官方提供的 Alertmanager。详见 Prometheus Alerting 介绍章节&lt;/p>
&lt;p>在 Prometheus 中一条告警规则主要由以下几部分组成：&lt;/p>
&lt;ul>
&lt;li>告警名称：用户需要为告警规则命名，当然对于命名而言，需要能够直接表达出该告警的主要内容&lt;/li>
&lt;li>告警规则：告警规则实际上主要由 PromQL 进行定义，其实际意义是当表达式（PromQL）查询结果持续多长时间（During）后出发告警&lt;/li>
&lt;/ul>
&lt;p>在 Prometheus 中，还可以通过 Group(告警组) 对一组相关的告警进行统一定义。当然，这些定义都是通过 YAML 文件来统一管理的。&lt;/p>
&lt;h2 id="配置示例-1">配置示例&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">groups&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">rules&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">alert&lt;/span>: &lt;span style="color:#ae81ff">TestAlert&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">expr&lt;/span>: &lt;span style="color:#ae81ff">prometheus_http_requests_total &amp;gt; 20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">for&lt;/span>: &lt;span style="color:#ae81ff">1m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">alert_test&lt;/span>: &lt;span style="color:#ae81ff">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">annotations&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">message&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;{{$labels.instance}}: 测试告警(current value is: {{ $value }}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在告警规则文件中，我们可以将一组相关的规则设置定义在一个 group 下。在每一个 group 中我们可以定义多个告警规则。一条告警规则主要由以下几部分组成：&lt;/p>
&lt;ul>
&lt;li>alert # 告警规则的名称。&lt;/li>
&lt;li>expr # 基于 PromQL 表达式告警触发条件，用于计算是否有时间序列满足该条件。
&lt;ul>
&lt;li>该样例的意思是某个值减去某几个值的和再除以某个值如果大于 20 就产生告警&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>for # evaluation(评估) 等待时间，可选参数。用于表示只有当触发条件持续一段时间后才发送告警。在等待期间新产生告警的状态为 pending。&lt;/li>
&lt;li>labels # 自定义标签，允许用户指定要附加到告警信息上的一组附加标签。&lt;/li>
&lt;li>annotations # 用于指定一组注释，用于描述告警的详细信息，annotations 的内容在告警产生时会一同作为参数发送到 Alertmanager。这里面的 key 与 value 都可以自己定义。这一部分的内容是在讲告警发到接收者的时候，接收者能看到的信息。常用语描述告警信息以便管理员定位问题&lt;/li>
&lt;/ul>
&lt;h2 id="告警规则配置进阶">告警规则配置进阶&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/am4r43/1616069617782-d847748c-9878-4e48-abbb-413799232424.jpeg" alt="">
如图所示，在一个告警产生时，会有其自身的 Labels，这些 Labels 信息可以填写进告警规则配置文件中，引用这些 Labels，就相当于把这些 Labels 中的值当做文件内容进行输出。(类似于引用变量)
引用语法：&lt;/p>
&lt;ol>
&lt;li>{{ $labels.LabelName }} # 这就是引用该 label 的值，其中 LabelName 就是上图红框中 Labels 的键&lt;/li>
&lt;li>{{ $value }} # 引用 expr 中 PromQL 表达式中获取到的值&lt;/li>
&lt;/ol>
&lt;h1 id="配置文件详解">配置文件详解&lt;/h1>
&lt;h2 id="groups-字段">groups 字段&lt;/h2>
&lt;p>Recording Rule 与 Alerting Rule 存在于规则组中。组中的规则以规定的时间间隔顺序运行，并具有相同的规则评估时间。Recording Rule 的名称必须是有效的 Metrics 名称。Alerting Rule 名称则比较宽泛，可以随意定义，一般来说，满足有效的标签值即可。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>注意：&lt;/strong>
groups 在 recording rule 中并没有实际意义，只是与 alerting rule 同在一个配置文件中，所以两种规则格式要相同罢了，不管在哪个组下定义的记录规则，都可以在任何地方直接使用。
生成新的时间序列后，Prometheus 会以新的时间序列名称保存数据，该数据与原始 expr 中的表达式所得出的值虽然一样，但是存储的指标是不一样的。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">groups&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">&amp;lt;string&amp;gt; &lt;/span> &lt;span style="color:#75715e"># group 的名称，在一个文件中必须是唯一的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 对这个组中的规则进行 evaluated(评估) 的频率。默认是 PrometheusServer 配置文件中的 global.evaluation_interval 的值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">[ interval&lt;/span>: &lt;span style="color:#ae81ff">&amp;lt;duration&amp;gt; | default = global.evaluation_interval ]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 该组规则的具体内容&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">rules&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [- &lt;span style="color:#ae81ff">&amp;lt;rule&amp;gt; ...]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所谓 Evaluated(评估)规则，就是指 PrometheusServer 会检查规则的状态，如果告警规则的状态是 FIRING，则发送告警。&lt;/p>
&lt;p>interval 字段的值 加上 PrometheusServer 的命令行标志 &amp;ndash;rules.alert.resend-delay 的值(默认 1m)，才是真实的评估周期。这个说明在官方文档中没有，请参考&lt;a href="https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Prometheus%20%E5%BC%80%E5%8F%91/Prometheus%20%E8%A7%84%E5%88%99%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91.md">源码解析&lt;/a>&lt;/p>
&lt;h2 id="rules-字段">rules 字段&lt;/h2>
&lt;blockquote>
&lt;p>注意缩进，该环境属于 rule 配置环境的 rules 字段的子字段，是一个数组。&lt;/p>
&lt;/blockquote>
&lt;p>这个配置环境中，不同的字段对应不同的规则。&lt;/p>
&lt;h3 id="适用于-recording-rule-的字段">适用于 Recording Rule 的字段&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">rules&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 新的时间序列的名字。必须是一个有效的时间序列的名字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">record&lt;/span>: &lt;span style="color:#ae81ff">&amp;lt;string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 用于生成新时间序列的 PromQL 表达式。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 每个评估周期都会在当前时间进行评估，并将结果记录为一组新的时间序列，其度量标准名称由 record 字段给出。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">expr&lt;/span>: &lt;span style="color:#ae81ff">&amp;lt;string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 为新的时间序列添加标签集&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels: [&amp;lt;labelname&amp;gt;&lt;/span>: &lt;span style="color:#ae81ff">&amp;lt;labelvalue&amp;gt;]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="适用于-alerting-rule-的字段">适用于 Alerting Rule 的字段&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">rules&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 告警的名字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">alert&lt;/span>: &lt;span style="color:#ae81ff">&amp;lt;string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 用于产生告警的 PromQL 表达式。 每个评估周期都会在当前时间进行评估，所有结果时间序列都会变为待处理/触发警报。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">expr&lt;/span>: &lt;span style="color:#ae81ff">&amp;lt;string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 发送告警的等待时间。默认0s，即没有等待期。告警产生后，默认是立刻发送的。配置该字段，可以指定在产生告警后的多长时间再发送告警。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 在等待期的告警状态为 Pending，超过等待期后，变为 Firing。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">for&lt;/span>: &lt;span style="color:#ae81ff">&amp;lt;duration&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 为该告警添加或覆盖标签&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;LabelName&amp;gt;&lt;/span>: &lt;span style="color:#ae81ff">&amp;lt;tmpl_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 为该告警添加注释。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">annotations&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;LabelName&amp;gt;&lt;/span>: &lt;span style="color:#ae81ff">&amp;lt;tmpl_string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="配置文件示例">配置文件示例&lt;/h1>
&lt;h2 id="高级记录规则配置">高级记录规则配置&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">groups&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">node-exporter.rules&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">rules&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">record&lt;/span>: &lt;span style="color:#ae81ff">instance:node_num_cpu:sum&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">expr&lt;/span>: |&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> count without (cpu) (
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> count without (mode) (
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> node_cpu_seconds_total{job=&amp;#34;node-exporter&amp;#34;}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> )&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如图所示 expr 字段写的表达式与 record 指定的表达式查询结果相同
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/am4r43/1616069617793-9bf3f46e-a10f-4b18-9555-369ba0d8d17f.jpeg" alt="">
等同于
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/am4r43/1616069617804-82e7c2f5-8bd7-4932-a5aa-9b702e780e59.jpeg" alt="">&lt;/p></description></item><item><title>Docs: Server 配置</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Server-%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Server-%E9%85%8D%E7%BD%AE/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/">官方文档,配置-配置&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Prometheus Server 可通过两种方式来改变运行时行为&lt;/p>
&lt;ul>
&lt;li>命令行标志&lt;/li>
&lt;li>配置文件&lt;/li>
&lt;/ul>
&lt;h2 id="配置文件热更新">配置文件热更新&lt;/h2>
&lt;p>Prometheus Server 可以在运行时重新加载其配置文件(也就俗称的热更新)。如果是新的配置不正确，则 Prometheus Server 则不会应用新的配置，并在日志中显示错误点。&lt;/p>
&lt;p>有两种方式可以实现 Prometheus Server 的热更新功能&lt;/p>
&lt;ul>
&lt;li>向 Prometheus Server 进程发送 &lt;code>SIGHUP&lt;/code> 信号。&lt;/li>
&lt;li>向 Prometheus Server 暴露的 &lt;code>/-/reload&lt;/code> 端点发送 &lt;code>HTTP 的 POST&lt;/code> 请求&lt;/li>
&lt;/ul>
&lt;p>注意：想要实现热更新功能，需要在 Prometheus Server 中指定 &lt;code>--web.enable-lifecycle&lt;/code> 标志，这也将重新加载所有的 Rules 配置文件。&lt;/p>
&lt;h1 id="prometheus-server-命令行标志详解">Prometheus Server 命令行标志详解&lt;/h1>
&lt;p>可以通过 prometheus -h 命令查看所有的可以用标志&lt;/p>
&lt;p>prometheus 程序在启动时，可以使用一些标志来对程序进行一些基本设定，比如数据存储路径、存储时间等等&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ndash;config.file=/PATH/TO/FILE&lt;/strong> # prometheus 主配置文件，默认为当前路径的 prometheus.yml&lt;/li>
&lt;li>&lt;strong>&amp;ndash;enable-feature=&amp;hellip;&lt;/strong> # 启动指定的功能特性，多个功能以逗号分割。可以开启的功能详见：&lt;a href="https://prometheus.io/docs/prometheus/latest/disabled_features/">官方文档,已关闭的功能&lt;/a>&lt;/li>
&lt;li>&lt;strong>&amp;ndash;web.listen-address=&amp;ldquo;0.0.0.0:9090&amp;rdquo;&lt;/strong> # Prometheus 监听地址。&lt;code>默认值：0.0.0.0:9090&lt;/code>。该端口用于 Web UI、API 和 Telemetry(遥测)&lt;/li>
&lt;li>&lt;strong>&amp;ndash;web.config.file=/PATH/TO/FILE&lt;/strong> # [实验标志]用于开启 TLS 或 身份验证 配置文件路径。&lt;/li>
&lt;li>&amp;ndash;web.read-timeout=5m** **# Maximum duration before timing out read of the request, and closing idle connections.&lt;/li>
&lt;li>&lt;strong>&amp;ndash;web.max-connections=INT&lt;/strong> # 可以同时连接到 Prometheus Server 的最大数量。&lt;code>默认值:512&lt;/code>&lt;/li>
&lt;li>&lt;strong>&amp;ndash;web.external-url=URL&lt;/strong># 可以从外部访问 Prometheus 的 URL。
&lt;ul>
&lt;li>例如，如果 Prometheus 是通过反向代理提供的，用于生成返回 Prometheus 本身的相对和绝对链接。如果 URL 具有路径部分，它将被用作所有 HTTP 的前缀 Prometheus 服务的端点。 如果省略，则会自动派生相关的 URL 组件。
&lt;ul>
&lt;li>注意：该标志在反向代理时似乎问题，详见：&lt;a href="https://github.com/prometheus/prometheus/issues/1583">https://github.com/prometheus/prometheus/issues/1583&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>例如，Prometheus 产生的的告警，推送到 AlertManager 时，会有一个 &lt;code>generatorURL&lt;/code> 字段，该字段中所使用的 URL 中的 Endpoint，就是 web.external-url，这个 URL 可以让获取该告警的人，点击 URL 即可跳转到 Prometheus 的 Web 页面并使用对应的 PromQL 查询。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>&amp;ndash;web.route-prefix=PATH&lt;/strong> # Web 端内部路由的前缀。 默认为 &amp;ndash;web.external-url 标志指定的路径。i.e.后端代码的路由入口路径。一般默认为 / 。&lt;/li>
&lt;li>&amp;ndash;web.user-assets= # Path to stat storage.tsdb.max-block-durationic asset directory, available at /user.&lt;/li>
&lt;li>&lt;strong>&amp;ndash;web.enable-lifecycle&lt;/strong> # 开启配置热更新，开启后，可使用 curl -X POST &lt;a href="http://PrometheusServerIP:9090/-/reload">http://PrometheusServerIP:9090/-/reload&lt;/a> 命令来重载配置以便让更改后的配置生效，而不用重启 prometheus 进程&lt;/li>
&lt;li>&lt;strong>&amp;ndash;web.enable-admin-api&lt;/strong> # 开启管理操作 API 端点。通过 admin API，可以删除时序数据。&lt;/li>
&lt;li>&amp;ndash;web.console.templates=&amp;ldquo;consoles&amp;rdquo; # Path to the console template directory, available at /consoles.&lt;/li>
&lt;li>&amp;ndash;web.console.libraries=&amp;ldquo;console_libraries&amp;rdquo; # Path to the console library directory.&lt;/li>
&lt;li>&amp;ndash;web.page-title=&amp;ldquo;Prometheus Time Series Collection and Processing Server&amp;rdquo; # Document title of Prometheus instance.&lt;/li>
&lt;li>&amp;ndash;web.cors.origin=&amp;quot;.*&amp;quot; # Regex for CORS origin. It is fully anchored. Example: &amp;lsquo;https?://(domain1|domain2).com&amp;rsquo;&lt;/li>
&lt;li>&lt;strong>&amp;ndash;storage.tsdb.path=&amp;quot;/PATH/DIR&amp;quot;&lt;/strong># prometheus 存储 metircs 数据的目录(使用绝对路径)&lt;/li>
&lt;li>&lt;strong>&amp;ndash;storage.tsdb.retention.time=TIME&lt;/strong> # 数据的存储时间，如果既未设置此标志也未设置 storage.tsdb.retention.size 标志，&lt;code>默认值：15d&lt;/code>。支持的单位：y，w，d，h，m，s，ms。&lt;/li>
&lt;li>&amp;ndash;storage.tsdb.retention.size=STORAGE.TSDB.RETENTION.SIZE # [EXPERIMENTAL] Maximum number of bytes that can be stored for blocks. Units supported: KB, MB, GB, TB, PB. This flag is experimental and can be changed in future releases.&lt;/li>
&lt;li>&amp;ndash;storage.tsdb.no-lockfile # 不在数据目录创建锁文件。暂时不理解什么意思，待研究&lt;/li>
&lt;li>&amp;ndash;storage.tsdb.allow-overlapping-blocks # [EXPERIMENTAL] Allow overlapping blocks, which in turn enables vertical compaction and vertical query merge.&lt;/li>
&lt;li>&amp;ndash;storage.tsdb.wal-compression # Compress the tsdb WAL.&lt;/li>
&lt;li>&amp;ndash;storage.remote.flush-deadline= # How long to wait flushing sample on shutdown or config reload.&lt;/li>
&lt;li>&amp;ndash;storage.remote.read-sample-limit=5e7 # Maximum overall number of samples to return via the remote read interface, in a single query. 0 means no limit. This limit is ignored for streamed response types.&lt;/li>
&lt;li>&amp;ndash;storage.remote.read-concurrent-limit=10 # Maximum number of concurrent remote read calls. 0 means no limit.&lt;/li>
&lt;li>&amp;ndash;storage.remote.read-max-bytes-in-frame=1048576 # Maximum number of bytes in a single frame for streaming remote read response types before marshalling. Note that client might have limit on frame size as well. 1MB as recommended by protobuf&lt;/li>
&lt;li>by default.&lt;/li>
&lt;li>&amp;ndash;rules.alert.for-outage-tolerance=1h # Max time to tolerate prometheus outage for restoring &amp;ldquo;for&amp;rdquo; state of alert.&lt;/li>
&lt;li>&amp;ndash;rules.alert.for-grace-period=10m # Minimum duration between alert and restored &amp;ldquo;for&amp;rdquo; state. This is maintained only for alerts with configured &amp;ldquo;for&amp;rdquo; time greater than grace period.&lt;/li>
&lt;li>&lt;strong>&amp;ndash;rules.alert.resend-delay=DURATION&lt;/strong># 向 Alertmanager 重新发送警报前的最少等待时间。&lt;code>默认值：1m&lt;/code>。
&lt;ul>
&lt;li>当告警处于 FIRING 状态时，每间隔 1m，就会再次发送一次。注意：重发送之前，还需要一个评估规则的等待期，评估完成后，再等待该值的时间，才会重新发送告警。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&amp;ndash;alertmanager.notification-queue-capacity=10000 # The capacity of the queue for pending Alertmanager notifications.&lt;/li>
&lt;li>&amp;ndash;alertmanager.timeout=10s # Timeout for sending alerts to Alertmanager.&lt;/li>
&lt;li>&lt;strong>&amp;ndash;query.lookback-delta=DURATION&lt;/strong> # 评估 PromQL 表达式时最大的回溯时间。&lt;code>默认值：5m&lt;/code>
&lt;ul>
&lt;li>比如，当采集目标的间隔时间为 10m 时，由于该设置，最大只能查询当前时间的前 5m 的数据，这是，即时向量表达式返回的结果将会为空。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>&amp;ndash;query.timeout=DURATION&lt;/strong> # 一次查询的超时时间。&lt;code>默认值：2m&lt;/code>&lt;/li>
&lt;li>&amp;ndash;query.max-concurrency=20 # Maximum number of queries executed concurrently.&lt;/li>
&lt;li>&amp;ndash;query.max-samples=50000000 # Maximum number of samples a single query can load into memory. Note that queries will fail if they try to load more samples than this into memory, so this also limits the number of samples a query can return.&lt;/li>
&lt;li>&lt;strong>&amp;ndash;log.level=STRING&lt;/strong> # 设定 Prometheus Server 运行时输出的日志的级别。&lt;code>默认值：info&lt;/code>。 可用的值有：debug, info, warn, error&lt;/li>
&lt;li>&lt;strong>&amp;ndash;log.format=logfmt&lt;/strong> # 设定 Prometheus Server 运行时输出的日志的格式。&lt;code>默认值：logfmt&lt;/code>。可用的值有：logfmt, json&lt;/li>
&lt;/ul>
&lt;h1 id="prometheusyaml-配置文件详解">prometheus.yaml 配置文件详解&lt;/h1>
&lt;p>下文用到的字段值的占位符说明&lt;/p>
&lt;ul>
&lt;li>&amp;lt;BOOLEAN&amp;gt; # 可以采用 true 或 false 值的布尔值&lt;/li>
&lt;li>&amp;lt;DURATION&amp;gt; # 持续时间。可以使用正则表达式
&lt;ul>
&lt;li>((([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?((([0-9]+)m)?((([0-9]+)s)?((([0-9]+)ms)?|0)，例如：1d、1h30m、5m、10s。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&amp;lt;FILENAME&amp;gt; # 当前工作目录中的有效路径&lt;/li>
&lt;li>&amp;lt;HOST&amp;gt; # 由主机名或 IP 后跟可选端口号组成的有效字符串。&lt;/li>
&lt;li>&amp;lt;INT&amp;gt; # 一个整数值&lt;/li>
&lt;li>&amp;lt;LABELNAME&amp;gt; # 与正则表达式[a-zA-Z _] [a-zA-Z0-9 _] *匹配的字符串&lt;/li>
&lt;li>&amp;lt;LABELVALUE&amp;gt; # 一串 unicode 字符&lt;/li>
&lt;li>&amp;lt;PATH&amp;gt; # 有效的 URL 路径&lt;/li>
&lt;li>&amp;lt;SCHEME&amp;gt; # 一个字符串，可以使用值 http 或 https&lt;/li>
&lt;li>&amp;lt;SECRET&amp;gt; # 作为机密的常规字符串，例如密码&lt;/li>
&lt;li>&amp;lt;STRING&amp;gt; # 常规字符串&lt;/li>
&lt;li>&amp;lt;TMPL_STRING&amp;gt; # 使用前已模板扩展的字符串&lt;/li>
&lt;/ul>
&lt;p>每个字段下&lt;/p>
&lt;h2 id="顶层字段">顶层字段&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>global&lt;/strong>(&lt;a href="#global">global&lt;/a>) # 全局配置，所有内容作用于所有配置环境中,若其余配置环境中不再指定同样的配置，则global中的配置作为默认配置&lt;/li>
&lt;li>&lt;strong>rule_files&lt;/strong>(&lt;a href="#rule_files">rule_files&lt;/a>) #&lt;/li>
&lt;li>&lt;strong>scrape_configs&lt;/strong>([]&lt;a href="#scrape_configs(%E5%8D%A0%E6%AF%94%E6%9C%80%E5%A4%A7%E7%9A%84%E5%AD%97%E6%AE%B5)">scrape_configs&lt;/a>) # 抓取 Target 的 metrics 时的配置&lt;/li>
&lt;li>&lt;strong>alerting&lt;/strong>(&lt;a href="#alerting">alerting&lt;/a>) # 与 Alertmanager 相关的配置
&lt;ul>
&lt;li>alert_relabel_configs(&lt;a href="#relabel_configs">relabel_configs&lt;/a>)&lt;/li>
&lt;li>alertmanagers&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>remote_write&lt;/strong>([]&lt;a href="#remote_write">remote_write&lt;/a>) # 与远程写入相关功能的配置&lt;/li>
&lt;li>&lt;strong>remote_read&lt;/strong>([]&lt;a href="#remote_read">remote_read&lt;/a>) # 与远程读取相关功能的配置&lt;/li>
&lt;/ul>
&lt;h2 id="global">global&lt;/h2>
&lt;p>全局配置，所有内容作用于所有配置环境中,若其余配置环境中不再指定同样的配置，则 global 中的配置作为默认配置&lt;/p>
&lt;p>&lt;strong>scrape_interval: &amp;lt;DURATION&amp;gt;&lt;/strong> # 抓取 targets 的指标频率，&lt;code>默认值：1m&lt;/code>。&lt;/p>
&lt;p>&lt;strong>scrape_timeout: &amp;lt;DURATION&amp;gt;&lt;/strong># 对 targets 发起抓取请求的超时时间。&lt;code>默认值：10s&lt;/code>。&lt;/p>
&lt;p>&lt;strong>evaluation_interval: &amp;lt;DURATION&amp;gt;&lt;/strong># 评估规则的周期。&lt;code>默认值：1m&lt;/code>。&lt;/p>
&lt;p>该字段主要用于向规则配置文件传递全局的配置。这个值会被规则配置文件中的 &lt;code>.groups.interval&lt;/code> 覆盖，详见 interval 字段详解&lt;/p>
&lt;p>&lt;strong>external_labels: &amp;lt;map[STRING]STRING&amp;gt;&lt;/strong> # 与外部系统(federation, remote storage, Alertmanager)通信时添加到任何时间序列或警报的标签。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>KEY: VAL&lt;/strong> # 比如该键值可以是 run: httpd，标签名是 run，run 的值是 httpd，KEY 与 VAL 使用字母，数字，_，-，.这几个字符且以字母或数字开头；val 可以为空。&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;h2 id="rule_files">rule_files&lt;/h2>
&lt;p>&lt;a href="https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Rules%20%E9%85%8D%E7%BD%AE.md">规则文件配置&lt;/a>列表，从所有匹配到的文件中读取配置内容。可以使用正则表达式匹配多个符合的文件。Prometheus 支持两种规则&lt;/p>
&lt;ul>
&lt;li>recording rules(记录规则)&lt;/li>
&lt;li>alerting rules(告警规则)&lt;/li>
&lt;/ul>
&lt;h2 id="scrape_configs占比最大的字段">scrape_configs(占比最大的字段)&lt;/h2>
&lt;p>&lt;a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config">https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config&lt;/a>&lt;/p>
&lt;p>在 &lt;a href="https://www.yuque.com/go/doc/33112724">Prometheus&lt;/a> 一文中，粗略介绍了基本的 scrape_configs 配置段的内容，下面是最基本的配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;prometheus&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scrape_interval&lt;/span>: &lt;span style="color:#ae81ff">5s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">static_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;localhost:9090&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>scrape_configs 是 Prometheus 采集指标的最重要也是最基本的配置信息，scrape_configs 字段是一个数组，所以可以配置多个 Scrape 配置，不同的 Scrape 配置，所以该段配置至少需要包含以下几个方面：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>名字&lt;/strong> # 每个 scrape 工作都应该具有一个名字。称为 job_name，名字主要起到标识符的作用。
&lt;ul>
&lt;li>该示例定义了一个抓取配置的 job，名字叫 prometheus&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>目标&lt;/strong> # 要抓取的 metrics 的目标。目标可以通过 &lt;strong>静态&lt;/strong>或者 **动态(i.e.各种服务发现)**这两种方式指定
&lt;ul>
&lt;li>该示例通过静态配置定义这个 job 中要抓取的目标主机，目标主机由 IP:PORT 组成&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>间隔&lt;/strong> # 该 scrape 工作每次抓取 metrics 的时间间隔。就是每隔 X 秒抓一次
&lt;ul>
&lt;li>该示例每次抓取 metrics 的时间间隔为 5 秒(i.e.每 5 秒获取一次 metrics)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>其他&lt;/strong> # 除了名字、目标、间隔 以外，还可以配置一些额外的抓取配置，比如发起 HTTP 请求时需要携带的 Header 与 Body、抓取策略 等等&lt;/li>
&lt;/ul>
&lt;h3 id="基本配置">基本配置&lt;/h3>
&lt;p>&lt;strong>job_name: &amp;lt;STRING&amp;gt;&lt;/strong> # 指定抓取 Metrics 的 Job 名字
&lt;strong>scrape_interval: &amp;lt;DURATION&amp;gt;&lt;/strong> # 指定这个 job 中抓取 targets 的频率。默认使用 global 配置环境中同名参数的值
&lt;strong>scrape_timeout: &amp;lt;DURATION&amp;gt;&lt;/strong> # 指定这个 job 中抓取 targets 的超时时长。默认使用 global 配置环境中同名参数的值
&lt;strong>metrics_path: PATH&lt;/strong> # 从 targets 获取 metrics 时 http 请求的路径。默认为/metrics
&lt;strong>honor_labels: &amp;lt;BOOLEAN&amp;gt;&lt;/strong> # 控制 Prometheus 如何处理标间之间的冲突。&lt;code>默认值：false&lt;/code>&lt;/p>
&lt;ul>
&lt;li>获取 targets 的 metrics 时(e.g.snmp_exporter|Federate|pushgateway 等)，其中的标签有可能会与本身的标签存在冲突
&lt;ul>
&lt;li>该参数的值为 true 时，则以抓取数据中的标签为准&lt;/li>
&lt;li>值为 false 时，就会重新命名表桥为 exported 形式，然后添加配置文件中的标签。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>honor_timestamps: &amp;lt;BOOLEAN&amp;gt;&lt;/strong> # 控制 Prometheus 是否尊重抓去到的数据中的时间戳 &lt;code>默认值：true&lt;/code>&lt;/p>
&lt;ul>
&lt;li>比如从 federate、pushgateway 等地方获取指标时，指标中都是带着时间戳的，
&lt;ul>
&lt;li>若设置为 false，则会忽略这些采集到的时间戳，在入库时加上采集时的时间戳。&lt;/li>
&lt;li>若设置为 true，则是在入库时使用抓到到的指标中的时间戳。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>sample_limit: &amp;lt;INT&amp;gt;&lt;/strong> # 每次抓取 metrics 的数量限制。&lt;code>默认值：0&lt;/code>。0 表示不限制&lt;/p>
&lt;h3 id="http-配置">HTTP 配置&lt;/h3>
&lt;p>Prometheus 抓取目标就是发起 HTTP 请求。&lt;/p>
&lt;p>除了 scheme、params 字段以外的其他字段是 Prometheus 共享库中的通用 HTTP 客户端配置，即下面的 &lt;code>HTTPClientConfig&lt;/code> 结构体中的内容。&lt;/p>
&lt;p>代码：&lt;a href="https://github.com/prometheus/common/blob/v0.30.0/config/http_config.go#L159">common/config/http_config.go&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// HTTPClientConfig configures an HTTP client.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">HTTPClientConfig&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// The HTTP basic authentication credentials for the targets.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">BasicAuth&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">BasicAuth&lt;/span> &lt;span style="color:#e6db74">`yaml:&amp;#34;basic_auth,omitempty&amp;#34; json:&amp;#34;basic_auth,omitempty&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// The HTTP authorization credentials for the targets.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Authorization&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Authorization&lt;/span> &lt;span style="color:#e6db74">`yaml:&amp;#34;authorization,omitempty&amp;#34; json:&amp;#34;authorization,omitempty&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// The OAuth2 client credentials used to fetch a token for the targets.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">OAuth2&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">OAuth2&lt;/span> &lt;span style="color:#e6db74">`yaml:&amp;#34;oauth2,omitempty&amp;#34; json:&amp;#34;oauth2,omitempty&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// The bearer token for the targets. Deprecated in favour of
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Authorization.Credentials.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">BearerToken&lt;/span> &lt;span style="color:#a6e22e">Secret&lt;/span> &lt;span style="color:#e6db74">`yaml:&amp;#34;bearer_token,omitempty&amp;#34; json:&amp;#34;bearer_token,omitempty&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// The bearer token file for the targets. Deprecated in favour of
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Authorization.CredentialsFile.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">BearerTokenFile&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`yaml:&amp;#34;bearer_token_file,omitempty&amp;#34; json:&amp;#34;bearer_token_file,omitempty&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// HTTP proxy server to use to connect to the targets.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">ProxyURL&lt;/span> &lt;span style="color:#a6e22e">URL&lt;/span> &lt;span style="color:#e6db74">`yaml:&amp;#34;proxy_url,omitempty&amp;#34; json:&amp;#34;proxy_url,omitempty&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// TLSConfig to use to connect to the targets.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">TLSConfig&lt;/span> &lt;span style="color:#a6e22e">TLSConfig&lt;/span> &lt;span style="color:#e6db74">`yaml:&amp;#34;tls_config,omitempty&amp;#34; json:&amp;#34;tls_config,omitempty&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// The omitempty flag is not set, because it would be hidden from the
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// marshalled configuration when set to false.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">FollowRedirects&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#e6db74">`yaml:&amp;#34;follow_redirects&amp;#34; json:&amp;#34;follow_redirects&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>scheme: &amp;lt;STRING&amp;gt;&lt;/strong> # 指定用于抓取 Metrics 时使用的协议。&lt;code>默认值：http&lt;/code>&lt;/p>
&lt;p>&lt;strong>params: &amp;lt;&amp;gt;&lt;/strong> # 发起 http 请求时，URL 里的参数(以键值对的方式表示)。
常用于 snmp_exporter，比如 &lt;a href="http://10.10.100.12:9116/snmp?module=if_mib&amp;amp;target=10.10.100.254">http://10.10.100.12:9116/snmp?module=if_mib&amp;amp;target=10.10.100.254&lt;/a>，问号后面就是参数的 key 与 value)&lt;/p>
&lt;ul>
&lt;li>STRING: STRING&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>basic_auth: &amp;lt;Object&amp;gt;&lt;/strong># 配置 HTTP 的基础认证信息。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>username: &amp;lt;STRING&amp;gt;&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>password: &amp;lt;SECRET&amp;gt;&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>password_file: &amp;lt;STRING&amp;gt;&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>authorization: &amp;lt;Object&amp;gt;&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>type: &amp;lt;STRING&amp;gt;&lt;/strong> # 发起抓取请求时的身份验证类型。&lt;code>默认值：Bearer&lt;/code>&lt;/li>
&lt;li>&lt;strong>credentials: &amp;lt;SECRET&amp;gt;&lt;/strong> # 用于身份验证的信息。与 credentials_file 字段互斥。如果是 type 字段是 Bearer，那么这里的值就用 Token 即可。&lt;/li>
&lt;li>&lt;strong>credentials_file: &amp;lt;FileName&amp;gt;&lt;/strong> # 从文件中读取用于身份验证的信息。与 credentials 字段互斥&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>oauth2: &amp;lt;Object&amp;gt;&lt;/strong> # 配置 OAuth 2.0 的认证配置。与 basic_auth 和 authorization 两个字段互斥&lt;/p>
&lt;p>&lt;strong>proxy_url: &amp;lt;STRING&amp;gt;&lt;/strong> # 指定代理的 URL&lt;/p>
&lt;p>&lt;strong>tls_config&lt;/strong>(&lt;a href="#tls_config">tls_config&lt;/a>) # 指定抓取 metrics 请求时的 TLS 设定&lt;/p>
&lt;h3 id="scrape-目标配置">Scrape 目标配置&lt;/h3>
&lt;p>Prometheus 将会根据这里的字段配置，以发现需要 Scrape 指标的目标，有两种方式来发现目标：静态 与 动态。&lt;/p>
&lt;p>&lt;strong>static_configs&lt;/strong>(&lt;a href="#static_configs">static_configs&lt;/a>) # 静态配置。直接指定需要抓去 Metrics 的 Targets。&lt;/p>
&lt;ul>
&lt;li>具体配置详见下文&lt;a href="#J021o">静态目标发现&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>XX_sd_configs&lt;/strong>([]OBJECT) # 动态配置。动态需要抓去 Metrics 的 Targets。XXX_sd_configs 中的 sd 全称为 Service Discovery(服务发现)&lt;/p>
&lt;ul>
&lt;li>具体配置详见下文&lt;a href="#IWvg5">动态目标发现&lt;/a>&lt;/li>
&lt;li>不同的服务发现，有不同的配置方式。比如 &lt;code>kubernetes_sd_configs&lt;/code>、&lt;code>file_sd_configs&lt;/code> 等等。&lt;/li>
&lt;li>注意：当 Prometheus 自动发现这些待抓取目标时，会附带一些原始标签，这些标签以 &lt;code>__meta_XX&lt;/code> 开头，不同的服务发现配置发现标签不同，具体说明详见&lt;a href="https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Target(%E7%9B%AE%E6%A0%87)%20%E4%B8%8E%20Relabeling(%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0).md">《Label 与 Relabel》文章中的 Discovered Labels 章节&lt;/a> 的说明&lt;/li>
&lt;/ul>
&lt;p>&lt;code>XX_sd_configs&lt;/code> 与 &lt;code>static_configs&lt;/code> 的区别：静态配置与动态配置就好比主机获取 IP 时是 DHCP 还是 STATIC。动态配置可以动态获取要抓取的 Targets、静态就是指定哪个 Target 就去哪个 Target 抓取 Metrics&lt;/p>
&lt;h3 id="relabel-配置">Relabel 配置&lt;/h3>
&lt;p>&lt;strong>relabel_configs&lt;/strong>(&lt;a href="#relabel_configs">relabel_configs&lt;/a>) # 在发现目标后，重新配置 targets 的标签。&lt;/p>
&lt;ul>
&lt;li>具体配置详见下文 &lt;a href="#%E9%87%8D%E8%AE%BE%E6%A0%87%E7%AD%BE">重设标签&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>metric_relabel_configs&lt;/strong>(&lt;a href="#relabel_configs">relabel_configs&lt;/a>) # 在抓取到指标后，重新配置 metrics 的标签&lt;/p>
&lt;ul>
&lt;li>与 relabel_configs 字段配置内容相同&lt;/li>
&lt;/ul>
&lt;h2 id="alerting">alerting&lt;/h2>
&lt;p>&lt;strong>alert_relabel_configs&lt;/strong>(&lt;a href="#relabel_configs">relabel_configs&lt;/a>)&lt;/p>
&lt;p>适用于推送告警时的 Relabel 功能，配置与 &lt;a href="#PGKul">relabel_configs&lt;/a> 相同&lt;/p>
&lt;p>&lt;strong>alertmanager&lt;/strong>([]OBJECT)&lt;/p>
&lt;p>&lt;a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alertmanager_config">https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alertmanager_config&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>该字段配置方式与 scrape_config 字段的配置非常相似，只不过不是配置抓取目标，而是配置推送告警的目标&lt;/p>
&lt;/blockquote>
&lt;p>alertmanager 字段指定了 Prometheus Server 发送警报的目标 Alertmanager，还提供了参数来配置如何与这些 Alertmanager 通信。此外，relabel_configs 允许从已发现的实体中选择 Alertmanagers，并对使用的 API 路径进行高级修改，该路径通过 &lt;strong>alerts_path&lt;/strong> 标签暴露。&lt;/p>
&lt;p>&lt;strong>alerts.timeout: &amp;lt;DURATION&amp;gt;&lt;/strong> # 推送警报时，每个目标 Alertmanager 超时，单位：秒。&lt;code>默认值: 10&lt;/code>。&lt;/p>
&lt;p>&lt;strong>timeout: &amp;lt;DURATION&amp;gt;&lt;/strong> # 推送告警时的超时时间。&lt;/p>
&lt;p>&lt;strong>api_version: &amp;lt;STRING&amp;gt;&lt;/strong> # 推送告警时，应该使用哪个版本的 Alertmanager 路径。&lt;code>默认值：v2&lt;/code>。&lt;/p>
&lt;p>&lt;strong>path_prefix: &amp;lt;PATH&amp;gt;&lt;/strong> # 推送告警时的，目标路径前缀。&lt;code>默认值：/&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>注意：就算指定了其他路径，也会默认在末尾添加 &lt;code>/api/v2/alerts&lt;/code>&lt;/li>
&lt;/ul>
&lt;h4 id="http-配置-1">HTTP 配置&lt;/h4>
&lt;p>&lt;strong>scheme: &amp;lt;SCHEME&amp;gt;&lt;/strong> # 推送告警时，所使用的协议。&lt;code>默认值：HTTP&lt;/code>&lt;/p>
&lt;p>下面的部分是 HTTP 的认证，是用来配置将告警推送到目标时所需要的认证信息。比如目标是 HTTPS 时，就需要这些配置。发起的 POST 推送请求时，Prometheus 使用 username 和 passwrod 字段的值为这个 HTTP 请求设置 Authorization 请求头。说白了就是发起 HTTP 请求时带着用户名和密码。&lt;/p>
&lt;p>&lt;strong>basic_auth: &amp;lt;Object&amp;gt;&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>username: &amp;lt;STRING&amp;gt;&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>password: &amp;lt;SECRET&amp;gt;&lt;/strong> # password 和 password_files 字段是互斥的&lt;/li>
&lt;li>&lt;strong>password_file: &amp;lt;STRING&amp;gt;&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>authorization: &amp;lt;Object&amp;gt;&lt;/strong> #&lt;/p>
&lt;ul>
&lt;li>&lt;strong>type: &amp;lt;STRING&amp;gt;&lt;/strong> # 推送告警时的身份验证类型。&lt;code>默认值：Bearer&lt;/code>&lt;/li>
&lt;li>&lt;strong>credentials: &amp;lt;secret&amp;gt;&lt;/strong> # 用于身份验证的信息。与 credentials_file 字段互斥。如果是 type 字段是 Bearer，那么这里的值就用 Token 即可。&lt;/li>
&lt;li>&lt;strong>credentials_file: &amp;lt;filename&amp;gt;&lt;/strong> # 从文件中读取用于身份验证的信息。与 credentials 字段互斥&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>oauth2: &amp;lt;Object&amp;gt;&lt;/strong> # 配置 OAuth 2.0 的认证配置。与 basic_auth 和 authorization 两个字段互斥&lt;/p>
&lt;p>&lt;strong>tls_config: &amp;lt;Object&amp;gt;&lt;/strong> # 指定推送告警时的 TLS 设定&lt;/p>
&lt;h4 id="alerts-推送目标的配置">Alerts 推送目标的配置&lt;/h4>
&lt;p>Prometheus 根据这部分配置来推送需要&lt;/p>
&lt;p>&lt;strong>static_configs&lt;/strong>(&lt;a href="#static_configs">static_configs&lt;/a>) # 静态配置。指定推送告警时的目标。&lt;/p>
&lt;ul>
&lt;li>具体配置详见下文 &lt;a href="#%E9%9D%99%E6%80%81%E7%9B%AE%E6%A0%87%E5%8F%91%E7%8E%B0">静态目标发现&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>XXX_sd_configs&lt;/strong>([]OBJECT) # 动态配置。动态发现可供推送告警的 alertmanager- XXXX # 不同的服务发现，有不同的配置方式。与 scrape_configs 字段中的 XXX_sd_configs 配置类似。&lt;/p>
&lt;ul>
&lt;li>具体配置详见下文 &lt;a href="#IWvg5">动态目标发现&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="relabel-配置-1">Relabel 配置&lt;/h4>
&lt;p>&lt;strong>relabel_configs&lt;/strong>(&lt;a href="#relabel_configs">relabel_configs&lt;/a>) # 在发现目标后，重新配置 targets 的标签&lt;/p>
&lt;p>详见下文 &lt;a href="#%E9%87%8D%E8%AE%BE%E6%A0%87%E7%AD%BE">重设标签&lt;/a>&lt;/p>
&lt;h2 id="remote_write">remote_write&lt;/h2>
&lt;p>与远程写相关的配置，详见 &lt;a href="https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Storage(%E5%AD%98%E5%82%A8).md">Prometheus 存储章节&lt;/a>&lt;/p>
&lt;p>&lt;strong>url: &amp;lt;STRING&amp;gt;&lt;/strong> # 指定要发送时间序列数据到远程存储的端点的 URL&lt;/p>
&lt;h2 id="remote_read">remote_read&lt;/h2>
&lt;p>与远程读相关的配置，详见 &lt;a href="https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Storage(%E5%AD%98%E5%82%A8).md">Prometheus 存储章节&lt;/a>&lt;/p>
&lt;p>&lt;strong>url: &amp;lt;STRING&amp;gt;&lt;/strong> # 指定发起查询请求的远程数据库的端点的 URL&lt;/p>
&lt;h1 id="配置文件中的通用配置字段">配置文件中的通用配置字段&lt;/h1>
&lt;h2 id="静态目标发现">静态目标发现&lt;/h2>
&lt;p>这些通用字段会被配置文件中的某些字段共同使用&lt;/p>
&lt;h3 id="static_configs">static_configs&lt;/h3>
&lt;p>&lt;a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#static_config">https://prometheus.io/docs/prometheus/latest/configuration/configuration/#static_config&lt;/a>&lt;/p>
&lt;p>静态配置。指定用户抓取 metrics 的 targets。静态配置与动态配置就好比主机获取 IP 时是 DHCP 还是 STATIC。动态配置可以动态获取要抓取的 targets、静态就是指定哪个 target 就去哪个 target 抓取 metrics&lt;/p>
&lt;p>&lt;strong>targets: &amp;lt;[]STRING&amp;gt;&lt;/strong> # 指定要抓取 metrics 的 targets 的 IP:PORT&lt;/p>
&lt;ul>
&lt;li>&lt;strong>HOST&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>labels: &amp;lt;map[STRING]STRING&amp;gt;&lt;/strong> # 指定该 targets 的标签，可以随意添加任意多个&lt;/p>
&lt;ul>
&lt;li>&lt;strong>KEY: VAL&lt;/strong> # 比如该键值可以是 run: httpd，标签名是 run，run 的值是 httpd，key 与 val 使用字母，数字，_，-，.这几个字符且以字母或数字开头；val 可以为空。&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;h2 id="动态目标发现">动态目标发现&lt;/h2>
&lt;h3 id="file_sd_configs">file_sd_configs&lt;/h3>
&lt;p>&lt;a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#file_sd_config">https://prometheus.io/docs/prometheus/latest/configuration/configuration/#file_sd_config&lt;/a>&lt;/p>
&lt;p>基于文件的服务发现提供了一种配置静态目标的更通用的方法，并用作插入自定义服务发现机制的接口。&lt;/p>
&lt;p>在 Prometheus 支持的众多服务发现的实现方式中，基于文件的服务发现是最通用的方式。这种方式不需要依赖于任何的平台或者第三方服务。对于 Prometheus 而言也不可能支持所有的平台或者环境。通过基于文件的服务发现方式下，Prometheus 会定时从指定文件中读取最新的 Target 信息，因此，你可以通过任意的方式将监控 Target 的信息写入即可。&lt;/p>
&lt;p>用户可以通过 JSON 或者 YAML 格式的文件，定义所有的监控目标。同时还可以通过为这些实例添加一些额外的标签信息，这样从这些实例中采集到的样本信息将包含这些标签信息，从而可以为后续按照环境进行监控数据的聚合。&lt;/p>
&lt;p>&lt;strong>files: &amp;lt;map[STRING]STRING&amp;gt;&lt;/strong> # Prometheus 将要读取的文件路径，将会从该文件发现待采集的 Target。支持正则表达式&lt;/p>
&lt;p>&lt;strong>refresh_interval: &amp;lt;DURATION&amp;gt;&lt;/strong> # 重新读取文件的间隔时间。&lt;code>默认值：5m&lt;/code>&lt;/p>
&lt;p>通过这种方式，Prometheus 会自动的周期性读取文件中的内容。当文件中定义的内容发生变化时，不需要对 Prometheus Server 进行任何的重启操作。&lt;/p>
&lt;h4 id="配置样例">配置样例&lt;/h4>
&lt;p>假设现在有一个名为 file_sd.yaml 文件，中分别定义了 2 个采集任务，以及每个任务对应的 Target 列表，内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">targets&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;172.19.42.200&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">network&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;switch&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">targets&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;172.19.42.243&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">server&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;host-1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建 Prometheus 配置文件/etc/prometheus/prometheus-file-sd.yml，并添加以下内容：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">global&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scrape_interval&lt;/span>: &lt;span style="color:#ae81ff">15s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scrape_timeout&lt;/span>: &lt;span style="color:#ae81ff">10s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">evaluation_interval&lt;/span>: &lt;span style="color:#ae81ff">15s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;file_ds&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">file_sd_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">refresh_interval&lt;/span>: &lt;span style="color:#ae81ff">5m&lt;/span> &lt;span style="color:#75715e"># Prometheus 默认每 5m 重新读取一次文件内容，当需要修改时，可以通过refresh_interval进行设置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">files&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;file_sd.yaml&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里定义了一个基于 file_sd_configs 的监控采集任务，其中模式的任务名称为 file_ds。在 JSON 文件中可以使用 job 标签覆盖默认的 Job 名称。&lt;/p>
&lt;p>在 Prometheus UI 的 Targets 下就可以看到当前从 targets.json 文件中动态获取到的 Target 实例信息以及监控任务的采集状态，同时在 Labels 列下会包含用户添加的自定义标签&lt;/p>
&lt;p>这种通用的方式可以衍生了很多不同的玩法，比如与自动化配置管理工具(Ansible)结合、与 Cron Job 结合等等。 对于一些 Prometheus 还不支持的云环境，比如国内的阿里云、腾讯云等也可以使用这种方式通过一些自定义程序与平台进行交互自动生成监控 Target 文件，从而实现对这些云环境中基础设施的自动化监控支持。&lt;/p>
&lt;h3 id="kubernetes_sd_configs">kubernetes_sd_configs&lt;/h3>
&lt;p>&lt;a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config">https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config&lt;/a>&lt;/p>
&lt;p>kubernetes_sd_configs 字段的配置可以让 Prometheus 从 Kubernetes 的 API Server 中自动发现需要抓取目标，并始终与集群状态保持同步。可以抓取的目标有 node、service、pod、endpoints、ingress。&lt;/p>
&lt;blockquote>
&lt;p>注意：如果 Prometheus Server 部署在 Kubernetes 集群外部，通过 k8s 的 API Server 自动发现的 pod ip 是集群内部 IP，一般情况下不互联的。因为 pod 的 ip 一般都是集群内部 IP。所以如果在发现目标后想要采集，需要在 Prometheus Server 所在服务器添加到 Kubernetes 的 Pod IP 的路由条目。&lt;/p>
&lt;/blockquote>
&lt;p>Note：使用该配置进行服务发现，请求都会经过 API Server，集群规模越大，API Server 压力也会跟随增高。&lt;/p>
&lt;h4 id="api-server-配置">API Server 配置&lt;/h4>
&lt;p>&lt;strong>api_server: &amp;lt;HOST&amp;gt;&lt;/strong> # 指定 k8s 集群中 API Server 的地址。
如果该字段为空，则默认 Prometheus 在 k8s 集群内部运行，将自动发现 apiserver，并使用 Pod 中 /var/run/secrets/kubernetes.io/serviceaccount/ 目录下的的 CA 证书 和 Token。
&lt;strong>basic_auth: &amp;lt;Object&amp;gt;&lt;/strong># 如果 apiserver 使用基本认证启动，则使用 basic_auth 字段。&lt;code>authorization&lt;/code> 字段互斥。password 和 password_file 是互斥的。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>username: &amp;lt;STRING&amp;gt;&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>password: &amp;lt;SECRET&amp;gt;&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>password_file: &amp;lt;STRING&amp;gt;&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>authorization: &amp;lt;Object&amp;gt;&lt;/strong> # 如果 apiserver 使用证书启动，则使用 authorization 字段。与 &lt;code>basic_auth&lt;/code> 字段互斥。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>type: &amp;lt;STRING&amp;gt;&lt;/strong> # 发起抓取请求时的身份验证类型。&lt;code>默认值：Bearer&lt;/code>&lt;/li>
&lt;li>&lt;strong>credentials: &amp;lt;SECRET&amp;gt;&lt;/strong> # 用于身份验证的信息。与 credentials_file 字段互斥。如果是 type 字段是 Bearer，那么这里的值就用 Token 即可。该字段就是老版本的 bearer_token 字段&lt;/li>
&lt;li>&lt;strong>credentials_file: &amp;lt;filename&amp;gt;&lt;/strong> # 从文件中读取用于身份验证的信息。与 credentials 字段互斥.该字段就是老版本的 bearer_token_file 字段&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>oauth2: &amp;lt;Object&amp;gt;&lt;/strong> # 配置 OAuth 2.0 的认证配置。与 basic_auth 和 authorization 两个字段互斥
&lt;strong>tls_config: &amp;lt;Object&amp;gt;&lt;/strong> # 指定抓取 metrics 请求时的 TLS 设定
&lt;strong>proxy_url: &amp;lt;STRING&amp;gt;&lt;/strong> # Optional proxy URL&lt;/p>
&lt;h4 id="目标发现的规则配置">目标发现的规则配置&lt;/h4>
&lt;p>&lt;strong>role: &amp;lt;STRING&amp;gt;&lt;/strong> # 根据 STRING 动态发现地 Target。可用的 STRING 为 endpoints, service, pod, node,ingress。&lt;/p>
&lt;ul>
&lt;li>比如，Prometheus 可以自动发现 ep、svc 等等对象作为 scrape 地 target&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>namespaces: &amp;lt;Object&amp;gt;&lt;/strong> # 指定动态发现哪个 namesapce 下的 Target ，如果省略，则 Target 将从所有 namespaces 中动态发现&lt;/p>
&lt;ul>
&lt;li>&lt;strong>names: &amp;lt;[]STRING&amp;gt;&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>selectors: &amp;lt;[]Object&amp;gt;&lt;/strong> # 可以根据 selectors 中指定地 label 或者 field 来过滤动态发现的 Target 。如果省略，则不进行任何过滤。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>role: &amp;lt;ROLE&amp;gt;&lt;/strong> #&lt;/li>
&lt;li>&lt;strong>label: &amp;lt;STRING&amp;gt;&lt;/strong> # STRING 使用 key=value 的格式。&lt;/li>
&lt;li>&lt;strong>field: &amp;lt;STRING&amp;gt;&lt;/strong> #&lt;/li>
&lt;/ul>
&lt;h4 id="配置样例-1">配置样例&lt;/h4>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/prometheus/prometheus/blob/main/documentation/examples/prometheus-kubernetes.yml">官方推荐的样例&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>下面的例子是这样的：动态发现 kube-system 名称空间下的所有 pod 作为 target，并且进行过滤，只选择其中标签为 k8s-app=kube-dns 的 pod 作为 target&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;kubernetes-node&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">honor_timestamps&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">metrics_path&lt;/span>: &lt;span style="color:#ae81ff">/metrics&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 注意 scheme 字段，自动发现机制只是会发现 IP:PORT，并不会添加协议，有的 pod 是只提供 https 的。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 比如，如果是发现 kubelet、kube-apiserver 等 pod ，则这里应该改为 https&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scheme&lt;/span>: &lt;span style="color:#ae81ff">http&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">bearer_token_file&lt;/span>: &lt;span style="color:#ae81ff">/etc/prometheus/config_out/serviceaccount/token&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">tls_config&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">insecure_skip_verify&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ca_file&lt;/span>: &lt;span style="color:#ae81ff">/etc/prometheus/config_out/serviceaccount/ca.crt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">kubernetes_sd_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">api_server&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;https://172.19.42.234:6443&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 这里写了两遍认证信息，这是因为这里的认证则是针对 apiserver 的认证。而 scrape_configs 字段下的认证是针对已经发现的目标进行认证。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 需要先认证 apiserver 以发现待抓取的目标，然后再使用 scrape_configs 字段下的认证来采集目标的指标。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">bearer_token_file&lt;/span>: &lt;span style="color:#ae81ff">/etc/prometheus/config_out/serviceaccount/token&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">tls_config&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">insecure_skip_verify&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ca_file&lt;/span>: &lt;span style="color:#ae81ff">/etc/prometheus/config_out/serviceaccount/ca.crt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">role&lt;/span>: &lt;span style="color:#ae81ff">pod&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespaces&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">names&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">kube-system&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">selectors&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">role&lt;/span>: &lt;span style="color:#ae81ff">pod&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">label&lt;/span>: &lt;span style="color:#ae81ff">k8s-app=kube-dns&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的配置将会自动发现 k8s 集群中的所有 coredns pod&lt;/p>
&lt;blockquote>
&lt;p>注意：这里可以发现，我们是可以访问集群内部的 10.244.0.243，这是因为我加了静态路由配置(&lt;code>ip route add 10.244.0.0/16 dev ens3 via 172.19.42.231&lt;/code>)，否则，集群外部的 Prometheus 是无法抓取访问不到的目标的。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hzhbid/1616049623195-79b06041-01c2-4b81-bcb5-d4efd06de281.png" alt="">&lt;/p>
&lt;p>可以看到，coredns 的两个端口都发现了，由于我们不需要 53 端口，所以还需要进一步过滤，就是把 53 端口过滤调。可以使用 Relabeling 功能，在配置后面添加如下内容：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">relabel_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">source_labels&lt;/span>: [&lt;span style="color:#ae81ff">__meta_kubernetes_pod_container_port_number]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">regex&lt;/span>: &lt;span style="color:#ae81ff">53&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">action&lt;/span>: &lt;span style="color:#ae81ff">drop&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时，我们删除了 &lt;code>__meta_kubernetes_pod_container_port_number&lt;/code> 这个标签的值为 53 的所有指标。这样我们就可以看到，只剩下 9153 端口的指标了&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/hzhbid/1616049623219-a5447656-6c61-40f1-acfe-df6218904b3a.png" alt="">&lt;/p>
&lt;h2 id="重设标签">重设标签&lt;/h2>
&lt;h3 id="relabel_configs">relabel_configs&lt;/h3>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config">官方文档，配置-配置-relabel_config&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Target(%E7%9B%AE%E6%A0%87)%20%E4%B8%8E%20Relabeling(%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0).md">Label 与 Relabeling&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>relabel 重设标签功能，用于将抓取到的样本中的原始 label 进行重新标记以生成新的 label。&lt;/p>
&lt;p>&lt;strong>source_labels: [&amp;lt;LabelName&amp;gt;, &amp;hellip; ]&lt;/strong> # 从现有的标签中选择将要获取值的标签作为 source_labels。source_labels 可以有多个。&lt;/p>
&lt;p>&lt;strong>separator: &amp;lt;STRING&amp;gt;&lt;/strong> # 指定 source_labels 中所有值之间的分隔符。&lt;code>默认值: ;&lt;/code>。&lt;/p>
&lt;p>&lt;strong>target_label: &amp;lt;LabelName&amp;gt;&lt;/strong> # 通过 regex 字段匹配到的值写入的指定的 target_label 中&lt;/p>
&lt;p>&lt;strong>regex: &amp;lt;REGEX&amp;gt;&lt;/strong> # 从 source_label 获取的值进行正则匹配，匹配到的值写入到 target_label 中。&lt;code>默认正则表达式为(.*)&lt;/code>。i.e.匹配所有值&lt;/p>
&lt;p>&lt;strong>modulus: &amp;lt;UINT64&amp;gt;&lt;/strong> # 去 source_labels 值的哈希值的模数&lt;/p>
&lt;p>&lt;strong>replacement: &amp;lt;STRING&amp;gt;&lt;/strong> # 替换。指定要写入 target_label 的值，STRING 中可以引用 regex 字段的值，使用正则表达式方式引用。&lt;code>默认值：$1&lt;/code>。与 action 字段的 replace 值配合使用。&lt;/p>
&lt;p>&lt;strong>action: &amp;lt;Relabel_Action&amp;gt;&lt;/strong> # 对匹配到的标签要执行的动作。&lt;code>默认值: replace&lt;/code>。&lt;/p>
&lt;h2 id="其他">其他&lt;/h2>
&lt;h3 id="tls_config">tls_config&lt;/h3>
&lt;p>&lt;a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#tls_config">https://prometheus.io/docs/prometheus/latest/configuration/configuration/#tls_config&lt;/a>&lt;/p>
&lt;p>tls_config 字段用来配置 TLS 连接信息。下面描述客户端就是 Prometheus Server，服务端就是要抓取 Metrics 的目标。&lt;/p>
&lt;p>&lt;strong>ca_file: &amp;lt;FileName&amp;gt;&lt;/strong> # CA 证书，用于验证服务端证书&lt;/p>
&lt;p>&lt;strong>cert_file: &amp;lt;FileName&amp;gt;&lt;/strong> # 证书文件，用于客户端对服务器的证书认证。&lt;/p>
&lt;p>&lt;strong>key_file: &amp;lt;FileName&amp;gt;&lt;/strong> # 密钥文件，用于客户端对服务器的证书认证。&lt;/p>
&lt;p>&lt;strong>server_name: &amp;lt;STRING&amp;gt;&lt;/strong> # ServerName 扩展名，用于指示服务器的名称。ServerName extension to indicate the name of the server. ServerName 概念参考：&lt;a href="https://tools.ietf.org/html/rfc4366#section-3.1">https://tools.ietf.org/html/rfc4366#section-3.1&lt;/a>&lt;/p>
&lt;p>&lt;strong>insecure_skip_verify: &amp;lt;BOOLEAN&amp;gt;&lt;/strong> # 禁用服务端对证书的验证。类似于 curl 的 -k 选项&lt;/p></description></item><item><title>Docs: Storage(存储)</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Storage%E5%AD%98%E5%82%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Storage%E5%AD%98%E5%82%A8/</guid><description/></item><item><title>Docs: Target(目标) 与 Relabeling(重新标记)</title><link>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Target%E7%9B%AE%E6%A0%87-%E4%B8%8E-Relabeling%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/6.%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Prometheus/Target%E7%9B%AE%E6%A0%87-%E4%B8%8E-Relabeling%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config">官方文档,配置-配置&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jianshu.com/p/c21d399c140a">简书大佬&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Targets(目标)&lt;/strong> 是 Prometheus 核心概念的其中之一，Targets 是&lt;strong>一组 Label(标签) 的集合。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Prometheus 在采集 Targets(目标) 的指标时，会自动将 Target 的标签附加到采集到的每条时间序列上&lt;/strong>才存储，这样是为了更好的对数据进行筛选过滤，而这些附加的新标签是怎么来的呢？~~这就是本文所要描述的东西。&lt;/p>
&lt;p>如下面两张图所示，随便找一条时间序列，就可以看到，原始的指标中没有下图红框中的标签，而通过 Prometheus Server 采集后，就附加了两个新的标签上去。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iyi5xg/1616045780719-65995290-1f02-4fc9-b1ac-d26b80601eaa.png" alt="">
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iyi5xg/1616045780717-62e9699b-0064-4ea8-93d2-c741437d0a7f.png" alt="">
这里为什么会多出来两个标签呢，这种现象又是什么功能来实现的呢？~&lt;/p>
&lt;p>首先，我们在 Prometheus Server 的 web 界面的 Status 标签中的 Targets 页面和 Service Discovery 页面中，可以发现 Prometheus 把标签分为两类：&lt;/p>
&lt;ul>
&lt;li>Discovered Labels(已发现的标签)&lt;/li>
&lt;li>Target Labels(目标标签)&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iyi5xg/1616045780732-4d75ae11-3fe5-4eb3-9866-ec9e55506a49.png" alt="">
从 &lt;a href="https://www.yuque.com/go/doc/33147376">Prometheus 数据模型&lt;/a> 中，可以知道 Label 的作用就是用来标识一条唯一的时间序列。那么 Prometheus 为什么会分为 Discovered Labels 和 Target Labels 呢？&lt;/p>
&lt;ul>
&lt;li>因为，如果只有一套 Labels，那么 Prometheus 在采集目标时所使用的 Labels 就需要完完整整全部附加到已采集的指标上。当我们不想将所有标签都写入数据库，或者想改变某些标签的时候，这一套标签就已经不够用了。&lt;/li>
&lt;li>既然出现了两套标签，也就需要一个两套标签之间的转换功能，而这就是 **Relabeling(重新标记) **机制。&lt;/li>
&lt;/ul>
&lt;p>从某种程度上来说，Prometheus 一切介标签。Prometheus 有如下基本规定：&lt;/p>
&lt;ul>
&lt;li>Discovered Labels 用来描述采集目标的属性，只有根据这些属性才能找到目标。比如目标的 IP、PORT 等等。
&lt;ul>
&lt;li>采集目标的属性标签名一般都以 &lt;code>__&lt;/code> 符号开头。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Target Labels 是用来附加到采集的指标上。这个才是真正被用户使用，以及存储的标签，PromQL 表达式中的标签也是指的 Target Labels
&lt;ul>
&lt;li>&lt;code>__&lt;/code> 符号开头的标签是不会被添加到 Target Labels 中，也就也不会附加到指标上。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>其中 Discovered Labels 是根据配置自动生成的，而 Target Labels 则是通过一种称为 &lt;strong>Relabeling(重新标记)&lt;/strong> 的功能生成的。&lt;/li>
&lt;/ul>
&lt;h2 id="relabeling重新标记-功能">Relabeling(重新标记) 功能&lt;/h2>
&lt;p>&lt;strong>Relabeling(重新标记)&lt;/strong> 是一种可以在抓取目标数据之前动态重写目标的标签集的功能。每个抓取配置可以配置多个 Relabeling 机制。这些行为按照在配置文件中出现的顺序，由上至下依次应用于每个 Target(目标) 的标签集上。&lt;/p>
&lt;h3 id="为什么需要-relabeling-功能呢">为什么需要 Relabeling 功能呢？&lt;/h3>
&lt;ul>
&lt;li>由于 Prometheus 的规定，&lt;code>__&lt;/code> 符号开头的标签不会被写入到时间序列数据中，也就无法再使用 promQL 语句进行数据过滤中使用，所以需要有一种方法，以便将&lt;code>__&lt;/code> 符号开头的标签的值存储到一个新的标签中去，让这些新的标签写到时间序列数据中。而将标签 Relabeling 后，非 __ 符号开头原始标签也不会消失，只是将原始标签里的值写入的目标标签中去了。&lt;/li>
&lt;li>自动发现机制的原始标签都是 __ 开头的，用户可以使用 Relabeling 机制，自己决定哪些需要留下，哪些需要抛弃。留下的那些又可以以新的标签名保留。&lt;/li>
&lt;li>另外一个作用就是比较普遍的对标签值进行重新规划了，比如 原始标签有 IP 与 PORT，而实际只需要 IP，那么就需要用 relabel 功能了~~&lt;/li>
&lt;li>总之，Relabeling 是一个非常强大的功能，可以重新规划每一条采集到的指标，也可以在持久存储前删除抓取到的指定指标。说白了，就是在&lt;strong>存到数据库之前，重新规划指标的信息&lt;/strong>。因为时间序列是一组标签的集合作为唯一标识符。所以改标签，就是给时间序列改名了~~~~~&lt;/li>
&lt;/ul>
&lt;h2 id="relabeling-功能的两个阶段">Relabeling 功能的两个阶段&lt;/h2>
&lt;h3 id="阶段一发现目标之后采集指标之前">阶段一：发现目标之后，采集指标之前&lt;/h3>
&lt;h3 id="阶段二采集指标之后储存指标之前">阶段二：采集指标之后，储存指标之前&lt;/h3>
&lt;h3 id="这两个阶段的区别">这两个阶段的区别&lt;/h3>
&lt;p>这两个阶段都可以使用 Relabeling 功能，不同点在于：&lt;/p>
&lt;ul>
&lt;li>阶段一中，主要针对 Discovered Labels 进行操作，然后将 Target Label 附加到采集到的指标上。
&lt;ul>
&lt;li>配置文件中的 &lt;code>relabel_config&lt;/code> 字段工作在这个阶段。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>阶段二中，可以针对采集到的指标中自带的标签进行操作。
&lt;ul>
&lt;li>配置文件中的 &lt;code>metric_relabel_configs&lt;/code> 字段工作在这个阶段。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="discovered-labels-与-target-labels">Discovered Labels 与 Target Labels&lt;/h1>
&lt;h2 id="数据采集流程">数据采集流程&lt;/h2>
&lt;p>当 Prometheus Server 加载配置文件启动时，并不是立刻就开始抓取 Target(目标) 的 Metrics(指标)&lt;/p>
&lt;ul>
&lt;li>首先需要根据配置文件，获取目标信息，这些目标信息就是由一系列标签组成，称为 &lt;strong>Discovered Labels(已发现标签)&lt;/strong>。&lt;/li>
&lt;li>根据配置中的 Relabeling 配置，生成 &lt;strong>Target Labels(目标标签)&lt;/strong>
&lt;ul>
&lt;li>默认生成的 Target Labels 中将会删除 __ 开头的标签，并将其他标签原封不动得映射到 Target Labels。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>然后根据 Discovered Labels 的信息，从目标开始采集 Metrics，采集到 Metrics 后，将 Target Labels 附加到这些 Metrics 中。&lt;/li>
&lt;li>&lt;strong>从某种程度上来说，Prometheus 中一切介标签&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="discovered-labels已发现标签">Discovered Labels(已发现标签)&lt;/h2>
&lt;p>当 Prometheus 加载完 Target 后，会自动发现一些标签，这些就是 Discovered Labels。Discovered Labels 分为两部分：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>系统信息标签&lt;/strong>
&lt;ul>
&lt;li>*&lt;strong>*address**&lt;/strong> # 采集目标的 IP 和 PORT&lt;/li>
&lt;li>*&lt;strong>*scheme**&lt;/strong> # 采集目标时，要使用的协议，HTTP 或者 HTTPS&lt;/li>
&lt;li>*&lt;strong>*metrics_path**&lt;/strong> # 采集目标时，请求的访问路径&lt;/li>
&lt;li>**__param_XXXX **# 配置文件中指定 params 字段的时，将会自动生成这类标签。&lt;/li>
&lt;li>&lt;strong>__meta_XXX&lt;/strong> # 通过服务发现功能发现的 Target 自带的元数据标签
&lt;ul>
&lt;li>比如 kubernetes 发现，就是 __meta_kubernetes_XXX 这种格式的标签&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>其他系统标签&lt;/li>
&lt;li>注意：这些前面带 &lt;code>__&lt;/code> (两个&lt;code>_&lt;/code> 符号)的标签，都是系统自动生成的，是无法在使用 promQL 语句进行筛选过滤时直接使用的。
&lt;ul>
&lt;li>并且，这些标签标签也不会变为 Target Labels&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>job&lt;/strong> # 配置文件中的 job_name 字段的值就是 job 标签的值。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>用户自定的标签&lt;/strong>
&lt;ul>
&lt;li>一般都是写在配置文件中的 labels 字段下的内容，这些内容经过 Relabels 之后，不会从 Discovered Labels 中删除。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Discovered Labels 中的 **系统标签 **会告诉 Prometheus Server 如何从 Target 中获取时间序列数据(e.g.使用什么协议、从哪个 IP 上的主机哪个路径获取、等等类似的信息)。比如 &lt;strong>address&lt;/strong>、&lt;strong>metrics_path&lt;/strong>、&lt;strong>scheme&lt;/strong> 这三个标签就表明，Prometheus 采集目标为 http://localhost:9090/metrics。相当于执行了 curl -XGET http://localhost:9090/metrics 这个命令。如果还有 __param_XX 标签，则该标签的值，就是这次请求 URL 中的参数部分&lt;/p>
&lt;blockquote>
&lt;p>默认情况下，Prometheus 会将 &lt;strong>address&lt;/strong> 标签重新标记为 instance 标签，job 标签原封不同。如果想要其他的 Target Labels，则需要使用配置文件中的 relabel 以及 labels 字段来定义了。
如果重新标记步骤仅需要临时存储标签值（作为后续重新标记步骤的输入），请使用__tmp 标签名称前缀。保证该前缀不会被 Prometheus 自己使用。&lt;/p>
&lt;/blockquote>
&lt;p>注意，被发现的所有标签中，标签名中的 &lt;code>-&lt;/code>、&lt;code>.&lt;/code>、&lt;code>/&lt;/code> 等等特殊符号，都会转换成 &lt;code>_&lt;/code> 符号。&lt;/p>
&lt;h3 id="关于-__meta_xx-标签">关于 __meta_XX 标签&lt;/h3>
&lt;p>当 Prometheus 根据其自动发现机制，来自动发现待抓取目标时，会附带一些原始标签，这些标签以 &lt;code>__meta_XX&lt;/code> 开头。
不同的服务发现配置发现标签不同，具体详见各种各种服务发现配置的官方文档(比如&lt;a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config">这里就是 kubernetes_sd_configs 配置&lt;/a>中，所有自动发现的标签)，效果如下：
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iyi5xg/1616049623207-f0fb653e-75ef-4e86-8c15-21bcb2292f02.png" alt="">&lt;/p>
&lt;blockquote>
&lt;p>像 static_configs 这种直接指定抓取目标的配置，只会发现最基本的 &lt;strong>address&lt;/strong>、&lt;strong>schem&lt;/strong> 等标签。
这些各种服务发现配置发现标签就是用来描述目标属性的，然后可以通过 Relabeling 机制，将这些发现的标签保留下来，以便使用 PromQL 查询时，可以有更多的过滤选项。&lt;/p>
&lt;/blockquote>
&lt;h2 id="target-labels目标标签">Target Labels(目标标签)&lt;/h2>
&lt;p>Target Labels 中的所有标签都是 Relabeling 之后的标签。Target Labels 包括两部分&lt;/p>
&lt;ul>
&lt;li>Prometheus 自身默认的 Relabel。就是去掉系统信息标签后剩下的标签
&lt;ul>
&lt;li>**instance **# 由 &lt;strong>address&lt;/strong> 标签生成。注意：该标签会一直存在，无法通过 Relabeling 行为删除或改名&lt;/li>
&lt;li>**job **# 由 job 标签生成&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>通过配置文件配置的 relabel 标签&lt;/li>
&lt;/ul>
&lt;h1 id="relabeling-配置">Relabeling 配置&lt;/h1>
&lt;p>在 Prometheus Server 的配置中，Relabeling 行为的配置通常写在在 &lt;strong>relabel_configs&lt;/strong> 和 &lt;strong>metrics_relabel_configs&lt;/strong> 字段下。在很多地方都可以编写 &lt;strong>relabel_configs&lt;/strong> 字段下的内容，以便为各种数据实现 relabel 功能&lt;/p>
&lt;ul>
&lt;li>&lt;code>scrape_config.relabel_configs&lt;/code> 字段中 # Prometheus Relabeling 功能体现最主要的地方&lt;/li>
&lt;li>&lt;code>alert_relabel_configs&lt;/code> 字段中 # 用于为告警内容实现 Relabeling 功能&lt;/li>
&lt;li>等等等等，有很多地方都可以配置 Relabeling，还包括 Loki 日志套件中 Promtail 程序，也可以对日志流执行同样效果的 Relabeling 功能。因为 Relabeling 功能是 Prometheus 设计哲学 “&lt;strong>标签即一切”&lt;/strong> 的必备功能&lt;/li>
&lt;/ul>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>relabel_cofigs&lt;/strong> 是 Prometheus 在发现**待采集的 Target(目标) **之后，从目标采集指标之前，这两个行为之间发生的 Relabeling 行为配置。所以主要是针对 **待采集的 Target(目标) 及其标签 **进行操作，而不是针对采集后的指标或其标签进行操作。所以，就如前文描述的一样，Relabeling 行为是针对待采集目标的 Discovered Label 的一种行为，经过 Relabeling 后，待采集目标就会生成 Target Labels。&lt;/li>
&lt;li>&lt;strong>metrics_relabel_configs&lt;/strong> 是 Prometheus 在采集到 Target(目标) 的指标之后，并存储到时序数据库之前，这两个行为之间发生的 Relabeling 行为配置。所以主要是针对&lt;strong>采集到的指标&lt;/strong>进行操作。
&lt;ul>
&lt;li>该配置不适用于自动生成的指标，比如 &lt;code>up&lt;/code> 这类。因为这类指标在启动时就存在了，不用任何目标即可获取。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>这两个配置的配置格式一摸一样。&lt;/li>
&lt;/ul>
&lt;p>**后文描述的 &lt;strong>&lt;code>**目标**&lt;/code>&lt;/strong> 二字，都是指 **&lt;code>**待采集的目标**&lt;/code>。&lt;/p>
&lt;h2 id="relabel_configs-字段详解">relabel_configs 字段详解&lt;/h2>
&lt;h3 id="action-relabel_action--指定本次-relabeling-的具体行为默认值replace">action: &amp;lt;Relabel_Action&amp;gt; # 指定本次 Relabeling 的具体行为。&lt;code>默认值：replace&lt;/code>。&lt;/h3>
&lt;p>Relabeling 的行为主要是围绕着 &lt;strong>Extracted Value(提取的值)&lt;/strong> 进行的。Relabeling 行为将会对已提取的值进行正则匹配以获取匹配结果，再根据匹配结果生成新的标签。
这些提取出来的待匹配的值，其实本质上就分为两类：&lt;strong>标签名称&lt;/strong> 与 &lt;strong>标签值&lt;/strong>。而正则匹配中，正则表达式的内容，则是由 &lt;strong>regex 字段&lt;/strong>指定的。&lt;/p>
&lt;ul>
&lt;li>**提取标签值进行匹配的行为。**从 &lt;code>source_labels&lt;/code> 字段指定的标签名中提取所有的标签值，作为待匹配的值。
&lt;ul>
&lt;li>注意：只有目标的 Discovered Labels 中包含 source_labels 字段中指定的标签，且这些标签的值能被 regex 字段的正则表达式匹配上，那么这些目标才会受到下列行为的影响。&lt;/li>
&lt;li>&lt;strong>replace&lt;/strong> # 为目标添加新标签，target_label 将会作为目标的新标签名，&lt;code>replacement&lt;/code> 字段的值将会作为目标的新标签名的值。
&lt;ul>
&lt;li>如果 regex 字段匹配不到任何内容，则不会进行替换。&lt;/li>
&lt;li>与 labelmap 行为不同，除了更改标签名之外，还可以更改标签的值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>keep&lt;/strong> # 保留匹配到的目标。即只采集匹配到的目标的指标。&lt;/li>
&lt;li>&lt;strong>drop&lt;/strong> # 删除匹配到的目标。即不采集匹配到的目标的指标。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**提取标签名进行匹配的行为。**从 Discovered Labels 中提取所有标签名，作为待匹配的值。
&lt;ul>
&lt;li>注意：只有目标的 Discovered Labels 中，标签名能被 regex 字段的正则表达式匹配上，那么这些目标才会受到下列行为的影响&lt;/li>
&lt;li>&lt;strong>labelmap&lt;/strong> # 为目标添加新标签，&lt;code>replacement&lt;/code> 字段的值将会作为目标的新标签名。
&lt;ul>
&lt;li>与 replace 行为不同，无法更改标签的值。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>labelkeep&lt;/strong> # 保留匹配到的标签。其余的标签移除&lt;/li>
&lt;li>&lt;strong>labeldrop&lt;/strong> # 移除匹配到的标签。其余的标签保留
&lt;ul>
&lt;li>注意：labeldrop 和 labelkeep 这两个行为与 keep 和 drop 不同，仅仅是用来删除时间序列中某些标签的。小心使用这两个行为，以确保标签被删除后，指标仍然具有唯一的标签。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>其他行为。&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>hashmod&lt;/strong> # 设置 target_label 为的 modulus 哈希值的 source_labels，通过对指定 source_labels 进行 hash 计算，的出来一个新的 hash 值写入的 target_label 中。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>action 不同的值代表不同的行为，而不同的行为也决定 relabel_configs 下可用的字段也不同。比如 labelkeep 行为，就无需 source_labels 等字段。&lt;/li>
&lt;li>当 action 字段的值为 &lt;code>replace&lt;/code>, &lt;code>keep&lt;/code>, &lt;code>drop&lt;/code>, &lt;code>labelmap&lt;/code>,&lt;code>labeldrop&lt;/code>、&lt;code>labelkeep&lt;/code> 时，regex 字段是必须存在的。The regex is anchored on both ends. To un-anchor the regex, use &lt;code>.*&amp;lt;regex&amp;gt;.*&lt;/code>。&lt;/li>
&lt;/ul>
&lt;h3 id="source_labels--labelname----指定一个或多个标签提取这些标签的值作为待匹配的值">source_labels: [ &lt;!-- raw HTML omitted -->, &amp;hellip; ] # 指定一个或多个标签，提取这些标签的值作为待匹配的值。&lt;/h3>
&lt;ul>
&lt;li>source_labels 可以有多个，若指定多个标签，则多个标签的值将会组合在一起作为待匹配的值，并以 &lt;code>separator&lt;/code> 字段指定的分隔符分隔。&lt;/li>
&lt;/ul>
&lt;h3 id="separator-string--指定-source_labels-字段提取出来的所有标签值之间的分隔符默认值-">separator: &lt;!-- raw HTML omitted --> # 指定 &lt;code>source_labels&lt;/code> 字段提取出来的所有标签值之间的分隔符。&lt;code>默认值： ;&lt;/code>。&lt;/h3>
&lt;h3 id="regex-regex--针对提取出来的值进行正则表达式的匹配默认值ie匹配提取出来的所有值并将这些值放入一个组里">regex: &lt;!-- raw HTML omitted --> # 针对提取出来的值进行正则表达式的匹配。&lt;code>默认值：(.*)&lt;/code>，i.e.匹配提取出来的所有值，并将这些值放入一个组里。&lt;/h3>
&lt;h3 id="replacement-string--指定要写入新标签的标签值默认值1">replacement: &lt;!-- raw HTML omitted --> # 指定要写入新标签的标签值。&lt;code>默认值：$1&lt;/code>。&lt;/h3>
&lt;ul>
&lt;li>STRING 中可以引用 regex 字段的值，引用方式是正则表达式中的组引用。i.e.regex 字段中的第一个 ()，与正则表达式对 () 引用的概念相同，${0} 表示所有()中的值。&lt;/li>
&lt;/ul>
&lt;h3 id="modulus-uint64--去-source_labels-值的哈希值的模数">modulus: &lt;!-- raw HTML omitted --> # 去 source_labels 值的哈希值的模数&lt;/h3>
&lt;h3 id="target_label-labelname--指定一个新标签名replacement-字段的值会作为名为-labelname-这个标签的标签值">target_label: &lt;!-- raw HTML omitted --> # 指定一个新标签名。replacement 字段的值会作为名为 LabelName 这个标签的标签值。&lt;/h3>
&lt;h2 id="action-字段下各种行为的特殊说明">action 字段下各种行为的特殊说明&lt;/h2>
&lt;h3 id="labelmap">labelmap&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">regex&lt;/span>: &lt;span style="color:#ae81ff">__meta_kubernetes_(namespace)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">action&lt;/span>: &lt;span style="color:#ae81ff">labelmap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">replacement&lt;/span>: &lt;span style="color:#ae81ff">$1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iyi5xg/1616045780763-37c765c1-bf4b-49db-8b05-e469a00618f8.png" alt="">&lt;/p>
&lt;p>这个行为跟映射这个词特别搭，就是将通过正则表达式匹配到的标签，生成新的标签。&lt;/p>
&lt;blockquote>
&lt;p>注意：不能这么玩 &lt;code>regex: (__meta_kubernetes_namespace)&lt;/code>，因为 Target Labels 是要添加给采集到的 Metrics 上的，不能使用 &lt;code>__&lt;/code> 符号开头的标签。&lt;/p>
&lt;/blockquote>
&lt;h2 id="relabel-配置的工作方式概述">relabel 配置的工作方式概述&lt;/h2>
&lt;ol>
&lt;li>根据 action 字段指定的 Relabeling 行为，来提取待匹配的值。&lt;/li>
&lt;li>使用 regex 字段指定的正则表达式对这些提取出来的值进行匹配，匹配结果将会根据不同的行为，而作用在不用的地方。&lt;/li>
&lt;li>relabel 机制是在抓取时间序列数据与存储时间序列数据之间发生的，一般情况，每个 target 刚创建完，Prometheus 都会自动将 &lt;strong>address&lt;/strong> 标签的值写入到 instance 标签中。&lt;/li>
&lt;li>其实，没有 source_label 也是可以的，relabel 本质是定义一个标签，而不是纯粹的替换，比如我不指定 source_label 字段，只指定 target_label 和 replacement 字段，就相当于是为这个 Metric 添加了一个标签&lt;/li>
&lt;li>所谓的 relabel，并不是绝对的替换，更像是定义 label&lt;/li>
&lt;li>所以，当我们在使用 Relabeling 功能时，首先应该先想自己到底要干什么，然后先决定 action 的值，再写其他的。
&lt;ol>
&lt;li>比如我想修改标签名，那么可用的 action 就是 replace 或者 labelmap，选择好具体的行为，再根据改行为支持的字段，写其它的。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h1 id="最简单的配置样例">最简单的配置样例&lt;/h1>
&lt;p>这些原始标签可以在配置中通过 relabel_configs 的配置段进行更改，这样这些标签的值在 proemetheus 存储起来之后，就会以新的标签标示&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">global&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scrape_interval&lt;/span>: &lt;span style="color:#ae81ff">15s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">evaluation_interval&lt;/span>: &lt;span style="color:#ae81ff">15s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;prometheus&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">static_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">targets&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">localhost&lt;/span>: &lt;span style="color:#ae81ff">9090&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">relabel_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">action&lt;/span>: &lt;span style="color:#ae81ff">replace&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">source_labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">__metrics_path__&lt;/span> &lt;span style="color:#75715e"># 指定原始标签&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">regex&lt;/span>: &lt;span style="color:#ae81ff">(.*)&lt;/span> &lt;span style="color:#75715e"># 指定原始标签值中要匹配的字符串&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">replacement&lt;/span>: &lt;span style="color:#ae81ff">$1&lt;/span> &lt;span style="color:#75715e"># 将原始标签值匹配到的字符串赋值给新标签&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">target_label&lt;/span>: &lt;span style="color:#ae81ff">metricsPath&lt;/span> &lt;span style="color:#75715e"># 指定原始标签替换为的目标标签&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下图的示例，就是将原始的 &lt;strong>metrics_path&lt;/strong> 标签重新配置为新的 metricsPath 标签，新标签的值就是原始标签的值
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iyi5xg/1616045780743-579762c3-abaa-4adf-99f8-3574b88460c2.jpeg" alt="">&lt;/p>
&lt;h2 id="高级样例">高级样例&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iyi5xg/1616045780735-c4c388d8-5602-4ffa-8c95-c78a4ff338d1.jpeg" alt="">&lt;/p>
&lt;h3 id="过滤-target">过滤 target&lt;/h3>
&lt;h4 id="使用-keep-行为保留标签值匹配-regex-的-targets">使用 keep 行为，保留标签值匹配 regex 的 targets&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#ae81ff">…&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cephs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">relabel_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">action&lt;/span>: &lt;span style="color:#ae81ff">keep&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">source_labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">__address__&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">regex&lt;/span>: &lt;span style="color:#ae81ff">ceph01.*&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>relabel 结果可以在 Prometheus 网页的 status/ Service Discovery 中查看
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iyi5xg/1616045780731-a742cbc1-1a16-445a-8b17-1b0561db43e7.webp" alt="">&lt;/p>
&lt;h4 id="使用-drop-行为丢弃匹配-regex-的-targets">使用 drop 行为，丢弃匹配 regex 的 Targets&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#ae81ff">…&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cephs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">relabel_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">action&lt;/span>: &lt;span style="color:#ae81ff">drop&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">source_labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">__address__&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">regex&lt;/span>: &lt;span style="color:#ae81ff">ceph01.*&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iyi5xg/1616045780860-e6406a1b-4bc1-4ba8-921e-39949436a028.webp" alt="">&lt;/p>
&lt;h3 id="删除标签">删除标签&lt;/h3>
&lt;h4 id="使用-labeldrop-行为将标签名为-job-的标签删除">使用 labeldrop 行为，将标签名为 job 的标签删除&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">…&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cephs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">relabel_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">regex&lt;/span>: &lt;span style="color:#ae81ff">job&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">action&lt;/span>: &lt;span style="color:#ae81ff">labeldrop&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iyi5xg/1616045780745-ad5eb6aa-c37b-431c-8593-ffb5ab8ff40e.webp" alt="">
labelKeep 和 labeldrop 不操作 __ 开头的标签，要操作需要先改名&lt;/p>
&lt;h3 id="修改-label-名">修改 label 名&lt;/h3>
&lt;h4 id="使用-replace-行为将-scheme-标签改名为-protocol">使用 replace 行为，将 scheme 标签改名为 protocol&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">…&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cephs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">relabel_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">action&lt;/span>: &lt;span style="color:#ae81ff">replace&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">source_labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">__scheme__&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">regex&lt;/span>: &lt;span style="color:#ae81ff">(http)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">target_label&lt;/span>: &lt;span style="color:#ae81ff">procotol&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iyi5xg/1616045780754-bd537921-de9b-4cf6-b665-6951e6a4329c.webp" alt="">
这里可以是多个 source_labels，只有值匹配到 regex，才会进行替换&lt;/p>
&lt;h4 id="使用-labelmap-行为将原始标签的一部分转换为-target-标签这一功能-replace-无法实现">使用 labelmap 行为，将原始标签的一部分转换为 target 标签，这一功能 replace 无法实现&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">…&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;sd_file_mysql&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">file_sd_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">files&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">mysql.yml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">refresh_interval&lt;/span>: &lt;span style="color:#ae81ff">1m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">relabel_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">action&lt;/span>: &lt;span style="color:#ae81ff">labelmap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">regex&lt;/span>: &lt;span style="color:#ae81ff">(.*)(address)(.*)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">replacement&lt;/span>: &lt;span style="color:#ae81ff">${2}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iyi5xg/1616045780764-cc349a0e-af4b-4b83-b39d-6188ca93da4f.webp" alt="">&lt;/p>
&lt;h3 id="修改-label-值">修改 label 值&lt;/h3>
&lt;p>配置 k8s 服务发现&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">…&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;sd_k8s_nodes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">kubernetes_sd_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">role&lt;/span>: &lt;span style="color:#ae81ff">node&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">bearer_token_file&lt;/span>: &lt;span style="color:#ae81ff">bearer_token&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">tls_config&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ca_file&lt;/span>: &lt;span style="color:#ae81ff">ca.crt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespaces&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">names&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">api_server&lt;/span>: &lt;span style="color:#ae81ff">https://master01:6443&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>服务发现完成后，默认 node 的 port 是 10250，会无法取得数据，同通过 relabel 修改标签.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">relabel_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">source_labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">__address__&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">regex&lt;/span>: &lt;span style="color:#ae81ff">(.*)\:10250&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">replacement&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;${1}:10255&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">target_label&lt;/span>: &lt;span style="color:#ae81ff">__address__&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iyi5xg/1616045780766-2db0040a-e0ba-4b36-81e7-c1e1ed4a81cd.webp" alt="">&lt;/p>
&lt;h3 id="多标签合并">多标签合并&lt;/h3>
&lt;p>标签合并，可以将多个源标签合并为一个目标标签，可以取源标签的值，也可以进行 hash，用户 target 分组
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iyi5xg/1616045780757-35f7df16-b3a1-4666-8b4a-ee755a1d6115.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>将多个标签的值进行 hash，形成一个 target 标签，只要 target 标签一致，则表示源标签一致，可以用来实现 prometheus 的负载均衡&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">scrape_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">…&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">job_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;sd_file_mysql&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">file_sd_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">files&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">mysql.yml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">refresh_interval&lt;/span>: &lt;span style="color:#ae81ff">1m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">relabel_configs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">action&lt;/span>: &lt;span style="color:#ae81ff">hashmod&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">source_labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">__scheme__&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">__metrics_path__&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">modulus&lt;/span>: &lt;span style="color:#ae81ff">64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">target_label&lt;/span>: &lt;span style="color:#ae81ff">hash_id&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iyi5xg/1616045780783-56416a5f-6ee9-4c58-97b8-d99731d0fc9b.webp" alt="">&lt;/p>
&lt;h2 id="完整案例">完整案例&lt;/h2>
&lt;p>以下是一个完整的 relabel 案例，这个案例包括&lt;/p>
&lt;ul>
&lt;li>根据标签值过滤 target&lt;/li>
&lt;li>合并标签值，并进行正则匹配&lt;/li>
&lt;li>修改标签名&lt;/li>
&lt;li>直接添加标签名&lt;/li>
&lt;/ul>
&lt;p>这个案例说明源标签是可以重复使用的
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/iyi5xg/1616045780790-516771ee-6fe1-49bf-aeb5-ee033ba1f35f.webp" alt="">&lt;/p></description></item></channel></rss>