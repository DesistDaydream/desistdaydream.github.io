<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – Redis 高可用</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Redis/Redis-%E9%AB%98%E5%8F%AF%E7%94%A8/</link><description>Recent content in Redis 高可用 on 断念梦</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Redis/Redis-%E9%AB%98%E5%8F%AF%E7%94%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Redis 高可用</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Redis/Redis-%E9%AB%98%E5%8F%AF%E7%94%A8/Redis-%E9%AB%98%E5%8F%AF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Redis/Redis-%E9%AB%98%E5%8F%AF%E7%94%A8/Redis-%E9%AB%98%E5%8F%AF%E7%94%A8/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://blog.jboost.cn/redis-cluster.html">原文&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/129640817">知乎&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247492218&amp;amp;idx=1&amp;amp;sn=8e233cf3c3abd0e6821262d1c78b03d1&amp;amp;chksm=eac6c353ddb14a4535ae92f911ae846592066bf9250b9aca4d91287015de8b23347cb56838ce&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1123S90JeR1nwKagOdJBlQTz&amp;amp;sharer_sharetime=1606090661231&amp;amp;sharer_shareid=09464b4a0389b967659ba78076a1ef58&amp;amp;key=48765414c6ece973eab40bd813ac84f36f02f86a2b622e5efcf4fb98864fdb95a49286689ce7513bf3642cc2a2b6d4bd4235c0de418caee7320bf928f76e57b65a7c762b34b8e80ed88a847524e64e1d6e08271ee31db62eb4ff0bce50cdc03f2b4161ba26993d58b1f19972154a004ce4cadfca3a79f41936616473cacfeff7&amp;amp;ascene=1&amp;amp;uin=MTI5NTMzMzA0MQ%3D%3D&amp;amp;devicetype=Windows+10+x64&amp;amp;version=6300002f&amp;amp;lang=zh_CN&amp;amp;exportkey=AanBDsftQoVwZuEgK1A5lo8%3D&amp;amp;pass_ticket=S1%2BMQ7vYsbZSNuJMJOqmLPRlt4Y3dQwyWaD%2FAmp3sq1Yd7omWT6hEhxkL9s%2BaMxR&amp;amp;wx_header=0">微信公众号&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Redis 支持三种高可用方案&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Redis/Redis%20%E9%AB%98%E5%8F%AF%E7%94%A8/Replication(%E5%A4%8D%E5%88%B6)%20%E6%A8%A1%E5%BC%8F.md">Replication(复制) 模式&lt;/a>
&lt;ul>
&lt;li>实际上，该模式并不是绝对的高可用，仅仅保证了数据的不丢失&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Redis/Redis%20%E9%AB%98%E5%8F%AF%E7%94%A8/Sentinel(%E5%93%A8%E5%85%B5)%20%E6%A8%A1%E5%BC%8F.md">Sentinel(哨兵) 模式&lt;/a>&lt;/li>
&lt;li>Cluster(集群) 模式&lt;/li>
&lt;/ul>
&lt;h1 id="cluster集群">Cluster(集群)&lt;/h1>
&lt;p>&lt;a href="http://www.redis.cn/topics/cluster-tutorial.html">http://www.redis.cn/topics/cluster-tutorial.html&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://redis.io/topics/cluster-tutorial">https://redis.io/topics/cluster-tutorial&lt;/a>&lt;/p>
&lt;h2 id="客户端操作原理请求路由原理">客户端操作原理(请求路由原理)&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gnlint/1616134822977-6bf24d85-a95a-4729-8807-b5c63d74e9a7.jpeg" alt="">&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/gnlint/1616134822986-56d8d02c-0433-4df5-a829-8e7fb0435fb0.jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>请求重定向&lt;/li>
&lt;/ol>
&lt;p>在集群模式下，Redis 接收任何键相关命令时首先计算键对应的槽，再根据槽找出所对应的节点，如果节点是自身，则处理键命令；否则回复 MOVED 重定向错误，通知客户端请求正确的节点。这个过程称为 MOVED 重定向。&lt;/p>
&lt;pre>&lt;code># 如果key经过计算后，其分配的slot就在当前节点，那么可以请求成功，否则，回复重定向消息
[root@node01 redis]# redis-cli -h 10.0.0.100 -p 6379
10.0.0.100:6379&amp;gt; set name tom
OK
10.0.0.100:6379&amp;gt; set age 20
(error) MOVED 741 10.0.0.101:6379
&lt;/code>&lt;/pre>
&lt;p>重定向信息包含了键所对应的槽以及负责该槽的节点地址，根据这些信息客户端就可以向正确的节点发起请求。在 10.0.0.101:6379 节点上成功执行之前的命令：&lt;/p>
&lt;pre>&lt;code>[root@node02 redis]# redis-cli -h 10.0.0.101 -p 6379
10.0.0.101:6379&amp;gt; set age 20
OK
&lt;/code>&lt;/pre>
&lt;p>使用 redis-cli 命令时，可以加入-c 参数支持自动重定向，简化手动发起重定向的操作：&lt;/p>
&lt;pre>&lt;code>[root@node01 redis]# redis-cli -c -h 10.0.0.100 -p 6379
10.0.0.100:6379&amp;gt; set age 30
-&amp;gt; Redirected to slot [741] located at 10.0.0.101:6379
OK
&lt;/code>&lt;/pre>
&lt;p>redis-cli 自动帮我们连接到正确的节点执行命令，这个过程是在 redis-cli 内部维护，实质上是 client 端接到 MOVED 信息指定的节点之后再次发起请求，并不是在当前 Redis 节点中完成请求转发，节点对于不属于它的键命令只回复重定向响应，并不负责转发。&lt;/p>
&lt;p>键命令执行步骤主要分两步：&lt;/p>
&lt;ol>
&lt;li>计算槽&lt;/li>
&lt;/ol>
&lt;p>Redis 首先需要计算键所对应的槽，根据键的有效部分使用 CRC16 函数计算出散列值，再取对 16383 的余数，得到槽的编号，这样每个键都可以映射到 0~16383 槽范围内&lt;/p>
&lt;pre>&lt;code>10.0.0.101:6379&amp;gt; cluster keyslot age
(integer) 741
&lt;/code>&lt;/pre>
&lt;p>Redis 集群相对单机在功能上存在一些限制，限制如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>key 批量操作支持有限，如 mset、mget，目前只支持具有相同 slot 值的 key 执行批量操作。对于映射为不同 slot 值的 key 由于执行 mget、mget 等操作可能存在于多个节点上因此不被支持&lt;/p>
&lt;/li>
&lt;li>
&lt;p>key 事务操作支持有限，同理只支持多 key 在同一节点上的事务操作，当多个 key 分布在不同的节点上时无法使用事务功能&lt;/p>
&lt;/li>
&lt;li>
&lt;p>key 作为数据分区的最小粒度，因此不能将一个大的键值对象如 hash、list 等映射到不同的节点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不支持多数据库空间，单机下的 Redis 可以支持 16 个数据库，集群模式下只能使用一个数据库空间，即 db0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构&lt;/p>
&lt;p>10.0.0.102:6379&amp;gt; mget name age
(error) CROSSSLOT Keys in request don&amp;rsquo;t hash to the same slot&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>但通常会有这样的需求，例如把一个用户的信息存入到一个 slot 中，这是可以这样设置：&lt;/p>
&lt;pre>&lt;code>10.0.0.102:6379&amp;gt; set user:{user1}:name tony
-&amp;gt; Redirected to slot [8106] located at 10.0.0.100:6379
OK
10.0.0.100:6379&amp;gt; set user:{user1}:age 20
OK
10.0.0.100:6379&amp;gt; cluster keyslot user:{user1}:name
(integer) 8106
10.0.0.100:6379&amp;gt; cluster keyslot user:{user1}:age
(integer) 8106
10.0.0.100:6379&amp;gt; mget user:{user1}:name user:{user1}:age
1) &amp;quot;tony&amp;quot;
2) &amp;quot;20&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>这样，这两个 key 在计算 hash 值的时候，不会根据整个 key 来计算，而是只是拿{}中的内容的来计算，这样它们的 hash 值一定是相同的，就可以分配到同一个 slot 中，{}中的内容称为 hash_tag&lt;/p>
&lt;ol>
&lt;li>查找槽所对应的节点&lt;/li>
&lt;/ol>
&lt;p>Redis 计算得到键对应的槽后，需要查找槽所对应的节点。集群内通过消息交换每个节点都会知道所有节点的槽信息。&lt;/p>
&lt;p>根据 MOVED 重定向机制，客户端可以随机连接集群内任一 Redis 获取键所在节点，这种客户端又叫 Dummy(傀 儡)客户端，它优点是代码实现简单，对客户端协议影响较小，只需要根据重定向信息再次发送请求即可。但是它的弊端很明显，每次执行键命令前都要到 Redis 上进行重定向才能找到要执行命令的节点，额外增加了 IO 开销，这不是 Redis 集群高效的使用方式。正因为如此通常集群客户端都采用另一种实现：Smart 客户端&lt;/p>
&lt;h2 id="cluster-模式的优缺点">Cluster 模式的优缺点&lt;/h2>
&lt;p>优点：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>无中心架构，数据按照 slot 分布在多个节点。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>集群中的每个节点都是平等的关系，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可线性扩展到 1000 多个节点，节点可动态添加或删除&lt;/p>
&lt;/li>
&lt;li>
&lt;p>能够实现自动故障转移，节点之间通过 gossip 协议交换状态信息，用投票机制完成 slave 到 master 的角色转换&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>缺点：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>客户端实现复杂，驱动要求实现 Smart Client，缓存 slots mapping 信息并及时更新，提高了开发难度。目前仅 JedisCluster 相对成熟，异常处理还不完善，比如常见的“max redirect exception”&lt;/p>
&lt;/li>
&lt;li>
&lt;p>节点会因为某些原因发生阻塞（阻塞时间大于 cluster-node-timeout）被判断下线，这种 failover 是没有必要的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据通过异步复制，不保证数据的强一致性&lt;/p>
&lt;/li>
&lt;li>
&lt;p>slave 充当“冷备”，不能缓解读压力&lt;/p>
&lt;/li>
&lt;li>
&lt;p>批量操作限制，目前只支持具有相同 slot 值的 key 执行批量操作，对 mset、mget、sunion 等操作支持不友好&lt;/p>
&lt;/li>
&lt;li>
&lt;p>key 事务操作支持有线，只支持多 key 在同一节点的事务操作，多 key 分布不同节点时无法使用事务功能&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不支持多数据库空间，单机 redis 可以支持 16 个 db，集群模式下只能使用一个，即 db 0&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Redis Cluster 模式不建议使用 pipeline 和 multi-keys 操作，减少 max redirect 产生的场景。&lt;/p>
&lt;h1 id="sentinel-与-cluster-的区别">Sentinel 与 Cluster 的区别&lt;/h1>
&lt;p>……我感觉楼主自己对 redis 的理解是有一定问题的，但提的问题其实是个好问题，而回帖的大部分人没有回应准确楼主的疑问，少部分评论我看一眼就明白，但楼主可能是想不到的。&lt;/p>
&lt;p>那咱们把集群和哨兵能解决的问题列出来，就比较清楚了。&lt;/p>
&lt;p>哨兵： 哨兵仅仅提供故障切换能力，在这之上，对使用方来说，和单机的 redis 是完全一样的。&lt;/p>
&lt;p>集群： 集群最主要的，解决的是一个“数据分片”的问题，它能把 redis 的数据分散到不同的 slot 里，而不是都集中在一台机器的内存里。这样也就给单进程单线程、纯内存的 redis 提供了水平扩容的能力。&lt;/p>
&lt;p>但是这是有代价的， 一部分命令无法跨节点执行，比如 zunionstore 等一些命令，它涉及多个 key，因此在集群状态下，需要自行保证这些 key 都在一个 slot 上；&lt;/p>
&lt;p>再比如 watch exec， 在单节点或哨兵场景下可以用，但集群模式下是不能使用的。&lt;/p>
&lt;p>还有一些命令，在集群状态下虽能执行或有替代方案，但会丧失原子性。 比如 mget 等。&lt;/p>
&lt;p>所以楼主的疑问是为什么集群模式没有取代哨兵模式，是因为哨兵模式作为单节点+高可用的方案而言，确实有集群模式实现不了的功能。&lt;/p>
&lt;p>……想换行不小心发出去了。&lt;/p>
&lt;p>除了功能上的区别以外，集群模式显然比哨兵模式更重、需要更多的资源去运行；再就是部署运维复杂度也是更高的。&lt;/p>
&lt;p>而哨兵和单节点，一般来说除了配置稍有区别以外，绝大部分业务代码是可以相容的，无需特地修改。&lt;/p>
&lt;p>而现有的代码如果使用了集群模式不支持的那些命令，那么集群模式下是无法正常工作的。&lt;/p>
&lt;p>所以目前哨兵模式仍然被广泛使用，没有被集群模式彻底替代。&lt;/p>
&lt;p>我们公司就是用哨兵了。为什么不用 Cluster 。因为费钱。集群需要机器太多了。本身数据量就不大。分片功能不需要。 就只是想要一个高可用的 redis 。 用哨兵符合需求了。 只需要三台机器。而且三台机器还部署了 3 个 zookeeper 和 kafka 。都是数据量不大。 节约机器钱&lt;/p></description></item><item><title>Docs: Redis 高可用部署</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Redis/Redis-%E9%AB%98%E5%8F%AF%E7%94%A8/Redis-%E9%AB%98%E5%8F%AF%E7%94%A8%E9%83%A8%E7%BD%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Redis/Redis-%E9%AB%98%E5%8F%AF%E7%94%A8/Redis-%E9%AB%98%E5%8F%AF%E7%94%A8%E9%83%A8%E7%BD%B2/</guid><description>
&lt;h1 id="docker-部署-redis-高可用">Docker 部署 Redis 高可用&lt;/h1>
&lt;p>Docker 部署 Redis Sentinel 模式&lt;/p>
&lt;p>Sentinel 模式至少需要 3 个节点，所以这里假设有如下三个节点&lt;/p>
&lt;ul>
&lt;li>
&lt;p>172.19.42.231&lt;/p>
&lt;/li>
&lt;li>
&lt;p>172.19.42.232&lt;/p>
&lt;/li>
&lt;li>
&lt;p>172.19.42.233&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="创建配置文件与存储所在路径">创建配置文件与存储所在路径&lt;/h3>
&lt;pre>&lt;code>mkdir -p /opt/redis/config
mkdir -p /opt/redis/data
chmod 777 /opt/redis/data
&lt;/code>&lt;/pre>
&lt;h3 id="启动-redis">启动 Redis&lt;/h3>
&lt;p>master 节点配置&lt;/p>
&lt;pre>&lt;code>cat &amp;gt; /opt/redis/config/redis.conf &amp;lt;&amp;lt;EOF
save 900 1
maxmemory 1G
EOF
chmod 666 /opt/redis/config/redis.conf
&lt;/code>&lt;/pre>
&lt;p>replica 节点配置&lt;/p>
&lt;pre>&lt;code>cat &amp;gt; /opt/redis/config/redis.conf &amp;lt;&amp;lt;EOF
save 900 1
maxmemory 1G
replicaof 172.19.42.231 6379
EOF
chmod 666 /opt/redis/config/redis.conf
&lt;/code>&lt;/pre>
&lt;p>启动 Redis&lt;/p>
&lt;pre>&lt;code>docker run -d --name redis \
--network=host \
-v /opt/redis/config:/etc/redis \
-v /opt/redis/data:/data \
redis:5.0.10-alpine \
/etc/redis/redis.conf
&lt;/code>&lt;/pre>
&lt;h3 id="启动-redis-sentinel">启动 Redis Sentinel&lt;/h3>
&lt;p>所有节点配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /opt/redis/config/sentinel.conf &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">sentinel monitor mymaster 172.19.42.231 6379 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">sentinel down-after-milliseconds mymaster 60000
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">sentinel failover-timeout mymaster 180000
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">sentinel parallel-syncs mymaster 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>chmod &lt;span style="color:#ae81ff">666&lt;/span> /opt/redis/config/sentinel.conf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>启动 Sentinel&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -d --name redis-sentinel &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --network&lt;span style="color:#f92672">=&lt;/span>host &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /opt/redis/config:/etc/redis &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> redis:5.0.10-alpine &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> /etc/redis/sentinel.conf &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --sentinel
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="kubernetes-中部署-redis-高可用">Kubernetes 中部署 Redis 高可用&lt;/h1>
&lt;h2 id="helm-官方维护的-redis-ha-chart">Helm 官方维护的 Redis-HA Chart&lt;/h2>
&lt;p>参考：&lt;a href="https://github.com/helm/charts/tree/master/stable/redis-ha">Helm 官方网站&lt;/a>、&lt;a href="https://github.com/DandyDeveloper/charts">GitHub&lt;/a>、&lt;a href="https://artifacthub.io/packages/helm/dandydev-charts/redis-ha">ArtifactHub&lt;/a>&lt;/p>
&lt;p>Grafana Dashboard:11835&lt;/p>
&lt;h2 id="第三方-redis-operator-部署-cluster-模式-redis">第三方 redis operator 部署 Cluster 模式 Redis&lt;/h2>
&lt;p>&lt;a href="https://github.com/ucloud/redis-cluster-operator">https://github.com/ucloud/redis-cluster-operator&lt;/a> ucloud 出品&lt;/p>
&lt;h2 id="第三方-redis-operator-部署-sentinel-模式-redis">第三方 redis operator 部署 Sentinel 模式 redis&lt;/h2>
&lt;p>&lt;a href="https://github.com/spotahome/redis-operator">https://github.com/spotahome/redis-operator&lt;/a>，通过 operator 可以简单得创建出 6 个 pod，3 个 redis 节点，3 个 sentinel 节点。&lt;/p>
&lt;p>ucloud 基于该项目推出了一个类似的：&lt;a href="https://github.com/ucloud/redis-operator">https://github.com/ucloud/redis-operator&lt;/a>&lt;/p>
&lt;p>部署所需 yaml 在 github 上&lt;/p>
&lt;p>创建 operator&lt;/p>
&lt;pre>&lt;code>kubectl apply -f https://raw.githubusercontent.com/spotahome/redis-operator/master/example/operator/all-redis-operator-resources.yaml
&lt;/code>&lt;/pre>
&lt;p>配置 redis 密码认证&lt;/p>
&lt;pre>&lt;code># “密码”修改为自己想设置的密码
echo -n &amp;quot;密码&amp;quot; &amp;gt; password
kubectl create -n redis secret generic redis-auth --from-file=password
&lt;/code>&lt;/pre>
&lt;p>部署 redis&lt;/p>
&lt;pre>&lt;code>kubectl create -f https://raw.githubusercontent.com/spotahome/redis-operator/master/example/redisfailover/basic.yaml
&lt;/code>&lt;/pre>
&lt;p>Bitnami 官方用于部署 redis 的 helm chart&lt;/p>
&lt;p>&lt;a href="https://github.com/bitnami/charts/tree/master/bitnami/redis/">https://github.com/bitnami/charts/tree/master/bitnami/redis/&lt;/a>&lt;/p>
&lt;p>获取 charts 文件&lt;/p>
&lt;ol>
&lt;li>
&lt;p>helm repo add bitnami &lt;a href="https://charts.bitnami.com/bitnami">https://charts.bitnami.com/bitnami&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>helm pull bitnami/redis&lt;/p>
&lt;/li>
&lt;li>
&lt;p>tar -zxvf redis-XX.X.X.tgz&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修改值文件，参考：&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>部署 redis&lt;/p>
&lt;ol>
&lt;li>helm install redis -n redis &amp;ndash;set password=oc123 .&lt;/li>
&lt;/ol>
&lt;p>Bitnami 版问题：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>无法故障恢复，删除 pod 后， master 无法切换&lt;/p>
&lt;/li>
&lt;li>
&lt;p>是有了安全环境容器，导致容器内无法读取 /proc/sys/net/core/somaxconn 参数的值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>问题跟踪：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/bitnami/charts/issues/3700">https://github.com/bitnami/charts/issues/3700&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/bitnami/charts/issues/4569">https://github.com/bitnami/charts/issues/4569&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: Replication(复制) 模式</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Redis/Redis-%E9%AB%98%E5%8F%AF%E7%94%A8/Replication%E5%A4%8D%E5%88%B6-%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Redis/Redis-%E9%AB%98%E5%8F%AF%E7%94%A8/Replication%E5%A4%8D%E5%88%B6-%E6%A8%A1%E5%BC%8F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://redis.io/topics/replication">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ol>
&lt;li>基本原理&lt;/li>
&lt;/ol>
&lt;p>主从复制模式中包含 一个主数据库实例(master) 与 一个或多个从数据库实例(slave)，如下图&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/equ0le/1616134781068-8b8f1a94-6405-4bea-98b3-5627a9d8ff17.png" alt="">&lt;/p>
&lt;p>客户端可对主数据库进行读写操作，对从数据库进行读操作，主数据库写入的数据会实时自动同步给从数据库。&lt;/p>
&lt;p>具体工作机制为：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>slave 启动后，向 master 发送 SYNC 命令，master 接收到 SYNC 命令后通过 bgsave 保存快照(即上文所介绍的 RDB 持久化)，并使用缓冲区记录保存快照这段时间内执行的写命令&lt;/p>
&lt;/li>
&lt;li>
&lt;p>master 将保存的快照文件发送给 slave，并继续记录执行的写命令&lt;/p>
&lt;/li>
&lt;li>
&lt;p>slave 接收到快照文件后，加载快照文件，载入数据&lt;/p>
&lt;/li>
&lt;li>
&lt;p>master 快照发送完后开始向 slave 发送缓冲区的写命令，slave 接收命令并执行，完成复制初始化&lt;/p>
&lt;/li>
&lt;li>
&lt;p>此后 master 每次执行一个写命令都会同步发送给 slave，保持 master 与 slave 之间数据的一致性&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>2. 部署示例&lt;/strong>&lt;/p>
&lt;p>redis.conf 的主要配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">###网络相关###&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># bind 127.0.0.1 # 绑定监听的网卡IP，注释掉或配置成0.0.0.0可使任意IP均可访问&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>protected-mode no &lt;span style="color:#75715e"># 关闭保护模式，使用密码访问&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>port &lt;span style="color:#ae81ff">6379&lt;/span> &lt;span style="color:#75715e"># 设置监听端口，建议生产环境均使用自定义端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>timeout &lt;span style="color:#ae81ff">30&lt;/span> &lt;span style="color:#75715e"># 客户端连接空闲多久后断开连接，单位秒，0表示禁用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">###通用配置###&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>daemonize yes &lt;span style="color:#75715e"># 在后台运行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pidfile /var/run/redis_6379.pid &lt;span style="color:#75715e"># pid进程文件名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>logfile /usr/local/redis/logs/redis.log &lt;span style="color:#75715e"># 日志文件的位置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">###RDB持久化配置###&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>save &lt;span style="color:#ae81ff">900&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#75715e"># 900s内至少一次写操作则执行bgsave进行RDB持久化&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>save &lt;span style="color:#ae81ff">300&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>save &lt;span style="color:#ae81ff">60&lt;/span> &lt;span style="color:#ae81ff">10000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 如果禁用RDB持久化，可在这里添加 save &amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rdbcompression yes &lt;span style="color:#75715e">#是否对RDB文件进行压缩，建议设置为no，以（磁盘）空间换（CPU）时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dbfilename dump.rdb &lt;span style="color:#75715e"># RDB文件名称&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dir /usr/local/redis/datas &lt;span style="color:#75715e"># RDB文件保存路径，AOF文件也保存在这里&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">###AOF配置###&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>appendonly yes &lt;span style="color:#75715e"># 默认值是no，表示不使用AOF增量持久化的方式，使用RDB全量持久化的方式&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>appendfsync everysec &lt;span style="color:#75715e"># 可选值 always， everysec，no，建议设置为everysec&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">###设置密码###&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>requirepass &lt;span style="color:#ae81ff">123456&lt;/span> &lt;span style="color:#75715e"># 设置复杂一点的密码&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>部署主从复制模式只需稍微调整 slave 的配置，在 redis.conf 中添加&lt;/p>
&lt;pre>&lt;code>replicaof 127.0.0.1 6379 # master的ip，port
masterauth 123456 # master的密码
replica-serve-stale-data no # 如果slave无法与master同步，设置成slave不可读，方便监控脚本发现问题
&lt;/code>&lt;/pre>
&lt;p>本示例在单台服务器上配置 master 端口 6379，两个 slave 端口分别为 7001,7002，启动 master，再启动两个 slave&lt;/p>
&lt;pre>&lt;code>[root@dev-server-1 master-slave]# redis-server master.conf
[root@dev-server-1 master-slave]# redis-server slave1.conf
[root@dev-server-1 master-slave]# redis-server slave2.conf
&lt;/code>&lt;/pre>
&lt;p>进入 master 数据库，写入一个数据，再进入一个 slave 数据库，立即便可访问刚才写入 master 数据库的数据。如下所示&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@dev-server-1 master-slave&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># redis-cli&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>127.0.0.1:6379&amp;gt; auth &lt;span style="color:#ae81ff">123456&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OK
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>127.0.0.1:6379&amp;gt; set site blog.jboost.cn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OK
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>127.0.0.1:6379&amp;gt; get site
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;blog.jboost.cn&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>127.0.0.1:6379&amp;gt; info replication
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Replication&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>role:master
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>connected_slaves:2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>slave0:ip&lt;span style="color:#f92672">=&lt;/span>127.0.0.1,port&lt;span style="color:#f92672">=&lt;/span>7001,state&lt;span style="color:#f92672">=&lt;/span>online,offset&lt;span style="color:#f92672">=&lt;/span>13364738,lag&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>slave1:ip&lt;span style="color:#f92672">=&lt;/span>127.0.0.1,port&lt;span style="color:#f92672">=&lt;/span>7002,state&lt;span style="color:#f92672">=&lt;/span>online,offset&lt;span style="color:#f92672">=&lt;/span>13364738,lag&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>127.0.0.1:6379&amp;gt; exit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@dev-server-1 master-slave&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># redis-cli -p 7001&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>127.0.0.1:7001&amp;gt; auth &lt;span style="color:#ae81ff">123456&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OK
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>127.0.0.1:7001&amp;gt; get site
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;blog.jboost.cn&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行 info replication 命令可以查看连接该数据库的其它库的信息，如上可看到有两个 slave 连接到 master&lt;/p>
&lt;p>&lt;strong>主从复制的优缺点&lt;/strong>&lt;/p>
&lt;p>优点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>master 能自动将数据同步到 slave，可以进行读写分离，分担 master 的读压力&lt;/p>
&lt;/li>
&lt;li>
&lt;p>master、slave 之间的同步是以非阻塞的方式进行的，同步期间，客户端仍然可以提交查询或更新请求&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>缺点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>不具备自动容错与恢复功能，master 或 slave 的宕机都可能导致客户端请求失败，需要等待机器重启或手动切换客户端 IP 才能恢复&lt;/p>
&lt;/li>
&lt;li>
&lt;p>master 宕机，如果宕机前数据没有同步完，则切换 IP 后会存在数据不一致的问题&lt;/p>
&lt;/li>
&lt;li>
&lt;p>难以支持在线扩容，Redis 的容量受限于单机配置&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: Sentinel 配置详解</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Redis/Redis-%E9%AB%98%E5%8F%AF%E7%94%A8/Sentinel-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Redis/Redis-%E9%AB%98%E5%8F%AF%E7%94%A8/Sentinel-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;p>参考：&lt;a href="https://redis.io/topics/sentinel#other-sentinel-options">官方文档 1&lt;/a>、&lt;/p>
&lt;p>Sentinel 的配置与 Redis 配置用法相同，当使用 &amp;ndash;sentinel 参数启动 redis 时，则 redis 程序加载配置文件时，将只会特定的配置信息&lt;/p>
&lt;h1 id="sentinel-配置环境">Sentinel 配置环境&lt;/h1>
&lt;h2 id="port-int--sentinel-监听的端口sentinel-之间使用该端口通讯">&lt;strong>port &amp;lt;INT&amp;gt;&lt;/strong> # Sentinel 监听的端口，Sentinel 之间使用该端口通讯&lt;/h2>
&lt;h2 id="sentinel-monitor-master-group-name-ip-port-quorum--指定-sentinel-要监听的-master">sentinel monitor &amp;lt;master-group-name&amp;gt; &amp;lt;IP&amp;gt; &amp;lt;PORT&amp;gt; &amp;lt;QUORUM&amp;gt; # 指定 Sentinel 要监听的 MASTER&lt;/h2>
&lt;p>&lt;code>sentinel montior mymaster 192.168.50.101 6379 1&lt;/code> 这个配置意味着，Sentinel 监控的目标 master 节点的 IP 为 192.168.50.101、端口为 6379，最后一个数字表示投票需要的&amp;quot;最少法定人数&amp;quot;。&lt;/p>
&lt;blockquote>
&lt;p>最少法定人数的理解：比如有 10 个 sentinal 哨兵都在监控某一个 master 节点，如果需要至少 6 个哨兵发现 master 挂掉后，才认为 master 真正 down 掉，那么这里就配置为 6，最小配置 1 台 master，1 台 slave，在二个机器上都启动 sentinal 的情况下，哨兵数只有 2 个，如果一台机器物理挂掉，只剩一个 sentinal 能发现该问题，所以这里配置成 1。&lt;/p>
&lt;/blockquote>
&lt;p>至于 mymaster 只是一个名字，可以随便起，但要保证下面使用同一个名字&lt;/p>
&lt;h2 id="sentinel-down-after-milliseconds-target-duration--监控目标的-sdown-等待时长单位毫秒">sentinel down-after-milliseconds &amp;lt;TARGET&amp;gt; &amp;lt;DURATION&amp;gt; # 监控目标的 SDOWN 等待时长。单位：毫秒&lt;/h2>
&lt;p>持续 DURATION 时间 TARGET 没响应，就认为 SDOWN。&lt;/p>
&lt;h2 id="sentinel-parallel-syncs-target-int--与监控目标并行同步数据的节点数">sentinel parallel-syncs &amp;lt;TARGET&amp;gt; &amp;lt;INT&amp;gt; # 与监控目标并行同步数据的节点数&lt;/h2>
&lt;p>如果 master 重新选出来后，其它 replica 节点能同时并行从新 master 同步缓存的节点数有多少个。该值越大，所有 replica 节点完成同步切换的整体速度越快，但如果此时正好有人在访问这些 replica，可能造成读取失败，影响面会更广。最保定的设置为 1，只同一时间，只能有一台干这件事，这样其它 replica 还能继续服务，但是所有 replica 全部完成缓存更新同步的进程将变慢。&lt;/p>
&lt;h2 id="sentinel-failover-timeout-mymaster-duration--故障恢复超时时长单位毫秒">sentinel failover-timeout mymaster &amp;lt;DURATION&amp;gt; # 故障恢复超时时长。单位：毫秒&lt;/h2>
&lt;p>在指定时间 DURATION 后，故障恢复如果没有成功，则再次进行 Failover 操作&lt;/p>
&lt;h1 id="配置示例">配置示例&lt;/h1>
&lt;pre>&lt;code>#
sentinel monitor mymaster 172.19.42.231 6379 2
sentinel down-after-milliseconds mymaster 60000
sentinel failover-timeout mymaster 180000
sentinel parallel-syncs mymaster 1
&lt;/code>&lt;/pre></description></item><item><title>Docs: Sentinel(哨兵) 模式</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Redis/Redis-%E9%AB%98%E5%8F%AF%E7%94%A8/Sentinel%E5%93%A8%E5%85%B5-%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Redis/Redis-%E9%AB%98%E5%8F%AF%E7%94%A8/Sentinel%E5%93%A8%E5%85%B5-%E6%A8%A1%E5%BC%8F/</guid><description>
&lt;h1 id="概述">概述&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://redis.io/topics/sentinel">官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.redis.cn/topics/sentinel.html">中文文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cnblogs.com/kevingrace/p/9004460.html">博客园大佬&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cnblogs.com/biglittleant/p/7770960.html">博客园大佬 2&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>Redis Sentinel(哨兵) 基于 Redis 的 Replication(复制) 模式，增加了一个名为 Sentinel 的管理程序&lt;/strong>，用来保存 Redis Replication 模式的架构信息，以及对外提供该信息。同时 sentinel 程序监控多台 Redis 状态，当 Redis 不可用时，Sentinel 将自动下线该 Redis。&lt;/p>
&lt;p>注意：Sentinel(哨兵) 模式必须基于 Replication 模式，否则没有任何意义。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ep6g3m/1616134767001-d94ca9de-6764-40ef-977f-4af0f094154f.png" alt="">&lt;/p>
&lt;p>注意：一套 Sentinel 是可以监听多套 Replication 模式的 Redis 的组合，这样可以有效节省资源，其中每套 Replication 模式的 Redis 会使用一个 master-name 作为一个标识。&lt;/p>
&lt;p>&lt;strong>客户端操作 Redis 原理&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>client 访问 sentinel 集群，获取 redis 集群 master 的 ip&lt;/p>
&lt;/li>
&lt;li>
&lt;p>client 连接 redis 集群的 master 对数据进行读写操作。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Redis Sentinel 为 Redis 提供了高可用性。这意味着，可以使用 Sentinel 程序部署 Redis，这种部署可以在无需人工干预的情况下抵抗某些类型的故障。Sentinel 具有以下特性：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Monitoring(监控)&lt;/strong># Sentinel 会不断检查指定的 master 和 replica 节点是否正常工作。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Notification(通知)&lt;/strong># 当 Sentinel 监控的 Redis 出现问题时，可以通过 API 向 人或程序 发送通知。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Automatic failover(自动故障转移)&lt;/strong># 如果 master 节点未按预期工作，则 Sentinel 将会启动 &lt;strong>Failover(故障转移)&lt;/strong> 过程。在这个过程中，replica 节点将会升级为 master 节点，其他的 replica 节点将使用新的 master 信息。&lt;/p>
&lt;ul>
&lt;li>在故障转移期间，所有 Redis 节点的配置文件、所有 Sentinel 节点的配置文件，都会被自动更新。正是由于这种机制，Sentinel 才可以正常完整自动故障转移流程。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Configuration provider(配置提供器)&lt;/strong> # Sentinel 作为客户端服务发现的权威来源：客户端连接到 Sentinels，以便询问负责特定服务的当前 Redis Master 节点的地址。如果发生故障转移，Sentinels 将报告新的地址。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="sentinel-配置">Sentinel 配置&lt;/h1>
&lt;p>&lt;strong>/etc/sentinel.conf&lt;/strong> # Sentinel 主程序的配置文件&lt;/p>
&lt;h2 id="基本配置示例">基本配置示例&lt;/h2>
&lt;pre>&lt;code>sentinel monitor mymaster 172.19.42.231 6379 2
sentinel down-after-milliseconds mymaster 60000
sentinel failover-timeout mymaster 180000
sentinel parallel-syncs mymaster 1
&lt;/code>&lt;/pre>
&lt;h1 id="sentinel-和-replicas-的自动发现机制">Sentinel 和 Replicas 的自动发现机制&lt;/h1>
&lt;p>参考：&lt;a href="https://redis.io/topics/sentinel#sentinels-and-replicas-auto-discovery">官方文档&lt;/a>&lt;/p>
&lt;p>虽然 Sentinel 集群中各个 Sentinel 都互相连接彼此来检查对方的可用性以及互相发送消息。但是不用为任何一个 Sentinel 手动配置其它的 Sentinel 的信息。因为 Sentinel 利用了 Redis 的 &lt;a href="https://www.yuque.com/go/doc/33188044">&lt;strong>Pub/Sub(发布/订阅)&lt;/strong>&lt;/a>** **机制去自动发现，监控了相同的 master 和 replica 的其他 Sentinel 节点。&lt;/p>
&lt;blockquote>
&lt;p>通过向名为&lt;code>__sentinel__:hello&lt;/code>的频道中发送消息来实现自动发现 Sentinel 节点的功能。&lt;/p>
&lt;/blockquote>
&lt;p>同样，也不需要在 Sentinel 中配置某个 master 的所有 replica 的地址，Sentinel 会通过询问 master 来得到这些 replica 的地址的。&lt;/p>
&lt;p>所以，Sentinel 具有两个发现机制&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Sentinel 发现监控相同目标的其他 Sentinel 节点&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Sentinel 发现监控目标的 Replica 节点&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>自动发现流程&lt;/p>
&lt;ul>
&lt;li>
&lt;p>每隔 2 秒钟，每个 Sentinel 向每个 master 和 replica 中的&lt;code>__sentinel__:hello&lt;/code> 频道，&lt;strong>发布&lt;/strong>一条消息，消息内容为发布消息的 Sentinel 的 IP、PORT、runid。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个 Sentinel 也&lt;strong>订阅&lt;/strong>了每个 master 和 replica 中的 &lt;code>__sentinel__:hello&lt;/code> 频道，以便发现未知的 Sentinel ，当检测到了新的 Sentinel ，则将其加入到自身维护的 master 监控列表中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个 Sentinel 发送的消息中也包含了其当前维护的最新的 master 配置。如果某个 Sentinel 发现自己的配置版本低于接收到的配置版本，则会用新的配置更新自己的 master 配置。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在添加一个新的 sentinel 前，sentinel 总是检查是否已经有 sentinel 与新的 sentinel 的进程号或者是地址是一样的。如果是那样，这个 sentinel 将会被删除，而把新的 sentinel 添加上去。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>自动发现后配置文件变化效果&lt;/p>
&lt;p>当我们想要启动 Sentienl 时，仅仅需要配置一些基本信息，以及要监控的目标 IP 与 PORT，即可使用该文件启动了。以该文件启动 Sentinel 后，Sentinel 将会根据自动发现功能，补全这些配置，效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 手动写的 Sentinel 运行时配置文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-1 config&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat sentinel.conf&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sentinel monitor mymaster 172.19.42.231 &lt;span style="color:#ae81ff">6379&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sentinel down-after-milliseconds mymaster &lt;span style="color:#ae81ff">60000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sentinel failover-timeout mymaster &lt;span style="color:#ae81ff">180000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sentinel parallel-syncs mymaster &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-1 config&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># docker restart redis-sentinel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>redis-sentinel
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Sentinel 启动后，配置文件变成如下样子&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 这就是根据自动发现机制，发现了其他的 sentinel 节点以及其他 replica 节点&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@master-1 config&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># cat sentinel.conf&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sentinel myid c3463c1f451f766b13947ea315f4f38e7c7296f0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sentinel deny-scripts-reconfig yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sentinel monitor mymaster 172.19.42.231 &lt;span style="color:#ae81ff">6379&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sentinel down-after-milliseconds mymaster &lt;span style="color:#ae81ff">60000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Generated by CONFIG REWRITE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>port &lt;span style="color:#ae81ff">26379&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dir &lt;span style="color:#e6db74">&amp;#34;/data&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sentinel config-epoch mymaster &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sentinel leader-epoch mymaster &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sentinel known-replica mymaster 172.19.42.232 &lt;span style="color:#ae81ff">6379&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sentinel known-replica mymaster 172.19.42.233 &lt;span style="color:#ae81ff">6379&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sentinel known-sentinel mymaster 172.19.42.233 &lt;span style="color:#ae81ff">26379&lt;/span> bda131accb328d1254cf95b8a918d85d262c72c2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sentinel known-sentinel mymaster 172.19.42.232 &lt;span style="color:#ae81ff">26379&lt;/span> 0d4e5dffff14df5fb54b1a00b7d286f0f22eb74e
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sentinel current-epoch &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Sentinel 工作流程&lt;/p>
&lt;h2 id="名词解释">名词解释&lt;/h2>
&lt;p>&lt;strong>SDOWN(主观下线)&lt;/strong> 与&lt;strong>ODOWN(客观下线)&lt;/strong> # 参考：&lt;a href="https://www.cnblogs.com/kevingrace/p/9004460.html">https://www.cnblogs.com/kevingrace/p/9004460.html&lt;/a>&lt;/p>
&lt;p>&lt;strong>Configuration Epochs(配置时代)&lt;/strong> # 类似 Raft 算法中的 term(任期) 概念。参考：&lt;a href="https://redis.io/topics/sentinel#configuration-epochs">官方文档&lt;/a>&lt;/p>
&lt;h2 id="monitoring监控">Monitoring(监控)&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>每个 Sentinel 以每秒钟一次的频率向它所知的 Master，Slave 以及其他 Sentinel 实例发送一个 PING 命令。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 own-after-milliseconds 选项所指定的值，则这个实例会被 Sentinel 标记为主观下线。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果一个 Master 被标记为主观下线，则正在监视这个 Master 的所有 Sentinel 要以每秒一次的频率确认 Master 的确进入了主观下线状态。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认 Master 的确进入了主观下线状态，则 Master 会被标记为客观下线。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在一般情况下，每个 Sentinel 会以每 10 秒一次的频率向它已知的所有 Master，Slave 发送 INFO 命令。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当 Master 被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若没有足够数量的 Sentinel 同意 Master 已经下线，Master 的客观下线状态就会被移除。 若 Master 重新向 Sentinel 的 PING 命令返回有效回复，Master 的主观下线状态就会被移除。&lt;strong>三个定时任务&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="sentinel-在内部有-3-个定时任务">Sentinel 在内部有 3 个定时任务&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>每 10 秒 sentinel 会对 master 和 slave 执行 info 命令，这个任务达到两个目的：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>发现 slave 节点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>确认主从关系&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>每 2 秒 sentinel 通过 master 节点的 channel 交换信息（pub/sub）。master 节点上有一个发布订阅的频道(&lt;strong>sentinel&lt;/strong>:hello)。sentinel 节点通过 &lt;code>__sentinel__:hello&lt;/code> 频道进行信息交换(对节点的&amp;quot;看法&amp;quot;和自身的信息)，达成共识。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每 1 秒 sentinel 对其他 sentinel 和 redis 节点执行 ping 操作(相互监控)。这个其实是一个心跳检测，是失败判定的依据。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Failover(故障转移)&lt;/p>
&lt;p>一个 sentinel 发现 master 离线，争取 sentinel 集群大多数节点认可，认可成功则确认该 master 离线，开始故障转移。&lt;/p>
&lt;p>选出一个 slave 服务器，将其升级为 master&lt;/p>
&lt;p>向被选中的从服务器发送 REPLICAOF NO ONE 命令，让它变为主服务器。&lt;/p>
&lt;p>通过发布与订阅功能，将更新后的配置推送给其他 Sentinel。&lt;/p>
&lt;p>向已下线主服务器的从服务器发送 REPLICAOF host port 命令， 让它们去复制新的主服务器。&lt;/p>
&lt;p>所有 Sentinel 发送 sentinel flushconfig 命令刷新配置文件。所有 Redis master 和 replica 节点发送 config rewrite 命令刷新配置文件&lt;/p>
&lt;ul>
&lt;li>Configuration propagation(配置传播)。参考：&lt;a href="https://redis.io/topics/sentinel#configuration-propagation">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>当所有从服务器都已经开始复制新的主服务器时， 领头 Sentinel 终止这次故障迁移操作。&lt;/p>
&lt;h1 id="哨兵模式的优缺点">哨兵模式的优缺点&lt;/h1>
&lt;p>优点：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>哨兵模式基于主从复制模式，所以主从复制模式有的优点，哨兵模式也有&lt;/p>
&lt;/li>
&lt;li>
&lt;p>哨兵模式下，master 挂掉可以自动进行切换，系统可用性更高&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>缺点：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>同样也继承了主从模式难以在线扩容的缺点，Redis 的容量受限于单机配置&lt;/p>
&lt;/li>
&lt;li>
&lt;p>需要额外的资源来启动 sentinel 进程，实现相对复杂一点，同时 slave 节点作为备份节点不提供服务&lt;/p>
&lt;/li>
&lt;/ol></description></item></channel></rss>