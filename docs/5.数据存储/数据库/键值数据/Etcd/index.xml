<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Etcd on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/</link><description>Recent content in Etcd on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/index.xml" rel="self" type="application/rss+xml"/><item><title>Etcd</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd/</guid><description>概述 参考：
GitHub 项目，etcd-io/etcd GitHub 项目，etcd-io/website 官网 官方文档 掘金 etcd 万字长文 腾讯云社区上的 etcd 万字长文 Etcd 是 CoreOS 基于 Raft 共识算法 开发的分布式 key-value 存储，可用于服务发现、共享配置以及一致性保障(如数据库选主、分布式锁等)。
基本的 key-value 存储，后端存储采用的是 BBolt 存储引擎，其前身是 BoltDB ，这是一款 golang 实现的嵌入式 KV 存储引擎，参考的是 LMDB，支持事务、ACID、MVCC、ZeroCopy、BTree 等特性。 监听机制 key 的过期及续约机制，用于监控和服务发现 原子 CAS 和 CAD，用于分布式锁和 leader 选举 选举机制详见：Etcd 基于 RAFT 的一致性 Glossary(术语) 参考：
官方文档：https://github.com/etcd-io/etcd/blob/master/Documentation/learning/glossary.md Raft # etcd 所采用的保证分布式系统强一致性的算法。 Endpoint(端点)# 指向 etcd 服务或资源的 URL 。比如 http://172.38.40.212:2379 就是 etcd 中的一个 endpoint ，这个 endpoint 指向了 172.</description></item><item><title>Etcd API 文档</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-API-%E6%96%87%E6%A1%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-API-%E6%96%87%E6%A1%A3/</guid><description>https://github.com/etcd-io/website/blob/master/static/apispec/swagger/rpc.swagger.json</description></item><item><title>Etcd 部署</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E9%83%A8%E7%BD%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E9%83%A8%E7%BD%B2/</guid><description>概述 参考：
官方文档 Etcd 可以通过多种方式部署。如果要启动 etcd 集群，则每种部署方式，都需要配置最基本标志为以下几个：
&amp;ndash;name # etcd 集群中的节点名，这里可以随意，可区分且不重复就行 &amp;ndash;listen-peer-urls # 监听的用于节点之间通信的 url，可监听多个，集群内部将通过这些 url 进行数据交互(如选举，数据同步等) &amp;ndash;initial-advertise-peer-urls # 建议用于节点之间通信的 url，节点间将以该值进行通信。 &amp;ndash;listen-client-urls # 监听的用于客户端通信的 url，同样可以监听多个。 &amp;ndash;advertise-client-urls # 建议使用的客户端通信 url，该值用于 etcd 代理或 etcd 成员与 etcd 节点通信。 &amp;ndash;initial-cluster-token etcd-cluster-1 # 节点的 token 值，设置该值后集群将生成唯一 id，并为每个节点也生成唯一 id，当使用相同配置文件再启动一个集群时，只要该 token 值不一样，etcd 集群就不会相互影响。 &amp;ndash;initial-cluster # 也就是集群中所有的 initial-advertise-peer-urls 的合集。 &amp;ndash;initial-cluster-state new # 新建集群的标志 如果是单节点部署，则直接启动即可。
使用二进制文件部署 etcd 直接使用 yum install etcd -y 命令即可安装
在容器内运行 etcd 运行一个单节点的 etcd
export NODE1=192.168.1.21 # 配置Docker卷以存储etcd数据： docker volume create --name etcd-data export DATA_DIR=&amp;#34;etcd-data&amp;#34; # 运行最新版本的etcd： REGISTRY=quay.</description></item><item><title>Etcd 高可用</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E9%AB%98%E5%8F%AF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E9%AB%98%E5%8F%AF%E7%94%A8/</guid><description>Etcd 集群介绍 官方文档：https://etcd.io/docs/latest/op-guide/clustering/</description></item><item><title>Etcd 基于 RAFT 的一致性</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E5%9F%BA%E4%BA%8E-RAFT-%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E5%9F%BA%E4%BA%8E-RAFT-%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</guid><description>Etcd 基于 RAFT 的一致性 选举方法
初始启动时，节点处于 follower 状态并被设定一个 election timeout，如果在这一时间周期内没有收到来自 leader 的 heartbeat，节点将发起选举：将自己切换为 candidate 之后，向集群中其它 follower 节点发送请求，询问其是否选举自己成为 leader。 当收到来自集群中过半数节点的接受投票后，节点即成为 leader，开始接收保存 client 的数据并向其它的 follower 节点同步日志。如果没有达成一致，则 candidate 随机选择一个等待间隔（150ms ~ 300ms）再次发起投票，得到集群中半数以上 follower 接受的 candidate 将成为 leader leader 节点依靠定时向 follower 发送 heartbeat 来保持其地位。 任何时候如果其它 follower 在 election timeout 期间都没有收到来自 leader 的 heartbeat，同样会将自己的状态切换为 candidate 并发起选举。每成功选举一次，新 leader 的任期（Term）都会比之前 leader 的任期大 1。 日志复制
当前 Leader 收到客户端的日志（事务请求）后先把该日志追加到本地的 Log 中，然后通过 heartbeat 把该 Entry 同步给其他 Follower，Follower 接收到日志后记录日志然后向 Leader 发送 ACK，当 Leader 收到大多数（n/2+1）Follower 的 ACK 信息后将该日志设置为已提交并追加到本地磁盘中，通知客户端并在下个 heartbeat 中 Leader 将通知所有的 Follower 将该日志存储在自己的本地磁盘中。</description></item><item><title>Etcd 配置详解</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><description>概述 参考：
官方文档 Etcd 运行时的行为可以通过三种方式进行配置
配置文件 命令行标志 环境变量 而一般情况，配置文件中的关键字 与 命令行标志 和 环境变量 是 一一对应的。比如：
配置文件中关键字：ETCD_DATA_DIR 对应的环境变量中的变量名：ETCD_DATA_DIR 对应的 flag： &amp;ndash;data-dir 优先级：配置文件 &amp;gt; 命令行标志 &amp;gt; 环境变量
Member 成员相关标志 &amp;ndash;name # member 的名称。默认值：default &amp;ndash;data-dir # etcd 数据存储路径。默认值：${name}.etcd。一般大家都修改到 /var/lib/etcd 下。 &amp;ndash;wal-dir &amp;ndash;snapshot-count &amp;ndash;heartbeat-interval # 心跳检测的间隔时间，时间单位是 milliseconds(毫秒)。默认值：100
注意：修改心跳值的同时要修改 election-timeout 标志。因为 选举超时 时间至少需要是 心跳检测间隔的 5 倍，如果达不到 5 倍，则 etcd 启动失败 &amp;ndash;election-timeout # 选举超时时间，时间单位是 milliseconds(毫秒)。默认值：1000 &amp;ndash;listen-peer-urls # 监听的用于节点之间通信的 url，可监听多个，集群内部将通过这些 url 进行数据交互(如选举，数据同步等) &amp;ndash;listen-client-urls # 监听的用于客户端通信的 url，同样可以监听多个。 &amp;ndash;max-snapshots &amp;ndash;max-wals &amp;ndash;cors &amp;ndash;quota-backend-bytes # etcd 可储存的数据配额上限。默认值：0。</description></item><item><title>Etcd 数据模型</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</guid><description>概述 参考：
官方文档 WAL 数据库通常使用 WAL； etcd 也使用它。有关预写日志记录的详细信息不在本文讨论范围之内，但是出于此目的，我们需要知道的是-每个 etcd 集群成员都在持久性存储上保留一个预写日志（WAL）。 etcd 在将某些操作（例如更新）写入键值存储之前，将其写入 WAL。如果成员崩溃并在快照之间重新启动，则可以通过查看 WAL 的内容在本地恢复自上次快照以来完成的事务。
因此，每当客户将密钥添加到键值存储或更新现有密钥的值时，客户端都会 etcd 在 WAL 上附加一个记录操作的条目，WAL 是持久性存储上的普通文件。在继续进行之前， etcd 必须 100％确信 WAL 条目已被实际保留。要在 Linux 上实现此目的，仅使用 write 系统调用是不够的， 因为实际写入物理存储的时间可能会延迟。例如，Linux 可能会将写入的 WAL 条目在内核内存高速缓存（例如页面高速缓存）中保留一段时间。为了确保将数据写入持久性存储中，您必须在“”之后调用 fdatasync 系统调用，write 这正是该 etcd 操作（如以下 strace 所示） 输出，其中 8 是 WAL 文件的文件描述符）：
21:23:09.894875 lseek(8, 0, SEEK_CUR) = 12808 &amp;lt;0.000012&amp;gt; 21:23:09.894911 write(8, &amp;#34;.\0\0\0\0\0\0\202\10\2\20\361\223\255\266\6\32$\10\0\20\10\30\26\&amp;#34;\34\&amp;#34;\r\n\3fo&amp;#34;..., 2296) = 2296 &amp;lt;0.000130&amp;gt; 21:23:09.895041 fdatasync(8) = 0 &amp;lt;0.008314&amp;gt; 不幸的是，写入持久性存储需要时间。如果 fdatasync 花费太长时间，则 etcd 系统性能会降低。 etcd 文档建议 为了使存储足够快，fdatasync 写入 WAL 文件时调用的第 99 个百分点 必须小于 10ms。还有其他与存储相关的指标，但这是本文的重点。</description></item><item><title>revision概念</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/revision-%E6%A6%82%E5%BF%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/revision-%E6%A6%82%E5%BF%B5/</guid><description>每次 key 的 value 改变，version 都会+1
revision 概念
Etcd 存储数据时，并不是像其他的 KV 存储那样，存放数据的键做为 key，而是以数据的 revision 做为 key，键值做为数据来存放。如何理解 revision 这个概念，以下面的例子来说明。
比如通过批量接口两次更新两对键值，第一次写入数据时，写入和，在 Etcd 这边的存储看来，存放的数据就是这样的：
revision={1,0}, key=key1, value=value1 revision={1,1}, key=key2, value=value2 而在第二次更新写入数据和后，存储中又记录（注意不是覆盖前面的数据）了以下数据：
revision={2,0}, key=key1, value=update1 revision={2,1}, key=key2, value=update2 其中 revision 有两部分组成，第一部分成为 main revision，每次事务递增 1；第二部分称为 sub revision，一个事务内的一次操作递增 1。 两者结合，就能保证每次 key 唯一而且是递增的。
但是，就客户端看来，每次操作的时候是根据 Key 来进行操作的，所以这里就需要一个 Key 映射到当前 revision 的操作了，为了做到这个映射关系，Etcd 引入了一个内存中的 Btree 索引，整个操作过程如下面的流程所示。
查询时，先通过内存中的 btree 索引来查询该 key 对应的 keyIndex 结构体，然后再根据这个结构体才能去 boltdb 中查询真实的数据返回。
所以，下面先展开讨论这个 keyIndex 结构体和 btree 索引。</description></item></channel></rss>