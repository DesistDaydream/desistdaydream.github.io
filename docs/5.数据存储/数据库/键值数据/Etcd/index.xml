<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦的站点 – Etcd</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/</link><description>Recent content in Etcd on 断念梦的站点</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Etcd</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/etcd-io/etcd">GitHub 项目，etcd-io/etcd&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/etcd-io/website">GitHub 项目，etcd-io/website&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://etcd.io/">官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://etcd.io/docs/">官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://juejin.cn/post/6844904031186321416">掘金 etcd 万字长文&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cloud.tencent.com/developer/article/1754878">腾讯云社区上的 etcd 万字长文&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Etcd 是 CoreOS 基于 &lt;a href="https://desistdaydream.github.io/docs/3.%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95.md">Raft 共识算法&lt;/a> 开发的分布式 key-value 存储，可用于服务发现、共享配置以及一致性保障(如数据库选主、分布式锁等)。&lt;/p>
&lt;ul>
&lt;li>基本的 key-value 存储，后端存储采用的是 BBolt 存储引擎，其前身是 BoltDB ，这是一款 golang 实现的嵌入式 KV 存储引擎，参考的是 LMDB，支持事务、ACID、MVCC、ZeroCopy、BTree 等特性。&lt;/li>
&lt;li>监听机制&lt;/li>
&lt;li>key 的过期及续约机制，用于监控和服务发现&lt;/li>
&lt;li>原子 CAS 和 CAD，用于分布式锁和 leader 选举
&lt;ul>
&lt;li>选举机制详见：&lt;a href="https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd%20%E5%9F%BA%E4%BA%8E%20RAFT%20%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7.md">Etcd 基于 RAFT 的一致性&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="glossary术语">Glossary(术语)&lt;a class="td-heading-self-link" href="#glossary%e6%9c%af%e8%af%ad" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>官方文档：&lt;a href="https://github.com/etcd-io/etcd/blob/master/Documentation/learning/glossary.md">https://github.com/etcd-io/etcd/blob/master/Documentation/learning/glossary.md&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>Raft&lt;/strong> # etcd 所采用的保证分布式系统强一致性的算法。&lt;/li>
&lt;li>&lt;strong>Endpoint(端点)&lt;/strong># 指向 etcd 服务或资源的 URL 。比如 &lt;a href="http://172.38.40.212:2379">http://172.38.40.212:2379&lt;/a> 就是 etcd 中的一个 endpoint ，这个 endpoint 指向了 172.38.40.212 设备的 2379 端口上的 etcd&lt;/li>
&lt;li>&lt;strong>Node&lt;/strong> # 一个 Raft 状态机实例。&lt;/li>
&lt;li>&lt;strong>Member(成员)&lt;/strong> # 一个 etcd 实例。它管理着一个 Node，并且可以为客户端请求提供服务。
&lt;ul>
&lt;li>Member 是组成 etcd cluster 的一部分。一个逻辑概念，是集群中提供服务的 etcd 服务器。可以为一个 member 单独定义一个名字和描述等信息。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Cluster(集群)&lt;/strong> # 由多个 Member 构成可以协同工作的 etcd 集群。&lt;/li>
&lt;li>&lt;strong>Peer&lt;/strong> # 对同一个 etcd 集群中另外一个 Member 的称呼。&lt;/li>
&lt;li>&lt;strong>Client&lt;/strong> # 向 etcd 集群发送 HTTP 请求的客户端。&lt;/li>
&lt;li>&lt;strong>snapshot&lt;/strong> # etcd 防止 WAL 文件过多而设置的快照，存储 etcd 数据状态。&lt;/li>
&lt;li>&lt;strong>Proxy&lt;/strong> # etcd 的一种模式，为 etcd 集群提供反向代理服务。&lt;/li>
&lt;li>&lt;strong>Leader&lt;/strong> # Raft 算法中通过竞选而产生的处理所有数据提交的节点。&lt;/li>
&lt;li>&lt;strong>Follower&lt;/strong> # 竞选失败的节点作为 Raft 中的从属节点，为算法提供强一致性保证。&lt;/li>
&lt;li>&lt;strong>Candidate&lt;/strong> # 当 Follower 超过一定时间接收不到 Leader 的心跳时转变为 Candidate 开始竞选。&lt;/li>
&lt;li>&lt;strong>Term&lt;/strong> # Raft 算法中的概念。某个节点成为 Leader 到下一次竞选时间，称为一个 Term。&lt;/li>
&lt;li>&lt;strong>Index&lt;/strong> # 数据项编号。Raft 中通过 Term 和 Index 来定位数据。&lt;/li>
&lt;/ul>
&lt;h1 id="etcd-工作方式简述">Etcd 工作方式简述&lt;a class="td-heading-self-link" href="#etcd-%e5%b7%a5%e4%bd%9c%e6%96%b9%e5%bc%8f%e7%ae%80%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>每个 etcd 一般使用两个端口进行工作，一个端口面向客户端提供服务(2379)，另一个端口集群内部通信(2380)。可以将 etcd 端口设置为接受 TLS 流量，非 TLS 流量，或同时接受 TLS 和非 TLS 流量。&lt;/p>
&lt;h3 id="数据读写顺序">数据读写顺序&lt;a class="td-heading-self-link" href="#%e6%95%b0%e6%8d%ae%e8%af%bb%e5%86%99%e9%a1%ba%e5%ba%8f" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>为了保证数据的强一致性，etcd 集群中所有的数据流向都是一个方向，从 Leader （主节点）流向 Follower，也就是所有 Follower 的数据必须与 Leader 保持一致，如果不一致会被覆盖。&lt;/p>
&lt;p>用户对于 etcd 集群所有节点进行读写&lt;/p>
&lt;ul>
&lt;li>读取：由于集群所有节点数据是强一致性的，读取可以从集群中随便哪个节点进行读取数据&lt;/li>
&lt;li>写入：etcd 集群有 leader，如果写入往 leader 写入，可以直接写入，然后然后 Leader 节点会把写入分发给所有 Follower，如果往 follower 写入，然后 Leader 节点会把写入分发给所有 Follower&lt;/li>
&lt;/ul>
&lt;h3 id="leader-选举">leader 选举&lt;a class="td-heading-self-link" href="#leader-%e9%80%89%e4%b8%be" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>假设三个节点的集群，三个节点上均运行 Timer（每个 Timer 持续时间是随机的），Raft 算法使用随机 Timer 来初始化 Leader 选举流程，第一个节点率先完成了 Timer，随后它就会向其他两个节点发送成为 Leader 的请求，其他节点接收到请求后会以投票回应然后第一个节点被选举为 Leader。&lt;/p>
&lt;p>成为 Leader 后，该节点会以固定时间间隔向其他节点发送通知，确保自己仍是 Leader。有些情况下当 Follower 们收不到 Leader 的通知后，比如说 Leader 节点宕机或者失去了连接，其他节点会重复之前选举过程选举出新的 Leader。&lt;/p>
&lt;h3 id="判断数据是否写入">判断数据是否写入&lt;a class="td-heading-self-link" href="#%e5%88%a4%e6%96%ad%e6%95%b0%e6%8d%ae%e6%98%af%e5%90%a6%e5%86%99%e5%85%a5" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>etcd 认为写入请求被 Leader 节点处理并分发给了多数节点后，就是一个成功的写入。那么多少节点如何判定呢，假设总结点数是 N，那么多数节点 &lt;code>Quorum=N/2+1&lt;/code>。关于如何确定 etcd 集群应该有多少个节点的问题，上图的左侧的图表给出了集群中节点总数(Instances)对应的 Quorum 数量，用 Instances 减去 Quorom 就是集群中容错节点（允许出故障的节点）的数量。&lt;/p>
&lt;p>所以在集群中推荐的最少节点数量是 3 个，因为 1 和 2 个节点的容错节点数都是 0，一旦有一个节点宕掉整个集群就不能正常工作了。&lt;/p>
&lt;h2 id="etcd-监控指标">Etcd 监控指标&lt;a class="td-heading-self-link" href="#etcd-%e7%9b%91%e6%8e%a7%e6%8c%87%e6%a0%87" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>官方文档：&lt;a href="https://etcd.io/docs/latest/op-guide/monitoring/">https://etcd.io/docs/latest/op-guide/monitoring/&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>ID：3070 是一个不错的 grafana dashboard&lt;/p>
&lt;/blockquote>
&lt;p>每个 etcd 服务器在 /metrics 路径下暴露 metrics 。默认在 http://ETCDIP:2379/metrics 下。&lt;/p>
&lt;p>可以使用 &amp;ndash;listen-metrics-urls 参数单独指定 etcd 要暴露 metrics 的 ip 和 port。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>~&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>$ curl -L http://localhost:2379/metrics &lt;span style="color:#000;font-weight:bold">|&lt;/span> grep -v debugging &lt;span style="color:#8f5902;font-style:italic"># ignore unstable debugging metrics&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># HELP etcd_disk_backend_commit_duration_seconds The latency distributions of commit called by backend.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># TYPE etcd_disk_backend_commit_duration_seconds histogram&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>etcd_disk_backend_commit_duration_seconds_bucket&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>&lt;span style="color:#000">le&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;0.002&amp;#34;&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">72756&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>etcd_disk_backend_commit_duration_seconds_bucket&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>&lt;span style="color:#000">le&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;0.004&amp;#34;&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">401587&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>etcd_disk_backend_commit_duration_seconds_bucket&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>&lt;span style="color:#000">le&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;0.008&amp;#34;&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">405979&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>etcd_disk_backend_commit_duration_seconds_bucket&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>&lt;span style="color:#000">le&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;0.016&amp;#34;&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">406464&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="健康检查">健康检查&lt;a class="td-heading-self-link" href="#%e5%81%a5%e5%ba%b7%e6%a3%80%e6%9f%a5" aria-label="Heading self-link">&lt;/a>&lt;/h3>
&lt;p>从 v3.3.0 开始，除了响应 /metrics 端点之外，&amp;ndash;listen-metrics-urls 参数指定的任何位置也将响应 /health 端点。如果标准端点配置了相互（客户机）TLS 身份验证，但负载平衡器或监视服务仍需要访问运行状况检查，则此功能非常有用。&lt;/p>
&lt;h1 id="etcd-关联文件与配置">Etcd 关联文件与配置&lt;a class="td-heading-self-link" href="#etcd-%e5%85%b3%e8%81%94%e6%96%87%e4%bb%b6%e4%b8%8e%e9%85%8d%e7%bd%ae" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;strong>/var/lib/etcd/&lt;/strong> # Etcd 数据存储目录。该目录为默认目录，可以在配置文件的 ETCD_DATA_DIR 字段中修改路径&lt;/p>
&lt;p>&lt;strong>/etc/etcd/etcd.conf&lt;/strong> # 基本配置文件&lt;/p>
&lt;p>&lt;strong>/etc/etcd/etcd.conf.yaml&lt;/strong> # 与基本配置文件类似，可以已 yaml 的形式写配置文件。&lt;/p>
&lt;p>下面是基本配置文件的示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#[Member]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">ETCD_DATA_DIR&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;/PATH&amp;#34; #etcd中的数据是基于内存的Key/Val存储，持久化之后，需要保存的目录即在此配置中定义&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">ETCD_LISTEN_PEER_URLS&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;Protocol://IP:PORT,....&amp;#34; #指定etcd集群内互相通信时所监听的端口，默认2380&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">ETCD_LISTEN_CLIENT_URLS&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;Protocol://IP:PORT,...&amp;#34; #指定etcd与其客户端(apiserver)通信时所监听的端口，默认2379&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">ETCD_NAME&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;HostName&amp;#34; #指定etcd所在节点的主机名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">ETCD_SNAPSHOT_COUNT&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;NUM&amp;#34; #指定可以快照多少次，默认100000,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#[Clustering]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">ETCD_INITAL_ADVERTISE_PEER_URLS&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;Protocol://{IP|HostName}:PORT,....&amp;#34; #一个声明，指定对外广告的etcd集群内互相通信时所监听的端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">ETCD_ADVERTISE_CLIENT_URLS&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;Protocol://{IP|HostName}:PORT,....&amp;#34; #一个声明，指定对外广告的etcd与其客户端(apiserver)通信时所监听的端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">ETCD_INITIAL_CLUSTER&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;HostName1=Protocol://HostName1:PORT,HostName2=Protocol://HostName2:PORT,.......&amp;#34; #指定etcd集群初始成员信息，集群中有几个etcd就用写几个&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#[Proxy]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#ETCD_PROXY=&amp;#34;off&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#ETCD_PROXY_FAILURE_WAIT=&amp;#34;5000&amp;#34; #&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#ETCD_PROXY_REFRESH_INTERVAL=&amp;#34;30000&amp;#34; #&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#ETCD_PROXY_DIAL_TIMEOUT=&amp;#34;1000&amp;#34; #&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#ETCD_PROXY_WRITE_TIMEOUT=&amp;#34;5000&amp;#34; #&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#ETCD_PROXY_READ_TIMEOUT=&amp;#34;0&amp;#34; #&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#[Security]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">ETCD_CERT_FILE&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;/PATH/FILE&amp;#34; #指定集群与客户端通信时所用的服务端证书&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">ETCD_KEY_FILE&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;/PATH/FILE&amp;#34; #指定集群与客户端通信时所用的服务端证书的私钥&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">ETCD_CLIENT_CERT_AUTH&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;false|ture&amp;#34; #指明是否验证客户端证书&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">ETCD_TRUSTED_CA_FILE&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;/PATH/FILE&amp;#34; ##指定签署服务端证书的CA证书&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">ETCD_AUTO_TLS&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;false|ture&amp;#34; #是否让etcd自动生成服务端证书&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">ETCD_PEER_CERT_FILE&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;/PATH/FILE&amp;#34; #指定集群间通信时所用的证书&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">ETCD_PEER_KEY_FILE&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;/PATH/FILE&amp;#34; #指定集群间通信时所用的证书的私钥&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">ETCD_PEER_CLIENT_CERT_AUTH&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;false|ture&amp;#34; #指明是否验证客户端(即apiserver)的证书(peer模式中各节点互为服务端和客户端)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">ETCD_PEER_TRUSTED_CA_FILE&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;/PATH/FILE&amp;#34; #指定签署peer证书的CA证书&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c4a000">ETCD_PEER_AUTO_TLS&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;false|ture&amp;#34; #是否让etcd自动生成peer证书&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#[Logging]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#ETCD_DEBUG=&amp;#34;false&amp;#34; #&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#ETCD_LOG_PACKAGE_LEVELS=&amp;#34;&amp;#34; #&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#ETCD_LOG_OUTPUT=&amp;#34;default&amp;#34; #&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#[Unsafe]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#ETCD_FORCE_NEW_CLUSTER=&amp;#34;false&amp;#34; #&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#[Version]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#ETCD_VERSION=&amp;#34;false&amp;#34; #&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#ETCD_AUTO_COMPACTION_RETENTION=&amp;#34;0&amp;#34; #&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#[Profiling]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#ETCD_ENABLE_PPROF=&amp;#34;false&amp;#34; #&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#ETCD_METRICS=&amp;#34;basic&amp;#34; #&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#[Auth]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#ETCD_AUTH_TOKEN=&amp;#34;simple&amp;#34; #&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="etcd-架构">Etcd 架构&lt;a class="td-heading-self-link" href="#etcd-%e6%9e%b6%e6%9e%84" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ummz3n/1616136796826-e3ea264c-885a-49c9-b416-06f0bf2f90ed.png" alt="">&lt;/p>
&lt;p>从 etcd 的架构图中我们可以看到，etcd 主要分为四个部分。&lt;/p>
&lt;ul>
&lt;li>HTTP Server：用于处理用户发送的 API 请求以及其它 etcd 节点的同步与心跳信息请求。&lt;/li>
&lt;li>Store：用于处理 etcd 支持的各类功能的事务，包括数据索引、节点状态变更、监控与反馈、事件处理与执行等等，是 etcd 对用户提供的大多数 API 功能的具体实现。&lt;/li>
&lt;li>Raft：Raft 强一致性算法的具体实现，是 etcd 的核心。&lt;/li>
&lt;li>WAL：Write Ahead Log（预写式日志），是 etcd 的数据存储方式。除了在内存中存有所有数据的状态以及节点的索引以外，etcd 就通过 WAL 进行持久化存储。WAL 中，所有的数据提交前都会事先记录日志。
&lt;ul>
&lt;li>Snapshot 是为了防止数据过多而进行的状态快照；&lt;/li>
&lt;li>Entry 表示存储的具体日志内容。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>通常，一个用户的请求发送过来，会经由 HTTP Server 转发给 Store 进行具体的事务处理，如果涉及到节点的修改，则交给 Raft 模块进行状态的变更、日志的记录，然后再同步给别的 etcd 节点以确认数据提交，最后进行数据的提交，再次同步。&lt;/p>
&lt;h1 id="etcd-应用场景">Etcd 应用场景&lt;a class="td-heading-self-link" href="#etcd-%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;h2 id="31-服务注册与发现">3.1 服务注册与发现&lt;a class="td-heading-self-link" href="#31-%e6%9c%8d%e5%8a%a1%e6%b3%a8%e5%86%8c%e4%b8%8e%e5%8f%91%e7%8e%b0" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>etcd 可以用于服务的注册与发现&lt;/p>
&lt;ul>
&lt;li>前后端业务注册发现&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ummz3n/1616136796808-e6ed3149-9eed-470a-9087-57aceb2dae5f.webp" alt="">&lt;/p>
&lt;p>中间价已经后端服务在 etcd 中注册，前端和中间价可以很轻松的从 etcd 中发现相关服务器然后服务器之间根据调用关系相关绑定调用&lt;/p>
&lt;ul>
&lt;li>多组后端服务器注册发现&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ummz3n/1616136796829-3feff5ec-d633-4d98-94c9-586dff97110b.webp" alt="">&lt;/p>
&lt;p>后端多个无状态相同副本的 app 可以同事注册到 etcd 中，前端可以通过 haproxy 从 etcd 中获取到后端的 ip 和端口组，然后进行请求转发，可以用来故障转移屏蔽后端端口已经后端多组 app 实例。&lt;/p>
&lt;h2 id="32-消息发布与订阅">3.2 消息发布与订阅&lt;a class="td-heading-self-link" href="#32-%e6%b6%88%e6%81%af%e5%8f%91%e5%b8%83%e4%b8%8e%e8%ae%a2%e9%98%85" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ummz3n/1616136796813-0167a273-8ea1-4594-84d6-7453ecaafbda.webp" alt="">&lt;/p>
&lt;p>etcd 可以充当消息中间件，生产者可以往 etcd 中注册 topic 并发送消息，消费者从 etcd 中订阅 topic，来获取生产者发送至 etcd 中的消息。&lt;/p>
&lt;h2 id="33-负载均衡">3.3 负载均衡&lt;a class="td-heading-self-link" href="#33-%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ummz3n/1616136796852-c515c4de-effd-4a85-b3e6-67aa0ff98665.webp" alt="">&lt;/p>
&lt;p>后端多组相同的服务提供者可以经自己服务注册到 etcd 中，etcd 并且会与注册的服务进行监控检查，服务请求这首先从 etcd 中获取到可用的服务提供者真正的 ip:port，然后对此多组服务发送请求，etcd 在其中充当了负载均衡的功能&lt;/p>
&lt;h2 id="34-分部署通知与协调">3.4 分部署通知与协调&lt;a class="td-heading-self-link" href="#34-%e5%88%86%e9%83%a8%e7%bd%b2%e9%80%9a%e7%9f%a5%e4%b8%8e%e5%8d%8f%e8%b0%83" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ummz3n/1616136796815-22640fce-a1d8-4364-bfbc-f138d85a04df.webp" alt="">&lt;/p>
&lt;ul>
&lt;li>当 etcd watch 服务发现丢失，会通知服务检查&lt;/li>
&lt;li>控制器向 etcd 发送启动服务，etcd 通知服务进行相应操作&lt;/li>
&lt;li>当服务完成 work 会讲状态更新至 etcd，etcd 对应会通知用户&lt;/li>
&lt;/ul>
&lt;h2 id="35-分布式锁">3.5 分布式锁&lt;a class="td-heading-self-link" href="#35-%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ummz3n/1616136796823-f19aa84e-8a3e-4e0a-85f2-a464b8faf1e6.webp" alt="">&lt;/p>
&lt;p>当有多个竞争者 node 节点，etcd 作为总控，在分布式集群中与一个节点成功分配 lock&lt;/p>
&lt;h2 id="36-分布式队列">3.6 分布式队列&lt;a class="td-heading-self-link" href="#36-%e5%88%86%e5%b8%83%e5%bc%8f%e9%98%9f%e5%88%97" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ummz3n/1616136796858-7ab4d693-a873-4932-b5c2-74fe5cb92fe8.webp" alt="">&lt;/p>
&lt;p>有对个 node，etcd 根据每个 node 来创建对应 node 的队列，根据不同的队列可以在 etcd 中找到对应的 competitor&lt;/p>
&lt;h2 id="37-集群与监控与-leader-选举">3.7 集群与监控与 Leader 选举&lt;a class="td-heading-self-link" href="#37-%e9%9b%86%e7%be%a4%e4%b8%8e%e7%9b%91%e6%8e%a7%e4%b8%8e-leader-%e9%80%89%e4%b8%be" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/ummz3n/1616136796814-3cb985e2-3fb5-4778-b8d7-06453c189268.webp" alt="">&lt;/p>
&lt;p>etcd 可以根据 raft 算法在多个 node 节点来选举出 leader&lt;/p>
&lt;h1 id="重大变化">重大变化&lt;a class="td-heading-self-link" href="#%e9%87%8d%e5%a4%a7%e5%8f%98%e5%8c%96" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>2022 年 8 月 22 日
众所周知，etcd 是 Kubernetes 的核心组件之一，同时它也被大量其他的开源项目所依赖，比如 Apache APISIX 也是使用 etcd 作为其默认的数据存储的。
但是 etcd 最早的两个维护者，基本上都由于工作变动的原因已经不在 etcd 项目中积极活跃了。后来社区中剩余的一些贡献者开始承担起了该项目的维护工作。
在几个月之前，etcd 项目现有的维护者们，由于难以达到大多数人的同意，也发起了一次社区治理方案的调整，在决策时改成了惰性共识 &lt;a href="https://github.com/etcd-io/etcd/pull/14053">https://github.com/etcd-io/etcd/pull/14053&lt;/a>
当前 CNCF TOC 正在讨论 etcd 项目的健康度问题，也许我们可以做点什么，让这个项目变的更好。&lt;/p></description></item><item><title>Docs: Etcd API 文档</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-API-%E6%96%87%E6%A1%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-API-%E6%96%87%E6%A1%A3/</guid><description>
&lt;p>&lt;a href="https://github.com/etcd-io/website/blob/master/static/apispec/swagger/rpc.swagger.json">https://github.com/etcd-io/website/blob/master/static/apispec/swagger/rpc.swagger.json&lt;/a>&lt;/p></description></item><item><title>Docs: Etcd 部署</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E9%83%A8%E7%BD%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E9%83%A8%E7%BD%B2/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://etcd.io/docs/latest/op-guide/container/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Etcd 可以通过多种方式部署。如果要启动 etcd 集群，则每种部署方式，都需要配置最基本标志为以下几个：&lt;/p>
&lt;ul>
&lt;li>&amp;ndash;name # etcd 集群中的节点名，这里可以随意，可区分且不重复就行&lt;/li>
&lt;li>&amp;ndash;listen-peer-urls # 监听的用于节点之间通信的 url，可监听多个，集群内部将通过这些 url 进行数据交互(如选举，数据同步等)&lt;/li>
&lt;li>&amp;ndash;initial-advertise-peer-urls # 建议用于节点之间通信的 url，节点间将以该值进行通信。&lt;/li>
&lt;li>&amp;ndash;listen-client-urls # 监听的用于客户端通信的 url，同样可以监听多个。&lt;/li>
&lt;li>&amp;ndash;advertise-client-urls # 建议使用的客户端通信 url，该值用于 etcd 代理或 etcd 成员与 etcd 节点通信。&lt;/li>
&lt;li>&amp;ndash;initial-cluster-token etcd-cluster-1 # 节点的 token 值，设置该值后集群将生成唯一 id，并为每个节点也生成唯一 id，当使用相同配置文件再启动一个集群时，只要该 token 值不一样，etcd 集群就不会相互影响。&lt;/li>
&lt;li>&amp;ndash;initial-cluster # 也就是集群中所有的 initial-advertise-peer-urls 的合集。&lt;/li>
&lt;li>&amp;ndash;initial-cluster-state new # 新建集群的标志&lt;/li>
&lt;/ul>
&lt;p>如果是单节点部署，则直接启动即可。&lt;/p>
&lt;h1 id="使用二进制文件部署-etcd">使用二进制文件部署 etcd&lt;a class="td-heading-self-link" href="#%e4%bd%bf%e7%94%a8%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%96%87%e4%bb%b6%e9%83%a8%e7%bd%b2-etcd" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>直接使用 yum install etcd -y 命令即可安装&lt;/p>
&lt;h1 id="在容器内运行-etcd">在容器内运行 etcd&lt;a class="td-heading-self-link" href="#%e5%9c%a8%e5%ae%b9%e5%99%a8%e5%86%85%e8%bf%90%e8%a1%8c-etcd" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>运行一个单节点的 etcd&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">export&lt;/span> &lt;span style="color:#000">NODE1&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>192.168.1.21
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 配置Docker卷以存储etcd数据：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker volume create --name etcd-data
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">export&lt;/span> &lt;span style="color:#000">DATA_DIR&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;etcd-data&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># 运行最新版本的etcd：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">REGISTRY&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>quay.io/coreos/etcd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># available from v3.2.5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">REGISTRY&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>gcr.io/etcd-development/etcd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> -p 2379:2379 &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> -p 2380:2380 &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --volume&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">DATA_DIR&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>:/etcd-data &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --name etcd &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">REGISTRY&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>:latest &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> /usr/local/bin/etcd &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --data-dir&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>/etcd-data --name node1 &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --initial-advertise-peer-urls http://&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">NODE1&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>:2380 --listen-peer-urls http://0.0.0.0:2380 &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --advertise-client-urls http://&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">NODE1&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>:2379 --listen-client-urls http://0.0.0.0:2379 &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --initial-cluster &lt;span style="color:#000">node1&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>http://&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">NODE1&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>:2380
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="部署-3-节点-etcd-集群">部署 3 节点 etcd 集群&lt;a class="td-heading-self-link" href="#%e9%83%a8%e7%bd%b2-3-%e8%8a%82%e7%82%b9-etcd-%e9%9b%86%e7%be%a4" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">REGISTRY&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>quay.io/coreos/etcd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># available from v3.2.5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">REGISTRY&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>gcr.io/etcd-development/etcd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># For each machine&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">ETCD_VERSION&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>latest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">TOKEN&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>my-etcd-token
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">CLUSTER_STATE&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>new
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">NAME_1&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>etcd-node-0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">NAME_2&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>etcd-node-1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">NAME_3&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>etcd-node-2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">HOST_1&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>10.20.30.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">HOST_2&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>10.20.30.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">HOST_3&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>10.20.30.3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">CLUSTER&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">NAME_1&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>http://&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">HOST_1&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>:2380,&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">NAME_2&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>http://&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">HOST_2&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>:2380,&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">NAME_3&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>http://&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">HOST_3&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>:2380
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">DATA_DIR&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>/var/lib/etcd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># For node 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">THIS_NAME&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">NAME_1&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">THIS_IP&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">HOST_1&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> -p 2379:2379 &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> -p 2380:2380 &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --volume&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">DATA_DIR&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>:/etcd-data &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --name etcd &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">REGISTRY&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>:&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">ETCD_VERSION&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span> &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> /usr/local/bin/etcd &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --data-dir&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>/etcd-data --name &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">THIS_NAME&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span> &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --initial-advertise-peer-urls http://&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">THIS_IP&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>:2380 --listen-peer-urls http://0.0.0.0:2380 &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --advertise-client-urls http://&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">THIS_IP&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>:2379 --listen-client-urls http://0.0.0.0:2379 &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --initial-cluster &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">CLUSTER&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span> &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --initial-cluster-state &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">CLUSTER_STATE&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span> --initial-cluster-token &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">TOKEN&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># For node 2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">THIS_NAME&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">NAME_2&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">THIS_IP&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">HOST_2&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> -p 2379:2379 &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> -p 2380:2380 &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --volume&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">DATA_DIR&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>:/etcd-data &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --name etcd &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">REGISTRY&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>:&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">ETCD_VERSION&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span> &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> /usr/local/bin/etcd &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --data-dir&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>/etcd-data --name &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">THIS_NAME&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span> &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --initial-advertise-peer-urls http://&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">THIS_IP&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>:2380 --listen-peer-urls http://0.0.0.0:2380 &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --advertise-client-urls http://&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">THIS_IP&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>:2379 --listen-client-urls http://0.0.0.0:2379 &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --initial-cluster &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">CLUSTER&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span> &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --initial-cluster-state &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">CLUSTER_STATE&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span> --initial-cluster-token &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">TOKEN&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"># For node 3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">THIS_NAME&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">NAME_3&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">THIS_IP&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">HOST_3&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> -p 2379:2379 &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> -p 2380:2380 &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --volume&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">DATA_DIR&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>:/etcd-data &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --name etcd &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">REGISTRY&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>:&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">ETCD_VERSION&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span> &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> /usr/local/bin/etcd &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --data-dir&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>/etcd-data --name &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">THIS_NAME&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span> &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --initial-advertise-peer-urls http://&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">THIS_IP&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>:2380 --listen-peer-urls http://0.0.0.0:2380 &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --advertise-client-urls http://&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">THIS_IP&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>:2379 --listen-client-urls http://0.0.0.0:2379 &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --initial-cluster &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">CLUSTER&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span> &lt;span style="color:#4e9a06">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4e9a06">&lt;/span> --initial-cluster-state &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">CLUSTER_STATE&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span> --initial-cluster-token &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">TOKEN&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="使用证书部署一个安全的-etcd-集群">使用证书部署一个安全的 ETCD 集群&lt;a class="td-heading-self-link" href="#%e4%bd%bf%e7%94%a8%e8%af%81%e4%b9%a6%e9%83%a8%e7%bd%b2%e4%b8%80%e4%b8%aa%e5%ae%89%e5%85%a8%e7%9a%84-etcd-%e9%9b%86%e7%be%a4" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;h2 id="生成自签名证书">生成自签名证书&lt;a class="td-heading-self-link" href="#%e7%94%9f%e6%88%90%e8%87%aa%e7%ad%be%e5%90%8d%e8%af%81%e4%b9%a6" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>官方文档：&lt;/p>
&lt;p>make 自动生成：&lt;a href="https://github.com/etcd-io/etcd/tree/master/hack/tls-setup">https://github.com/etcd-io/etcd/tree/master/hack/tls-setup&lt;/a>&lt;/p>
&lt;p>使用 cfssl 工具：&lt;a href="https://github.com/coreos/docs/blob/master/os/generate-self-signed-certificates.md">https://github.com/coreos/docs/blob/master/os/generate-self-signed-certificates.md&lt;/a>&lt;/p>
&lt;h2 id="部署-etcd">部署 etcd&lt;a class="td-heading-self-link" href="#%e9%83%a8%e7%bd%b2-etcd" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>在上面的部署示例中，每个 etcd 节点添加如下命令行标志即可&lt;/p>
&lt;p>客户端到服务端通信认证所需配置&lt;/p>
&lt;p>&amp;ndash;client-cert-auth=true # 设置此选项后，etcd 将检查所有传入的 HTTPS 请求以查找由受信任的 CA 签名的客户端证书，未提供有效客户端证书的请求将失败。如果启用了&lt;a href="https://github.com/etcd-io/etcd/blob/master/Documentation/op-guide/authentication.md">身份验证&lt;/a>，则证书将为“公用名”字段提供的用户名提供凭据。&lt;/p>
&lt;p>&amp;ndash;cert-file=/etc/kubernetes/pki/etcd/server.crt # 用于与 etcd 的 SSL / TLS 连接的证书。设置此选项后，advertise-client-urls 可以使用 HTTPS 模式。&lt;/p>
&lt;p>&amp;ndash;key-file=/etc/kubernetes/pki/etcd/server.key # 证书密钥。必须未加密。&lt;/p>
&lt;p>&amp;ndash;trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt # 受信任的证书颁发机构。&lt;/p>
&lt;p>服务端到服务端通信认证所需配置&lt;/p>
&lt;p>&amp;ndash;peer-client-cert-auth=true # 设置后，etcd 将检查来自集群的所有传入对等请求，以查找由提供的 CA 签名的有效客户端证书。&lt;/p>
&lt;p>&amp;ndash;peer-cert-file=/etc/kubernetes/pki/etcd/peer.crt # 对等体之间用于 SSL / TLS 连接的证书。这将用于侦听对等方地址以及向其他对等方发送请求。&lt;/p>
&lt;p>&amp;ndash;peer-key-file=/etc/kubernetes/pki/etcd/peer.key # 证书密钥。必须未加密。&lt;/p>
&lt;p>&amp;ndash;peer-trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt # 受信任的证书颁发机构。&lt;/p></description></item><item><title>Docs: Etcd 高可用</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E9%AB%98%E5%8F%AF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E9%AB%98%E5%8F%AF%E7%94%A8/</guid><description>
&lt;h1 id="etcd-集群介绍">Etcd 集群介绍&lt;a class="td-heading-self-link" href="#etcd-%e9%9b%86%e7%be%a4%e4%bb%8b%e7%bb%8d" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>官方文档：&lt;a href="https://etcd.io/docs/latest/op-guide/clustering/">https://etcd.io/docs/latest/op-guide/clustering/&lt;/a>&lt;/p></description></item><item><title>Docs: Etcd 管理</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E7%AE%A1%E7%90%86/</guid><description/></item><item><title>Docs: Etcd 基于 RAFT 的一致性</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E5%9F%BA%E4%BA%8E-RAFT-%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E5%9F%BA%E4%BA%8E-RAFT-%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</guid><description>
&lt;h1 id="etcd-基于-raft-的一致性">Etcd 基于 RAFT 的一致性&lt;a class="td-heading-self-link" href="#etcd-%e5%9f%ba%e4%ba%8e-raft-%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>选举方法&lt;/p>
&lt;ul>
&lt;li>
&lt;ol>
&lt;li>初始启动时，节点处于 follower 状态并被设定一个 election timeout，如果在这一时间周期内没有收到来自 leader 的 heartbeat，节点将发起选举：将自己切换为 candidate 之后，向集群中其它 follower 节点发送请求，询问其是否选举自己成为 leader。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;ol start="2">
&lt;li>当收到来自集群中过半数节点的接受投票后，节点即成为 leader，开始接收保存 client 的数据并向其它的 follower 节点同步日志。如果没有达成一致，则 candidate 随机选择一个等待间隔（150ms ~ 300ms）再次发起投票，得到集群中半数以上 follower 接受的 candidate 将成为 leader&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;ol start="3">
&lt;li>leader 节点依靠定时向 follower 发送 heartbeat 来保持其地位。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;ol start="4">
&lt;li>任何时候如果其它 follower 在 election timeout 期间都没有收到来自 leader 的 heartbeat，同样会将自己的状态切换为 candidate 并发起选举。每成功选举一次，新 leader 的任期（Term）都会比之前 leader 的任期大 1。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;p>日志复制&lt;/p>
&lt;p>当前 Leader 收到客户端的日志（事务请求）后先把该日志追加到本地的 Log 中，然后通过 heartbeat 把该 Entry 同步给其他 Follower，Follower 接收到日志后记录日志然后向 Leader 发送 ACK，当 Leader 收到大多数（n/2+1）Follower 的 ACK 信息后将该日志设置为已提交并追加到本地磁盘中，通知客户端并在下个 heartbeat 中 Leader 将通知所有的 Follower 将该日志存储在自己的本地磁盘中。&lt;/p>
&lt;p>安全性&lt;/p>
&lt;p>安全性是用于保证每个节点都执行相同序列的安全机制，如当某个 Follower 在当前 Leader commit Log 时变得不可用了，稍后可能该 Follower 又会被选举为 Leader，这时新 Leader 可能会用新的 Log 覆盖先前已 committed 的 Log，这就是导致节点执行不同序列；Safety 就是用于保证选举出来的 Leader 一定包含先前 committed Log 的机制；&lt;/p>
&lt;ul>
&lt;li>
&lt;p>选举安全性（Election Safety）：每个任期（Term）只能选举出一个 Leader&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Leader 完整性（Leader Completeness）：指 Leader 日志的完整性，当 Log 在任期 Term1 被 Commit 后，那么以后任期 Term2、Term3… 等的 Leader 必须包含该 Log；Raft 在选举阶段就使用 Term 的判断用于保证完整性：当请求投票的该 Candidate 的 Term 较大或 Term 相同 Index 更大则投票，否则拒绝该请求。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>失效处理&lt;/p>
&lt;ul>
&lt;li>
&lt;ol>
&lt;li>Leader 失效：其他没有收到 heartbeat 的节点会发起新的选举，而当 Leader 恢复后由于步进数小会自动成为 follower（日志也会被新 leader 的日志覆盖）&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>2）follower 节点不可用：follower 节点不可用的情况相对容易解决。因为集群中的日志内容始终是从 leader 节点同步的，只要这一节点再次加入集群时重新从 leader 节点处复制日志即可。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>3）多个 candidate：冲突后 candidate 将随机选择一个等待间隔（150ms ~ 300ms）再次发起投票，得到集群中半数以上 follower 接受的 candidate 将成为 leader&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>wal 日志&lt;/p>
&lt;p>Etcd 实现 raft 的时候，充分利用了 go 语言 CSP 并发模型和 chan 的魔法，想更进行一步了解的可以去看源码，这里只简单分析下它的 wal 日志。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lb3mb0/1616136460766-77609f41-c735-4349-b1ed-064ea78ed0ae.jpeg" alt="">&lt;/p>
&lt;p>etcdv3&lt;/p>
&lt;p>wal 日志是二进制的，解析出来后是以上数据结构 LogEntry。其中第一个字段 type，只有两种，一种是 0 表示 Normal，1 表示 ConfChange（ConfChange 表示 Etcd 本身的配置变更同步，比如有新的节点加入等）。第二个字段是 term，每个 term 代表一个主节点的任期，每次主节点变更 term 就会变化。第三个字段是 index，这个序号是严格有序递增的，代表变更序号。第四个字段是二进制的 data，将 raft request 对象的 pb 结构整个保存下。Etcd 源码下有个 tools/etcd-dump-logs，可以将 wal 日志 dump 成文本查看，可以协助分析 raft 协议。&lt;/p>
&lt;p>raft 协议本身不关心应用数据，也就是 data 中的部分，一致性都通过同步 wal 日志来实现，每个节点将从主节点收到的 data apply 到本地的存储，raft 只关心日志的同步状态，如果本地存储实现的有 bug，比如没有正确的将 data apply 到本地，也可能会导致数据不一致。&lt;/p>
&lt;p>Etcd v2 与 v3&lt;/p>
&lt;p>Etcd v2 和 v3 本质上是共享同一套 raft 协议代码的两个独立的应用，接口不一样，存储不一样，数据互相隔离。也就是说如果从 Etcd v2 升级到 Etcd v3，原来 v2 的数据还是只能用 v2 的接口访问，v3 的接口创建的数据也只能访问通过 v3 的接口访问。所以我们按照 v2 和 v3 分别分析。&lt;/p>
&lt;p>推荐在 Kubernetes 集群中使用 Etcd v3，v2 版本已在 Kubernetes v1.11 中弃用。&lt;/p>
&lt;p>Etcd v2 存储，Watch 以及过期机制&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lb3mb0/1616136460787-f5c53c06-f976-4d02-a992-a60abe753ec9.jpeg" alt="">&lt;/p>
&lt;p>etcdv2&lt;/p>
&lt;p>Etcd v2 是个纯内存的实现，并未实时将数据写入到磁盘，持久化机制很简单，就是将 store 整合序列化成 json 写入文件。数据在内存中是一个简单的树结构。比如以下数据存储到 Etcd 中的结构就如图所示。&lt;/p>
&lt;p>/nodes/1/name node1&lt;/p>
&lt;p>/nodes/1/ip 192.168.1.1&lt;/p>
&lt;p>store 中有一个全局的 currentIndex，每次变更，index 会加 1. 然后每个 event 都会关联到 currentIndex.&lt;/p>
&lt;p>当客户端调用 watch 接口（参数中增加 wait 参数）时，如果请求参数中有 waitIndex，并且 waitIndex 小于 currentIndex，则从 EventHistroy 表中查询 index 大于等于 waitIndex，并且和 watch key 匹配的 event，如果有数据，则直接返回。如果历史表中没有或者请求没有带 waitIndex，则放入 WatchHub 中，每个 key 会关联一个 watcher 列表。 当有变更操作时，变更生成的 event 会放入 EventHistroy 表中，同时通知和该 key 相关的 watcher。&lt;/p>
&lt;p>这里有几个影响使用的细节问题：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>EventHistroy 是有长度限制的，最长 1000。也就是说，如果你的客户端停了许久，然后重新 watch 的时候，可能和该 waitIndex 相关的 event 已经被淘汰了，这种情况下会丢失变更。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果通知 watcher 的时候，出现了阻塞（每个 watcher 的 channel 有 100 个缓冲空间），Etcd 会直接把 watcher 删除，也就是会导致 wait 请求的连接中断，客户端需要重新连接。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Etcd store 的每个 node 中都保存了过期时间，通过定时机制进行清理。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>从而可以看出，Etcd v2 的一些限制：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>过期时间只能设置到每个 key 上，如果多个 key 要保证生命周期一致则比较困难。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>watcher 只能 watch 某一个 key 以及其子节点（通过参数 recursive)，不能进行多个 watch。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>很难通过 watch 机制来实现完整的数据同步（有丢失变更的风险），所以当前的大多数使用方式是通过 watch 得知变更，然后通过 get 重新获取数据，并不完全依赖于 watch 的变更 event。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Etcd v3 存储，Watch 以及过期机制&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/lb3mb0/1616136460746-e9c93537-e374-4227-a464-765260bc4f75.jpeg" alt="">&lt;/p>
&lt;p>etcdv3&lt;/p>
&lt;p>Etcd v3 将 watch 和 store 拆开实现，我们先分析下 store 的实现。&lt;/p>
&lt;p>Etcd v3 store 分为两部分，一部分是内存中的索引，kvindex，是基于 google 开源的一个 golang 的 btree 实现的，另外一部分是后端存储。按照它的设计，backend 可以对接多种存储，当前使用的 boltdb。boltdb 是一个单机的支持事务的 kv 存储，Etcd 的事务是基于 boltdb 的事务实现的。Etcd 在 boltdb 中存储的 key 是 revision，value 是 Etcd 自己的 key-value 组合，也就是说 Etcd 会在 boltdb 中把每个版本都保存下，从而实现了多版本机制。&lt;/p>
&lt;p>举个例子： 用 etcdctl 通过批量接口写入两条记录：&lt;/p>
&lt;p>etcdctl txn &amp;laquo;&amp;lt;'&lt;/p>
&lt;p>put key1 &amp;ldquo;v1&amp;rdquo;&lt;/p>
&lt;p>put key2 &amp;ldquo;v2&amp;rdquo;&lt;/p>
&lt;p>'&lt;/p>
&lt;p>再通过批量接口更新这两条记录：&lt;/p>
&lt;p>etcdctl txn &amp;laquo;&amp;lt;'&lt;/p>
&lt;p>put key1 &amp;ldquo;v12&amp;rdquo;&lt;/p>
&lt;p>put key2 &amp;ldquo;v22&amp;rdquo;&lt;/p>
&lt;p>'&lt;/p>
&lt;p>boltdb 中其实有了 4 条数据：&lt;/p>
&lt;p>rev={3 0}, key=key1, value=&amp;ldquo;v1&amp;rdquo;&lt;/p>
&lt;p>rev={3 1}, key=key2, value=&amp;ldquo;v2&amp;rdquo;&lt;/p>
&lt;p>rev={4 0}, key=key1, value=&amp;ldquo;v12&amp;rdquo;&lt;/p>
&lt;p>rev={4 1}, key=key2, value=&amp;ldquo;v22&amp;rdquo;&lt;/p>
&lt;p>revision 主要由两部分组成，第一部分 main rev，每次事务进行加一，第二部分 sub rev，同一个事务中的每次操作加一。如上示例，第一次操作的 main rev 是 3，第二次是 4。当然这种机制大家想到的第一个问题就是空间问题，所以 Etcd 提供了命令和设置选项来控制 compact，同时支持 put 操作的参数来精确控制某个 key 的历史版本数。&lt;/p>
&lt;p>了解了 Etcd 的磁盘存储，可以看出如果要从 boltdb 中查询数据，必须通过 revision，但客户端都是通过 key 来查询 value，所以 Etcd 的内存 kvindex 保存的就是 key 和 revision 之前的映射关系，用来加速查询。&lt;/p>
&lt;p>然后我们再分析下 watch 机制的实现。Etcd v3 的 watch 机制支持 watch 某个固定的 key，也支持 watch 一个范围（可以用于模拟目录的结构的 watch），所以 watchGroup 包含两种 watcher，一种是 key watchers，数据结构是每个 key 对应一组 watcher，另外一种是 range watchers, 数据结构是一个 IntervalTree（不熟悉的参看文文末链接），方便通过区间查找到对应的 watcher。&lt;/p>
&lt;p>同时，每个 WatchableStore 包含两种 watcherGroup，一种是 synced，一种是 unsynced，前者表示该 group 的 watcher 数据都已经同步完毕，在等待新的变更，后者表示该 group 的 watcher 数据同步落后于当前最新变更，还在追赶。&lt;/p>
&lt;p>当 Etcd 收到客户端的 watch 请求，如果请求携带了 revision 参数，则比较请求的 revision 和 store 当前的 revision，如果大于当前 revision，则放入 synced 组中，否则放入 unsynced 组。同时 Etcd 会启动一个后台的 goroutine 持续同步 unsynced 的 watcher，然后将其迁移到 synced 组。也就是这种机制下，Etcd v3 支持从任意版本开始 watch，没有 v2 的 1000 条历史 event 表限制的问题（当然这是指没有 compact 的情况下）。&lt;/p>
&lt;p>另外我们前面提到的，Etcd v2 在通知客户端时，如果网络不好或者客户端读取比较慢，发生了阻塞，则会直接关闭当前连接，客户端需要重新发起请求。Etcd v3 为了解决这个问题，专门维护了一个推送时阻塞的 watcher 队列，在另外的 goroutine 里进行重试。&lt;/p>
&lt;p>Etcd v3 对过期机制也做了改进，过期时间设置在 lease 上，然后 key 和 lease 关联。这样可以实现多个 key 关联同一个 lease id，方便设置统一的过期时间，以及实现批量续约。&lt;/p>
&lt;p>相比 Etcd v2, Etcd v3 的一些主要变化：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>接口通过 grpc 提供 rpc 接口，放弃了 v2 的 http 接口。优势是长连接效率提升明显，缺点是使用不如以前方便，尤其对不方便维护长连接的场景。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>废弃了原来的目录结构，变成了纯粹的 kv，用户可以通过前缀匹配模式模拟目录。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内存中不再保存 value，同样的内存可以支持存储更多的 key。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>watch 机制更稳定，基本上可以通过 watch 机制实现数据的完全同步。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>提供了批量操作以及事务机制，用户可以通过批量事务请求来实现 Etcd v2 的 CAS 机制（批量事务支持 if 条件判断）。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Etcd，Zookeeper，Consul 比较&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Etcd 和 Zookeeper 提供的能力非常相似，都是通用的一致性元信息存储，都提供 watch 机制用于变更通知和分发，也都被分布式系统用来作为共享信息存储，在软件生态中所处的位置也几乎是一样的，可以互相替代的。二者除了实现细节，语言，一致性协议上的区别，最大的区别在周边生态圈。Zookeeper 是 apache 下的，用 java 写的，提供 rpc 接口，最早从 hadoop 项目中孵化出来，在分布式系统中得到广泛使用（hadoop, solr, kafka, mesos 等）。Etcd 是 coreos 公司旗下的开源产品，比较新，以其简单好用的 rest 接口以及活跃的社区俘获了一批用户，在新的一些集群中得到使用（比如 kubernetes）。虽然 v3 为了性能也改成二进制 rpc 接口了，但其易用性上比 Zookeeper 还是好一些。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>而 Consul 的目标则更为具体一些，Etcd 和 Zookeeper 提供的是分布式一致性存储能力，具体的业务场景需要用户自己实现，比如服务发现，比如配置变更。而 Consul 则以服务发现和配置变更为主要目标，同时附带了 kv 存储。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Etcd 的周边工具&lt;/p>
&lt;ol>
&lt;li>Confd&lt;/li>
&lt;/ol>
&lt;p>在分布式系统中，理想情况下是应用程序直接和 Etcd 这样的服务发现 / 配置中心交互，通过监听 Etcd 进行服务发现以及配置变更。但我们还有许多历史遗留的程序，服务发现以及配置大多都是通过变更配置文件进行的。Etcd 自己的定位是通用的 kv 存储，所以并没有像 Consul 那样提供实现配置变更的机制和工具，而 Confd 就是用来实现这个目标的工具。&lt;/p>
&lt;p>Confd 通过 watch 机制监听 Etcd 的变更，然后将数据同步到自己的一个本地存储。用户可以通过配置定义自己关注哪些 key 的变更，同时提供一个配置文件模板。Confd 一旦发现数据变更就使用最新数据渲染模板生成配置文件，如果新旧配置文件有变化，则进行替换，同时触发用户提供的 reload 脚本，让应用程序重新加载配置。&lt;/p>
&lt;p>Confd 相当于实现了部分 Consul 的 agent 以及 consul-template 的功能，作者是 kubernetes 的 Kelsey Hightower，但大神貌似很忙，没太多时间关注这个项目了，很久没有发布版本，我们着急用，所以 fork 了一份自己更新维护，主要增加了一些新的模板函数以及对 metad 后端的支持。confd&lt;/p>
&lt;ol>
&lt;li>Metad&lt;/li>
&lt;/ol>
&lt;p>服务注册的实现模式一般分为两种，一种是调度系统代为注册，一种是应用程序自己注册。调度系统代为注册的情况下，应用程序启动后需要有一种机制让应用程序知道『我是谁』，然后发现自己所在的集群以及自己的配置。Metad 提供这样一种机制，客户端请求 Metad 的一个固定的接口 /self，由 Metad 告知应用程序其所属的元信息，简化了客户端的服务发现和配置变更逻辑。&lt;/p>
&lt;p>Metad 通过保存一个 ip 到元信息路径的映射关系来做到这一点，当前后端支持 Etcd v3，提供简单好用的 http rest 接口。 它会把 Etcd 的数据通过 watch 机制同步到本地内存中，相当于 Etcd 的一个代理。所以也可以把它当做 Etcd 的代理来使用，适用于不方便使用 Etcd v3 的 rpc 接口或者想降低 Etcd 压力的场景。 metad&lt;/p>
&lt;p>Etcd 使用注意事项&lt;/p>
&lt;ol>
&lt;li>Etcd cluster 初始化的问题&lt;/li>
&lt;/ol>
&lt;p>如果集群第一次初始化启动的时候，有一台节点未启动，通过 v3 的接口访问的时候，会报告 Error: Etcdserver: not capable 错误。这是为兼容性考虑，集群启动时默认的 API 版本是 2.3，只有当集群中的所有节点都加入了，确认所有节点都支持 v3 接口时，才提升集群版本到 v3。这个只有第一次初始化集群的时候会遇到，如果集群已经初始化完毕，再挂掉节点，或者集群关闭重启（关闭重启的时候会从持久化数据中加载集群 API 版本），都不会有影响。&lt;/p>
&lt;ol>
&lt;li>Etcd 读请求的机制&lt;/li>
&lt;/ol>
&lt;p>v2 quorum=true 的时候，读取是通过 raft 进行的，通过 cli 请求，该参数默认为 true。&lt;/p>
&lt;p>v3 &amp;ndash;consistency=“l” 的时候（默认）通过 raft 读取，否则读取本地数据。sdk 代码里则是通过是否打开：WithSerializable option 来控制。&lt;/p>
&lt;p>一致性读取的情况下，每次读取也需要走一次 raft 协议，能保证一致性，但性能有损失，如果出现网络分区，集群的少数节点是不能提供一致性读取的。但如果不设置该参数，则是直接从本地的 store 里读取，这样就损失了一致性。使用的时候需要注意根据应用场景设置这个参数，在一致性和可用性之间进行取舍。&lt;/p>
&lt;ol>
&lt;li>Etcd 的 compact 机制&lt;/li>
&lt;/ol>
&lt;p>Etcd 默认不会自动 compact，需要设置启动参数，或者通过命令进行 compact，如果变更频繁建议设置，否则会导致空间和内存的浪费以及错误。Etcd v3 的默认的 backend quota 2GB，如果不 compact，boltdb 文件大小超过这个限制后，就会报错：”Error: etcdserver: mvcc: database space exceeded”，导致数据无法写入。&lt;/p>
&lt;p>etcd 的问题&lt;/p>
&lt;p>当前 Etcd 的 raft 实现保证了多个节点数据之间的同步，但明显的一个问题就是扩充节点不能解决容量问题。要想解决容量问题，只能进行分片，但分片后如何使用 raft 同步数据？只能实现一个 multiple group raft，每个分片的多个副本组成一个虚拟的 raft group，通过 raft 实现数据同步。当前实现了 multiple group raft 的有 TiKV 和 Cockroachdb，但尚未一个独立通用的。理论上来说，如果有了这套 multiple group raft，后面挂个持久化的 kv 就是一个分布式 kv 存储，挂个内存 kv 就是分布式缓存，挂个 lucene 就是分布式搜索引擎。当然这只是理论上，要真实现复杂度还是不小。&lt;/p>
&lt;p>注： 部分转自 jolestar 和 infoq.&lt;/p>
&lt;p>参考文档&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Etcd website&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Etcd github&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Projects using etcd&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://jolestar.com/etcd-architecture/">http://jolestar.com/etcd-architecture/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>etcd 从应用场景到实现原理的全方位解读&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: Etcd 命令行工具</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid><description/></item><item><title>Docs: Etcd 配置详解</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://etcd.io/docs/current/op-guide/configuration/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Etcd 运行时的行为可以通过三种方式进行配置&lt;/p>
&lt;ol>
&lt;li>配置文件&lt;/li>
&lt;li>命令行标志&lt;/li>
&lt;li>环境变量&lt;/li>
&lt;/ol>
&lt;p>而一般情况，配置文件中的关键字 与 命令行标志 和 环境变量 是 一一对应的。比如：&lt;/p>
&lt;ol>
&lt;li>配置文件中关键字：ETCD_DATA_DIR&lt;/li>
&lt;li>对应的环境变量中的变量名：ETCD_DATA_DIR&lt;/li>
&lt;li>对应的 flag： &amp;ndash;data-dir&lt;/li>
&lt;/ol>
&lt;p>优先级：配置文件 &amp;gt; 命令行标志 &amp;gt; 环境变量&lt;/p>
&lt;h2 id="member-成员相关标志">Member 成员相关标志&lt;a class="td-heading-self-link" href="#member-%e6%88%90%e5%91%98%e7%9b%b8%e5%85%b3%e6%a0%87%e5%bf%97" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&amp;ndash;name # member 的名称。&lt;code>默认值：default&lt;/code>
&amp;ndash;data-dir # etcd 数据存储路径。&lt;code>默认值：${name}.etcd&lt;/code>。一般大家都修改到 /var/lib/etcd 下。
&amp;ndash;wal-dir
&amp;ndash;snapshot-count
&amp;ndash;heartbeat-interval # 心跳检测的间隔时间，时间单位是 milliseconds(毫秒)。&lt;code>默认值：100&lt;/code>&lt;/p>
&lt;ul>
&lt;li>注意：修改心跳值的同时要修改 election-timeout 标志。因为 选举超时 时间至少需要是 心跳检测间隔的 5 倍，如果达不到 5 倍，则 etcd 启动失败&lt;/li>
&lt;/ul>
&lt;p>&amp;ndash;election-timeout # 选举超时时间，时间单位是 milliseconds(毫秒)。&lt;code>默认值：1000&lt;/code>
&amp;ndash;listen-peer-urls # 监听的用于节点之间通信的 url，可监听多个，集群内部将通过这些 url 进行数据交互(如选举，数据同步等)
&amp;ndash;listen-client-urls # 监听的用于客户端通信的 url，同样可以监听多个。
&amp;ndash;max-snapshots
&amp;ndash;max-wals
&amp;ndash;cors
&amp;ndash;quota-backend-bytes # etcd 可储存的数据配额上限。&lt;code>默认值：0&lt;/code>。&lt;/p>
&lt;blockquote>
&lt;p>默认值 0 表示最低配额。在 3.4 版本时，最低配额是 2G，也就是说 etcd 最多可以保存 2G 的数据。&lt;/p>
&lt;/blockquote>
&lt;p>&amp;ndash;backend-batch-limit
&amp;ndash;backend-bbolt-freelist-type
&amp;ndash;backend-batch-interval
&amp;ndash;max-txn-ops
&amp;ndash;max-request-bytes
&amp;ndash;grpc-keepalive-min-time
&amp;ndash;grpc-keepalive-interval
&amp;ndash;grpc-keepalive-timeout&lt;/p>
&lt;h2 id="clustering-集群相关标志">Clustering 集群相关标志&lt;a class="td-heading-self-link" href="#clustering-%e9%9b%86%e7%be%a4%e7%9b%b8%e5%85%b3%e6%a0%87%e5%bf%97" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>注意：
&amp;ndash;initial-advertise-peer-urls，-initial-cluster，-initial-cluster-state 和 &amp;ndash;initial-cluster-token 这 4 个标志是比较特殊的存在。只在 etcd 第一次启动并加入集群之前生效。
上面这 4 个标志用于引导（静态引导，服务发现引导 or 运行时配置）新成员，并且已经在集群中的成员重新启动时，将忽略这些标志。
使用发现服务时，需要设置 &amp;ndash;discovery 前缀标志。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>&amp;ndash;initial-advertise-peer-urls&lt;/strong> # 用于节点间通信的 URL，节点间以该值进行通信。&lt;/p>
&lt;ul>
&lt;li>默认值： &lt;a href="http://localhost:2380">http://localhost:2380&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>&amp;ndash;initial-cluster&lt;/strong> # 用来引导初始集群的配置。一般是集群中所有 &amp;ndash;initial-advertise-peer-urls 标志值的合集，每个值以逗号分隔&lt;/p>
&lt;ul>
&lt;li>默认值：default=&lt;a href="http://localhost:2380">http://localhost:2380&lt;/a>&lt;/li>
&lt;li>default 是每个节点的 etcd 的 &amp;ndash;name 标志的值。&amp;ndash;name 标志的默认值就是 default&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>&amp;ndash;initial-cluster-state&lt;/strong> # 初始群集状态(两种状态：new 或 existing)。&lt;/p>
&lt;ul>
&lt;li>默认值： new&lt;/li>
&lt;li>new # 对于在初始静态或 DNS 引导过程中存在的所有成员，将其设置为 new。&lt;/li>
&lt;li>existing # 设为 existing 状态的 etcd 将尝试加入 &amp;ndash;initial-cluster 标志指定的集群。如果设置了错误的值，则 etcd 将尝试启动但安全失败。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>&amp;ndash;initial-cluster-token&lt;/strong> # 初始集群引导时所使用的 token。设置该值后集群将生成唯一 id，并为每个节点也生成唯一 id，当使用相同配置文件再启动一个集群时，只要该 token 值不一样，etcd 集群就不会相互影响。&lt;/p>
&lt;ul>
&lt;li>默认值：etcd-cluster&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>&amp;ndash;advertise-client-urls&lt;/strong> # 建议使用的客户端通信 url，该值用于 etcd 代理或 etcd 成员与 etcd 节点通信。&lt;/p>
&lt;ul>
&lt;li>默认值：&lt;a href="http://localhost:2379">http://localhost:2379&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&amp;ndash;discovery #
&amp;ndash;discovery-srv #
&amp;ndash;discovery-srv-name #
&amp;ndash;discovery-fallback #
&amp;ndash;discovery-proxy #
&amp;ndash;strict-reconfig-check #
&amp;ndash;auto-compaction-retention #
&amp;ndash;auto-compaction-mode #
&amp;ndash;enable-v2 #&lt;/p>
&lt;h2 id="proxy-代理相关标志">Proxy 代理相关标志&lt;a class="td-heading-self-link" href="#proxy-%e4%bb%a3%e7%90%86%e7%9b%b8%e5%85%b3%e6%a0%87%e5%bf%97" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&amp;ndash;proxy&lt;/p>
&lt;p>&amp;ndash;proxy-failure-wait&lt;/p>
&lt;p>&amp;ndash;proxy-refresh-interval&lt;/p>
&lt;p>&amp;ndash;proxy-dial-timeout&lt;/p>
&lt;p>&amp;ndash;proxy-write-timeout&lt;/p>
&lt;p>&amp;ndash;proxy-read-timeout&lt;/p>
&lt;h2 id="security-安全相关标志">Security 安全相关标志&lt;a class="td-heading-self-link" href="#security-%e5%ae%89%e5%85%a8%e7%9b%b8%e5%85%b3%e6%a0%87%e5%bf%97" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>安全相关的标志用来帮助&lt;a href="https://github.com/etcd-io/etcd/blob/master/Documentation/op-guide/security.md">建立一个安全的 etcd 集群&lt;/a>&lt;/p>
&lt;p>&amp;ndash;ca-file&lt;/p>
&lt;p>&amp;ndash;cert-file&lt;/p>
&lt;p>&amp;ndash;key-file&lt;/p>
&lt;p>&amp;ndash;client-cert-auth&lt;/p>
&lt;p>&amp;ndash;client-crl-file&lt;/p>
&lt;p>&amp;ndash;client-cert-allowed-hostname&lt;/p>
&lt;p>&amp;ndash;trusted-ca-file&lt;/p>
&lt;p>&amp;ndash;auto-tls&lt;/p>
&lt;p>&amp;ndash;peer-ca-file&lt;/p>
&lt;p>&amp;ndash;peer-cert-file&lt;/p>
&lt;p>&amp;ndash;peer-key-file&lt;/p>
&lt;p>&amp;ndash;peer-client-cert-auth&lt;/p>
&lt;p>&amp;ndash;peer-crl-file&lt;/p>
&lt;p>&amp;ndash;peer-trusted-ca-file&lt;/p>
&lt;p>&amp;ndash;peer-auto-tls&lt;/p>
&lt;p>&amp;ndash;peer-cert-allowed-cn&lt;/p>
&lt;p>&amp;ndash;peer-cert-allowed-hostname&lt;/p>
&lt;p>&amp;ndash;cipher-suites&lt;/p>
&lt;h2 id="logging-flags">Logging flags&lt;a class="td-heading-self-link" href="#logging-flags" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&amp;ndash;logger&lt;/p>
&lt;p>&amp;ndash;log-outputs&lt;/p>
&lt;p>&amp;ndash;log-level&lt;/p>
&lt;p>&amp;ndash;debug&lt;/p>
&lt;p>&amp;ndash;log-package-levels&lt;/p>
&lt;h2 id="unsafe-flags">Unsafe flags&lt;a class="td-heading-self-link" href="#unsafe-flags" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&amp;ndash;force-new-cluster&lt;/p>
&lt;h2 id="miscellaneous-flags">Miscellaneous flags&lt;a class="td-heading-self-link" href="#miscellaneous-flags" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&amp;ndash;version&lt;/p>
&lt;p>&amp;ndash;config-file&lt;/p>
&lt;h2 id="profiling-flags">Profiling flags&lt;a class="td-heading-self-link" href="#profiling-flags" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&amp;ndash;enable-pprof&lt;/p>
&lt;p>&amp;ndash;metrics&lt;/p>
&lt;p>&amp;ndash;listen-metrics-urls&lt;/p>
&lt;h2 id="auth-flags">Auth flags&lt;a class="td-heading-self-link" href="#auth-flags" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>&amp;ndash;auth-token&lt;/p>
&lt;p>&amp;ndash;bcrypt-cost&lt;/p>
&lt;h2 id="experimental-flags">Experimental flags&lt;a class="td-heading-self-link" href="#experimental-flags" aria-label="Heading self-link">&lt;/a>&lt;/h2>
&lt;p>-experimental-corrupt-check-time&lt;/p>
&lt;p>&amp;ndash;experimental-compaction-batch-limit&lt;/p>
&lt;p>&amp;ndash;experimental-peer-skip-client-san-verification&lt;/p></description></item><item><title>Docs: Etcd 数据模型</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/Etcd-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</guid><description>
&lt;h1 id="概述">概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://etcd.io/docs/latest/learning/data_model/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="wal">WAL&lt;a class="td-heading-self-link" href="#wal" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>数据库通常使用 &lt;a href="https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/WAL.md">WAL&lt;/a>； etcd 也使用它。有关预写日志记录的详细信息不在本文讨论范围之内，但是出于此目的，我们需要知道的是-每个 etcd 集群成员都在持久性存储上保留一个预写日志（WAL）。 etcd 在将某些操作（例如更新）写入键值存储之前，将其写入 WAL。如果成员崩溃并在快照之间重新启动，则可以通过查看 WAL 的内容在本地恢复自上次快照以来完成的事务。&lt;/p>
&lt;p>因此，每当客户将密钥添加到键值存储或更新现有密钥的值时，客户端都会 etcd 在 WAL 上附加一个记录操作的条目，WAL 是持久性存储上的普通文件。在继续进行之前， etcd 必须 100％确信 WAL 条目已被实际保留。要在 Linux 上实现此目的，仅使用 write 系统调用是不够的， 因为实际写入物理存储的时间可能会延迟。例如，Linux 可能会将写入的 WAL 条目在内核内存高速缓存（例如页面高速缓存）中保留一段时间。为了确保将数据写入持久性存储中，您必须在“”之后调用 fdatasync 系统调用，write 这正是该 etcd 操作（如以下 strace 所示） 输出，其中 8 是 WAL 文件的文件描述符）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>21:23:09.894875 lseek&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>8, 0, SEEK_CUR&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">12808&lt;/span> &amp;lt;0.000012&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>21:23:09.894911 write&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>8, &lt;span style="color:#4e9a06">&amp;#34;.\0\0\0\0\0\0\202\10\2\20\361\223\255\266\6\32&lt;/span>$&lt;span style="color:#4e9a06">\10\0\20\10\30\26\&amp;#34;\34\&amp;#34;\r\n\3fo&amp;#34;&lt;/span>..., 2296&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">2296&lt;/span> &amp;lt;0.000130&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>21:23:09.895041 fdatasync&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>8&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> &amp;lt;0.008314&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不幸的是，写入持久性存储需要时间。如果 fdatasync 花费太长时间，则 etcd 系统性能会降低。 &lt;a href="https://github.com/etcd-io/etcd/blob/master/Documentation/faq.md#what-does-the-etcd-warning-failed-to-send-out-heartbeat-on-time-mean">etcd 文档建议&lt;/a> 为了使存储足够快，fdatasync 写入 WAL 文件时调用的第 99 个百分点 &lt;strong>必须小于 10ms&lt;/strong>。还有其他与存储相关的指标，但这是本文的重点。&lt;/p>
&lt;h1 id="bbolt">bbolt&lt;a class="td-heading-self-link" href="#bbolt" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;a href="https://github.com/DesistDaydream/go-library/tree/master/bbolt">https://github.com/DesistDaydream/go-library/tree/master/bbolt&lt;/a> 代码练习&lt;/p></description></item><item><title>Docs: revision概念</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/revision-%E6%A6%82%E5%BF%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE/Etcd/revision-%E6%A6%82%E5%BF%B5/</guid><description>
&lt;h1 id="heading">&lt;a class="td-heading-self-link" href="#heading" aria-label="Heading self-link">&lt;/a>&lt;/h1>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dv1a6u/1616136169287-784743e4-15d5-4b53-81a3-4ba3477a27d4.jpeg" alt="">&lt;/p>
&lt;p>每次 key 的 value 改变，version 都会+1&lt;/p>
&lt;p>revision 概念&lt;/p>
&lt;p>Etcd 存储数据时，并不是像其他的 KV 存储那样，存放数据的键做为 key，而是以数据的 revision 做为 key，键值做为数据来存放。如何理解 revision 这个概念，以下面的例子来说明。&lt;/p>
&lt;p>比如通过批量接口两次更新两对键值，第一次写入数据时，写入和，在 Etcd 这边的存储看来，存放的数据就是这样的：&lt;/p>
&lt;pre>&lt;code>revision={1,0}, key=key1, value=value1
revision={1,1}, key=key2, value=value2
&lt;/code>&lt;/pre>
&lt;p>而在第二次更新写入数据和后，存储中又记录（注意不是覆盖前面的数据）了以下数据：&lt;/p>
&lt;pre>&lt;code>revision={2,0}, key=key1, value=update1
revision={2,1}, key=key2, value=update2
&lt;/code>&lt;/pre>
&lt;p>其中 revision 有两部分组成，第一部分成为 main revision，每次事务递增 1；第二部分称为 sub revision，一个事务内的一次操作递增 1。 两者结合，就能保证每次 key 唯一而且是递增的。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dv1a6u/1616136169539-c45ecbb0-f59a-48f4-b901-9cb6b923f169.jpeg" alt="">&lt;/p>
&lt;p>但是，就客户端看来，每次操作的时候是根据 Key 来进行操作的，所以这里就需要一个 Key 映射到当前 revision 的操作了，为了做到这个映射关系，Etcd 引入了一个内存中的 Btree 索引，整个操作过程如下面的流程所示。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dv1a6u/1616136169298-3f7e3fa8-e446-400e-8830-f3fdaf07e6b5.jpeg" alt="">&lt;/p>
&lt;p>查询时，先通过内存中的 btree 索引来查询该 key 对应的 keyIndex 结构体，然后再根据这个结构体才能去 boltdb 中查询真实的数据返回。&lt;/p>
&lt;p>所以，下面先展开讨论这个 keyIndex 结构体和 btree 索引。&lt;/p>
&lt;p>keyIndex 结构&lt;/p>
&lt;p>keyIndex 结构体有以下成员：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>key：存储数据真实的键。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>modified：最后一次修改该键对应的 revision。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>generations：generation 数组。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>如何理解 generation 结构呢，可以认为每个 generation 对应一个数据从创建到删除的过程。每次删除 key 的操作，都会导致一个 generation 最后添加一个 tombstone 记录，然后创建一个新的空 generation 记录添加到 generations 数组中。&lt;/p>
&lt;p>generation 结构体存放以下数据：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>ver：当前 generation 中存放了多少次修改，其实就是 revs 数组的大小-1（因为需要去掉 tombstone）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>created：创建该 generation 时的 revision。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>revs：存放该 generation 中存放的 revision 数组。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>以下图来说明 keyIndex 结构体：&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dv1a6u/1616136169269-c36dd19f-ee7b-40db-873d-c6da6b81da6e.jpeg" alt="">&lt;/p>
&lt;p>如上图所示，存放的键为 test 的 keyIndex 结构。&lt;/p>
&lt;p>它的 generations 数组有两条记录，其中 generations[0]在 revision 1.0 时创建，当 revision2.1 的时候进行 tombstone 操作，因此该 generation 的 created 是 1.0；对应的 generations[1]在 revision3.3 时创建，紧跟着就做了 tombstone 操作。&lt;/p>
&lt;p>所以该 keyIndex.modifiled 成员存放的是 3.3，因为这是这条数据最后一次被修改的 revision。&lt;/p>
&lt;p>一个已经被 tombstone 的 generation 是可以被删除的，如果整个 generations 数组都已经被删除空了，那么整个 keyIndex 记录也可以被删除了。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/dv1a6u/1616136169303-1a5e569c-0985-495b-b196-ab09de02c4ad.jpeg" alt="">&lt;/p>
&lt;p>如上图所示，keyIndex.compact(n)函数可以对 keyIndex 数据进行压缩操作，将删除满足 main revision &amp;lt; n 的数据。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>compact(2)：找到了 generations[0]的 1.0 revision 的数据进行了删除。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>compact(3)：找到了 generations[0]的 2.1 revision 的数据进行了删除，此时由于 generations[0]已经没有数据了，所以这一整个 generation 被删除，原先的 generations[1]变成了 generations[0]。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>compact(4)：找到了 generations[0]的 3.3 revision 的数据进行了删除。由于所有的 generation 数据都被删除了，此时这个 keyIndex 数据可以删除了。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>treeIndex 结构&lt;/p>
&lt;p>Etcd 中使用 treeIndex 来在内存中存放 keyIndex 数据信息，这样就可以快速的根据输入的 key 定位到对应的 keyIndex。&lt;/p>
&lt;p>treeIndex 使用开源的 github.com/google/btree 来在内存中存储 btree 索引信息，因为用的是外部库，所以不打算就这部分做解释。而如果很清楚了前面 keyIndex 结构，其实这部分很好理解。&lt;/p>
&lt;p>所有的操作都以 key 做为参数进行操作，treeIndex 使用 btree 根据 key 查找到对应的 keyIndex，再进行相关的操作，最后重新写入到 btree 中。&lt;/p></description></item></channel></rss>