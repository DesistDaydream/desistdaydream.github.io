<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>其他 on 断念梦的站点</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E5%85%B6%E4%BB%96/</link><description>Recent content in 其他 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E5%85%B6%E4%BB%96/index.xml" rel="self" type="application/rss+xml"/><item><title>多路径multipath</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E5%85%B6%E4%BB%96/%E5%A4%9A%E8%B7%AF%E5%BE%84multipath/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E5%85%B6%E4%BB%96/%E5%A4%9A%E8%B7%AF%E5%BE%84multipath/</guid><description>所需安装的组件：
device-mapper-multipath-libs-XXXX device-mapper-multipath-XXXX 配置说明详见官方文档：https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/dm_multipath/mpio_description
配置示例：
# This is a basic configuration file with some examples, for device mapper # multipath. # # For a complete list of the default configuration values, run either # multipath -t # or # multipathd show config # # For a list of configuration options with descriptions, see the multipath.conf # man page ## By default, devices with vendor = &amp;#34;IBM&amp;#34; and product = &amp;#34;S/390.*&amp;#34; are ## blacklisted.</description></item><item><title>如何实现rsync多并发同步？</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E5%85%B6%E4%BB%96/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0rsync%E5%A4%9A%E5%B9%B6%E5%8F%91%E5%90%8C%E6%AD%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E5%85%B6%E4%BB%96/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0rsync%E5%A4%9A%E5%B9%B6%E5%8F%91%E5%90%8C%E6%AD%A5/</guid><description>原文: https://mp.weixin.qq.com/s/py_AxuJ60YhKx329j7B_KA
前言
工作中经常会遇到 数据拷贝 或者 数据同步 事情。一般情况会使用 rsync 来做数据拷贝或者数据同步等。
问题 rsync 不能做并发同步，特别是需要拷贝 上 T 数据 时，rsync 一个进程拷贝有很大的瓶颈，不能把存储设备 IO 性能发挥的最好或者说把存储设备 IO 跑满。有什么方法让 rsync 实现多进程同步，并且自动识别目录下有多少个文件或者目录，不会出现重复性同步。
解决方法 下面是作者写的一个 shell 脚本，实现 rsync 多进程同步。
#!/usr/bin/env bash # Define source, target, maxdepth and cd to source source=&amp;#34;/tmp/tmp_data&amp;#34; target=&amp;#34;/tmp/tmp_data2&amp;#34; depth=3 cd &amp;#34;${source}&amp;#34; # Set the maximum number of concurrent rsync threads maxthreads=5 # How long to wait before checking the number of rsync threads again sleeptime=5 # Find all folders in the source directory within the maxdepth level find .</description></item><item><title>预读失效与缓存污染</title><link>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E5%85%B6%E4%BB%96/%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88%E4%B8%8E%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/docs/5.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E5%85%B6%E4%BB%96/%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88%E4%B8%8E%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93/</guid><description>概述 参考：
公众号-小林 coding，说两个问题 大家好，我是小林。
上周群里看到有位小伙伴面试时，被问到这两个问题： 咋一看，以为是在问操作系统的问题，其实这两个题目都是在问如何改进 LRU 算法。
因为传统的 LRU 算法存在这两个问题：
「预读失效」导致缓存命中率下降（对应第一个问题） 「缓存污染」导致缓存命中率下降（对应第二个问题） Redis 的缓存淘汰算法则是通过实现 LFU 算法来避免「缓存污染」而导致缓存命中率下降的问题（Redis 没有预读机制）。
MySQL 和 Linux 操作系统是通过改进 LRU 算法来避免「预读失效和缓存污染」而导致缓存命中率下降的问题。
这次，就重点讲讲 MySQL 和 Linux 操作系统是如何改进 LRU 算法的？
好了，开始发车，坐稳了！
Linux 和 MySQL 的缓存 Linux 操作系统的缓存 在应用程序读取文件的数据的时候，Linux 操作系统是会对读取的文件数据进行缓存的，会缓存在文件系统中的 Page Cache（如下图中的页缓存）。
Page Cache 属于内存空间里的数据，由于内存访问比磁盘访问快很多，在下一次访问相同的数据就不需要通过磁盘 I/O 了，命中缓存就直接返回数据即可。
因此，Page Cache 起到了加速访问数据的作用。
MySQL 的缓存 MySQL 的数据是存储在磁盘里的，为了提升数据库的读写性能，Innodb 存储引擎设计了一个缓冲池（Buffer Pool），Buffer Pool 属于内存空间里的数据。
有了缓冲池后：
当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。 当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘。 传统 LRU 是如何管理内存数据的？ Linux 的 Page Cache 和 MySQL 的 Buffer Pool 的大小是有限的，并不能无限的缓存数据，对于一些频繁访问的数据我们希望可以一直留在内存中，而一些很少访问的数据希望可以在某些时机可以淘汰掉，从而保证内存不会因为满了而导致无法再缓存新的数据，同时还能保证常用数据留在内存中。</description></item></channel></rss>