<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>断念梦 – 博客</title><link>https://desistdaydream.github.io/blog/</link><description>Recent content in 博客 on 断念梦</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 26 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://desistdaydream.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Blog: 硬核致敬Linux ！30岁生日快乐！</title><link>https://desistdaydream.github.io/blog/copy/cE4x63tYxoqrDinifeWqeg/</link><pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/blog/copy/cE4x63tYxoqrDinifeWqeg/</guid><description>
&lt;p>原文链接：&lt;a href="https://mp.weixin.qq.com/s/cE4x63tYxoqrDinifeWqeg">https://mp.weixin.qq.com/s/cE4x63tYxoqrDinifeWqeg&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhH4SOtTAkhF5RQnT4PAWdG2NT9Smu9eqEV5PAwKq3PbC6iagpqsfWz47RFLIZibibcIDAn3IyVS0ahw/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>1991年8月25日，21岁的Linus Torvalds（以下简称Linus）做了一个免费的操作系统“Linux”，并在这一天向外界公布这个由“业余爱好”主导的个人项目；如今，全球超级计算机500强和超过70%的智能手机都在运行Linux，因此，8月25日也被许多Linux的爱好者视为Linux真正的诞生日期。&lt;/p>
&lt;h1 id="你好">你好&lt;/h1>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgH5rcBjAWV0lF8QBtlXSJgRrJqBP90P2rfTd8WpVRAtyzqxhbXd6QnNg/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>30 年前，Linus Torvalds 首次发布 Linux 内核时还是赫尔辛基大学的一名 21 岁学生。他的声明是这样开始的，“我正在做一个（免费的）操作系统（只是一个爱好，不会很大和专业&amp;hellip;&amp;hellip;）”。三十年后，排名前 500 的超级计算机都在运行 Linux，所有智能手机的 70% 以上都是如此。Linux 显然既庞大又专业。&lt;/p>
&lt;p>三十年来，Linus Torvalds 领导了 Linux 内核开发，激励了无数其他开发人员和开源项目。2005 年，Linus 还创建了 Git来帮助管理内核开发过程，此后它成为最受欢迎的版本控制系统，受到无数开源和专有项目的信赖。&lt;/p>
&lt;h3 id="linux历史">Linux历史&lt;/h3>
&lt;p>&lt;strong>OS史前历史&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHE70XibBtS3DT8Nf3r5k48PGFo8ON6CPEsuyBOxIia8eLIQOuuz6JV1aA/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>&lt;strong>Linux的历史&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHRicpx9aScqDmIdIib1M2UdibnVGVHJoTR5j94qiaCosHsT4G1XlPL1vYzA/640?wx_fmt=png" alt="">&lt;/p>
&lt;h3 id="linux系统">Linux系统&lt;/h3>
&lt;p>&lt;strong>Linux系统软件架构&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgH1QmL07tiarw5K00x2LuwJEaRFCR4eev2O1DI1uEd6rZPOKnNZHzv5Eg/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>Linux系统由硬件、kernel、系统调用、shell、c库、应用程序组成，架构层次分明，Linux内的各种层功能独立，程序在用户空间和内核空间之间的分离，能支持更多应用。&lt;/p>
&lt;p>| 用户模态 | &lt;strong>用户应用&lt;/strong> | 例如：Bash，LibreOffice，GIMP，Blender，0 A.D.，Mozilla Firefox等 |
| 低层系统构件 | &lt;strong>系统守护进程&lt;/strong>：&lt;br>
systemd，runit，logind，networkd，PulseAudio等 | &lt;strong>窗口系统&lt;/strong>：&lt;br>
X11，Wayland，SurfaceFlinger(Android) | &lt;strong>其他库&lt;/strong>：&lt;br>
GTK+, Qt, EFL, SDL, SFML, FLTK, GNUstep等 | &lt;strong>图形&lt;/strong>：&lt;br>
Mesa，AMD Catalyst等 |
| &lt;strong>C标准库&lt;/strong> | open()，exec()，sbrk()，socket()，fopen()，calloc()，&amp;hellip; (直到2000个子例程)&lt;br>
glibc目标为POSIX/SUS兼容，musl和uClibc目标为嵌入式系统，bionic为Android而写等 |
| 内核模态 | &lt;strong>Linux内核&lt;/strong> | stat, splice, dup, read, open, ioctl, write, mmap, close, exit等（大约380个系统调用）&lt;br>
Linux内核系统调用接口（SCI，目标为POSIX/SUS兼容） |
| 进程调度子系统 | IPC子系统 | 内存管理子系统 | 虚拟文件子系统 | 网络子系统 |
| 其他构件：ALSA，DRI，evdev，LVM，device mapper，Linux Network Scheduler，Netfilter&lt;br>
Linux安全模块：SELinux，TOMOYO，AppArmor, Smack |
| 硬件（CPU，内存，数据存储设备等。） |&lt;/p>
&lt;p>&lt;strong>Linux内核代码架构&lt;/strong>&lt;/p>
&lt;p>&lt;strong>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHSXWCabp9jDHopYuOGHSSq3HgXcQKLkWedlzYiaNOBStEEod9YkB8JAw/640?wx_fmt=jpeg" alt="">&lt;/strong>&lt;/p>
&lt;p>Linux代码包含核心几个子系统，比如&lt;strong>内存子系统&lt;/strong>，&lt;strong>I/O子系统&lt;/strong>，&lt;strong>CPU(调度）子系统&lt;/strong>，&lt;strong>设备驱动子系统&lt;/strong>，&lt;strong>网络子系统&lt;/strong>，&lt;strong>虚拟文件子系统&lt;/strong>等。这里简单介绍一些比较重要的子系统。&lt;/p>
&lt;h3 id="调度子系统">调度子系统&lt;/h3>
&lt;p>&lt;strong>进程调度&lt;/strong>是Linux内核中最重要的子系统，它主要提供对CPU的访问控制。因为在计算机中，CPU资源是有限的，而众多的应用程序都要使用CPU资源，所以需要“进程调度子系统”对CPU进行调度管理。&lt;/p>
&lt;p>&lt;strong>进程调度子系统&lt;/strong>包括4个子模块（见下图），它们的功能如下：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHzhTgCrceib1hkg2RZuwSgf86iaN2JfyHMptZFZGdw0fhQW1hNLgMBlHA/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Scheduling Policy，实现进程调度的策略，它决定哪个（或哪几个）进程将拥有CPU。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Architecture-specific Schedulers，体系结构相关的部分，用于将对不同CPU的控制，抽象为统一的接口。这些控制主要在suspend和resume进程时使用，牵涉到CPU的寄存器访问、汇编指令操作等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Architecture-independent Scheduler，体系结构无关的部分。它会和“Scheduling Policy模块”沟通，决定接下来要执行哪个进程，然后通过“Architecture-specific Schedulers模块”resume指定的进程。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>System Call Interface，系统调用接口。进程调度子系统通过系统调用接口，将需要提供给用户空间的接口开放出去，同时屏蔽掉不需要用户空间程序关心的细节。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="内存子系统">内存子系统&lt;/h3>
&lt;p>&lt;strong>内存管理&lt;/strong>同样是Linux内核中最重要的子系统，它主要提供对内存资源的访问控制。Linux系统会在硬件物理内存和进程所使用的内存（称作虚拟内存）之间建立一种映射关系，这种映射是以进程为单位，因而不同的进程可以使用相同的虚拟内存，而这些相同的虚拟内存，可以映射到不同的物理内存上。&lt;/p>
&lt;p>&lt;strong>内存管理子系统&lt;/strong>包括3个子模块（见下图），它们的功能如下：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHNY1OZLaKPcddjClNYLNRmEPuUt7fQf7iafZ7eJtrP46fWqws0wD5yww/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Architecture Specific Managers，体系结构相关部分。提供用于访问硬件Memory的虚拟接口。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Architecture Independent Manager，体系结构无关部分。提供所有的内存管理机制，包括：以进程为单位的memory mapping；虚拟内存的Swapping。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>System Call Interface，系统调用接口。通过该接口，向用户空间程序应用程序提供内存的分配、释放，文件的map等功能。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="虚拟文件子系统virtual-filesystem-vfs">虚拟文件子系统（Virtual Filesystem, VFS）&lt;/h3>
&lt;p>传统意义上的文件系统，是一种存储和组织计算机数据的方法。它用易懂、人性化的方法（文件和目录结构），抽象计算机磁盘、硬盘等设备上冰冷的数据块，从而使对它们的查找和访问变得容易。因而文件系统的实质，就是“存储和组织数据的方法”，文件系统的表现形式，就是“从某个设备中读取数据和向某个设备写入数据”。&lt;/p>
&lt;p>随着计算机技术的进步，存储和组织数据的方法也是在不断进步的，从而导致有多种类型的文件系统，例如FAT、FAT32、NTFS、EXT2、EXT3等等。而为了兼容，操作系统或者内核，要以相同的表现形式，同时支持多种类型的文件系统，这就延伸出了**虚拟文件系统（VFS）**的概念。VFS的功能就是管理各种各样的文件系统，屏蔽它们的差异，以统一的方式，为用户程序提供访问文件的接口。&lt;/p>
&lt;p>我们可以从磁盘、硬盘、NAND Flash等设备中读取或写入数据，因而最初的文件系统都是构建在这些设备之上的。这个概念也可以推广到其它的硬件设备，例如内存、显示器（LCD）、键盘、串口等等。我们对硬件设备的访问控制，也可以归纳为读取或者写入数据，因而可以用统一的文件操作接口访问。Linux内核就是这样做的，除了传统的磁盘文件系统之外，它还抽象出了设备文件系统、内存文件系统等等。这些逻辑，都是由VFS子系统实现。&lt;/p>
&lt;p>&lt;strong>VFS子系统&lt;/strong>包括6个子模块（见下图），它们的功能如下：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHxGOz2c8yZ6yxrrHeibxu3ac8nibP9KGUkVkrXPmgIH9iasFgLjaofdWqA/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Device Drivers，设备驱动，用于控制所有的外部设备及控制器。由于存在大量不能相互兼容的硬件设备（特别是嵌入式产品），所以也有非常多的设备驱动。因此，Linux内核中将近一半的Source Code都是设备驱动，大多数的Linux底层工程师（特别是国内的企业）都是在编写或者维护设备驱动，而无暇估计其它内容（它们恰恰是Linux内核的精髓所在）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Device Independent Interface， 该模块定义了描述硬件设备的统一方式（统一设备模型），所有的设备驱动都遵守这个定义，可以降低开发的难度。同时可以用一致的形势向上提供接口。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Logical Systems，每一种文件系统，都会对应一个Logical System（逻辑文件系统），它会实现具体的文件系统逻辑。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>System Independent Interface，该模块负责以统一的接口（快设备和字符设备）表示硬件设备和逻辑文件系统，这样上层软件就不再关心具体的硬件形态了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>System Call Interface，系统调用接口，向用户空间提供访问文件系统和硬件设备的统一的接口。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="网络子系统net">网络子系统（Net）&lt;/h3>
&lt;p>&lt;strong>网络子系统&lt;/strong>在Linux内核中主要负责管理各种网络设备，并实现各种网络协议栈，最终实现通过网络连接其它系统的功能。在Linux内核中，网络子系统几乎是自成体系，它包括5个子模块（见下图），它们的功能如下：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHy9IqgNnoDPLwVHDKqVBzD6iaJtzNk7wm3h9aSn1Nf6xOsNM870ScwEA/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Network Device Drivers，网络设备的驱动，和VFS子系统中的设备驱动是一样的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Device Independent Interface，和VFS子系统中的是一样的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Network Protocols，实现各种网络传输协议，例如IP, TCP, UDP等等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Protocol Independent Interface，屏蔽不同的硬件设备和网络协议，以相同的格式提供接口（socket)。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>System Call interface，系统调用接口，向用户空间提供访问网络设备的统一的接口。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Linux内核版本时间线：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHRqUJPPCSOutrOnet4ICAkEbUHf9LLgGX4rorHj7nXDOcyTvLEJ29Bg/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>&lt;strong>Linux内核支持各种硬件架构&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Linux内核&lt;/strong>最成功的地方之一就是支持各种硬件架构，为软件提供了公共的平台：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHlp75WAFV1ibBJ0IAN2BVxzKia8ET9rFicziaQxtA0sEl0icYnHula6HzsIQ/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>基于Linux的系统是一个模块化的类Unix操作系统。&lt;strong>Linux操作系统&lt;/strong>的大部分设计思想来源于20世纪70年代到80年代的Unix操作系统所建立的基本设计思想。Linux系统使用宏内核，由Linux内核负责处理进程控制、网络，以及外围设备和文件系统的访问。在系统运行的时候，设备驱动程序要么与内核直接整合，要么以加载模块形式添加。&lt;/p>
&lt;p>&lt;strong>Linux具有设备独立性&lt;/strong>，它内核具有高度适应能力，从而给系统提供了更高级的功能。GNU用户界面组件是大多数Linux操作系统的重要组成部分，提供常用的C函数库，Shell，还有许多常见的Unix实用工具，可以完成许多基本的操作系统任务。大多数Linux系统使用的图形用户界面建立在X窗口系统之上，由X窗口(XWindow)系统通过软件工具及架构协议来建立操作系统所用的图形用户界面.&lt;/p>
&lt;p>&lt;strong>基于Linux内核各种衍生OS系统&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHiaA5ia2r6z3iarNHHZN7gHOISWONZ0vfBibAz5wm0tJfxaBao2KOF4fM8Q/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>各种发行版本&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHJQp1UUv39Vx04CB4W3DSdh2twrDS7kZV01ygjFXbyeUCfg92kJpiaqA/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>当前比较流行发行版是：&lt;strong>Debian&lt;/strong>、&lt;strong>Ubuntu&lt;/strong>、&lt;strong>Fedora&lt;/strong>、&lt;strong>CentOS&lt;/strong>、&lt;strong>Arch Linux&lt;/strong>和&lt;strong>openSUSE&lt;/strong>等，每个发行版都有自己优势地方，都有一批忠实用户。&lt;/p>
&lt;p>&lt;strong>基于Linux内核著名OS&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Android&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHwsGP7L9tNBESaK6GlTHaZWjXcial9ia9bWDQoXqPDUSh4rxfYtCOG1XA/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>&lt;strong>Android&lt;/strong>（读音：英：[&amp;lsquo;ændrɔɪd]，美：[ˈænˌdrɔɪd]），中文用户多以非官方名称“安卓”称之，是一个基于Linux内核与其他开源软件的开放源代码的移动操作系统，Android的内核是根据Linux内核的长期支持的分支，具有典型的Linux调度和功能。截至2018年，Android的目标是Linux内核的4.4、4.9或是4.14版本。&lt;/p>
&lt;p>&lt;strong>ChromeOS&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHGtbgyZUUeFSicfcZCeRpTGicmJI5vzDibiaCibBfoA06demaPcn1iaVficviag/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>&lt;strong>Chrome OS&lt;/strong> 是由Google设计基于Linux内核的操作系统，并使用Google Chrome浏览器作为其主要用户界面。因此，Chrome OS主要支持Web应用程序[6]，2016年起开始陆续兼容Android应用程序（可通过Google Play商店下载）和Linux应用程序。&lt;/p>
&lt;p>&lt;strong>鸿蒙OS&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHdmDMzZHEZR94PaMFm9CYibMfvicxDs2ULz9jQJVZKUQNOtAUduCqRJUA/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>&lt;strong>鸿蒙&lt;/strong>（&lt;strong>HarmonyOS&lt;/strong>，开发代号Ark[1]）是华为自2012年开发的一款可兼容Android应用程序的跨平台分布式操作系统[2]。系统性能包括利用“分布式”技术将各款设备融合成一个“超级终端”，便于操作和共享各设备资源。[3][4][5]系统架构支持多内核，包括Linux内核、LiteOS和鸿蒙微内核，可按各种智能设备选择所需内核，例如在低功耗设备上使用LiteOS内核。[6][7]2019年8月华为发布首款搭载鸿蒙操作系统的产品“荣耀智能屏”，之后于2021年6月发布搭载鸿蒙操作系统的智能手机、平板电脑和智能手表。&lt;/p>
&lt;p>Linux 内核是最大且变动最快的开源项目之一，它由大约 53,600 个文件和近 2,000 万行代码组成。在全世界范围内超过 15,600 位程序员为它贡献代码，Linux 内核项目的维护者使用了如下的协作模型。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHHIWib5fYsnBg0ziccyM2IEj3VRhGUQlkzPSyDpQ5cicLo148yoJ8z33LQ/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>如果你有&lt;strong>深入linux内核的激情&lt;/strong>和&lt;strong>极客精神&lt;/strong>，可以为Linux项目贡献源码，具体如何提交第一个补丁，可以详细阅读下面文章，这里篇幅有限不展开：&lt;/p>
&lt;p>&lt;a href="https://opensource.com/article/18/8/first-linux-kernel-patch">https://opensource.com/article/18/8/first-linux-kernel-patch&lt;/a>&lt;/p>
&lt;p>Linux 开源代码仓库：&lt;/p>
&lt;p>&lt;a href="https://github.com/torvalds/linux">https://github.com/torvalds/linux&lt;/a>&lt;/p>
&lt;p>提交给kernel的补丁，刚开始可能不需要高深的技术，比如这个补丁，可以 是简单的对于已有内容的格式或拼写错误的修正，比如这个来自4岁小朋友的补丁：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHv1787MroX0hXfDbFQCZhqCW68Otw5fpggEib5QicCewZGj0ZRWDVBduQ/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHhCiab6dlIM2ibMY4KPSrup1iaHNp6ciayzJ0oBRcvyIibRLltBDSw1zyxMA/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>&lt;strong>Linux内核学习资源&lt;/strong>&lt;/p>
&lt;p>&lt;strong>源码：&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://elixir.bootlin.com/linux/latest/source">https://elixir.bootlin.com/linux/latest/source&lt;/a>&lt;/p>
&lt;p>在线交叉索引看源码，包括Linux几乎所有版本；&lt;/p>
&lt;p>&lt;a href="https://github.com/torvalds/linux">https://github.com/torvalds/linux&lt;/a>&lt;/p>
&lt;p>内核github仓库，可以下载本地，编译，修改和开发。&lt;/p>
&lt;p>&lt;strong>网站&lt;/strong>&lt;/p>
&lt;p>&lt;strong>&lt;a href="http://www.kernel.org">http://www.kernel.org&lt;/a>&lt;/strong>&lt;/p>
&lt;p>可以通过这个网站上下载内核的源代码和补丁、跟踪内核bug等&lt;/p>
&lt;p>&lt;strong>&lt;a href="http://lwn.net">http://lwn.net&lt;/a>&lt;/strong>&lt;/p>
&lt;p>Linux 内核最新消息，提供给了定期的与内核开发相关的报道&lt;/p>
&lt;p>&lt;strong>&lt;a href="https://www.wiki.kernel.org/">https://www.wiki.kernel.org/&lt;/a>&lt;/strong>&lt;/p>
&lt;p>各种子模块wiki列表&lt;/p>
&lt;p>&lt;strong>&lt;a href="http://www.linuxdoc.org">http://www.linuxdoc.org&lt;/a>&lt;/strong>&lt;/p>
&lt;p>Linux Documentation Project(Linux文档项目)，拥有大量称为“HowTo”&lt;br>
的文档，其中一些是技术性的，并涉及到一些内核相关的主题。&lt;/p>
&lt;p>&lt;strong>&lt;a href="http://www.kerneltravel.net/">http://www.kerneltravel.net/&lt;/a>&lt;/strong>&lt;/p>
&lt;p>国内Linux内核之旅开源社区&lt;/p>
&lt;p>&lt;strong>&lt;a href="http://www.linux-mm.org">http://www.linux-mm.org&lt;/a>&lt;/strong>&lt;br>
该页面面向Linux内存管理开发，其中包含大量有用的信息，并且还包含大量与内核相关的Web站点链接。&lt;/p>
&lt;p>&lt;strong>&lt;a href="http://www.wowotech.net">http://www.wowotech.net&lt;/a>&lt;/strong>&lt;/p>
&lt;p>博客专注分享linux内核知识（偏嵌入式方向）, 很多文章都非常精华和透彻，值得内核学习者学习；&lt;/p>
&lt;p>&lt;strong>&lt;a href="https://blog.csdn.net/gatieme">https://blog.csdn.net/gatieme&lt;/a>&lt;/strong>&lt;/p>
&lt;p>操作系统优质博客，可以学习linux 调度相关内核知识；&lt;/p>
&lt;p>&lt;strong>&lt;a href="https://blog.csdn.net/dog250">https://blog.csdn.net/dog250&lt;/a>&lt;/strong>&lt;/p>
&lt;p>dog250的文章都比较深刻，属于Linux内核进阶，可能不太适合入门，建议入门后，再看这里文章，会让你醍醐灌顶。&lt;/p>
&lt;p>&lt;strong>&lt;a href="https://www.kernel.org/doc">https://www.kernel.org/doc&lt;/a>&lt;/strong>&lt;/p>
&lt;p>内核文档&lt;/p>
&lt;p>&lt;strong>书籍&lt;/strong>&lt;/p>
&lt;p>《深入理解Linux内核》&lt;/p>
&lt;p>《深入Linux内核架构》&lt;/p>
&lt;p>《Linux内核设计与实现》&lt;/p>
&lt;p>《Linux内核源代码情景分析》&lt;/p>
&lt;p>《深入理解LINUX网络内幕》&lt;/p>
&lt;p>《深入理解Linux虚拟内存管理》&lt;/p>
&lt;p>《Linux设备驱动程序》&lt;/p>
&lt;h3 id="git分布式版本控制系统">Git分布式版本控制系统&lt;/h3>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHplRZhR4pd07qoWDXz6icgRfqLyyC9SbZnxx2PIVCOyYHuWQjYDC3IDw/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>2005 年，Linus还创建了 &lt;strong>Git&lt;/strong>，这是非常流行的分布式源代码控制系统。迅速将 Linux 内核源代码树从专有 Bitkeeper 迁移到新创建的开源 Git。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHK6ewlMwmzxJxkuJ2Wb4dUxdUmOuUcVybz2NpicpKYHpbW3Kf8Rg9iabA/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>&lt;strong>git 架构&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Git&lt;/strong> 是出于需要而创建的，不是因为发现源代码控制很有趣，而是因为其他多数源代码控制系统不好用，不能满足当时开发需求，并且 git 在 Linux 开发模型中确实运行得相当好，BitKeeper变得站不住脚。&lt;/p>
&lt;p>完美适应现代开源软件的开发模式，分布式版本管理：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHq1UTS3ZCgoIbcKBtU67SJcsLUS7osnicsG9LzkJM75hkjT1O9wVat9g/640?wx_fmt=png" alt="">&lt;/p>
&lt;h3 id="linux内核名人堂">Linux内核名人堂&lt;/h3>
&lt;p>让我们膜拜一下对Linux内核做出核心贡献的大神们：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHtEVHKmWufP3VMY68yCQnh3fgdg40AFwfHhLmz2PaqLqXZJHCKQSn9Q/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>&lt;strong>林纳斯·班奈狄克·托瓦兹&lt;/strong>（1969年12月28日－），生于芬兰赫尔辛基市，拥有美国国籍，Linux内核的最早作者，随后发起了这个开源项目，担任Linux内核的首要架构师与项目协调者，是当今世界最著名的电脑程序员、黑客之一。他还发起了开源项目Git，并为主要的开发者。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHxticTE1khTNhUIXzRscgET2fazkOk0ISAzIrORD6X51wTUPSlfzCUxg/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>&lt;strong>大卫·史提芬·米勒&lt;/strong>（英语：David Stephen Miller，1974年11月26日－），网络昵称为 DaveM，生于美国新泽西州新布朗斯维克，著名程式员与骇客，负责Linux核心网络功能以及SPARC平台的实作。他也参与其他开源软件的开发，是GCC督导委员会的成员之一。根据2013年8月的统计，米勒是Linux核心源代码第二大的贡献者，自2005年开始，已经提交过4989个patch。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHC4qCA4jxF7rIrqwJpzFhzESIQx7ibZ5dIXkicz0XsBcwAibveORZ4NA5g/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>&lt;strong>葛雷格·克罗-哈曼&lt;/strong>（英语：Greg Kroah-Hartman，姓名缩写为GKH）， Linux核心开发者，目前为 Linux 核心中稳定分支（&lt;code>-stable&lt;/code>）的维护者[2]，他也是staging 子系统[2]、USB[2]driver core、debugfs、kref、kobject、sysfs kernel 子系统[2]、 TTY layer [2]、linux-hotplug、Userspace I/O（与 Hans J. Koch 共同维护）等专案的维护者[2]，也创立了udev专案。除此之外，他亦协助维护Gentoo Linux中上述程式及 kernel 的套件。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHiaR4nLoIu5MJ2cAFdjykndwROoicmZXR7rpqqXyReD4RCiaPwOrsc2urQ/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>&lt;strong>艾伦·考克斯&lt;/strong>（英语：Alan Cox，1968年7月22日－）是一名英国程序员，生于英格兰索利赫尔。他自1991年开始投入Linux内核的开发工作，在开发者社群中有很高的地位，是Linux开发工作中的关键人物之一。他负责维护Linux内核 2.2版这个分支，在2.4版中也提供许多程式码，拥有自己的分支版本。他住在威尔斯斯旺西，他的妻子于2015年逝世[1][2][3]。2020年他再婚[4][5]。他于1991年在斯旺西大学获得计算机科学理学学士学位，2005年在那里获得工商管理硕士学位[6]。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHuOQOEoMQhVfJibrcPjBxIy3Y61qGos8lFbz70cSf8Tycwy8OQsX5Nhg/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>&lt;strong>英格·蒙内&lt;/strong>（匈牙利语：Ingo Molnár），匈牙利软件程序员与骇客，在linux内核上有许多贡献，也拥有自己的linux分支版本。对于操作系统的安全性与效能提升方面，他的声名卓著，在linux内核中，他于Linux-2.6.0版加入O(1)排程器，在 Linux-2.6.23版中加入&lt;strong>完全公平调度器CFS&lt;/strong>（Completely Fair Scheduler）。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHBWhcnGvYiaDtbmsqnbjoRFnyXSTs5ibMAZ7Tm0vJuU573vKyrpzvvIjw/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>&lt;strong>米格尔·德伊卡萨&lt;/strong>（西班牙语：Miguel de Icaza ，1972年11月23日－），生于墨西哥市，著名墨西哥籍自由软件开发者，为GNOME项目与Mono项目的发起人。但后来[何时？]退出了GNOME项目。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHdkfW1X7mmFsq1ShM2iaHl6XJD5RPK1xaOJ60hAxiczdEDzGWrw2HorhA/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>&lt;strong>罗伯特·马修·拉姆&lt;/strong>（英语：Robert Matthew Love，1981年9月25日－），生于美国佛罗里达州，为著名自由软件程式开发者、作家，现职为google软件工程师。现居于波士顿。他是linux核心的主要开发者之一，主要负责程式排程、先占式核心、虚拟内存子系统、核心事件层。他也加入了GNOME计划。目前他在google，主要负责Android系统的开发。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHn9h6QWB8CfkNDIeoLLNgW4p3VkHveT61gVHiccEtjfkF708FfXUW3Aw/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>&lt;strong>安德鲁·基斯·保罗·莫顿&lt;/strong>（英语：Andrew Keith Paul Morton，1959年－），生于英国英格兰，澳洲软件工程师与著名骇客。他是Linux核心开发社群的领导者之一，现为ext3的共同维护者，负责区块装置的日志层（Journaling layer for block devices，JBD）。他也是mm tree的负责人。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgH2O1Ze7oATYXWrxfiaHkZqB5ggRna9RRft2huTliaQWyNrV061Z0q3icKQ/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>&lt;strong>埃里克·斯蒂芬·雷蒙&lt;/strong>（英语：Eric Steven Raymond，1957年12月4日－），是一名程序员，《大教堂与市集》的作者、《新黑客词典》（&amp;ldquo;Jargon File&amp;rdquo;）的维护人、著名黑客。作为《新黑客词典》的主要编撰人以及维护者，雷蒙很早就被认为是黑客文化的历史学家以及人类学家。但是在1997年以后，雷蒙被广泛公认为是开放源代码运动的主要领导者之一，并且是最为大众所知道（并最具争议性）的黑客。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHutx5g8HmjnzMFaeXZ7kc8TOttGwG1GUg5FswuJtelvTo0GWbZTOjPQ/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>&lt;strong>西奥多·曹&lt;/strong>（英语：Theodore Y. Ts&amp;rsquo;o，1968年1月23日－），小名&lt;strong>泰德·曹&lt;/strong>（Ted Tso），汉名&lt;strong>曹子德&lt;/strong>[1]，生于美国加利福尼亚州帕罗奥图，著名的自由软件工程师，专长于文件系统设计。他是Linux内核在北美最早的开发者，负责ext2、ext3与ext4文件系统的开发与维护工作。他也是e2fsprogs的开发者。为自由标准组织的创始者之一，也曾担任Linux基金会首席技术官。&lt;/p>
&lt;p>由于互联网发达，当前不管是从个人爱好，还是工作原因，对内核贡献的国人越来越多：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHQ2BEn5hagVPEelr1qE2EHlGWclItckm0saPvuB5zACbZWzIB6kbNeQ/640?wx_fmt=png" alt="">&lt;/p>
&lt;p>&lt;a href="http://www.remword.com/kps">http://www.remword.com/kps&lt;/a>_result/all_whole_line_country.html&lt;/p>
&lt;h3 id="最后">最后&lt;/h3>
&lt;p>30年的时间，Linux从一个个人玩具变成现在庞然大物，估值超过100亿美元，Linux还带来一股开源潮流，让开源软件百花齐放，对计算机发展和开源文化起到极大促进作用。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHibFAnWeJmNESo5lWBCcEYdI2MpVkiabQ6n4B3FRpv1FwfDpYaTDWXG4w/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>Linux 庞大的生态与发展过程，Linus伟大而富有创造力并不足以在一篇文章中尽述。&lt;/p>
&lt;p>匆匆30 年，Linux 已经不仅仅是改变了世界，而且已经成为了这个世界不可或缺的一部分感谢 Linus Torvalds，感谢为之致力的一切贡献者！&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/cYSwmJQric6nhH4RQfgaJfjrfmLsALibgHxfSUWjnl9ia6I5GPetib9tqehO96tNWdaPEQzicHIjk2QQ1eNq5WyQTDw/640?wx_fmt=jpeg" alt="">&lt;/p>
&lt;p>最后，为了致敬Linux，希望大家三连支持，让更多人可以看到！&lt;/p>
&lt;h3 id="参考和扩展">参考和扩展&lt;/h3>
&lt;p>&lt;a href="http://www.atguigu.com/jsfx/5694.html">http://www.atguigu.com/jsfx/5694.html&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://opensource.com/article/16/12/yearbook-9-lessons-25-years-linux-kernel-development">https://opensource.com/article/16/12/yearbook-9-lessons-25-years-linux-kernel-development&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.reddit.com/r/linux/comments/2pqqla/kernel">https://www.reddit.com/r/linux/comments/2pqqla/kernel&lt;/a>_commit_4_year_old_girl_fixes_formatting_to/utm_source=amp&amp;amp;utm_medium=&amp;amp;utm_content=post_title&lt;/p>
&lt;p>&lt;a href="http://oss.org.cn/ossdocs/linux/kernel/a1/index.html">http://oss.org.cn/ossdocs/linux/kernel/a1/index.html&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://www.wowotech.net/linux_kenrel/11.html">http://www.wowotech.net/linux_kenrel/11.html&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.wikiwand.com/zh/Linux">https://www.wikiwand.com/zh/Linux&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/Category:Linux%E6%A0%B8%E5%BF%83%E9%A7%AD%E5%AE%A2">https://zh.wikipedia.org/wiki/Category:Linux%E6%A0%B8%E5%BF%83%E9%A7%AD%E5%AE%A2&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://www.chromium.org/chromium-os/chromiumos-design-docs/software-architecture">http://www.chromium.org/chromium-os/chromiumos-design-docs/software-architecture&lt;/a>&lt;/p>
&lt;p>- END -&lt;/p></description></item><item><title>Blog: ext 文件系统机制原理剖析</title><link>https://desistdaydream.github.io/blog/copy/ext_filesystem/</link><pubDate>Sun, 25 Oct 2020 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/blog/copy/ext_filesystem/</guid><description>
&lt;p>原文链接：&lt;a href="https://www.junmajinlong.com/linux/ext_filesystem/">https://www.junmajinlong.com/linux/ext_filesystem/&lt;/a>&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://www.junmajinlong.com/linux/index">回到 Linux 基础系列文章大纲&lt;/a>&lt;/strong>&lt;br>
&lt;strong>&lt;a href="https://www.junmajinlong.com/shell/index">回到 Shell 系列文章大纲&lt;/a>&lt;/strong>&lt;/p>
&lt;hr>
&lt;p>将磁盘进行分区，分区是将磁盘按柱面进行物理上的划分。划分好分区后还要进行格式化，然后再挂载才能使用 (不考虑其他方法)。格式化分区的过程其实就是创建文件系统。&lt;/p>
&lt;p>文件系统的类型有很多种，如 CentOS 5 和 CentOS 6 上默认使用的 ext2/ext3/ext4，CentOS 7 上默认使用的 xfs，windows 上的 NTFS，光盘类的文件系统 ISO9660，MAC 上的混合文件系统 HFS，网络文件系统 NFS，Oracle 研发的 btrfs，还有老式的 FAT/FAT32 等。&lt;/p>
&lt;p>本文将非常全面且详细地介绍 ext 家族的文件系统，中间还非常详细地介绍了 inode、软链接、硬链接、数据存储方式以及操作文件的理论，基本上看完本文，对文件系统的宏观理解将再无疑惑。ext 家族的文件系统有 ext2/ext3/ext4，ext3 是有日志的 ext2 改进版，ext4 对相比 ext3 做了非常多的改进。虽然 xfs/btrfs 等文件系统有所不同，但它们只是在实现方式上不太同，再加上属于自己的特性而已。&lt;/p>
&lt;h2 id="block的出现-block的出现block-的出现">&lt;a href="#block%E7%9A%84%E5%87%BA%E7%8E%B0" title="block的出现">&lt;/a>block 的出现&lt;/h2>
&lt;p>硬盘最底层的读写 IO 一次是一个扇区 512 字节，如果要读写大量文件，以扇区为单位肯定很慢很消耗性能，所以硬盘使用了一个称作逻辑块的概念。逻辑块是逻辑的，由磁盘驱动器负责维护和操作，它并非是像扇区一样物理划分的。一个逻辑块的大小可能包含一个或多个扇区，每个逻辑块都有唯一的地址，称为 LBA。有了逻辑块之后，磁盘控制器对数据的操作就以逻辑块为单位，一次读写一个逻辑块，磁盘控制器知道如何将逻辑块翻译成对应的扇区并读写数据。&lt;/p>
&lt;p>到了 Linux 操作系统层次，通过文件系统提供了一个也称为块的读写单元，文件系统数据块的大小一般为 1024bytes (1K) 或 2048bytes (2K) 或 4096bytes (4K)。文件系统数据块也是逻辑概念，是文件系统层次维护的，而磁盘上的逻辑数据块是由磁盘控制器维护的，文件系统的 IO 管理器知道如何将它的数据块翻译成磁盘维护的数据块地址 LBA。对于使用文件系统的 IO 操作来说，比如读写文件，这些 IO 的基本单元是文件系统上的数据块，一次读写一个文件系统数据块。比如需要读一个或多个块时，文件系统的 IO 管理器首先计算这些文件系统块对应在哪些磁盘数据块，也就是计算出 LBA，然后通知磁盘控制器要读取哪些块的数据，硬盘控制器将这些块翻译成扇区地址，然后从扇区中读取数据，再通过硬盘控制器将这些扇区数据重组写入到内存中去。&lt;/p>
&lt;p>本文既然是讨论文件系统的，那么重点自然是在文件系统上而不是在磁盘上，所以后文出现的 block 均表示的是文件系统的数据块而不是磁盘维护的逻辑块。&lt;/p>
&lt;p>文件系统 block 的出现使得在文件系统层面上读写性能大大提高，也大量减少了碎片。但是它的副作用是可能造成空间浪费。由于文件系统以 block 为读写单元，即使存储的文件只有 1K 大小也将占用一个 block，剩余的空间完全是浪费的。在某些业务需求下可能大量存储小文件，这会浪费大量的空间。&lt;/p>
&lt;p>尽管有缺点，但是其优点足够明显，在当下硬盘容量廉价且追求性能的时代，使用 block 是一定的。&lt;/p>
&lt;h2 id="inode的出现-inode的出现inode-的出现">&lt;a href="#inode%E7%9A%84%E5%87%BA%E7%8E%B0" title="inode的出现">&lt;/a>inode 的出现&lt;/h2>
&lt;p>如果存储的 1 个文件占用了大量的 block 读取时会如何？假如 block 大小为 1KB，仅仅存储一个 10M 的文件就需要 10240 个 block，而且这些 blocks 很可能在位置上是不连续在一起的 (不相邻)，读取该文件时难道要从前向后扫描整个文件系统的块，然后找出属于该文件的块吗？显然是不应该这么做的，因为太慢太傻瓜式了。再考虑一下，读取一个只占用 1 个 block 的文件，难道只读取一个 block 就结束了吗？并不是，仍然是扫描整个文件系统的所有 block，因为它不知道什么时候扫描到，扫描到了它也不知道这个文件是不是已经完整而不需要再扫描其他的 block。&lt;/p>
&lt;p>另外，每个文件都有属性 (如权限、大小、时间戳等)，这些属性类的元数据存储在哪里呢？难道也和文件的数据部分存储在块中吗？如果一个文件占用多个 block 那是不是每个属于该文件的 block 都要存储一份文件元数据？但是如果不在每个 block 中存储元数据文件系统又怎么知道某一个 block 是不是属于该文件呢？但是显然，每个数据 block 中都存储一份元数据太浪费空间。&lt;/p>
&lt;p>文件系统设计者当然知道这样的存储方式很不理想，所以需要优化存储方式。如何优化？对于这种类似的问题的解决方法是使用索引，通过扫描索引找到对应的数据，而且索引可以存储部分数据。&lt;/p>
&lt;p>在文件系统上索引技术具体化为索引节点 (index node)，在索引节点上存储的部分数据即为文件的属性元数据及其他少量信息。一般来说索引占用的空间相比其索引的文件数据而言占用的空间就小得多，扫描它比扫描整个数据要快得多，否则索引就没有存在的意义。这样一来就解决了前面所有的问题。&lt;/p>
&lt;p>在文件系统上的术语中，索引节点称为 inode。在 inode 中存储了 inode 号（注，inode 中并未存储 inode num，但为了方便理解，这里暂时认为它存储了 inode 号）、文件类型、权限、文件所有者、大小、时间戳等元数据信息，最重要的是还存储了指向属于该文件 block 的指针，这样读取 inode 就可以找到属于该文件的 block，进而读取这些 block 并获得该文件的数据。由于后面还会介绍一种指针，为了方便称呼和区分，暂且将这个 inode 记录中指向文件 data block 的指针称之为 block 指针。以下是 ext2 文件系统中 inode 包含的信息示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>Inode: 12 Type: regular Mode: 0644 Flags: 0x0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Generation: 1454951771 Version: 0x00000000:00000001
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>User: 0 Group: 0 Size: 5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>File ACL: 0 Directory ACL: 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Links: 1 Blockcount: 8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Fragment: Address: 0 Number: 0 Size: 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctime: 0x5b628db2:15e0aff4 -- Thu Aug 2 12:50:58 2018
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> atime: 0x5b628db2:15e0aff4 -- Thu Aug 2 12:50:58 2018
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mtime: 0x5b628db2:15e0aff4 -- Thu Aug 2 12:50:58 2018
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>crtime: 0x5b628db2:15e0aff4 -- Thu Aug 2 12:50:58 2018
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Size of extra inode fields: 28
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BLOCKS:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(0):1024
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TOTAL: 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一般 inode 大小为 128 字节或 256 字节，相比那些 MB 或 GB 计算的文件数据而言小得多的多，但也要知道可能一个文件大小小于 inode 大小，例如只占用 1 个字节的文件。&lt;/p>
&lt;h2 id="bmap出现-bmap出现bmap-出现">&lt;a href="#bmap%E5%87%BA%E7%8E%B0" title="bmap出现">&lt;/a>bmap 出现&lt;/h2>
&lt;p>在向硬盘存储数据时，文件系统需要知道哪些块是空闲的，哪些块是已经占用了的。最笨的方法当然是从前向后扫描，遇到空闲块就存储一部分，继续扫描直到存储完所有数据。&lt;/p>
&lt;p>优化的方法当然也可以考虑使用索引，但是仅仅 1G 的文件系统就有 1KB 的 block 共 1024*1024=1048576 个，这仅仅只是 1G，如果是 100G、500G 甚至更大呢，仅仅使用索引索引的数量和空间占用也将极大，这时就出现更高一级的优化方法：使用块位图 (bitmap 简称 bmap)。&lt;/p>
&lt;p>位图只使用 0 和 1 标识对应 block 是空闲还是被占用，0 和 1 在位图中的位置和 block 的位置一一对应，第一位标识第一个块，第二个位标识第二个块，依次下去直到标记完所有的 block。&lt;/p>
&lt;p>考虑下为什么块位图更优化。在位图中 1 个字节 8 个位，可以标识 8 个 block。对于一个 block 大小为 1KB、容量为 1G 的文件系统而言，block 数量有 1024*1024 个，所以在位图中使用 1024*1024 个位共 1024*1024/8=131072 字节 = 128K，即 1G 的文件只需要 128 个 block 做位图就能完成一一对应。通过扫描这 100 多个 block 就能知道哪些 block 是空闲的，速度提高了非常多。&lt;/p>
&lt;p>但是要注意，&lt;strong>bmap 的优化针对的是写优化，因为只有写才需要找到空闲 block 并分配空闲 block&lt;/strong>。对于读而言，只要通过 inode 找到了 block 的位置，cpu 就能迅速计算出 block 在物理磁盘上的地址，cpu 的计算速度是极快的，计算 block 地址的时间几乎可以忽略，那么读速度基本认为是受硬盘本身性能的影响而与文件系统无关。大多数稍大一点的文件可能都会存储在不连续的 block 上，而且使用了一段时间的文件系统可能会有不少碎片，这时硬盘的随机读取性能直接决定读数据的速度，这也是机械硬盘速度相比固态硬盘慢的多的多的原因之一，而且固态硬盘的随机读和连续读取速度几乎是一致的，对它来说，文件系统碎片的多少并不会影响读取速度。&lt;/p>
&lt;p>虽然 bmap 已经极大的优化了扫描，但是仍有其瓶颈：如果文件系统是 100G 呢？100G 的文件系统要使用 128*100=12800 个 1KB 大小的 block，这就占用了 12.5M 的空间了。试想完全扫描 12800 个很可能不连续的 block 这也是需要占用一些时间的，虽然快但是扛不住每次存储文件都要扫描带来的巨大开销。&lt;/p>
&lt;p>所以需要再次优化，如何优化？简而言之就是将文件系统划分开形成块组，至于块组的介绍放在后文。&lt;/p>
&lt;h2 id="inode表的出现-inode表的出现inode-表的出现">&lt;a href="#inode%E8%A1%A8%E7%9A%84%E5%87%BA%E7%8E%B0" title="inode表的出现">&lt;/a>inode 表的出现&lt;/h2>
&lt;p>回顾下 inode 相关信息：inode 存储了 inode 号（注，同前文，inode 中并未存储 inode num）、文件属性元数据、指向文件占用的 block 的指针；每一个 inode 占用 128 字节或 256 字节。&lt;/p>
&lt;p>现在又出现问题了，一个文件系统中可以说有无数多个文件，每一个文件都对应一个 inode，难道每一个仅 128 字节的 inode 都要单独占用一个 block 进行存储吗？这太浪费空间了。&lt;/p>
&lt;p>所以更优的方法是将多个 inode 合并存储在 block 中，对于 128 字节的 inode，一个 block 存储 8 个 inode，对于 256 字节的 inode，一个 block 存储 4 个 inode。这就使得每个存储 inode 的块都不浪费。&lt;/p>
&lt;p>在 ext 文件系统上，将这些物理上存储 inode 的 block 组合起来，在逻辑上形成一张 inode 表 (inode table) 来记录所有的 inode。&lt;/p>
&lt;p>举个例子，每一个家庭都要向派出所登记户口信息，通过户口本可以知道家庭住址，而每个镇或街道的派出所将本镇或本街道的所有户口整合在一起，要查找某一户地址时，在派出所就能快速查找到。inode table 就是这里的派出所。它的内容如下图所示。&lt;/p>
&lt;p>&lt;a href="https://www.junmajinlong.com/img/linux/733013-20180830092223810-1825870107.jpg">&lt;img src="https://www.junmajinlong.com/img/linux/733013-20180830092223810-1825870107.jpg" alt="">
&lt;/a>&lt;/p>
&lt;p>再细细一思考，就能发现一个大的文件系统仍将占用大量的块来存储 inode，想要找到其中的一个 inode 记录也需要不小的开销，尽管它们已经形成了一张逻辑上的表，但扛不住表太大记录太多。那么如何快速找到 inode，这同样是需要优化的，优化的方法是将文件系统的 block 进行分组划分，每个组中都存有本组 inode table 范围、bmap 等。&lt;/p>
&lt;h2 id="imap的出现-imap的出现imap-的出现">&lt;a href="#imap%E7%9A%84%E5%87%BA%E7%8E%B0" title="imap的出现">&lt;/a>imap 的出现&lt;/h2>
&lt;p>前面说 bmap 是块位图，用于标识文件系统中哪些 block 是空闲哪些 block 是占用的。&lt;/p>
&lt;p>对于 inode 也一样，在存储文件 (Linux 中一切皆文件) 时需要为其分配一个 inode 号。但是在格式化创建文件系统后所有的 inode 号都已被事先计算好（创建文件系统时会为每个块组计算好该块组拥有哪些 inode 号），因此产生了问题：要为文件分配哪一个 inode 号呢？又如何知道某一个 inode 号是否已经被分配了呢？&lt;/p>
&lt;p>既然是” 是否被占用” 的问题，使用位图是最佳方案，像 bmap 记录 block 的占用情况一样。标识 inode 号是否被分配的位图称为 inodemap 简称为 imap。这时要为一个文件分配 inode 号只需扫描 imap 即可知道哪一个 inode 号是空闲的。&lt;/p>
&lt;p>imap 存在着和 bmap 和 inode table 一样需要解决的问题：如果文件系统比较大，imap 本身就会很大，每次存储文件都要进行扫描，会导致效率不够高。同样，优化的方式是将文件系统占用的 block 划分成块组，每个块组有自己的 imap 范围。&lt;/p>
&lt;h2 id="块组的出现-块组的出现块组的出现">&lt;a href="#%E5%9D%97%E7%BB%84%E7%9A%84%E5%87%BA%E7%8E%B0" title="块组的出现">&lt;/a>块组的出现&lt;/h2>
&lt;p>前面一直提到的优化方法是将文件系统占用的 block 划分成块组 (block group)，解决 bmap、inode table 和 imap 太大的问题。&lt;/p>
&lt;p>在物理层面上的划分是将磁盘按柱面划分为多个分区，即多个文件系统；在逻辑层面上的划分是将文件系统划分成块组。每个文件系统包含多个块组，每个块组包含多个元数据区和数据区：元数据区就是存储 bmap、inode table、imap 等的数据；数据区就是存储文件数据的区域。注意块组是逻辑层面的概念，所以并不会真的在磁盘上按柱面、按扇区、按磁道等概念进行划分。&lt;/p>
&lt;h2 id="块组的划分-块组的划分块组的划分">&lt;a href="#%E5%9D%97%E7%BB%84%E7%9A%84%E5%88%92%E5%88%86" title="块组的划分">&lt;/a>块组的划分&lt;/h2>
&lt;p>块组在文件系统创建完成后就已经划分完成了，也就是说元数据区 bmap、inode table 和 imap 等信息占用的 block 以及数据区占用的 block 都已经划分好了。那么文件系统如何知道一个块组元数据区包含多少个 block，数据区又包含多少 block 呢？&lt;/p>
&lt;p>&lt;strong>它只需确定一个数据 —— 每个 block 的大小，再根据 bmap 至多只能占用一个完整的 block 的标准就能计算出块组如何划分&lt;/strong>。如果文件系统非常小，所有的 bmap 总共都不能占用完一个 block，那么也只能空闲 bmap 的 block 了。&lt;/p>
&lt;p>每个 block 的大小在创建文件系统时可以人为指定，不指定也有默认值。&lt;/p>
&lt;p>假如现在 block 的大小是 1KB，一个 bmap 完整占用一个 block 能标识 1024*8=8192 个 block (当然这 8192 个 block 是数据区和元数据区共 8192 个，因为元数据区分配的 block 也需要通过 bmap 来标识)。每个 block 是 1K，每个块组是 8192K 即 8M，创建 1G 的文件系统需要划分 1024/8=128 个块组，如果是 1.1G 的文件系统呢？128+12.8=128+13=141 个块组。&lt;/p>
&lt;p>每个组的 block 数目是划分好了，但是每个组设定多少个 inode 号呢？inode table 占用多少 block 呢？这需要由系统决定了，因为描述” 每多少个数据区的 block 就为其分配一个 inode 号” 的指标默认是我们不知道的，当然创建文件系统时也可以人为指定这个指标或者百分比例。见后文”&lt;a href="#deep_into_inode">inode 深入&lt;/a> “。&lt;/p>
&lt;p>使用 dumpe2fs 可以将 ext 类的文件系统信息全部显示出来，当然 bmap 是每个块组固定一个 block 的不用显示，imap 比 bmap 更小所以也只占用 1 个 block 不用显示。&lt;/p>
&lt;p>下图是一个文件系统的部分信息，在这些信息的后面还有每个块组的信息，其实这里面的很多信息都可以通过几个比较基本的元数据推导出来。&lt;/p>
&lt;p>&lt;a href="https://www.junmajinlong.com/img/linux/733013-20170615093736759-1554527092.jpg">&lt;img src="https://www.junmajinlong.com/img/linux/733013-20170615093736759-1554527092.jpg" alt="">
&lt;/a>&lt;/p>
&lt;p>从这张表中能计算出文件系统的大小，该文件系统共 4667136 个 blocks，每个 block 大小为 4K，所以文件系统大小为 &lt;code>4667136*4/1024/1024=17.8GB&lt;/code>。&lt;/p>
&lt;p>也能计算出分了多少个块组，因为每一个块组的 block 数量为 32768，所以块组的数量为 4667136/32768=142.4 即 143 个块组。由于块组从 0 开始编号，所以最后一个块组编号为 Group 142。如下图所示是最后一个块组的信息。&lt;/p>
&lt;p>&lt;a href="https://www.junmajinlong.com/img/linux/733013-20170615093808509-902863729.jpg">&lt;img src="https://www.junmajinlong.com/img/linux/733013-20170615093808509-902863729.jpg" alt="">
&lt;/a>&lt;/p>
&lt;p>将上文描述的 bmap、inode table、imap、数据区的 blocks 和块组的概念组合起来就形成了一个文件系统，当然这还不是完整的文件系统。完整的文件系统如下图&lt;/p>
&lt;p>&lt;a href="https://www.junmajinlong.com/img/linux/733013-20180727160411876-443793371.jpg">&lt;img src="https://www.junmajinlong.com/img/linux/733013-20180727160411876-443793371.jpg" alt="">
&lt;/a>&lt;/p>
&lt;p>首先，该图中多了 Boot Block、Super Block、GDT、Reserver GDT 这几个概念。下面会分别介绍它们。&lt;/p>
&lt;p>然后，图中指明了块组中每个部分占用的 block 数量，除了 superblock、bmap、imap 能确定占用 1 个 block，其他的部分都不能确定占用几个 block。&lt;/p>
&lt;p>最后，图中指明了 Superblock、GDT 和 Reserved GDT 是同时出现且不一定存在于每一个块组中的，也指明了 bmap、imap、inode table 和 data blocks 是每个块组都有的。&lt;/p>
&lt;h2 id="引导块-引导块引导块">&lt;a href="#%E5%BC%95%E5%AF%BC%E5%9D%97" title="引导块">&lt;/a>引导块&lt;/h2>
&lt;p>即上图中的 Boot Block 部分，也称为 boot sector。它位于分区上的第一个块，占用 1024 字节，并非所有分区都有这个 boot sector，只有装了操作系统的主分区和装了操作系统的逻辑分区才有。里面存放的也是 boot loader，这段 boot loader 称为 VBR (主分区装操作系统时) 或 EBR (扩展分区装操作系统时)，这里的 Boot loader 和 mbr 上的 boot loader 是存在交错关系的。开机启动的时候，首先加载 mbr 中的 bootloader，然后定位到操作系统所在分区的 boot serctor 上加载此处的 boot loader。如果是多系统，加载 mbr 中的 bootloader 后会列出操作系统菜单，菜单上的各操作系统指向它们所在分区的 boot sector 上。它们之间的关系如下图所示。&lt;/p>
&lt;p>&lt;a href="https://www.junmajinlong.com/img/linux/733013-20170627160437071-1671926976.jpg">&lt;img src="https://www.junmajinlong.com/img/linux/733013-20170627160437071-1671926976.jpg" alt="">
&lt;/a>&lt;/p>
&lt;p>但是，这种方式的操作系统菜单早已经弃之不用了，而是使用 grub 来管理启动菜单。尽管如此，在安装操作系统时，仍然有一步是选择 boot loader 安装位置的步骤。&lt;/p>
&lt;h2 id="超级块-superblock-超级块superblock超级块-superblock">&lt;a href="#%E8%B6%85%E7%BA%A7%E5%9D%97-superblock" title="超级块(superblock)">&lt;/a>超级块 (superblock)&lt;/h2>
&lt;p>既然一个文件系统会分多个块组，那么文件系统怎么知道分了多少个块组呢？每个块组又有多少 block 多少 inode 号等等信息呢？还有，文件系统本身的属性信息如各种时间戳、block 总数量和空闲数量、inode 总数量和空闲数量、当前文件系统是否正常、什么时候需要自检等等，它们又存储在哪里呢？&lt;/p>
&lt;p>毫无疑问，这些信息必须要存储在 block 中。存储这些信息占用 1024 字节，所以也要一个 block，这个 block 称为超级块 (superblock)，它的 block 号可能为 0 也可能为 1。&lt;strong>如果 block 大小为 1K，则引导块正好占用一个 block，这个 block 号为 0，所以 superblock 的号为 1；如果 block 大小大于 1K，则引导块和超级块同置在一个 block 中，这个 block 号为 0。总之 superblock 的起止位置是第二个 1024 (1024-2047) 字节&lt;/strong>。&lt;/p>
&lt;p>使用 df 命令读取的就是每个文件系统的 superblock，所以它的统计速度非常快。相反，用 du 命令查看一个较大目录的已用空间就非常慢，因为不可避免地要遍历整个目录的所有文件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>[root@xuexi ~]# df -hT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Filesystem Type Size Used Avail Use% Mounted on
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/sda3 ext4 18G 1.7G 15G 11% /
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tmpfs tmpfs 491M 0 491M 0% /dev/shm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/sda1 ext4 190M 32M 149M 18% /boot
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>superblock 对于文件系统而言是至关重要的，超级块丢失或损坏必将导致文件系统的损坏。所以旧式的文件系统将超级块备份到每一个块组中，但是这又有所空间浪费，所以 ext2 文件系统只在块组 0、1 和 3、5、7 幂次方的块组中保存超级块的信息，如 Group9、Group25 等。尽管保存了这么多的 superblock，但是文件系统只使用第一个块组即 Group0 中超级块信息来获取文件系统属性，只有当 Group0 上的 superblock 损坏或丢失才会找下一个备份超级块复制到 Group0 中来恢复文件系统。&lt;/p>
&lt;p>下图是一个 ext4 文件系统的 superblock 的信息，ext 家族的文件系统都能使用 dumpe2fs -h 获取。&lt;/p>
&lt;p>&lt;a href="https://www.junmajinlong.com/img/linux/733013-20170615094025275-1008363481.jpg">&lt;img src="https://www.junmajinlong.com/img/linux/733013-20170615094025275-1008363481.jpg" alt="">
&lt;/a>&lt;/p>
&lt;h2 id="块组描述符表-gdt-块组描述符表gdt块组描述符表-gdt">&lt;a href="#%E5%9D%97%E7%BB%84%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8-GDT" title="块组描述符表(GDT)">&lt;/a>块组描述符表 (GDT)&lt;/h2>
&lt;p>既然文件系统划分了块组，那么每个块组的信息和属性元数据又保存在哪里呢？&lt;/p>
&lt;p>ext 文件系统每一个块组信息使用 32 字节描述，这 32 个字节称为块组描述符，所有块组的块组描述符组成块组描述符表 GDT (group descriptor table)。&lt;/p>
&lt;p>虽然每个块组都需要块组描述符来记录块组的信息和属性元数据，但是不是每个块组中都存放了块组描述符。ext 文件系统的存储方式是：将它们组成一个 GDT，并将该 GDT 存放于某些块组中，存放 GDT 的块组和存放 superblock 和备份 superblock 的块相同，也就是说它们是同时出现在某一个块组中的。读取时也总是读取 Group0 中的块组描述符表信息。&lt;/p>
&lt;p>假如 block 大小为 4KB 的文件系统划分了 143 个块组，每个块组描述符 32 字节，那么 GDT 就需要 143*32=4576 字节即两个 block 来存放。这两个 GDT block 中记录了所有块组的块组信息，且存放 GDT 的块组中的 GDT 都是完全相同的。&lt;/p>
&lt;p>下图是一个块组描述符的信息 (通过 dumpe2fs 获取)。&lt;/p>
&lt;p>&lt;a href="https://www.junmajinlong.com/img/linux/733013-20170615094101525-344682252.jpg">&lt;img src="https://www.junmajinlong.com/img/linux/733013-20170615094101525-344682252.jpg" alt="">
&lt;/a>&lt;/p>
&lt;h2 id="保留gdt-reserved-gdt-保留gdtreserved-gdt保留-gdt-reserved-gdt">&lt;a href="#%E4%BF%9D%E7%95%99GDT-Reserved-GDT" title="保留GDT(Reserved GDT)">&lt;/a>保留 GDT (Reserved GDT)&lt;/h2>
&lt;p>保留 GDT 用于以后扩容文件系统使用，防止扩容后块组太多，使得块组描述符超出当前存储 GDT 的 blocks。保留 GDT 和 GDT 总是同时出现，当然也就和 superblock 同时出现了。&lt;/p>
&lt;p>例如前面 143 个块组使用了 2 个 block 来存放 GDT，但是此时第二个 block 还空余很多空间，当扩容到一定程度时 2 个 block 已经无法再记录块组描述符了，这时就需要分配一个或多个 Reserved GDT 的 block 来存放超出的块组描述符。&lt;/p>
&lt;p>由于新增加了 GDT block，所以应该让每一个保存 GDT 的块组都同时增加这一个 GDT block，所以将保留 GDT 和 GDT 存放在同一个块组中可以直接将保留 GDT 变换为 GDT 而无需使用低效的复制手段备份到每个存放 GDT 的块组。&lt;/p>
&lt;p>同理，新增加了 GDT 需要修改每个块组中 superblock 中的文件系统属性，所以将 superblock 和 Reserved GDT/GDT 放在一起又能提升效率。&lt;/p>
&lt;p>&lt;a href="https://www.junmajinlong.com/img/linux/733013-20180727160431015-373938073.jpg">&lt;img src="https://www.junmajinlong.com/img/linux/733013-20180727160431015-373938073.jpg" alt="">
&lt;/a>&lt;/p>
&lt;p>如上图，除了 Data Blocks 其他的部分都解释过了。data block 是直接存储数据的 block，但事实上并非如此简单。&lt;/p>
&lt;p>数据所占用的 block 由文件对应 inode 记录中的 block 指针找到，不同的文件类型，数据 block 中存储的内容是不一样的。以下是 Linux 中不同类型文件的存储方式。&lt;/p>
&lt;ul>
&lt;li>对于常规文件，文件的数据正常存储在数据块中。&lt;/li>
&lt;li>对于目录，该目录下的所有文件和一级子目录的目录名存储在数据块中。
&lt;ul>
&lt;li>&lt;strong>文件名和 inode 号不是存储在其自身的 inode 中，而是存储在其所在目录的 data block 中。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对于符号链接，如果目标路径名较短则直接保存在 inode 中以便更快地查找，如果目标路径名较长则分配一个数据块来保存。&lt;/li>
&lt;li>设备文件、FIFO 和 socket 等特殊文件没有数据块，设备文件的主设备号和次设备号保存在 inode 中。&lt;/li>
&lt;/ul>
&lt;p>常规文件的存储就不解释了，下面分别解释特殊文件的存储方式。&lt;/p>
&lt;h2 id="目录文件的data-block-目录文件的data-block目录文件的-data-block">&lt;a href="#%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E7%9A%84data-block" title="目录文件的data block">&lt;/a>目录文件的 data block&lt;/h2>
&lt;p>目录的 data block 的内容如下图所示。&lt;/p>
&lt;p>&lt;a href="https://www.junmajinlong.com/img/linux/733013-20191005161844399-1089052435.jpg">&lt;img src="https://www.junmajinlong.com/img/linux/733013-20191005161844399-1089052435.jpg" alt="">
&lt;/a>&lt;/p>
&lt;p>由图可知，在目录文件的数据块中存储了其下的文件名、目录名、目录本身的相对名称”.” 和上级目录的相对名称”..”，还存储了这些文件名对应的 inode 号、目录项长度 rec_len、文件名长度 name_len 和文件类型 file_type。注意到除了文件本身的 inode 记录了文件类型，其所在的目录的数据块也记录了文件类型。由于 rec_len 只能是 4 的倍数，所以需要使用”\0” 来填充 name_len 不够凑满 4 倍数的部分。至于 rec_len 具体是什么，只需知道它是一种偏移即可。&lt;/p>
&lt;p>&lt;strong>需要注意的是，inode table 中的 inode 自身并没有存储每个 inode 的 inode 号，它是存储在目录的 data block 中的，通过 inode 号可以计算并索引到 inode table 中该 inode 号对应的 inode 记录，可以认为这个 inode 号是一个 inode 指针&lt;/strong> (当然，并非真的是指针，但有助于理解通过 inode 号索引找到对应 inode 的这个过程，后文将在需要的时候使用 inode 指针这个词来表示 inode 号。至此，已经知道了两种指针：一种是 inode table 中每个 inode 记录指向其对应 data block 的 block 指针，一个此处的『inode 指针』)。&lt;/p>
&lt;p>除了 inode 号，目录的 data block 中还使用数字格式记录了文件类型，数字格式和文件类型的对应关系如下图。&lt;/p>
&lt;p>&lt;a href="https://www.junmajinlong.com/img/linux/733013-20170615094424884-1119563692.jpg">&lt;img src="https://www.junmajinlong.com/img/linux/733013-20170615094424884-1119563692.jpg" alt="">
&lt;/a>&lt;/p>
&lt;p>注意到目录的 data block 中前两行存储的是目录本身的相对名称”.” 和上级目录的相对名称”..”，它们实际上是目录本身的硬链接和上级目录的硬链接。硬链接的本质后面说明。&lt;/p>
&lt;h2 id="如何根据inode号找到inode-如何根据inode号找到inode如何根据-inode-号找到-inode">&lt;a href="#%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AEinode%E5%8F%B7%E6%89%BE%E5%88%B0inode" title="如何根据inode号找到inode">&lt;/a>如何根据 inode 号找到 inode&lt;/h2>
&lt;p>前面提到过，inode 结构自身并没有保存 inode 号（同样，也没有保存文件名），那么 inode 号保存在哪里呢？目录的 data block 中保存了该目录中每个文件的 inode 号。&lt;/p>
&lt;p>另一个问题，既然 inode 中没有 inode 号，那么如何根据目录 data block 中的 inode 号找到 inode table 中对应的 inode 呢？&lt;/p>
&lt;p>实际上，只要有了 inode 号，就可以计算出 inode 表中对应该 inode 号的 inode 结构。在创建文件系统的时候，每个块组中的起始 inode 号以及 inode table 的起始地址都已经确定了，所以只要知道 inode 号，就能知道这个 inode 号和该块组起始 inode 号的偏移数量，再根据每个 inode 结构的大小 (256 字节或其它大小)，就能计算出来对应的 inode 结构。&lt;/p>
&lt;p>所以，目录的 data block 中的 inode number 和 inode table 中的 inode 是通过计算的方式一一映射起来的。从另一个角度上看，目录 data block 中的 inode number 是找到 inode table 中对应 inode 记录的唯一方式。&lt;/p>
&lt;p>考虑一种比较特殊的情况：目录 data block 的记录已经删除，但是该记录对应的 inode 结构仍然存在于 inode table 中。这种 inode 称为孤儿 inode（orphan inode）：存在于 inode table 中，但却无法再索引到它。因为目录中已经没有该 inode 对应的文件记录了，所以其它进程将无法找到该 inode，也就无法根据该 inode 找到该文件之前所占用的 data block，这正是创建便删除所实现的真正临时文件，该临时文件只有当前进程和子进程才能访问。&lt;/p>
&lt;h2 id="符号链接存储方式-符号链接存储方式符号链接存储方式">&lt;a href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F" title="符号链接存储方式">&lt;/a>符号链接存储方式&lt;/h2>
&lt;p>符号链接即为软链接，类似于 Windows 操作系统中的快捷方式，它的作用是指向原文件或目录。&lt;/p>
&lt;p>软链接之所以也被称为特殊文件的原因是：它一般情况下不占用 data block，仅仅通过它对应的 inode 记录就能将其信息描述完成；符号链接的大小是其指向目标路径占用的字符个数，例如某个符号链接的指向方式为”rmt –&amp;gt; ../sbin/rmt”，则其文件大小为 11 字节；只有当符号链接指向的目标的路径名较长 (60 个字节) 时文件系统才会划分一个 data block 给它；它的权限如何也不重要，因它只是一个指向原文件的” 工具”，最终决定是否能读写执行的权限由原文件决定，所以很可能 ls -l 查看到的符号链接权限为 777。&lt;/p>
&lt;p>注意，软链接的 block 指针存储的是目标文件名。也就是说，链接文件的一切都依赖于其目标文件名。这就解释了为什么 /mnt 的软链接 /tmp/mnt 在 /mnt 挂载文件系统后，通过软链接就能进入 /mnt 所挂载的文件系统。究其原因，还是因为其目标文件名”/mnt” 并没有改变。&lt;/p>
&lt;p>例如以下筛选出了 /etc/ 下的符号链接，注意观察它们的权限和它们占用的空间大小。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>[root@xuexi ~]# ll /etc/ | grep &amp;#39;^l&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx. 1 root root 56 Feb 18 2016 favicon.png -&amp;gt; /usr/share/icons/hicolor/16x16/apps/system-logo-icon.png
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx. 1 root root 22 Feb 18 2016 grub.conf -&amp;gt; ../boot/grub/grub.conf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx. 1 root root 11 Feb 18 2016 init.d -&amp;gt; rc.d/init.d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx. 1 root root 7 Feb 18 2016 rc -&amp;gt; rc.d/rc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx. 1 root root 10 Feb 18 2016 rc0.d -&amp;gt; rc.d/rc0.d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx. 1 root root 10 Feb 18 2016 rc1.d -&amp;gt; rc.d/rc1.d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx. 1 root root 10 Feb 18 2016 rc2.d -&amp;gt; rc.d/rc2.d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx. 1 root root 10 Feb 18 2016 rc3.d -&amp;gt; rc.d/rc3.d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx. 1 root root 10 Feb 18 2016 rc4.d -&amp;gt; rc.d/rc4.d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx. 1 root root 10 Feb 18 2016 rc5.d -&amp;gt; rc.d/rc5.d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx. 1 root root 10 Feb 18 2016 rc6.d -&amp;gt; rc.d/rc6.d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx. 1 root root 13 Feb 18 2016 rc.local -&amp;gt; rc.d/rc.local
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx. 1 root root 15 Feb 18 2016 rc.sysinit -&amp;gt; rc.d/rc.sysinit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx. 1 root root 14 Feb 18 2016 redhat-release -&amp;gt; centos-release
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx. 1 root root 11 Apr 10 2016 rmt -&amp;gt; ../sbin/rmt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lrwxrwxrwx. 1 root root 14 Feb 18 2016 system-release -&amp;gt; centos-release
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="设备文件fifo套接字文件-设备文件fifo套接字文件设备文件fifo套接字文件">&lt;a href="#%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E3%80%81FIFO%E3%80%81%E5%A5%97%E6%8E%A5%E5%AD%97%E6%96%87%E4%BB%B6" title="设备文件、FIFO、套接字文件">&lt;/a>设备文件、FIFO、套接字文件&lt;/h2>
&lt;p>关于这 3 种文件类型的文件只需要通过 inode 就能完全保存它们的信息，它们不占用任何数据块，所以它们是特殊文件。&lt;/p>
&lt;p>设备文件的主设备号和次设备号也保存在 inode 中。以下是 /dev/ 下的部分设备信息。注意到它们的第 5 列和第 6 列信息，它们分别是主设备号和次设备号，主设备号标识每一种设备的类型，次设备号标识同种设备类型的不同编号；也注意到这些信息中没有大小的信息，因为设备文件不占用数据块所以没有大小的概念。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>[root@xuexi ~]# ll /dev | tail
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>crw-rw---- 1 vcsa tty 7, 129 Oct 7 21:26 vcsa1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>crw-rw---- 1 vcsa tty 7, 130 Oct 7 21:27 vcsa2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>crw-rw---- 1 vcsa tty 7, 131 Oct 7 21:27 vcsa3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>crw-rw---- 1 vcsa tty 7, 132 Oct 7 21:27 vcsa4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>crw-rw---- 1 vcsa tty 7, 133 Oct 7 21:27 vcsa5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>crw-rw---- 1 vcsa tty 7, 134 Oct 7 21:27 vcsa6
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>crw-rw---- 1 root root 10, 63 Oct 7 21:26 vga_arbiter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>crw------- 1 root root 10, 57 Oct 7 21:26 vmci
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>crw-rw-rw- 1 root root 10, 56 Oct 7 21:27 vsock
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>crw-rw-rw- 1 root root 1, 5 Oct 7 21:26 zero
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每个文件都有一个 inode，在将 inode 关联到文件后系统将通过 inode 号来识别文件，而不是文件名。并且访问文件时将先找到 inode，通过 inode 中记录的 block 位置找到该文件。&lt;/p>
&lt;h2 id="硬链接-硬链接硬链接">&lt;a href="#%E7%A1%AC%E9%93%BE%E6%8E%A5" title="硬链接">&lt;/a>硬链接&lt;/h2>
&lt;p>虽然每个文件都有一个 inode，但是存在一种可能：多个文件的 inode 相同，也就即 inode 号、元数据、block 位置都相同，这是一种什么样的情况呢？能够想象这些 inode 相同的文件使用的都是同一条 inode 记录，所以代表的都是同一个文件，这些文件所在目录的 data block 中的 inode 号都是一样的，只不过各 inode 号对应的文件名互不相同而已。这种 inode 相同的文件在 Linux 中被称为” 硬链接”。&lt;/p>
&lt;p>硬链接文件的 inode 都相同，每个文件都有一个” 硬链接数” 的属性，使用 ls -l 的第二列就是被硬链接数，它表示的就是该文件有几个硬链接。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>[root@xuexi ~]# ls -l
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>total 48
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drwxr-xr-x 5 root root 4096 Oct 15 18:07 700
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-------. 1 root root 1082 Feb 18 2016 anaconda-ks.cfg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- 1 root root 399 Apr 29 2016 Identity.pub
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r--. 1 root root 21783 Feb 18 2016 install.log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r--. 1 root root 6240 Feb 18 2016 install.log.syslog
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>例如下图描述的是 dir1 目录中的文件 name1 及其硬链接 dir2/name2，右边分别是它们的 inode 和 data block。这里也看出了硬链接文件之间唯一不同的就是其所在目录中的记录不同。注意下图中有一列 Link Count 就是标记硬链接数的属性。&lt;/p>
&lt;p>&lt;a href="https://www.junmajinlong.com/img/linux/733013-20191005170242909-1745674821.jpg">&lt;img src="https://www.junmajinlong.com/img/linux/733013-20191005170242909-1745674821.jpg" alt="">
&lt;/a>&lt;/p>
&lt;p>每创建一个文件的硬链接，实质上是多一个指向该 inode 记录的 inode 指针，并且硬链接数加 1。&lt;/p>
&lt;p>删除文件的实质是删除该文件所在目录 data block 中的对应的 inode 行，所以也是减少硬链接次数，由于 block 指针是存储在 inode 中的，所以不是真的删除数据，如果仍有其他 inode 号链接到该 inode，那么该文件的 block 指针仍然是可用的。当硬链接次数为 1 时再删除文件就是真的删除文件了，此时 inode 记录中 block 指针也将被删除。&lt;/p>
&lt;p>&lt;strong>不能跨分区创建硬链接&lt;/strong>，因为不同文件系统的 inode 号可能会相同，如果允许创建硬链接，复制到另一个分区时 inode 可能会和此分区已使用的 inode 号冲突。&lt;/p>
&lt;p>&lt;strong>硬链接只能对文件创建，无法对目录创建硬链接&lt;/strong>。之所以无法对目录创建硬链接，是因为文件系统已经把每个目录的硬链接创建好了，它们就是相对路径中的”.” 和”..”，分别标识当前目录的硬链接和上级目录的硬链接。每一个目录中都会包含这两个硬链接，它包含了两个信息：(1) 一个没有子目录的目录文件的硬链接数是 2，其一是目录本身，即该目录 datablock 中的”.”，其二是其父目录 datablock 中该目录的记录，这两者都指向同一个 inode 号；(2) 一个包含子目录的目录文件，其硬链接数是 2 + 子目录数，因为每个子目录都关联一个父目录的硬链接”..”。很多人在计算目录的硬链接数时认为由于包含了”.” 和”..”，所以空目录的硬链接数是 2，这是错误的，因为”..” 不是本目录的硬链接。另外，还有一个特殊的目录应该纳入考虑，即”/“目录，它自身是一个文件系统的入口，是自引用 (下文中会解释自引用) 的，所以”/“目录下的”.” 和”..” 的 inode 号相同，它自身不占用硬链接，因为其 datablock 中只记录 inode 号相同的”.” 和”..”，不再像其他目录一样还记录一个名为”/“的目录，所以”/“的硬链接数也是 2 + 子目录数，但这个 2 是”.” 和”..” 的结果。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>[root@xuexi ~]# ln /tmp /mydata
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ln: `/tmp&amp;#39;: hard link not allowed for directory
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为什么文件系统自己创建好了目录的硬链接就不允许人为创建呢？从”.” 和”..” 的用法上考虑，如果当前目录为 /usr，我们可以使用”./local” 来表示 /usr/local，但是如果我们人为创建了 /usr 目录的硬链接 /tmp/husr，难道我们也要使用”/tmp/husr/local” 来表示 /usr/local 吗？这其实已经是软链接的作用了。若要将其认为是硬链接的功能，这必将导致硬链接维护的混乱。&lt;/p>
&lt;p>不过，通过 mount 工具的”–bind” 选项，可以将一个目录挂载到另一个目录下，实现伪” 硬链接”，它们的内容和 inode 号是完全相同的。&lt;/p>
&lt;p>硬链接的创建方法：&lt;code>ln file_target link_name&lt;/code>。&lt;/p>
&lt;h2 id="软链接-软链接软链接">&lt;a href="#%E8%BD%AF%E9%93%BE%E6%8E%A5" title="软链接">&lt;/a>软链接&lt;/h2>
&lt;p>软链接就是字符链接，链接文件默认指的就是字符链接文件 (注意不是字符设备)，使用”l” 表示其类型。&lt;/p>
&lt;p>硬链接不能跨文件系统创建，否则 inode 号可能会冲突。于是实现了软链接以便跨文件系统建立链接。既然是跨文件系统，那么软链接必须得有自己的 inode 号。&lt;/p>
&lt;p>软链接在功能上等价与 Windows 系统中的快捷方式，它指向原文件，原文件损坏或消失，软链接文件就损坏。&lt;strong>可以认为软链接 inode 记录中的指针内容是目标路径的字符串&lt;/strong>。&lt;/p>
&lt;p>创建方式：&lt;code>ln –s source_file softlink_name&lt;/code>，记住是 &lt;code>source_file&amp;lt;--link_name&lt;/code> 的指向关系 (反箭头)，以前我老搞错位置。&lt;/p>
&lt;p>查看软链接的值：&lt;code>readlink softlink_name&lt;/code>&lt;/p>
&lt;p>在设置软链接的时候，source_file 虽然不要求是绝对路径，但建议给绝对路径。是否还记得软链接文件的大小？它是根据软链接所指向路径的字符数计算的，例如某个符号链接的指向方式为”rmt –&amp;gt; ../sbin/rmt”，它的文件大小为 11 字节，也就是说只要建立了软链接后，软链接的指向路径是不会改变的，仍然是”../sbin/rmt”。如果此时移动软链接文件本身，它的指向是不会改变的，仍然是 11 个字符的”../sbin/rmt”，但此时该软链接父目录下可能根本就不存在 /sbin/rmt，也就是说此时该软链接是一个被破坏的软链接。&lt;/p>
&lt;h2 id="inode大小和划分-inode大小和划分inode-大小和划分">&lt;a href="#inode%E5%A4%A7%E5%B0%8F%E5%92%8C%E5%88%92%E5%88%86" title="inode大小和划分">&lt;/a>inode 大小和划分&lt;/h2>
&lt;p>inode 大小为 128 字节的倍数，最小为 128 字节。它有默认值大小，它的默认值由 /etc/mke2fs.conf 文件中指定。不同的文件系统默认值可能不同。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>[root@xuexi ~]# cat /etc/mke2fs.conf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[defaults]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> base_features = sparse_super,filetype,resize_inode,dir_index,ext_attr
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> enable_periodic_fsck = 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> blocksize = 4096
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inode_size = 256
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inode_ratio = 16384
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[fs_types]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ext3 = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> features = has_journal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ext4 = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> features = has_journal,extent,huge_file,flex_bg,uninit_bg,dir_nlink,extra_isize
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inode_size = 256
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同样观察到这个文件中还记录了 blocksize 的默认值和 inode 分配比率 inode_ratio。inode_ratio=16384 表示每 16384 个字节即 16KB 就分配一个 inode 号，由于默认 blocksize=4KB，所以每 4 个 block 就分配一个 inode 号。当然分配的这些 inode 号只是预分配，并不真的代表会全部使用，毕竟每个文件才会分配一个 inode 号。但是分配的 inode 自身会占用 block，而且其自身大小 256 字节还不算小，所以 inode 号的浪费代表着空间的浪费。&lt;/p>
&lt;p>既然知道了 inode 分配比率，就能计算出每个块组分配多少个 inode 号，也就能计算出 inode table 占用多少个 block。&lt;/p>
&lt;p>如果文件系统中大量存储电影等大文件，inode 号就浪费很多，inode 占用的空间也浪费很多。但是没办法，文件系统又不知道你这个文件系统是用来存什么样的数据，多大的数据，多少数据。&lt;/p>
&lt;p>当然 inode size、inode 分配比例、block size 都可以在创建文件系统的时候人为指定。&lt;/p>
&lt;h2 id="ext文件系统预留的inode号-ext文件系统预留的inode号ext-文件系统预留的-inode-号">&lt;a href="#ext%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%A2%84%E7%95%99%E7%9A%84inode%E5%8F%B7" title="ext文件系统预留的inode号">&lt;/a>ext 文件系统预留的 inode 号&lt;/h2>
&lt;p>Ext 预留了一些 inode 做特殊特性使用，如下：某些可能并非总是准确，具体的 inode 号对应什么文件可以使用”find /-inum NUM” 查看。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>Ext4的特殊inode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Inode号 用途
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0 不存在0号inode，可用于标识目录data block中已删除的文件
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1 虚拟文件系统，如/proc和/sys
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2 根目录 # 注意此行
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>3 ACL索引
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>4 ACL数据
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>5 Boot loader
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>6 未删除的目录
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>7 预留的块组描述符inode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>8 日志inode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>11 第一个非预留的inode，通常是lost+found目录
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以在 ext4 文件系统的 dumpe2fs 信息中，能观察到 fisrt inode 号可能为 11 也可能为 12。&lt;/p>
&lt;p>并且注意到”/“的 inode 号为 2，这个特性在文件访问时会用上。&lt;/p>
&lt;p>需要注意的是，每个文件系统都会分配自己的 inode 号，不同文件系统之间是可能会出现使用相同 inode 号文件的。例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>[root@xuexi ~]# find / -ignore_readdir_race -inum 2 -ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 2 4 dr-xr-xr-x 22 root root 4096 Jun 9 09:56 /
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 2 2 dr-xr-xr-x 5 root root 1024 Feb 25 11:53 /boot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 2 0 c--------- 1 root root Jun 7 02:13 /dev/pts/ptmx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 2 0 -rw-r--r-- 1 root root 0 Jun 6 18:13 /proc/sys/fs/binfmt_misc/status
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 2 0 drwxr-xr-x 3 root root 0 Jun 6 18:13 /sys/fs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从结果中可见，除了根的 Inode 号为 2，还有几个文件的 inode 号也是 2，它们都属于独立的文件系统，有些是虚拟文件系统，如 /proc 和 /sys。&lt;/p>
&lt;h2 id="ext2-3的inode直接间接寻址-ext23的inode直接间接寻址ext23-的-inode-直接间接寻址">&lt;a href="#ext2-3%E7%9A%84inode%E7%9B%B4%E6%8E%A5%E3%80%81%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80" title="ext2/3的inode直接、间接寻址">&lt;/a>ext2/3 的 inode 直接、间接寻址&lt;/h2>
&lt;p>前文说过，inode 中保存了 blocks 指针，但是一条 inode 记录中能保存的指针数量是有限的，否则就会超出 inode 大小 (128 字节或 256 字节)。&lt;/p>
&lt;p>在 ext2 和 ext3 文件系统中，一个 inode 中最多只能有 15 个指针，每个指针使用 i_block [n] 表示。&lt;/p>
&lt;p>前 12 个指针 i_block [0] 到 i_block [11] 是直接寻址指针，每个指针指向一个数据区的 block。如下图所示。&lt;/p>
&lt;p>&lt;a href="https://www.junmajinlong.com/img/linux/733013-20170615095614790-1724952851.jpg">&lt;img src="https://www.junmajinlong.com/img/linux/733013-20170615095614790-1724952851.jpg" alt="">
&lt;/a>&lt;/p>
&lt;p>第 13 个指针 i_block [12] 是一级间接寻址指针，它指向一个仍然存储了指针的 block 即 i_block [12] –&amp;gt; Pointerblock –&amp;gt; datablock。&lt;/p>
&lt;p>第 14 个指针 i_block [13] 是二级间接寻址指针，它指向一个仍然存储了指针的 block，但是这个 block 中的指针还继续指向其他存储指针的 block，即 i_block [13] –&amp;gt; Pointerblock1 –&amp;gt; PointerBlock2 –&amp;gt; datablock。&lt;/p>
&lt;p>第 15 个指针 i_block [14] 是三级间接寻址指针，它指向一个任然存储了指针的 block，这个指针 block 下还有两次指针指向。即 i_block [13] –&amp;gt; Pointerblock1 –&amp;gt; PointerBlock2 –&amp;gt; PointerBlock3 –&amp;gt; datablock。&lt;/p>
&lt;p>其中由于每个指针大小为 4 字节，所以每个指针 block 能存放的指针数量为 BlockSize/4byte。例如 blocksize 为 4KB，那么一个 Block 可以存放 4096/4=1024 个指针。&lt;/p>
&lt;p>如下图。&lt;/p>
&lt;p>&lt;a href="https://www.junmajinlong.com/img/linux/733013-20170615095634665-801241861.jpg">&lt;img src="https://www.junmajinlong.com/img/linux/733013-20170615095634665-801241861.jpg" alt="">
&lt;/a>&lt;/p>
&lt;p>为什么要分间接和直接指针呢？如果一个 inode 中 15 个指针全是直接指针，假如每个 block 的大小为 1KB，那么 15 个指针只能指向 15 个 block 即 15KB 的大小，由于每个文件对应一个 inode 号，所以就限制了每个文件最大为 15*1=15KB，这显然是不合理的。&lt;/p>
&lt;p>如果存储大于 15KB 的文件而又不太大的时候，就占用一级间接指针 i_block [12]，这时可以存放指针数量为 1024/4+12=268，所以能存放 268KB 的文件。&lt;/p>
&lt;p>如果存储大于 268K 的文件而又不太大的时候，就继续占用二级指针 i_block [13]，这时可以存放指针数量为 [1024/4]^2+1024/4+12=65804，所以能存放 65804KB=64M 左右的文件。&lt;/p>
&lt;p>如果存放的文件大于 64M，那么就继续使用三级间接指针 i_block [14]，存放的指针数量为 [1024/4]^3+[1024/4]^2+[1024/4]+12=16843020 个指针，所以能存放 16843020KB=16GB 左右的文件。&lt;/p>
&lt;p>如果 blocksize=4KB 呢？那么最大能存放的文件大小为 ([4096/4]^3+[4096/4]^2+[4096/4]+12)*4/1024/1024/1024=4T 左右。&lt;/p>
&lt;p>当然这样计算出来的不一定就是最大能存放的文件大小，它还受到另一个条件的限制。这里的计算只是表明一个大文件是如何寻址和分配的。&lt;/p>
&lt;p>其实看到这里的计算数值，就知道 ext2 和 ext3 对超大文件的存取效率是低下的，它要核对太多的指针，特别是 4KB 大小的 blocksize 时。而 ext4 针对这一点就进行了优化，ext4 使用 extent 的管理方式取代 ext2 和 ext3 的块映射，大大提高了效率也降低了碎片。&lt;/p>
&lt;p>在 Linux 上执行删除、复制、重命名、移动等操作时，它们是怎么进行的呢？还有访问文件时是如何找到它的呢？其实只要理解了前文中介绍的几个术语以及它们的作用就很容易知道文件操作的原理了。&lt;/p>
&lt;p>注：在这一小节所解释的都是在单个文件系统下的行为，在多个文件系统中如何请看下一个小节：多文件系统关联。&lt;/p>
&lt;h2 id="读取文件-读取文件读取文件">&lt;a href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6" title="读取文件">&lt;/a>读取文件&lt;/h2>
&lt;p>当执行 &lt;code>cat /var/log/messages&lt;/code> 命令在系统内部进行了什么样的步骤呢？该命令能被成功执行涉及了 cat 命令的寻找、权限判断以及 messages 文件的寻找和权限判断等等复杂的过程。这里只解释和本节内容相关的如何寻找到被 cat 的 /var/log/messages 文件。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>找到根文件系统的块组描述符表所在的 blocks，读取 GDT (已在内存中) 找到 inode table 的 block 号。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>因为 GDT 总是和 superblock 在同一个块组，而 superblock 总是在分区的第 1024-2047 个字节，所以很容易就知道第一个 GDT 所在的块组以及 GDT 在这个块组中占用了哪些 block。&lt;/p>
&lt;p>其实 GDT 早已经在内存中了，在系统开机的时候会挂载根文件系统，挂载的时候就已经将所有的 GDT 放进内存中。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>在 inode table 的 block 中定位到根”/“的 inode，找出”/“指向的 data block。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>前文说过，ext 文件系统预留了一些 inode 号，其中”/“的 inode 号为 2，所以可以根据 inode 号直接定位根目录文件的 data block。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>在”/“的 datablock 中记录了 var 目录名和 var 的 inode 号，找到该 inode 记录，inode 记录中存储了指向 var 的 block 指针，所以也就找到了 var 目录文件的 data block。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>通过 var 目录的 inode 号，可以寻找到 var 目录的 inode 记录，但是在寻找的过程中，还需要知道该 inode 记录所在的块组以及所在的 inode table，所以需要读取 GDT，同样，GDT 已经缓存到了内存中。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>在 var 的 data block 中记录了 log 目录名和其 inode 号，通过该 inode 号定位到该 inode 所在的块组及所在的 inode table，并根据该 inode 记录找到 log 的 data block。&lt;/strong>&lt;/li>
&lt;li>&lt;strong>在 log 目录文件的 data block 中记录了 messages 文件名和对应的 inode 号，通过该 inode 号定位到该 inode 所在的块组及所在的 inode table，并根据该 inode 记录找到 messages 的 data block。&lt;/strong>&lt;/li>
&lt;li>&lt;strong>最后读取 messages 对应的 datablock。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>将上述步骤中 GDT 部分的步骤简化后比较容易理解。如下：找到 GDT–&amp;gt; 找到”/“的 inode–&amp;gt; 找到 / 的数据块读取 var 的 inode–&amp;gt; 找到 var 的数据块读取 log 的 inode–&amp;gt; 找到 log 的数据块读取 messages 的 inode–&amp;gt; 找到 messages 的数据块并读取它们。&lt;/p>
&lt;p>当然，在每次定位到 inode 记录后，都会先将 inode 记录加载到内存中，然后查看权限，如果权限允许，将根据 block 指针找到对应的 data block。&lt;/p>
&lt;h2 id="删除重命名和移动文件-删除重命名和移动文件删除重命名和移动文件">&lt;a href="#%E5%88%A0%E9%99%A4%E3%80%81%E9%87%8D%E5%91%BD%E5%90%8D%E5%92%8C%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6" title="删除、重命名和移动文件">&lt;/a>删除、重命名和移动文件&lt;/h2>
&lt;p>注意这里是不跨越文件系统的操作行为。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>删除文件分为普通文件和目录文件，知道了这两种类型的文件的删除原理，就知道了其他类型特殊文件的删除方法。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>对于删除普通文件：(1) 找到文件的 inode 和 data block (根据前一个小节中的方法寻找)；(2) 将 inode table 中该 inode 记录中的 data block 指针删除；(3) 在 imap 中将该文件的 inode 号标记为未使用；(4) 在其所在目录的 data block 中将该文件名所在的记录行删除，删除了记录就丢失了指向 inode 的指针（实际上不是真的删除，直接删除的话会在目录 data block 的数据结构中产生空洞，所以实际的操作是将待删除文件的 inode 号设置为特殊的值 0，这样下次新建文件时就可以重用该行记录）；(5) 将 bmap 中 data block 对应的 block 号标记为未使用（对于 ext 文件系统，这个步骤可能会导致删除大文件时间较久，资源消耗较多，对于其它文件系统，则视情况而定）。&lt;/p>
&lt;p>对于删除目录文件：找到目录和目录下所有文件、子目录、子文件的 inode 和 data block；在 imap 中将这些 inode 号标记为未使用；将 bmap 中将这些文件占用的 block 号标记为未使用；在该目录的父目录的 data block 中将该目录名所在的记录行删除。需要注意的是，删除父目录 data block 中的记录是最后一步，如果该步骤提前，将报目录非空的错误，因为在该目录中还有文件占用。&lt;/p>
&lt;p>关于上面的 (2)-(5)：当 (2) 中删除 data block 指针后，将无法再找到这个文件的数据；当 (3) 标记 inode 号未使用，表示该 inode 号可以被后续的文件重用；当 (4) 删除目录 data block 中关于该文件的记录，真正的删除文件，外界再也定位也无法看到这个文件了；当 (5) 标记 data block 为未使用后，表示开始释放空间，这些 data block 可以被其他文件重用。&lt;/p>
&lt;p>注意，在第 (5) 步之前，由于 data block 还未被标记为未使用，在 superblock 中仍然认为这些 data block 是正在使用中的。这表示尽管文件已经被删除了，但空间却还没有释放，df 也会将其统计到已用空间中 (df 是读取 superblock 中的数据块数量，并计算转换为空间大小)。&lt;/p>
&lt;p>什么时候会发生这种情况呢？当一个进程正在引用文件时将该文件删除，就会出现文件已删除但空间未释放的情况。这时步骤已经进行到 (4)，外界无法再找到该文件，但由于进程在加载该文件时已经获取到了该文件所有的 data block 指针，该进程可以获取到该文件的所有数据，但却暂时不会释放该文件空间。直到该进程结束，文件系统才将未执行的步骤 (5) 继续完成。这也是为什么有时候 du 的统计结果比 df 小的原因，关于 du 和 df 统计结果的差别，详细内容见：&lt;a href="https://www.junmajinlong.com/linux/du_df">详细分析 du 和 df 的统计结果为什么不一样&lt;/a>。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>重命名文件分为同目录内重命名和非同目录内重命名。非同目录内重命名实际上是移动文件的过程，见下文&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>同目录内重命名文件的动作仅仅只是修改所在目录 data block 中该文件记录的文件名部分，不是删除再重建的过程。&lt;/p>
&lt;p>如果重命名时有文件名冲突 (该目录内已经存在该文件名)，则提示是否覆盖。覆盖的过程是覆盖目录 data block 中冲突文件的记录。例如 /tmp/ 下有 a.txt 和 a.log，若将 a.txt 重命名为 a.log，则提示覆盖，若选择覆盖，则 /tmp 的 data block 中关于 a.log 的记录被覆盖。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>移动文件&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>同文件系统下移动文件实际上是修改目标文件所在目录的 data block，向其中添加一行指向 inode table 中待移动文件的 inode 记录，如果目标路径下有同名文件，则会提示是否覆盖，实际上是覆盖目录 data block 中冲突文件的记录，由于同名文件的 inode 记录指针被覆盖，所以无法再找到该文件的 data block，也就是说该文件被标记为删除 (如果多个硬链接数，则另当别论)。&lt;/p>
&lt;p>所以在同文件系统内移动文件相当快，仅仅在所在目录 data block 中添加或覆盖了一条记录而已。也因此，移动文件时，文件的 inode 号是不会改变的。&lt;/p>
&lt;p>对于不同文件系统内的移动，相当于先复制再删除的动作。见后文。&lt;/p>
&lt;p>&lt;a href="https://www.junmajinlong.com/img/linux/733013-20170615100156821-861349673.jpg">&lt;img src="https://www.junmajinlong.com/img/linux/733013-20170615100156821-861349673.jpg" alt="">
&lt;/a>&lt;/p>
&lt;p>关于文件移动，在 Linux 环境下有一个非常经典网上却又没任何解释的问题：/tmp/a/a 能覆盖为 /tmp/a 吗？答案是不能，但 windows 能。为什么不能？见 &lt;a href="https://www.junmajinlong.com/linux/linux_file_cmd/#mv_problem">mv 的一个经典问题 (mv 的本质)&lt;/a>。&lt;/p>
&lt;h2 id="存储和复制文件-存储和复制文件存储和复制文件">&lt;a href="#%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6" title="存储和复制文件">&lt;/a>存储和复制文件&lt;/h2>
&lt;ul>
&lt;li>对于文件存储
&lt;ul>
&lt;li>(1). 读取 GDT，找到各个 (或部分) 块组 imap 中未使用的 inode 号，并为待存储文件分配 inode 号；&lt;/li>
&lt;li>(2). 在 inode table 中完善该 inode 号所在行的记录；&lt;/li>
&lt;li>(3). 在目录的 data block 中添加一条该文件的相关记录；&lt;/li>
&lt;li>(4). 将数据填充到 data block 中。
&lt;ul>
&lt;li>注意，填充到 data block 中的时候会调用 block 分配器：一次分配 4KB 大小的 block 数量，当填充完 4KB 的 data block 后会继续调用 block 分配器分配 4KB 的 block，然后循环直到填充完所有数据。也就是说，如果存储一个 100M 的文件需要调用 block 分配器 100*1024/4=25600 次。&lt;/li>
&lt;li>另一方面，在 block 分配器分配 block 时，block 分配器并不知道真正有多少 block 要分配，只是每次需要分配时就分配，在每存储一个 data block 前，就去 bmap 中标记一次该 block 已使用，它无法实现一次标记多个 bmap 位。这一点在 ext4 中进行了优化。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>(5) 填充完之后，去 inode table 中更新该文件 inode 记录中指向 data block 的寻址指针。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对于复制，完全就是另一种方式的存储文件。步骤和存储文件的步骤一样。&lt;/li>
&lt;/ul>
&lt;p>在单个文件系统中的文件操作和多文件系统中的操作有所不同。本文将对此做出非常详细的说明。&lt;/p>
&lt;h2 id="根文件系统的特殊性-根文件系统的特殊性根文件系统的特殊性">&lt;a href="#%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7" title="根文件系统的特殊性">&lt;/a>根文件系统的特殊性&lt;/h2>
&lt;p>这里要明确的是，任何一个文件系统要在 Linux 上能正常使用，必须挂载在某个已经挂载好的文件系统中的某个目录下，例如 /dev/cdrom 挂载在 /mnt 上，/mnt 目录本身是在”/“文件系统下的。而且任意文件系统的一级挂载点必须是在根文件系统的某个目录下，因为只有”/“是自引用的。这里要说明挂载点的级别和自引用的概念。&lt;/p>
&lt;p>假如 /dev/sdb1 挂载在 /mydata 上，/dev/cdrom 挂载在 /mydata/cdrom 上，那么 /mydata 就是一级挂载点，此时 /mydata 已经是文件系统 /dev/sdb1 的入口了，而 /dev/cdrom 所挂载的目录 /mydata/cdrom 是文件系统 /dev/sdb1 中的某个目录，那么 /mydata/cdrom 就是二级挂载点。一级挂载点必须在根文件系统下，所以可简述为：文件系统 2 挂载在文件系统 1 中的某个目录下，而文件系统 1 又挂载在根文件系统中的某个目录下。&lt;/p>
&lt;p>再解释自引用。首先要说的是，自引用的只能是文件系统，而文件系统表现形式是一个目录，所以自引用是指该目录的 data block 中，”.” 和”..” 的记录中的 inode 号都对应 inode table 中同一个 inode 记录，所以它们 inode 号是相同的，即互为硬链接。而根文件系统是唯一可以自引用的文件系统。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>[root@xuexi /]# ll -ai /
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>total 102
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 2 dr-xr-xr-x. 22 root root 4096 Jun 6 18:13 .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 2 dr-xr-xr-x. 22 root root 4096 Jun 6 18:13 ..
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>由此也能解释 cd /. 和 cd /.. 的结果都还是在根下，这是自引用最直接的表现形式。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>[root@xuexi tmp]# cd /.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[root@xuexi /]#
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[root@xuexi tmp]# cd /..
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[root@xuexi /]#
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意，根目录下的”.” 和”..” 都是”/“目录的硬链接，且其 datablock 中不记录名为”/“的条目，因此除去根目录下子目录数后的硬链接数为 2。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>[root@server2 tmp]# a=$(ls -ld / | awk &amp;#39;{print $2}&amp;#39;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[root@server2 tmp]# b=$(ls -l / | grep &amp;#34;^d&amp;#34; |wc -l)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[root@server2 tmp]# echo $((a - b))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="挂载文件系统的细节-挂载文件系统的细节挂载文件系统的细节">&lt;a href="#%E6%8C%82%E8%BD%BD%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%86%E8%8A%82" title="挂载文件系统的细节">&lt;/a>挂载文件系统的细节&lt;/h2>
&lt;p>挂载文件系统到某个目录下，例如”mount /dev/cdrom/mnt”，挂载成功后 /mnt 目录中的文件全都暂时不可见了，且挂载后权限和所有者 (如果指定允许普通用户挂载) 等的都改变了，知道为什么吗？&lt;/p>
&lt;p>下面就以通过”mount /dev/cdrom/mnt” 为例，详细说明挂载过程中涉及的细节。&lt;/p>
&lt;p>在将文件系统 /dev/cdrom (此处暂且认为它是文件系统) 挂载到挂载点 /mnt 之前，挂载点 /mnt 是根文件系统中的一个目录，”/“的 data block 中记录了 /mnt 的一些信息，其中包括 inode 号 inode_n，而在 inode table 中，/mnt 对应的 inode 记录中又存储了 block 指针 block_n，此时这两个指针还是普通的指针。&lt;/p>
&lt;p>&lt;a href="https://www.junmajinlong.com/img/linux/733013-20170615100947634-2140254844.jpg">&lt;img src="https://www.junmajinlong.com/img/linux/733013-20170615100947634-2140254844.jpg" alt="">
&lt;/a>&lt;/p>
&lt;p>当文件系统 /dev/cdrom 挂载到 /mnt 上后，/mnt 此时就已经成为另一个文件系统的入口了，因此它需要连接两边文件系统的 inode 和 data block。但是如何连接呢？如下图。&lt;/p>
&lt;p>&lt;a href="https://www.junmajinlong.com/img/linux/733013-20170615101016571-14202340.jpg">&lt;img src="https://www.junmajinlong.com/img/linux/733013-20170615101016571-14202340.jpg" alt="">
&lt;/a>&lt;/p>
&lt;p>在根文件系统的 inode table 中，为 /mnt 重新分配一个 inode 记录 m，该记录的 block 指针 block_m 指向文件系统 /dev/cdrom 中的 data block。既然为 /mnt 分配了新的 inode 记录 m，那么在”/“目录的 data block 中，也需要修改其 inode 指针为 inode_m 以指向 m 记录。同时，原来 inode table 中的 inode 记录 n 就被标记为暂时不可用。&lt;/p>
&lt;p>block_m 指向的是文件系统 /dev/cdrom 的 data block，所以严格说起来，除了 /mnt 的元数据信息即 inode 记录 m 还在根文件系统上，/mnt 的 data block 已经是在 /dev/cdrom 中的了。这就是挂载新文件系统后实现的跨文件系统，它将挂载点的元数据信息和数据信息分别存储在不同的文件系统上。&lt;/p>
&lt;p>挂载完成后，将在 /proc/self/{mounts,mountstats,mountinfo} 这三个文件中写入挂载记录和相关的挂载信息，并会将 /proc/self/mounts 中的信息同步到 /etc/mtab 文件中，当然，如果挂载时加了 - n 参数，将不会同步到 /etc/mtab。&lt;/p>
&lt;p>而卸载文件系统，其实质是移除临时新建的 inode 记录 (当然，在移除前会检查是否正在使用) 及其指针，并将指针指回原来的 inode 记录，这样 inode 记录中的 block 指针也就同时生效而找回对应的 data block 了。由于卸载只是移除 inode 记录，所以使用挂载点和文件系统都可以实现卸载，因为它们是联系在一起的。&lt;/p>
&lt;p>下面是分析或结论。&lt;/p>
&lt;p>(1). 挂载点挂载时的 inode 记录是新分配的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span># 挂载前挂载点/mnt的inode号
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[root@server2 tmp]# ll -id /mnt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>100663447 drwxr-xr-x. 2 root root 6 Aug 12 2015 /mnt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[root@server2 tmp]# mount /dev/cdrom /mnt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># 挂载后挂载点的inode号
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[root@server2 tmp]# ll -id /mnt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1856 dr-xr-xr-x 8 root root 2048 Dec 10 2015 mnt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>由此可以验证，inode 号确实是重新分配的。&lt;/p>
&lt;p>(2). 挂载后，挂载点的内容将暂时不可见、不可用，卸载后文件又再次可见、可用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span># 在挂载前，向挂载点中创建几个文件
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[root@server2 tmp]# touch /mnt/a.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[root@server2 tmp]# mkdir /mnt/abcdir
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># 挂载
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[root@server2 tmp]# mount /dev/cdrom /mnt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># 挂载后，挂载点中将找不到刚创建的文件
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[root@server2 tmp]# ll /mnt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>total 636
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-r--r--r-- 1 root root 14 Dec 10 2015 CentOS_BuildTag
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dr-xr-xr-x 3 root root 2048 Dec 10 2015 EFI
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-r--r--r-- 1 root root 215 Dec 10 2015 EULA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-r--r--r-- 1 root root 18009 Dec 10 2015 GPL
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dr-xr-xr-x 3 root root 2048 Dec 10 2015 images
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dr-xr-xr-x 2 root root 2048 Dec 10 2015 isolinux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dr-xr-xr-x 2 root root 2048 Dec 10 2015 LiveOS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dr-xr-xr-x 2 root root 612352 Dec 10 2015 Packages
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dr-xr-xr-x 2 root root 4096 Dec 10 2015 repodata
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-r--r--r-- 1 root root 1690 Dec 10 2015 RPM-GPG-KEY-CentOS-7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-r--r--r-- 1 root root 1690 Dec 10 2015 RPM-GPG-KEY-CentOS-Testing-7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-r--r--r-- 1 root root 2883 Dec 10 2015 TRANS.TBL
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># 卸载后，挂载点/mnt中的文件将再次可见
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[root@server2 tmp]# umount /mnt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[root@server2 tmp]# ll /mnt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>total 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drwxr-xr-x 2 root root 6 Jun 9 08:18 abcdir
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- 1 root root 0 Jun 9 08:18 a.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>之所以会这样，是因为挂载文件系统后，挂载点原来的 inode 记录暂时被标记为不可用，关键是没有指向该 inode 记录的 inode 指针了。在卸载文件系统后，又重新启用挂载点原来的 inode 记录，”/“目录下的 mnt 的 inode 指针又重新指向该 inode 记录。&lt;/p>
&lt;p>(3). 挂载后，挂载点的元数据和 data block 是分别存放在不同文件系统上的。&lt;/p>
&lt;p>(4). 挂载点即使在挂载后，也还是属于源文件系统的文件。&lt;/p>
&lt;h2 id="多文件系统操作关联-多文件系统操作关联多文件系统操作关联">&lt;a href="#%E5%A4%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E5%85%B3%E8%81%94" title="多文件系统操作关联">&lt;/a>多文件系统操作关联&lt;/h2>
&lt;p>假如下图中的圆代表一块硬盘，其中划分了 3 个区即 3 个文件系统。其中根是根文件系统，/mnt 是另一个文件系统 A 的入口，A 文件系统挂载在 /mnt 上，/mnt/cdrom 也是一个文件系统 B 的入口，B 文件系统挂载在 /mnt/cdrom 上。每个文件系统都维护了一些 inode table，这里假设图中的 inode table 是每个文件系统所有块组中的 inode table 的集合表。&lt;/p>
&lt;p>&lt;a href="https://www.junmajinlong.com/img/linux/733013-20170615101444509-1613755325.jpg">&lt;img src="https://www.junmajinlong.com/img/linux/733013-20170615101444509-1613755325.jpg" alt="">
&lt;/a>&lt;/p>
&lt;p>如何读取 /var/log/messages 呢？这是和”/“在同一个文件系统的文件读取，在前面单文件系统中已经详细说明了。&lt;/p>
&lt;p>但如何读取 A 文件系统中的 /mnt/a.log 呢？首先，从根文件系统找到 /mnt 的 inode 记录，这是单文件系统内的查找；然后根据此 inode 记录的 block 指针，定位到 /mnt 的 data block 中，这些 block 是 A 文件系统的 data block；然后从 /mnt 的 data block 中读取 a.log 记录，并根据 a.log 的 inode 指针定位到 A 文件系统的 inode table 中对应 a.log 的 inode 记录；最后从此 inode 记录的 block 指针找到 a.log 的 data block。至此，就能读取到 /mnt/a.log 文件的内容。&lt;/p>
&lt;p>下图能更完整的描述上述过程。&lt;/p>
&lt;p>&lt;a href="https://www.junmajinlong.com/img/linux/733013-20170615101506743-1757840484.jpg">&lt;img src="https://www.junmajinlong.com/img/linux/733013-20170615101506743-1757840484.jpg" alt="">
&lt;/a>&lt;/p>
&lt;p>那么又如何读取 /mnt/cdrom 中的 /mnt/cdrom/a.rpm 呢？这里 cdrom 代表的文件系统 B 挂载点位于 /mnt 下，所以又多了一个步骤。先找到”/“，再找到根中的 mnt，进入到 mnt 文件系统中，找到 cdrom 的 data block，再进入到 cdrom 找到 a.rpm。也就是说，mnt 目录文件存放位置是根，cdrom 目录文件存放位置是 mnt，最后 a.rpm 存放的位置才是 cdrom。&lt;/p>
&lt;p>继续完善上图。如下。&lt;/p>
&lt;p>&lt;a href="https://www.junmajinlong.com/img/linux/733013-20170615101532431-1952370802.jpg">&lt;img src="https://www.junmajinlong.com/img/linux/733013-20170615101532431-1952370802.jpg" alt="">
&lt;/a>&lt;/p>
&lt;p>相比 ext2 文件系统，ext3 多了一个日志功能。&lt;/p>
&lt;p>在 ext2 文件系统中，只有两个区：数据区和元数据区。如果正在向 data block 中填充数据时突然断电，那么下一次启动时就会检查文件系统中数据和状态的一致性，这段检查和修复可能会消耗大量时间，甚至检查后无法修复。之所以会这样是因为文件系统在突然断电后，它不知道上次正在存储的文件的 block 从哪里开始、哪里结束，所以它会扫描整个文件系统进行排除 (也许是这样检查的吧)。&lt;/p>
&lt;p>而在创建 ext3 文件系统时会划分三个区：数据区、日志区和元数据区。每次存储数据时，先在日志区中进行 ext2 中元数据区的活动，直到文件存储完成后标记上 commit 才将日志区中的数据转存到元数据区。当存储文件时突然断电，下一次检查修复文件系统时，只需要检查日志区的记录，将 bmap 对应的 data block 标记为未使用，并把 inode 号标记未使用，这样就不需要扫描整个文件系统而耗费大量时间。&lt;/p>
&lt;p>虽说 ext3 相比 ext2 多了一个日志区转写元数据区的动作而导致 ext3 相比 ext2 性能要差一点，特别是写众多小文件时。但是由于 ext3 其他方面的优化使得 ext3 和 ext2 性能几乎没有差距。&lt;/p>
&lt;p>回顾前面关于 ext2 和 ext3 文件系统的存储格式，它使用 block 为存储单元，每个 block 使用 bmap 中的位来标记是否空闲，尽管使用划分块组的方法优化提高了效率，但是一个块组内部仍然使用 bmap 来标记该块组内的 block。对于一个巨大的文件，扫描整个 bmap 都将是一件浩大的工程。另外在 inode 寻址方面，ext2/3 使用直接和间接的寻址方式，对于三级间接指针，可能要遍历的指针数量是非常非常巨大的。&lt;/p>
&lt;p>ext4 文件系统的最大特点是在 ext3 的基础上使用区 (extent，或称为段) 的概念来管理。一个 extent 尽可能的包含物理上连续的一堆 block。inode 寻址方面也一样使用区段树的方式进行了改进。&lt;/p>
&lt;p>默认情况下，EXT4 不再使用 EXT3 的 block mapping 分配方式 ，而改为 Extent 方式分配。&lt;/p>
&lt;p>以下是 ext4 文件系统中一个文件的 inode 属性示例，注意最后两行的 EXTENTS。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>Inode: 12 Type: regular Mode: 0644 Flags: 0x80000
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Generation: 476513974 Version: 0x00000000:00000001
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>User: 0 Group: 0 Size: 11
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>File ACL: 0 Directory ACL: 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Links: 1 Blockcount: 8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Fragment: Address: 0 Number: 0 Size: 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctime: 0x5b628ca0:491d6224 -- Thu Aug 2 12:46:24 2018
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> atime: 0x5b628ca0:491d6224 -- Thu Aug 2 12:46:24 2018
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mtime: 0x5b628ca0:491d6224 -- Thu Aug 2 12:46:24 2018
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>crtime: 0x5b628ca0:491d6224 -- Thu Aug 2 12:46:24 2018
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Size of extra inode fields: 28
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>EXTENTS:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(0):33409
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>(1). 关于 EXT4 的结构特征&lt;/p>
&lt;p>EXT4 在总体结构上与 EXT3 相似，大的分配方向都是基于相同大小的块组，每个块组内分配固定数量的 inode、可能的 superblock (或备份) 及 GDT。&lt;/p>
&lt;p>EXT4 的 inode 结构做了重大改变，为增加新的信息，大小由 EXT3 的 128 字节增加到默认的 256 字节，同时 inode 寻址索引不再使用 EXT3 的”12 个直接寻址块 + 1 个一级间接寻址块 + 1 个二级间接寻址块 + 1 个三级间接寻址块” 的索引模式，而改为 4 个 Extent 片断流，每个片断流设定片断的起始 block 号及连续的 block 数量 (有可能直接指向数据区，也有可能指向索引块区)。&lt;/p>
&lt;p>片段流即下图中索引节点 (index node block) 部分的绿色区域，每个 15 字节，共 60 字节。&lt;/p>
&lt;p>&lt;a href="https://www.junmajinlong.com/img/linux/733013-20170615101630493-1536814900.jpg">&lt;img src="https://www.junmajinlong.com/img/linux/733013-20170615101630493-1536814900.jpg" alt="">
&lt;/a>&lt;/p>
&lt;p>(2).EXT4 删除数据的结构更改。&lt;/p>
&lt;p>EXT4 删除数据后，会依次释放文件系统 bitmap 空间位、更新目录结构、释放 inode 空间位。&lt;/p>
&lt;p>(3).ext4 使用多 block 分配方式。&lt;/p>
&lt;p>在存储数据时，ext3 中的 block 分配器一次只能分配 4KB 大小的 Block 数量，而且每存储一个 block 前就标记一次 bmap。假如存储 1G 的文件，blocksize 是 4KB，那么每存储完一个 Block 就将调用一次 block 分配器，即调用的次数为 1024*1024/4KB=262144 次，标记 bmap 的次数也为 1024*1024/4=262144 次。&lt;/p>
&lt;p>而在 ext4 中根据区段来分配，可以实现调用一次 block 分配器就分配一堆连续的 block，并在存储这一堆 block 前一次性标记对应的 bmap。这对于大文件来说极大的提升了存储效率。&lt;/p>
&lt;p>最大的缺点是它在创建文件系统的时候就划分好一切需要划分的东西，以后用到的时候可以直接进行分配，也就是说它不支持动态划分和动态分配。对于较小的分区来说速度还好，但是对于一个超大的磁盘，速度是极慢极慢的。例如将一个几十 T 的磁盘阵列格式化为 ext4 文件系统，可能你会因此而失去一切耐心。&lt;/p>
&lt;p>除了格式化速度超慢以外，ext4 文件系统还是非常可取的。当然，不同公司开发的文件系统都各有特色，最主要的还是根据需求选择合适的文件系统类型。&lt;/p>
&lt;p>每一个分区格式化后都可以建立一个文件系统，Linux 上可以识别很多种文件系统，那么它是如何识别的呢？另外，在我们操作分区中的文件时，并没有指定过它是哪个文件系统的，各种不同的文件系统如何被我们用户以无差别的方式操作呢？这就是虚拟文件系统的作用。&lt;/p>
&lt;p>虚拟文件系统为用户操作各种文件系统提供了通用接口，使得用户执行程序时不需要考虑文件是在哪种类型的文件系统上，应该使用什么样的系统调用来操作该文件。有了虚拟文件系统，只要将所有需要执行的程序调用 VFS 的系统调用就可以了，剩下的动作由 VFS 来帮忙完成。&lt;/p>
&lt;p>&lt;a href="https://www.junmajinlong.com/img/linux/733013-20170615101808150-916356306.jpg">&lt;img src="https://www.junmajinlong.com/img/linux/733013-20170615101808150-916356306.jpg" alt="">
&lt;/a>&lt;/p></description></item><item><title>Blog: My first blog</title><link>https://desistdaydream.github.io/blog/My-first-blog/</link><pubDate>Sat, 06 Oct 2018 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/blog/My-first-blog/</guid><description/></item><item><title>Blog: 「你天天关注这些新闻有什么用？」</title><link>https://desistdaydream.github.io/blog/copy/Lnw3wdJ0CQ88QV8bHsvWzw/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/blog/copy/Lnw3wdJ0CQ88QV8bHsvWzw/</guid><description>
&lt;p>原文：&lt;a href="https://mp.weixin.qq.com/s/Lnw3wdJ0CQ88QV8bHsvWzw">公众号-唐一水&lt;/a>
这是我前段时间，后台收到的一句质问。
具体信息我已翻找不到，只记得发这句质问的，是个从头像到昵称，都在彰显岁月静好正能量的中年网友。
我看到这个质问的那一刻，内心那个埋藏许久的声音也瞬间响起：是啊，我关注那么多新闻，我和读者们愤怒、发声、传播了那么多次，其实，又有什么用？
惨剧依旧在重复，不公依旧在上演，疫情、战争、自然灾害、性别暴力，无数不可抗拒的力量依旧将我们碾压，我们关注的唯一用处，似乎就是让自己和社会，更加陷入到「政治性抑郁」。
我们其实完全有另外一个选择——
不听不看，不烦不忧。
我也可以岁月静好，拍拍抖音卡点，发发情感文案，去做一个更稳当美好的自媒体人。各位也可以积极向上，看看正能量，转转暖心事，去做一个每天等待「反转」的理性网友。
但为什么不愿意呢？为什么做不到呢？
明明「政治性抑郁」已令你痛苦疲惫，需要通过停止阅读社交媒体来自我修复，可为什么第二天当再看到那些不公和惨剧，你依然会关注、会愤怒、会发声、会传播？
这个世界少一个「政治性抑郁」的人，多一个「政治性冷漠」的人，又能怎么样，可为什么，你就是不愿意快乐地冷漠着？
也许是因为我们明白，此刻的冷漠，只会换来未来更大的抑郁及荒谬，而那些使我们抑郁的存在，最乐于看到我们的冷漠，好成全一切使其获利的荒谬。
也许是因为我们明白，世界的本质就是荒谬——正义能被轻易打破、善恶并不遵循因果、法律和道德随时准备双标，人只能以「作为」抵抗荒谬。本身就因「无作为」而暴露的荒谬，如果我们仍以「无作为」对待，世界所剩下的，也就只有荒谬叠加荒谬。
当我们向「政治性抑郁」投降时，我们也就只配输给荒谬。
也许是因为我们明白，「政治性抑郁」本质就是一种妄自菲薄，我们以为面对坏消息，自己只能「无作为」。
可是「抑郁」本身就是一种「作为」。情绪，就是改变的开始。
社会历史的改变、进步、对灾难的预防，恰恰发源于一代又一代人的政治性抑郁，先哲前辈们自封建时代一路演进，正是依托一次次情绪的浪潮，而此刻的抑郁，不过是时代责任落于双肩，必然产生的痛楚。
也许是因为我们明白，正如徐贲所说，知识分子没有沉默的权利。当我们的学识，能够让我们理解什么是「政治性冷漠」时，我们就已没有资格去选择「政治性冷漠」。
当下观点市场中，大谈所谓消除或缓解「政治性抑郁」，太容易落入犬儒主义的圈套。当避免共情和社会责任变成一种理所当然的选择，冷漠必将成为主流。
你所受的教育和所学的知识，既是你发声的能力所在，更是你发声的义务所在。如果连能理解这一切荒谬的你都不再发声，你还能指望谁来替你发声，你又凭什么指望谁来替你发声。
这个社会最不缺「政治性冷漠」的人，不关心公共议题，更无视道德自律，他们蒙住双眼，他们面朝大海，甚至会嫌弃发声者聒噪：
「你天天关注这些新闻有什么用？」
「我也不知道。我只是不想成为你们。」&lt;/p></description></item><item><title>Blog: 程序员的酒后真言</title><link>https://desistdaydream.github.io/blog/copy/s_QacAHM9ELc9_jkrxL2cw/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/blog/copy/s_QacAHM9ELc9_jkrxL2cw/</guid><description>
&lt;p>原文链接：&lt;a href="https://mp.weixin.qq.com/s/s_QacAHM9ELc9_jkrxL2cw">https://mp.weixin.qq.com/s/s_QacAHM9ELc9_jkrxL2cw&lt;/a>&lt;/p>
&lt;p>美国最大的论坛 Reddit，最近有一个热帖[1]。
一个程序员说自己喝醉了，软件工程师已经当了 10 年，心里有好多话想说，“我可能会后悔今天说了这些话。”&lt;/p>
&lt;p>他洋洋洒洒写了一大堆，获得 9700 多个赞。内容很有意思，值得一读，下面是节选。
&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/po3xhu/1627796096008-fc438234-b89d-4142-aa9a-75b0994b2a5a.png" alt="image.png">&lt;/p>
&lt;p>（1）职业发展的最好方法是换公司。&lt;/p>
&lt;p>（2）技术栈不重要。技术领域有大约 10-20 条核心原则，重要的是这些原则，技术栈只是落实它们的方法。你如果不熟悉某个技术栈，不需要过度担心。&lt;/p>
&lt;p>（3）工作和人际关系是两回事。有一些公司，我交到了好朋友，但是工作得并不开心；另一些公司，我没有与任何同事建立友谊，但是工作得很开心。&lt;/p>
&lt;p>（4）我总是对经理实话实说。怕什么？他开除我？我会在两周内找到一份新工作。&lt;/p>
&lt;p>（5）如果一家公司的工程师超过 100 人，它的期权可能在未来十年内变得很有价值。对于工程师人数很少的公司，期权一般都是毫无价值。&lt;/p>
&lt;p>（6）好的代码是初级工程师可以理解的代码。伟大的代码可以被第一年的 CS 专业的新生理解。&lt;/p>
&lt;p>（7）作为一名工程师，最被低估的技能是记录。说真的，如果有人可以教我怎么写文档，我会付钱，也许是 1000 美元。&lt;/p>
&lt;p>（8）网上的口水战，几乎都无关紧要，别去参与。&lt;/p>
&lt;p>（9）如果我发现自己是公司里面最厉害的工程师，那就该离开了。&lt;/p>
&lt;p>（10）我们应该雇佣更多的实习生，他们很棒。那些精力充沛的小家伙用他们的想法乱搞。如果他们公开质疑或批评某事，那就更好了。我喜欢实习生。&lt;/p>
&lt;p>（11）技术栈很重要。如果你使用 Python 或 C++ 语言，就会忍不住想做一些非常不同的事情。因为某些工具确实擅长某些工作。&lt;/p>
&lt;p>（12）如果你不确定自己想做什么东西，请使用 Java。这是一种糟糕的编程语言，但几乎无所不能。&lt;/p>
&lt;p>（13）对于初学者来说，最赚钱的编程语言是 SQL，干翻所有其他语言。你只了解 SQL 而不会做其他事情，照样赚钱。人力资源专家的年薪？也许 5 万美元。懂 SQL 的人力资源专家？9 万美元。&lt;/p>
&lt;p>（14）测试很重要，但 TDD （测试驱动的开发）几乎变成了一个邪教。&lt;/p>
&lt;p>（15） 政府单位很轻松，但并不像人们说的那样好。对于职业生涯早期到中期的工程师，12 万美元的年薪 + 各种福利 + 养老金听起来不错，但是你将被禁锢在深奥的专用工具里面，离开政府单位以后，这些知识就没用了。我非常尊重政府工作人员，但说真的，这些地方的工程师，年龄中位数在 50 岁以上是有原因的。&lt;/p>
&lt;p>（16）再倒一杯酒。&lt;/p>
&lt;p>（17）大多数头衔都无关紧要，随便什么公司都可以有首席工程师。&lt;/p>
&lt;p>（18）手腕和背部的健康问题可不是开玩笑的，好的设备值得花钱。&lt;/p>
&lt;p>（19）当一个软件工程师，最好的事情是什么？你可以结识很多想法相同的人，大家互相交流，不一定有相同的兴趣，但是对方会用跟你相同的方式思考问题，这很酷。&lt;/p>
&lt;p>（20）有些技术太流行，我不得不用它。我心里就会很讨厌这种技术，但会把它推荐给客户，比如我恨 Jenkins，但把它推荐给新客户，我不觉得做错了。&lt;/p>
&lt;p>（21）成为一名优秀的工程师意味着了解最佳实践，成为高级工程师意味着知道何时打破最佳实践。&lt;/p>
&lt;p>（22）发生事故时，如果周围的人试图将责任归咎于外部错误或底层服务中断，那么是时候离开这家公司，继续前进了。&lt;/p>
&lt;p>（23）我遇到的最好的领导，同意我的一部分观点，同时耐心跟我解释，为什么不同意我的另一部分观点。我正在努力成为像他们一样的人。&lt;/p>
&lt;p>（24）算法和数据结构确实重要，但不应该无限夸大，尤其是面试的时候。我没见过药剂师面试时，还要测试有机化学的细节。这个行业的面试过程有时候很糟糕。&lt;/p>
&lt;p>（25）做自己喜欢的事情并不重要，不要让我做讨厌的事情更重要。&lt;/p>
&lt;p>（26）越接近产品，就越接近推动收入增长。无论工作的技术性如何，只要它接近产品，我都感到越有价值。&lt;/p>
&lt;p>（27）即使我平时用 Windows 工作，Linux 也很重要。为什么？因为服务器是 Linux 系统，你最终在 Linux 系统上工作。&lt;/p>
&lt;p>（28）人死了以后，你想让代码成为你的遗产吗？如果是那样，就花很多时间在代码上面吧，因为那是你的遗产。但是，如果你像我一样，更看重与家人、朋友和生活中其他人相处的时光，而不是写的代码，那就别对它太在意。&lt;/p>
&lt;p>（29）我挣的钱还不错，对此心存感激，但还是需要省钱。&lt;/p>
&lt;p>（30）糟糕，我没酒了。&lt;/p>
&lt;p>（完）&lt;/p>
&lt;h3 id="references">References&lt;/h3>
&lt;p>[1] 热帖: &lt;em>&lt;a href="https://old.reddit.com/r/ExperiencedDevs/comments/nmodyl/drunk">https://old.reddit.com/r/ExperiencedDevs/comments/nmodyl/drunk&lt;/a>_post_things_ive_learned_as_a_sr_engineer/&lt;/em>&lt;/p></description></item><item><title>Blog: 二十年老程序员的二十条心得：面试几乎没用，警惕很久没写过代码的“大牛”</title><link>https://desistdaydream.github.io/blog/copy/bHdkIkWCNZPmO-Hz-HQreQ/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/blog/copy/bHdkIkWCNZPmO-Hz-HQreQ/</guid><description>
&lt;p>原文链接：&lt;a href="https://mp.weixin.qq.com/s/bHdkIkWCNZPmO-Hz-HQreQ">https://mp.weixin.qq.com/s/bHdkIkWCNZPmO-Hz-HQreQ&lt;/a>&lt;/p>
&lt;p>作者 | Justin Etheredge&lt;/p>
&lt;p>译者 | 核子可乐&lt;/p>
&lt;p>务必警惕那些已经很久没写过代码、也没设计过系统的所谓“大牛”。&lt;/p>
&lt;p>站在巨人的肩膀上当然更容易成功，所以我们才会希望行业前辈能给出一些有意义的建议。今天这些建议来自一位有二十年行业经验的软件工程师，他的总结在 Hacker News 上引发了大量的讨论，帖子多天来一直占据“热榜”第一。&lt;/p>
&lt;p>&lt;img src="https://notes-learning.oss-cn-beijing.aliyuncs.com/f432d2fc-949a-48d3-8541-b3372c79b831/640" alt="">&lt;/p>
&lt;p>Justin Etheredge 最初在各类小型和初创企业中担任软件工程师，之后进入了咨询行业并开始为大型企业服务。Justin Etheredge 表示过去二十年以来的经历塑造了他对于软件的理解，并产生出一些坚定的信念。他把这些信念整理成一份明确的清单，希望能为大家带来一点帮助与启发。&lt;/p>
&lt;p>引起网友激烈讨论的二十条建议：&lt;/p>
&lt;ol>
&lt;li>我懂的并不多&lt;/li>
&lt;/ol>
&lt;p>“你怎么会不知道什么是 BGP？”“你难道没听说过 Rust？”&lt;/p>
&lt;p>类似的问题可能每天都会出现在我们面前。没错，投身于软件行业的很多人之所以热爱这份工作，就是因为它敦促着我们终身学习。&lt;/p>
&lt;p>在软件领域，无论我们朝哪个方向前进，都有着广阔的知识空间不断延伸而且每一天都有所变化。换句话说，这是一份能够承载我们度过几十年的职业生涯，而两位在类似岗位上分别工作了几十年的人之间也 &lt;strong>很可能存在巨大的知识差距&lt;/strong>。我们越早意识到这一点，就能越快摆脱“冒充者综合症”，成为一个乐于向他人学习、也乐于教导他人的积极分子。&lt;/p>
&lt;ol start="2">
&lt;li>软件里最难的部分，是构建正确的东西&lt;/li>
&lt;/ol>
&lt;p>我知道这种话大家肯定听过无数遍了，但大多数软件工程师仍拒不承认，理由是这种说法似乎在贬低他们的工作成果。我个人觉得这样的心态大可不必，这类表达其实是在突出软件开发环境中的复杂性与非理性因素，而这些都会加剧我们面临的挑战。我们当然可以设计出在技术上最令人印象深刻的东西，但却没人愿意用——这类困境随时都会出现。&lt;/p>
&lt;p>软件设计主要是一种聆听活动，开发者往往身兼软件工程师、通灵师乃至人类学家等多重角色。而我们对这种设计能力的每一点投资，无论是引入专业的用户体验师还是接受更进一步的自我教育，都能给开发成果带来巨大提升。毕竟与打磨设计能力相比，开发一款“没人用”的软件成本还是太高了、太高太高。&lt;/p>
&lt;ol start="3">
&lt;li>顶尖软件工程师会像设计师那样思考&lt;/li>
&lt;/ol>
&lt;p>伟大的软件工程师会深入思考代码成果的用户体验。虽然使用的术语或者切入点不同，但无论是对于外部 API、编程 API、用户界面、协议还是其他接口，优秀的工程师都会考虑由谁来使用、为什么要使用、如何使用以及对用户来说哪些因素真正重要等。总之，牢记用户需求才是实现良好体验的核心所在。&lt;/p>
&lt;ol start="4">
&lt;li>最好的代码就是没有代码，或者说不需要维护的代码&lt;/li>
&lt;/ol>
&lt;p>“程序员就是管编程的”，而且跟其他专业人士一样，我们也会在自己最擅长的方面犯错。这是人的本性，没办法。大多数软件工程师编写出的代码总是有点错误，而且往往无法用非技术方案来解决。&lt;/p>
&lt;p>另外有一种很神奇的现象，&lt;strong>越是有大量相当成熟的解决方案存在，工程团队就越是想“重新发明轮子”&lt;/strong>。想表达自我、加快专业成长当然是好事，但还请大家分清场合与需求，过度泛滥的发明欲望恐怕不利于编写出无需维护的代码。&lt;/p>
&lt;ol start="5">
&lt;li>软件是达成目的的手段&lt;/li>
&lt;/ol>
&lt;p>任何一位软件工程师的主要工作都是交付价值。但我发现大部分软件开发者并不理解这一点，能够将这个理念内化进日常工作的开发者就更少了。但只要能够完成内化，我们解决问题的方式、看待工具的角度都会有所变化。如果您真心相信软件要服从于结果，那就一定能找到“真正适合工作的工具”，而这种工具也许压根就不是软件。&lt;/p>
&lt;ol start="6">
&lt;li>有时候，你压根没时间磨刀&lt;/li>
&lt;/ol>
&lt;p>都说“磨刀不误砍柴工”，但刀磨久了反而让人心浮气躁、难以投入真正的工作。代码编写也是一样，研究多了容易让人陷入“分析瘫痪”。&lt;/p>
&lt;p>一旦出现这种状况，请马上给自己设定一个截止日期，之后再探索解决方案。在着手解决问题时，我们很快就能找到思路与线索、引导自己一步步迭代向更好的产出。&lt;/p>
&lt;ol start="7">
&lt;li>如果没法理解所有可能性，就设计不出优秀的系统&lt;/li>
&lt;/ol>
&lt;p>这也是我个人一直在努力解决的问题。我的职责变化导致自己距离常规软件工程任务越来越远，我发现跟上开发者生态的发展速度越来越难，有时候自己甚至不理解哪些趋势真正重要。总之，如果不能理解特定生态当中的那些可行性与可用选项，那么我们根本没办法为所有问题找到合理的解决方案。&lt;/p>
&lt;p>总而言之，&lt;strong>务必警惕那些已经很久没写过代码、也没设计过系统的所谓“大牛”&lt;/strong>。&lt;/p>
&lt;ol start="8">
&lt;li>每套系统最终都很差劲，要勇于接受这一点&lt;/li>
&lt;/ol>
&lt;p>Bjarne Stroustrup 有句名言，“世界上只有两种语言，人们抱怨的语言和没人用的语言。”大型系统也是同理。并不存在“正确”的架构，我们永远无法偿还所有技术债务、设计不出完美的界面、也不可能永远拥有迅如闪电的测试速度。但做不到不代表什么都不做，这只是一种参考视角。优雅和完美本身就是种终极目标，我们当下的任务就是不断改进并创造一个更友好的系统环境，保证团队至少还用得下去、并以可持续的方式交付价值。&lt;/p>
&lt;ol start="9">
&lt;li>通于探索，不断追问&lt;/li>
&lt;/ol>
&lt;p>相信大家都听过“我们向来这么处理”之类的鬼话。这时候请关注那些新加入的成员，看看他们在哪里遇到了问题、又提出了哪些质疑。这些质疑中，是否存在某种有意义的功能诉求？请保证您明确理解他们提出的目标，以及驱动这种功能诉求的原因。如果得不到明确答案，就不断追问下去、直到弄明白为止。&lt;/p>
&lt;ol start="10">
&lt;li>相比于寻找 10 倍程序员，最好是消除 0.1 倍程序员&lt;/li>
&lt;/ol>
&lt;p>10 倍程序员就是个愚蠢的笑话。&lt;/p>
&lt;p>没有任何一个人能在一天之内搞定另一位同样有能力、工作态度端正而且经验丰富的程序员需要两个礼拜才能做完的工作。我只见过 10 倍代码量程序员，他们写出来的 bug 也是 10 倍。或者说，10 倍程序员唯一的存在可能性，就是身边有个 0.1 倍程序员——就是那种浪费时间、不关注反馈、不测试代码也不考虑极端情况的家伙……所以相较于寻找神话中的 10 倍程序员，及时清除团队中的 0.1 倍程序员才是正道。&lt;/p>
&lt;ol start="11">
&lt;li>高级工程师与初级工程师间的最大区别之一，在于二者形成意见的具体方式&lt;/li>
&lt;/ol>
&lt;p>如果某位高级工程师对现有工具或者软件构建流程没有任何意见，那我实在是感觉不太正常。我宁愿有人能反馈出强烈的批评意见，也不愿他们压根没有任何意见。只要正在实际使用工具，那大家或多或少会有正面或者负面的批价；对其他语言、库和范式的应用也是类似的情况。而这种对于工具及技术的评判与探索，往往可以快速提升我们的技能水平。&lt;/p>
&lt;ol start="12">
&lt;li>人们并不真正想要创新&lt;/li>
&lt;/ol>
&lt;p>人们经常讨论创新，但实际想要的只是更廉价的胜利与新鲜感。如果真正进行创新、改变人们处理工作的方式，那么对方大概率会给出负面反馈。但如果您真的相信自己的决定代表未来、相信这一切能改善产出，那请做好打一场持久战、拉锯战的准备。&lt;/p>
&lt;ol start="13">
&lt;li>数据是系统当中最重要的组成部分&lt;/li>
&lt;/ol>
&lt;p>我见过很多以数据完整性作为主要保障目标的系统。但在这类系统中，任何预期范围之外的操作都会产生某些“脏”数据，它们会在后续处理中演变为一场噩梦。&lt;/p>
&lt;p>请记住，&lt;strong>数据的存在周期往往比代码库更长&lt;/strong>，所以请花点精力保持数据的清洁和有序。从长远来看，这种好习惯必然带来高回报。&lt;/p>
&lt;ol start="14">
&lt;li>寻找技术“鲨鱼”&lt;/li>
&lt;/ol>
&lt;p>所谓技术“鲨鱼”，就是那些长久存在、能够有效解决问题，所以可以在技术领域的快速变化中幸存下来的技术方案。注意，它们是鲨鱼、不是恐龙，所以除非有充分的理由，否则千万不要轻易更换。这些工具没什么特别、也不激动人心，但它们总是稳定有效，能让人睡个好觉。&lt;/p>
&lt;ol start="15">
&lt;li>不要把谦虚当成无知&lt;/li>
&lt;/ol>
&lt;p>很多软件工程师不爱主动说话，除非问题被推到面前。所以，千万别以为别人没发言就是大家没意见。有时候，最吵闹的家伙反而是我们最不想倾听的对象。总之，积极与其他人交谈，寻求他们的反馈与建议。这招回报很高，一试就灵。&lt;/p>
&lt;ol start="16">
&lt;li>软件工程师应该保持写作的习惯&lt;/li>
&lt;/ol>
&lt;p>软件工程师应该定期写点博客、日记和说明文档，或者其他能够保持自己书面沟通技巧的东西。写作能帮助我们思考问题，也能培养起我们与团队甚至是未来的自己良好沟通的能力。良好的书面沟通可以说是每一位软件工程师都必须掌握的重要技能之一。&lt;/p>
&lt;ol start="17">
&lt;li>让流程尽可能精简&lt;/li>
&lt;/ol>
&lt;p>时至今日，每个人都在说“敏捷”，但敏捷的本质并不复杂——构建小小的单元块、从中学习、再迭代。如果有人把它弄得更晦涩，那恐怕就是想夹带私货。&lt;/p>
&lt;p>换句话说，那些最成功的科技企业或者大型开源项目不会过度吹嘘自己的 Scrum 流程有多棒。大道至简，精益才是成功的关键。相信你的团队，他们也会用产出回应你的信任。&lt;/p>
&lt;ol start="18">
&lt;li>软件工程师也是人，也需要找到当家作主的感觉&lt;/li>
&lt;/ol>
&lt;p>如果硬要把某人跟他的工作成果分开，那他们也就不关心自己在干什么了。也正因为如此，跨职能团队以及 DevOps 理念才在当下获得广泛认同。这不只是要消除无谓的交接与低效率环节，更重要的是让每个人从头到尾拥有整个流程，并负责直接交付价值。只要让一群充满激情的工作者完全掌握软件设计、构建与交付的所有权，他们一定会拿出令人兴奋的成果。&lt;/p>
&lt;ol start="19">
&lt;li>面试在反映开发者水平方面几乎毫无价值&lt;/li>
&lt;/ol>
&lt;p>面试的最大作用就是了解对方，主要是对方对于特定专业领域抱有多大的兴趣。另一方面，&lt;strong>面试在反映开发者技术水平方面几乎毫无价值&lt;/strong>。相信我，无论一个人多聪明、多博学，都不代表对方就真的适合我们的团队。没人会在面试中坦言自己不太可靠、暴躁易怒、自负自大或者从来不准时出席会议。为了拿到工作，每个人都或多或少要粉饰一下自己，而那些能在原则问题上坚持立场的人反而值得尊敬。“永远不要雇用那些在面试中询问休息时间的人”，这种鬼话就是纯纯的放屁！&lt;/p>
&lt;ol start="20">
&lt;li>始终坚持从小处着眼&lt;/li>
&lt;/ol>
&lt;p>在系统开发当中，种种因素似乎都在推动我们构建起更大的体系。预算分配、难以取舍的功能方案、一举打造“最佳版本”的愿望等等，都会让刚刚起步的项目快速变得臃肿不堪。请千万克服自己的冲动，努力通过迭代让系统从最初的简单粗糙变得精致优雅。而且跟很多朋友想象中不同，这也是打造精致优雅系统的唯一方法。&lt;/p>
&lt;p>&lt;strong>参考链接：&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://www.simplethread.com/20-things-ive-learned-in-my-20-years-as-a-software-engineer/">https://www.simplethread.com/20-things-ive-learned-in-my-20-years-as-a-software-engineer/&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://news.ycombinator.com/item?id=28797485">https://news.ycombinator.com/item?id=28797485&lt;/a>&lt;/p></description></item></channel></rss>