<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>公众号,码农的荒岛求生-操作系统话题系列文章 on 断念梦的站点</title><link>https://desistdaydream.github.io/blog/copy/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/</link><description>Recent content in 公众号,码农的荒岛求生-操作系统话题系列文章 on 断念梦的站点</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://desistdaydream.github.io/blog/copy/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/index.xml" rel="self" type="application/rss+xml"/><item><title>公众号,码农的荒岛求生-操作系统话题系列文章</title><link>https://desistdaydream.github.io/blog/copy/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/blog/copy/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/</guid><description>系列文章目录</description></item><item><title>CPU 是如何读写内存的？</title><link>https://desistdaydream.github.io/blog/copy/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/CPU-%E6%98%AF%E5%A6%82%E4%BD%95%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98%E7%9A%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/blog/copy/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/CPU-%E6%98%AF%E5%A6%82%E4%BD%95%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98%E7%9A%84/</guid><description>https://mp.weixin.qq.com/s/S3Cn6KsDGKqxxP58y2m67Q
如果你觉得这是一个非常简单的问题，那么你真应该好好读读本文，我敢保证这个问题绝没有你想象的那么简单。注意，一定要完本文，否则可能会得出错误的结论。闲话少说，让我们来看看 CPU 在读写内存时底层究竟发生了什么。 谁来告诉 CPU 读写内存 我们第一个要搞清楚的问题是：谁来告诉 CPU 去读写内存？答案很明显，是程序员，更具体的是编译器。CPU 只是按照指令按部就班的执行，机器指令从哪里来的呢？是编译器生成的，程序员通过高级语言编写程序，编译器将其翻译为机器指令，机器指令来告诉 CPU 去读写内存。在精简指令集架构下会有特定的机器指令，Load/Store 指令来读写内存，以 x86 为代表的复杂指令集架构下没有特定的访存指令。精简指令集下，一条机器指令操作的数据必须来存放在寄存器中，不能直接操作内存数据，因此 RISC 下，数据必须先从内存搬运到寄存器，这就是为什么 RISC 下会有特定的 Load/Store 访存指令，明白了吧。而 x86 下无此限制，一条机器指令操作的数据可以来自于寄存器也可以来自内存，因此这样一条机器指令在执行过程中会首先从内存中读取数据。关于复杂指令集以及精简指令集你可以参考这两篇文章《CPU 进化论：复杂指令集》与《不懂精简指令集还敢说自己是程序员？》
两种内存读写 现在我们知道了，是特定的机器指令告诉 CPU 要去访问内存。不过，值得注意的是，不管是 RISC 下特定的 Load/Store 指令还是 x86 下包含在一条指令内部的访存操作，这里读写的都是内存中的数据，除此之外还要意识到，CPU 除了从内存中读写数据外，还要从内存中读取下一条要执行的机器指令。毕竟，我们的计算设备都遵从冯诺依曼架构：程序和数据一视同仁，都可以存放在内存中。现在，我们清楚了 CPU 读写内存其实是由两个因素来驱动的：
程序执行过程中需要读写来自内存中的数据
CPU 需要访问内存读取下一条要执行的机器指令
然后 CPU 根据机器指令中包含的内存地址或者 PC 寄存器中下一条机器指令的地址访问内存。这不就完了吗？有了内存地址，CPU 利用硬件通路直接读内存就好了，你可能也是这样的想的。真的是这样吗？别着急，我们接着往下看，这两节只是开胃菜，正餐才刚刚开始。
急性子吃货 VS 慢性子厨师 假设你是一个整天无所事事的吃货，整天无所事事，唯一的爱好就是找一家餐厅吃吃喝喝，由于你是职业吃货，因此吃起来非常职业，1 分钟就能吃完一道菜，但这里的厨师就没有那么职业了，炒一道菜速度非常慢，大概需要 1 小时 40 分钟才能炒出一道菜，速度比你慢了 100 倍，如果你是这个吃货，大概率会疯掉的。而 CPU 恰好就是这样一个吃货，内存就是这样一个慢吞吞的厨师，而且随着时间的推移这两者的速度差异正在越来越大：在这种速度差异下，CPU 执行一条涉及内存读写指令时需要等**“很长一段时间“数据才能”缓缓的“从内存读取到 CPU 中，在这种情况你还认为 CPU 应该直接读写内存吗**？
无处不在的 28 定律 28 定律我想就不用多介绍了吧，在《不懂精简指令集还敢说自己是程序员集中起来然后呢？放到哪里呢？当然是放到一种比内存速度更快的存储介质上，这种介质就是我们熟悉的 SRAM，普通内存一般是 DRAM，这种读写速度更快的介质充当 CPU 和内存之间的 Cache，这就是所谓的缓存。</description></item><item><title>程序员应如何理解内存：上篇</title><link>https://desistdaydream.github.io/blog/copy/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E4%B8%8A%E7%AF%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/blog/copy/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E4%B8%8A%E7%AF%87/</guid><description>https://mp.weixin.qq.com/s/U7F5LyzZ07KVOFYJF74LtQ 本节是操作系统系列教程的第三篇文章，属于操作系统第一章即基础篇，在真正开始操作系统相关章节前在这一部分回顾一些重要的主题，算是温故知新吧，以下是目录，由于本文篇幅较多因此接下来会分三次发布，目录中黑体为本篇内容。
什么是内存
C/C++ 内存模型
堆区与栈区的本质
Java、Python 等内存模型
Java 内存模型
Jave 中的堆区与栈区是如何实现的
Python 内存模型
指针与引用
进程的内存模型
幻想大师 - 操作系统
总结
什么是内存 0 和 1 这两个简单的数字能做什么？在其它学科中也许什么都做不了，但是在计算机科学中这就是全部。精彩纷呈的计算机世界正是构筑在这样两个简单数字之上。
内存本身其实非常简单，内存的作用就是用来装数字 0 和数字 1 的，如图所示，图中的一个盒子就是内存的一个基本单元，装的不是 0 就是装的 1。
内存由一大堆的 “盒子” 组成，每个盒子中要么是 0 要么是 1，其中 8 个盒子被称之为一个“字节”，每 8 个盒子也就是一个字节都有一个编号，这些编号就是简单的从 0 开始依次累加的，这个编号就被称之为“内存地址”。如图所示，你可以把内存理解为下面这张图，其中左边的数字是内存地址，每一排是一个字节，图中展示的就是一个 8 字节大小的内存。
而对于我们平时使用的比如 2G、4G 甚至 8G 大小的内存来说，只不过就是 “盒子” 多一点能装的 01 多一点而已，本质上和我们在这里展示的 8 字节大小的内存没有任何区别。
在后面的章节中我将用右图来表示内存，但是你的大脑里一定要有左图这样一个概念。当计算机在执行我们的程序时，无论是我们的机器指令还是机器指令操作的数据，都需要存放在这些小盒子中 (内存)。
以上就是从硬件角度来看内存，那么从编程语言上来看，程序员应该如何理解内存呢？
C/C++ 内存模型 对于 C/C++ 程序员来说，常用的 int，char 等变量都被装在盒子中，char 值只需要一排盒子就能装下 (8bit)，一个 int 值一般需要四排盒子才能装得下。连续几排装有同样类型变量的盒子就是数组 (array)，连续几排装有不同类型变量的盒子就是结构体 (struct)，C/C++ 语言中不管多么复杂的数据结构都是在此基础上构建出来的，都需要装在这些盒子里，没什么大不了的。</description></item><item><title>程序员应如何理解内存：下篇</title><link>https://desistdaydream.github.io/blog/copy/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E4%B8%8B%E7%AF%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/blog/copy/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E4%B8%8B%E7%AF%87/</guid><description>https://mp.weixin.qq.com/s/Uu8z7GIiPnrfRhDTj93UZQ 本节是操作系统系列教程的第三篇文章，属于操作系统第一章即基础篇，在真正开始操作系统相关章节前在这一部分回顾一些重要的主题，以下是目录，由于本文篇幅较多因此按上篇、中篇、下篇三次发布，目录中黑体为本篇内容，本文为该主题最后一篇。
什么是内存
C/C++ 内存模型
堆区与栈区的本质
Java、Python 等内存模型
Java 内存模型
Jave 中的堆区与栈区是如何实现的
Python 内存模型
指针与引用
进程的内存模型
幻想大师 - 操作系统
总结
指针与引用
在各种编程语言中我们应该经常听到两个词，那就是引用或者指针。这两个词都是和内存相关的，指针和引用的作用都是 “如何找到存放在内存上的数据”。
C/C++ 中有 “指针” 这样一个概念，而其它语言比如 Java、Python 有的只是 “引用” 这样一个概念。这两者有什么区别呢？我们打个比方你就能理解了。
“引用”就好比一个人的外号一样，就好有个程序员叫令狐冲，但是令狐冲同学在 A 公司的英文名可能是 “Tom”，在 B 公司中可能又叫“Jerry”，那么在 A 公司中你只需要喊一声“Tom” 就能找到令狐冲同学。
而 “指针” 强调的是位置，比如令狐冲在 A 公司的工位是“10 排第二个”，在 B 公司中的工位是“8 排第六个”，下班后回的位置在“中关村”。
这个例子当中的令狐冲同学就好比程序语言中的对象，令狐冲的各种外号就好比对象的引用，令狐冲当前所在的位置就好比对象的指针。
虽然通过 “引用” 和“指针”都能找到令狐冲同学，但是寻找的方式是不一样的。
只有 C/C++ 这样的编译型语言才会有 “指针” 这样一个概念，指的是当前的对象放在了内存中的哪个位置上了。在比如 Java、Python 等语言中只有 “引用” 这样一个概念。在 C/C++ 语言中，我们可以通过指针直接找到一个对象，因为你知道这个对象就在内存中指针所指向的位置，但在 Java、Python 等语言中，当你利用引用找到对象时基本上是冲着解释器喊一句“Hey，解释器，帮我找到令狐冲这个对象”，解释器通过记录查找到这个对象，注意解释器是知道对象在内存中的真正位置的，由于直接管理内存是一项非常繁琐容易出错的事情(C/C++ 程序员一定对此有深刻体会)，因此解释器就接手了对内存直接管理，Java、Python 等程序员是没有必要知道对象在内存中的真正位置的，没有指针也可以开心的写程序而且程序更加健壮，何乐不为呢，因此这些语言中是没有指针这样一个概念。
Sun 的一篇论文中提到了为什么 Java 里没有指针。</description></item><item><title>程序员应如何理解内存：中篇</title><link>https://desistdaydream.github.io/blog/copy/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E4%B8%AD%E7%AF%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/blog/copy/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E4%B8%AD%E7%AF%87/</guid><description>https://mp.weixin.qq.com/s/x52e0aGl0fC1KhXhai6MPg 本节是操作系统系列教程的第三篇文章，属于操作系统第一章即基础篇，在真正开始操作系统相关章节前在这一部分回顾一些重要的主题，以下是目录，由于本文篇幅较多因此会按上篇、中篇、下篇三次发布，目录中黑体为本篇内容。
什么是内存
C/C++ 内存模型
堆区与栈区的本质
Java、Python 等内存模型
Java 内存模型
Jave 中的堆区与栈区是如何实现的
Python 内存模型
指针与引用
进程的内存模型
幻想大师 - 操作系统
总结
堆与栈的本质是什么 在编程语言中，堆区和栈区本质上都是内存，因此二者在本质上没有任何区别，只不过这两块内存的使用方式是不一样的。
在数据结构与算法中，我们也有堆和栈的概念，但那里指的不是内存，而是两种数据结构。
你可能会想，我们为什么要费尽心力的提出堆和栈这两个概念呢？之所以需要区分两种内存用法，根源在于：内存是有限的。
如果计算机内存是无限的，那么我们根本就不用这么麻烦的给内存划分两个区域，在其中的一个区域中这样使用内存，另一区域那样使用内存，这些都是不需要的。即使在今天 PC 内存普遍都在 8G、16G，这依然是不够的，因此我们需要合理的来安排内存的使用，堆和栈就是为达到这一目的而采用的技术。
你会发现栈其实是一种非常巧妙的内存使用方法。函数调用完成后，函数运行过程中占用的内存就会被释放掉，这样，只要程序员代码写的合理 (栈帧不至于过大)，那我们程序就可以一直运行下去，而不会出现内存不足的现象。程序员在栈区不需要担心内存分配释放问题，因为这一切都是自动进行的。而如果程序员想自己控制内存，那么可以选择在堆上进行内存分配。因此这里提供了两种选择，一种是 “自动的”，一种是 “手动的”，目的都是在合理使用内存的同时提供给程序员最大的灵活性。
堆和栈是计算机科学中很优秀的设计思想，这种设计思想充分的体现了计算机如何合理且灵活的使用有限资源。
堆区和栈区对 C/C++ 程序员来说就是实实在在的内存，而对于 Java、Python 等语言的程序员来说又该如何理解内存呢?
Java、Python 等内存模型 当 Java、Python 等语言的程序在执行时其解释器的内存布局同样如下图所示，我们之前讲过，解释器也是一个 C/C++ 程序，因此这里的代码段包含的是解释器的实现代码而不是 Java、Python 等代码，这一点大家一定要注意。
&amp;ldquo;C/C++ 程序员面对的是实实在在的物理内存，Java、Python 等程序面对的是解释器。&amp;rdquo;
C/C++ 分配内存是直接在物理内存中进行的，而 Java、Python 等程序是将内存分配请求交给解释器，解释器再去物理内存上进行分配。希望大家务必理解这一点。
Java、Python 等程序员是看不到如下图所示的内存布局的，因为这一切都是解释器才能看到的，解释器对 Java、Python 等程序员屏蔽了这些。Java、Python 等程序员也无需关心解释器的内存布局。
Java、Python 等程序的一大优点就是内存的自动化管理，而 C/C++ 程序员需要自己来管理从堆上分配的内存。内存管理这一项工作在 Java、Python 等程序中被解释器接管了，解释器的这项功能被称为 “垃圾回收器”。
在非 C/C++ 语言中，我们来看两个有代表性的语言，首先我们看一下 Java。</description></item><item><title>函数运行时在内存中是什么样子？</title><link>https://desistdaydream.github.io/blog/copy/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/blog/copy/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/</guid><description>参考：公众号,码农的荒岛求生
在开始本篇的内容前，我们先来思考几个问题。
我们先来看一段简单的代码：
void func(int a) { if (a &amp;gt; 100000000) return; int arr[100] = {0}; func(a + 1); }
你能看出这段代码会有什么问题吗？
我们在上一篇文章《高性能高并发服务器是如何实现的》中提到了一项关键技术——协程，你知道协程的本质是什么吗？有的同学可能会说是用户态线程，那么什么是用户态线程，这是怎么实现的？
函数运行起来后在内存中是什么样子？
这几个问题看似没什么关联，但这背后都指向一样东西，这就是所谓的函数运行时栈，run time stack。
接下来我们就好好看看到底什么是函数运行时栈，为什么彻底理解函数运行时栈对程序员来说非常重要。
从进程、线程到函数调用
汽车在高速上行驶时有很多信息，像速度、位置等等，通过这些信息我们可以直观的感受汽车的运行时状态。
同样的，程序在运行时也有很多信息，像有哪些程序正在运行、这些程序执行到了哪里等等，通过这些信息我们可以直观的感受系统中程序运行的状态。
其中，我们创造了进程、线程这样的概念来记录有哪些程序正在运行，关于进程和线程的概念请参见《看完这篇还不懂进程、线程与线程池你来打我》。
进程和线程的运行体现在函数执行上，函数的执行除了函数内部执行的顺序执行还有子函数调用的控制转移以及子函数执行完毕的返回。其中函数内部的顺序执行乏善可陈，重点是函数的调用。
因此接下来我们的视角将从宏观的进程和线程拉近到微观下的函数调用，重点来讨论一下函数调用是怎样实现的。
函数执行的活动轨迹：栈
玩过游戏的同学应该知道，有时你为了完成一项主线任务不得不去打一些支线的任务，支线任务中可能还有支线任务，当一个支线任务完成后退回到前一个支线任务，这是什么意思呢，举个例子你就明白了。
假设主线任务西天取经 A 依赖支线任务收服孙悟空 B 和收服猪八戒 C，也就是说收服孙悟空 B 和收服猪八戒 C 完成后才能继续主线任务西天取经 A；
支线任务收服孙悟空 B 依赖任务拿到紧箍咒 D，只有当任务 D 完成后才能回到任务 B；
整个任务的依赖关系如图所示：
现在我们来模拟一下任务完成过程。
首先我们来到任务 A，执行主线任务：
执行任务 A 的过程中我们发现任务 A 依赖任务 B，这时我们暂停任务 A 去执行任务 B：
执行任务 B 的时候，我们又发现依赖任务 D：</description></item><item><title>神秘！申请内存时底层发生了什么？</title><link>https://desistdaydream.github.io/blog/copy/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E7%A5%9E%E7%A7%98%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E6%97%B6%E5%BA%95%E5%B1%82%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://desistdaydream.github.io/blog/copy/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A0%81%E5%86%9C%E7%9A%84%E8%8D%92%E5%B2%9B%E6%B1%82%E7%94%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%9D%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/%E7%A5%9E%E7%A7%98%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E6%97%B6%E5%BA%95%E5%B1%82%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</guid><description>参考：公众号,码农的荒岛求生
内存的申请释放对程序员来说就像空气一样自然，你几乎不怎么能意识到，有时你意识不到的东西却无比重要，申请过这么多内存，你知道申请内存时底层都发生什么了吗？
大家都喜欢听故事，我们就从神话故事开始吧。
三界 中国古代的神话故事通常有 “三界” 之说，一般指的是天、地、人三界，天界是神仙所在的地方，凡人无法企及；人界说的是就是人间；地界说的是阎罗王所在的地方，孙悟空上天入地无所不能就是说可以在这三界自由出入。
有的同学可能会问，这和计算机有什么关系呢？
原来，我们的代码也是分三六九等的，程序运行起来后也是有 “三界” 之说的，程序运行起来的 “三界” 就是这样的：
x86 CPU 提供了 “四界”：0,1,2,3，这几个数字其实就是指 CPU 的几种工作状态，数字越小表示 CPU 的特权越大，0 号状态下 CPU 特权最大，可以执行任何指令，数字越大表示 CPU 特权越小，3 号状态下 CPU 特权最小，不能执行一些特权指令。
一般情况下系统只使用 0 和 3，因此确切的说是 “两界”，这两界可不是说天、地，这两界指的是“用户态(3)” 以及“内核态(0)”，接下来我们看看什么是内核态、什么是用户态。
内核态 什么是内核态？当 CPU 执行操作系统代码时就处于内核态，在内核态下 CPU 可以执行任何机器指令、访问所有地址空间、不受限制的访问任何硬件，可以简单的认为内核态就是 “天界”，在这里的代码(操作系统代码) 无所不能。
用户态 什么是用户态？当 CPU 执行我们写的 “普通” 代码 (非操作系统、驱动程序员) 时就处于用户态，粗糙的划分方法就是除了操作系统之外的代码，就像我们写的 HelloWorld 程序。
用户态就好比 “人界”，在用户态我们的代码处处受限，不能直接访问硬件、不能访问特定地址空间，否则神仙(操作系统) 直接将你 kill 掉，这就是著名的 Segmentation fault、不能执行特权指令，等等。
关于这一部分的详细讲解，请参见《深入理解操作系统》系列文章。
跨界 孙悟空神通广大，一个跟斗就能从人间跑到天上去骂玉帝老儿，程序员就没有这个本领了。普通程序永远也去不了内核态，只能以通信的方式从用户态往内核态传递信息。
操作系统为普通程序员留了一些特定的暗号，这些暗号就和普通函数一样，程序员通过调用这些暗号就能向操作系统请求服务了，这些像普通函数一样的暗号就被称为系统调用，System Call，通过系统调用我们可以让操作系统代替我们完成一些事情，像打开文件、网络通信等等。
你可能有些疑惑，什么，还有系统调用这种东西，为什么我没调用过也可以打开文件、进行网络通信？
标准库 虽然我们可以通过系统让操作系统替我们完成一些特定任务，但这些系统调用都是和操作系统强相关的，Linux 和 Windows 的系统调用就完全不同。</description></item></channel></rss>